<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-05-05T17:35:07.119Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IMX269</title>
    <link href="https://2020.iosdevlog.com/2020/05/03/IMX269/"/>
    <id>https://2020.iosdevlog.com/2020/05/03/IMX269/</id>
    <published>2020-05-02T19:01:55.000Z</published>
    <updated>2020-05-05T17:35:07.119Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/PhysicalPixelArray.png" /></p><a id="more"></a><p>对角线21.77毫米（4/3型）CMOS图像传感器，带方形像素，用于彩色相机<br />IMX269AQR-D</p><h3 id="描述">描述</h3><p>IMX269AQR-D是对角线21.77毫米（4/3型）CMOS有源像素型图像传感器，具有正方形像素阵列和21.27 M有效像素。该传感器集成了最大24 dB PGA电路和12位A / D转换器。 12位数字输出可以在静止图像模式下以27.27帧/秒的速度读出21.27 M有效像素的信号。</p><p>另外，该产品设计用于消费类数码相机。当将此产品用于其他应用程序时，Sony不保证产品的质量和可靠性。因此，请勿将其用于消费类数码相机以外的其他应用。</p><p>另外，由于这是标准产品，因此不能支持单独的规格更改。如有任何疑问，请咨询您的Sony销售代表。</p><h3 id="特征">特征</h3><ul><li>HD 1080 120p：垂直1/2二次采样，水平2/2加权合并模式，</li><li>10位120. 28（135.23）帧/秒HD 720 60p：垂直2/3二次采样合并水平3/3加权合并模式，</li><li>12位，90. 19（101.46）帧/秒，垂直2/3二次采样合并水平3/3加权合并模式，* 12位，68.05（76.55）帧/秒，垂直1/3二次采样，水平2/2加权合并模式，10位， 135.41（ 152.24） 帧/秒垂直2/5二次采样合并水平3/3加权合并模式，12位，112.79（126.89）帧/ s垂直1/5二次采样水平2/2加权合并模式，10位，223.89（25 1.72 ）帧 /秒垂直2/9二次采样合并水平3/3加权合并模式，12位，198.49（223.30）帧/秒垂直1/9二次采样水平2/2加权合并模式，10位，394.99（444.08）帧/ s垂直1 /10子采样水 平2/2加权合并模式，10位，436.97（491.28）帧/秒注）帧速率显示576 Mbps操作中的值。括号之间的值显示648 Mbps操作下的帧速率<br /></li><li>芯片上的H驱动器，V驱动器和串行通信电路</li><li>片上10位/ 12位A / D转换器</li><li>12ch LVDS输出</li><li>片上R，G，B原色马赛克滤镜</li></ul><p>索尼保留更改产品和规格的权利，恕不另行通知。</p><p>此信息不以任何暗示或其他方式授予任何专利或其他权利的任何许可。</p><h3 id="设备结构">设备结构</h3><p>CMOS图像传感器</p><ul><li>图像尺寸对角线21 .77毫米（类型4/3）</li><li>像素总数约5388（H）×4040（V） 2177万像素</li><li>有效像素数约5324（H）×3996（V） 21 27万像素</li><li>有效像素数约5280（H）×3956（V） 2089万像素</li><li>芯片尺寸20.4 9毫米（H）×17.83毫米（V）</li><li>晶胞尺寸3.30 µm（ H）×3.30 µm（V）</li><li>光学黑水平（H）方向：前 36像素，后0像素垂直（V）方向：前16像素，后0像素</li><li>基材 硅</li></ul><h3 id="电路系统块图和引脚配置">电路系统块图和引脚配置</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/BlockDiagram.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/PinConfiguration.png" /></p><h3 id="光谱灵敏度特性">光谱灵敏度特性</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/SpectralSensitivityCharacteristics.png" /></p><h3 id="图像传感器特性测量方法">图像传感器特性测量方法</h3><p>测量条件</p><ol type="1"><li>在以下测量中，设备驱动条件为寄存器设置，AC 特性和 DC 特性的典型值。</li><li>在以下测量中，将排除斑点像素，除非另有说明，否则将使用传感器（不包括斑点像素）的光学黑电平作为信号输出的参考，将其作为 Gr / Gb 信号输出或 Gr / Gb 信号的值。测量系统的 R / B 信号输出。</li></ol><p>该图像传感器的颜色编码和读出</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/ColorCodingDiagram.png" /></p><p>颜色编码图</p><p>该图像传感器的原色滤镜按照上图所示的布局进行排列（<strong>拜耳阵列</strong>）。 <code>Gr</code> 和 <code>Gb</code> 分别表示与 <code>R</code> 和 <code>B</code> 信号在同一行上的G信号。</p><h3 id="标准成像条件的定义">标准成像条件的定义</h3><ul><li>标准成像条件I：</li></ul><p>使用图案盒（亮度：<span class="math inline">\(706 cd / m^2\)</span>，色温为 <span class="math inline">\(3200 K\)</span>）作为对象。 （不适用于评估模式。）将测试标准镜头与 CM500S（t = 1.0毫米）一起用作 IR 截止滤镜，并与色温转换滤镜一起使用，以将色温调节至 <code>5100K</code>。</p><p>图像在F5.6。将在这种条件下对接收像素阵列的发光强度定义为标准灵敏度测试发光强度。</p><ul><li>标准成像条件II：</li></ul><p>对光源（色温 3200 K）成像，所有角度的亮度均匀度均在 <code>2％</code> 以内。请使用带有CM500S（t = 1.0毫米）的测试标准镜头作为 <code>IR</code> 截止滤镜，并与色温转换滤镜一起使用，以将色温调整为 <code>5100K</code>。镜头光圈将发光强度调整为每个测试项目中指示的值。</p><ol type="1"><li>灵敏度 / Sensitivity</li><li>饱和信号 / Saturation signal</li><li>视频信号黑点(shading) / Video signal shading</li><li>水平深色阴影</li><li>垂直条纹固定图案</li><li>暗信号</li><li>暗信号阴影</li><li>线爬网</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/CmosBlockDiagram.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/cmos_design.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/pixel_array.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/pixel_array1.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/pixel_array2.png" /></p><p>参考：</p><ol type="1"><li>CMOS图像传感器集成电路</li><li>IMX269AQR-D_Data-Sheet(E15406C68)_160923-comp</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/PhysicalPixelArray.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="camera" scheme="https://2020.iosdevlog.com/categories/camera/"/>
    
    
      <category term="cmos" scheme="https://2020.iosdevlog.com/tags/cmos/"/>
    
      <category term="document" scheme="https://2020.iosdevlog.com/tags/document/"/>
    
  </entry>
  
  <entry>
    <title>cmos</title>
    <link href="https://2020.iosdevlog.com/2020/05/02/cmos/"/>
    <id>https://2020.iosdevlog.com/2020/05/02/cmos/</id>
    <published>2020-05-01T16:13:12.000Z</published>
    <updated>2020-05-05T17:26:40.497Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502002818.png" /></p><p>图像传感器的工作原理<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502010950.png" /></p><p>CMOS sensor内部结构<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><p>图像传感器是一种半导体装置，能够把光学影像转化为数字信号。传感器上植入的微小光敏物质称作像素。一块传感器上包含的像素数越多，其提供的画面分辨率也就越高。它的作用就像胶片一样，但它是把图像像素转换成数字信号。</p><a id="more"></a><h2 id="cmos-sensor-基础知识3">CMOS Sensor 基础知识<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></h2><p>CMOS Parallel Sensor 一些基础知识</p><p>1S秒 = 1000 ms毫秒 = 1000_1000 us微妙 = 1000_000_000 ns纳秒</p><p>1GHz = 1000 MHz = 1000_000 KHz = 1000_000_000 Hz</p><p>曝光时间以行长为单位； PCLK以Hz为单位；</p><p>行长以周期数为单位，帧长以行长数为单位；其中周期数就是频率</p><p>T 周期以ms为单位；f 频率以Hz为单位；f = 1 / T；周期和频率都是时间单位，只是表现形式不同</p><p>Vsync = Dummy Line = VTotal = VTS = V_Size + V_Blank   // 帧长;    不占用曝光时间，但是会影响帧率（FPS）</p><p>Hsync = Dummy Pixel = HTotal = HTS = H_Size + H_Blank // 行长;    会增加曝光时间，会影响帧率（FPS）</p><p>FPS = PCLK / （VTS * HTS ）// 计算FPS</p><p>T_Row = HTS / PCLK  // INT_Time 等于 1 的时候，此公式表示一行的曝光时间。</p><p>Exp = T_Row * INT_Time // INT_Time 积分时间（曝光时间寄存器）</p><ol type="1"><li>计算FPS可以通过修改 V_Total, H_Total 或者 降低 PCLK频率（当HTS or VTS降低到极限之后，需要通过降低PCLK来达到降FPS的目的） 达到降帧的目的。</li><li>Ob = Black Level 暗电流</li><li>AE 主要控制Sensor Exp &amp; Gain 这两种寄存器</li><li>Sensor自带ISP，Mirror，Flip，WDR不做多的讲解</li></ol><p>CMOS MIPI Sensor</p><p>看数据线对数可以知道是N Lane 的Sensor</p><p>CMOS Sub-LVDS Sensor</p><p>看数据线对数可以知道是N Lane 的Sensor</p><p>CMOS Hispi</p><ul><li>integration  time 积分时间</li></ul><p>当光源周期与integration time成整数倍时才不会产生flicker</p><p>integration time即积分时间是以行为单位表示曝光时间（exposure time）的，比如说INT TIM为159，就是指sensor曝光时间为159行，<br />两者所代表的意思是相同的，都是表示sensor的曝光时间，但是integration time是一个相对的概念，即以行为单位，而每行所占的绝对时间与pclk的时钟频率和每一行包含多少pclk（即行长）有关；而exposure time则是指sensor曝光的绝对时间，两者换算的关系如下：<br />exposure time = integration time x 行长 /pclk 频率</p><p>光源周期应该理解为光源能量周期，是交流电周期的两倍（如交流电频率为50hz，则光源能量周期为0.01s)，步长所占绝对时间与光源能量周期相等。<br />flicker有两种情况，一种是逐行复位积分产生的，即帧内flicker，显示时图像出现明暗行交替的现象，主要是因为一帧内不同行虽然int tim 一致，但是因为积分起始位置不一样，且室内人工光源的发光强度与交流电的频率呈周期关系，导致不同行的受光量不一致，从而产生这种明暗行交替的现象，而且如果一帧所占时间不为光源能量周期的整数倍，可观察到flicker不稳定，明暗行的相对位置不断是变化的，就好像暗行在不断向上移动一样，如果能保证一帧所占绝对时间为光源能量周期的整数倍，filiker就可以稳定下来；<br />另一种情况是整帧复位积分方式产生的，即视频浏览时，帧间闪烁，即不同帧明暗不一致，目前其消除方法是通过调节glb gain值来改善</p><p>GLB GAIN就是全局增益，是调节图像的整体亮度的GAIN值，而R/B/G GAIN是AWB中用到的概念，针对三原色分别进行调节，是为了调整色偏用的</p><p>sensor 输出分为四种</p><ul><li>YUV<ul><li>"Y"表示明亮度（Lumina nce或Luma），也就是灰度值</li><li>"U"和"V"表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</li><li>存储格式<ul><li>planar （平面）先连续存储所有像素点的Y</li><li>packed （打包）连续交叉存储</li></ul></li><li>采样<ul><li>YUV4:4:4</li><li>YUV4:2:2</li><li>YUV4:2:0</li></ul></li></ul></li><li>raw RGB</li><li>RGB<ul><li>RGB565<ul><li>每个像素用16位表示，RGB分量分别使用5位、6位、5位（常用也就是上说的RGB）</li></ul></li><li>RGB555<ul><li>每个像素用16位表示，RGB分量都使用5位（剩下1位不用）</li></ul></li><li>RGB24<ul><li>每个像素用24位表示，RGB分量各使用8位</li></ul></li><li>RGB32<ul><li>每个像素用32位表示，RGB分量各使用8位（剩下8位不用）</li></ul></li><li>ARGB32<ul><li>每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）</li></ul></li></ul></li><li>JPEG</li></ul><p>六大硬件技术指标</p><ol type="1"><li>像素</li><li>靶面尺寸</li><li>感光度</li><li>电子快门</li><li>帧率</li><li>信噪比</li></ol><h2 id="图像传感器整体架构">图像传感器整体架构</h2><p>CMOS图像传感器本质是一块芯片，主要包括：感光区阵列（Bayer阵列，或叫像素阵列）、时序控制、模拟信号处理以及模数转换等模块。</p><ul><li>像素阵列：<ul><li>完成光电转换，将光子转换为电子。</li></ul></li><li>时序控制：<ul><li>控制电信号的读出、传递。</li></ul></li><li>模拟信号处理（ADC）：<ul><li>对信号去噪。（如用CDS去除reset noise、fpn等）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502001716.png" /></p><p>CMOS传感器示例</p><p>其中，像素阵列占整个芯片的面积最大，像素阵列是由一个个像素组成，它对应到我们看到每张图片中的每个像素。</p><p>每个像素包括感光区和读出电路，每个像素的信号经由模拟信号处理后，交由ADC进行模数转换后即可输出到数字处理模块。</p><h3 id="像素阵列的信号读出如下">像素阵列的信号读出如下：</h3><ol type="1"><li>每个像素在进行reset，进行曝光。</li><li>行扫描寄存器，一行一行的激活像素阵列中的行选址晶体管。</li><li>列扫描寄存器，对于每一行像素，一个个的激活像素的列选址晶体管。</li><li>读出信号，并进行放大。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502001916.png" /></p><p>CMOS传感器信号读出示意图</p><h2 id="图像传感器像素结构4">图像传感器像素结构<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2><p>CMOS传感器上的主要部件是像素阵列，这是其与传统芯片的主要区别。每个像素的功能是将感受到的光转换为电信号，通过读出电路转为数字化信号，从而完成现实场景数字化的过程。像素阵列中的每个像素结构是一样的，如图2.1是典型的前照式像素结构，其主要结构包括：</p><ul><li><code>On-chip-lens</code>:<ul><li>该结构可以理解为在感光元件上覆盖的一层微透镜阵列，它用来将光线聚集在像素感光区的开口上。可以增加光电转化效率，减少相邻像素之间的光信号串扰。</li></ul></li><li><code>Color filter</code>：<ul><li>该结构是一个滤光片，包括红/绿/蓝三种，分别只能透过红色、绿色、蓝色对应波长的光线。该滤光片结构的存在，使得每个像素只能感应一种颜色，另外的两种颜色分量需要通过相邻像素插值得到，即demosaic算法。</li></ul></li><li><code>Metal wiring</code>：<ul><li>可以为金属排线，用于读出感光区的信号（其实就是像素内部的读出电路）。</li></ul></li><li><code>Photodiode</code>：<ul><li>即光电信号转换器，其转换出的电信号会经过金属排线读出。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502002057.png" /></p><p>像素结构</p><h2 id="参考文档">参考文档</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://blog.csdn.net/YXFLINUX/article/details/49468753" target="_blank" rel="noopener">ISP：CMOS Sensor 基础知识</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://blog.csdn.net/taotongning/article/details/84637319" target="_blank" rel="noopener">CMOS图像传感器内部结构及工作原理</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="https://blog.csdn.net/shiyimin1/article/details/81607693" target="_blank" rel="noopener">CMOS 图像传感器简介（1）：像素结构</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p><a href="https://www.sohu.com/a/123178097_468626" target="_blank" rel="noopener">一文读懂图像传感器</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502002818.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;图像传感器的工作原理&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200502010950.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;CMOS sensor内部结构&lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图像传感器是一种半导体装置，能够把光学影像转化为数字信号。传感器上植入的微小光敏物质称作像素。一块传感器上包含的像素数越多，其提供的画面分辨率也就越高。它的作用就像胶片一样，但它是把图像像素转换成数字信号。&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>《跟我一起写 Makefile》 读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/30/makefile/"/>
    <id>https://2020.iosdevlog.com/2020/04/30/makefile/</id>
    <published>2020-04-30T06:12:54.000Z</published>
    <updated>2020-05-01T16:49:59.472Z</updated>
    
    <content type="html"><![CDATA[<p>《跟我一起写Makefile》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 是 陈皓 发表在其 CSDN 博客上的系列文章。该系列文章翻译整理自 GNU Make Manual ，一直受到读者的推荐，是很多人学习Makefile的首选文档。</p><a id="more"></a><h2 id="makefile-里有什么">Makefile 里有什么</h2><ol type="1"><li>显式规则<ul><li>显式规则说明了如何生成一个或多个目标文件。这是由 Makefile 的书写者明显指出要 生成的文件、文件的依赖文件和生成的命令。</li></ul></li><li>隐晦规则<ul><li>由于我们的 make 有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Make- file，这是由 make 所支持的。</li></ul></li><li>变量的定义<ul><li>在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像你 C 语 言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</li></ul></li><li>文件指示<ul><li>在一个 Makefile 中引用另一个 Makefile，就像 C 语言中的 include 一样</li><li>根据某些情况指定 Makefile 中的有效部分，就像 C 语言中的预编译 #if 一样;</li><li>定义一个多行的命令</li></ul></li><li>注释。<ul><li>Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用 # 字符，这个就像 C/C++ 中的 // 一样。如果你要在你的 Makefile 中使用 # 字符，可以用反斜杠进行转义，如:# 。</li></ul></li></ol><blockquote><p>在 Makefile 中的命令，必须要以 Tab 键开始。</p></blockquote><h3 id="引用其它的-makefile">引用其它的 Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="make-的工作方式">make 的工作方式</h3><ol type="1"><li>读入所有的 Makefile。</li><li>读入被 include 的其它 Makefile。</li><li>初始化文件中的变量。</li><li>推导隐晦规则，并分析所有规则。</li><li>为所有的目标文件创建依赖关系链。</li><li>根据依赖关系，决定哪些目标要重新生成。</li><li>执行生成命令。</li></ol><h2 id="书写规则">书写规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="通配符">通配符</h3><ul><li>*</li><li>?</li><li>~</li></ul><h3 id="文件搜寻">文件搜寻</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特殊变量 VPATH</span></span><br><span class="line">VPATH = src:../headers</span><br><span class="line"><span class="comment"># make 的“vpath”关键字</span></span><br><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure><h3 id="伪目标">伪目标</h3><p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标” 不是文件，所以 make 无法生成它的依赖关系和决定它是否要执行。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm *.o temp</span><br></pre></td></tr></table></figure><h3 id="多目标">多目标</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">    generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="静态模式">静态模式</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;    </span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。</li><li>target-pattern 是指明了 targets 的模式，也就是的目标集模式。</li><li>prereq-patterns 是目标的依赖模式，它对 target-pattern 形成的模式再进行一次依赖目标的定义。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="自动生成依赖性">自动生成依赖性</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure><p>一个模式规则来产生 .d 文件:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">    @set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">    <span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">    sed 's,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g' &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>; \ rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure><p>引入别的 Makefile 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure><h2 id="书写命令">书写命令</h2><h3 id="显示命令">显示命令</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译 XXX 模块......</span><br></pre></td></tr></table></figure><h3 id="命令出错">命令出错</h3><p>在 Makefile 的命令行前加一个减号 - (在 Tab 键之 后)，标记为不管命令出不出错都认为是成功的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure><h3 id="嵌套执行-make">嵌套执行 make</h3><ul><li>=</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable = value</span><br><span class="line"><span class="comment"># ==</span></span><br><span class="line">variable = value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure><ul><li>:=</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable := value</span><br><span class="line"><span class="comment"># ==</span></span><br><span class="line">variable := value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure><ul><li>+=</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> variable += value</span><br><span class="line"><span class="comment"># ==</span></span><br><span class="line">variable += value</span><br><span class="line"><span class="keyword">export</span> variable</span><br></pre></td></tr></table></figure><h3 id="定义命令包">定义命令包</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc yacc</span><br><span class="line"><span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure><h2 id="使用变量">使用变量</h2><h3 id="变量的基础">变量的基础</h3><p>需要给在变量名前加上 <code>$</code> 符号，但最好用小括号 <code>()</code> 或是大括号 <code>{}</code> 把变量给包括起来。</p><p>如果你要使用真实的 <code>$</code> 字符，那么你需要用 <code>$$</code> 来表示。</p><h3 id="变量中的变量">变量中的变量</h3><ul><li><code>$&lt;</code>：第一个依赖文件；</li><li><code>$@</code>：目标；</li><li><code>$^</code>：所有不重复的依赖文件，以空格分开</li></ul><h4 id="使用后面定义">= 使用后面定义</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o program <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure><p>我们执行“make all”将会打出变量 $(foo) 的值是 Huh?</p><p>($(foo) 的值是 <span class="math inline">\((bar) ，\)</span>(bar) 的值 是 <span class="math inline">\((ugh) ，\)</span>(ugh) 的值是 Huh? )</p><p>把变量的真实值推到后面来定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FLAGS = <span class="variable">$(include_dirs)</span> -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure><p>不好的地方：递归定义</p><h4 id="前面的变量不能使用后面的变量">:= 前面的变量不能使用后面的变量</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span></span><br><span class="line">bar x := later</span><br><span class="line"><span class="comment"># ==</span></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure><p>前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure><p>定义空格</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure><p>nullstring 是一个 Empty 变量，其中什么也没有，而我们的 space 的值是一个空格</p><p>如果 FOO 没有被定义过，那么变量 FOO 的值就是“bar”，如果 FOO 先前被定义过，那么这条语将什么也不做，其等价于:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">    FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h4 id="追加变量值">+= 追加变量值</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br><span class="line"><span class="comment"># ==</span></span><br><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := <span class="variable">$(objects)</span> another.o</span><br></pre></td></tr></table></figure><p>所不同的是，用 <code>+=</code> 更为简洁。</p><h3 id="变量高级用法">变量高级用法</h3><p>变量值的替换</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure><p>另外一种变量替换的技术是以“静态模式”</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure><p>把变量的值再当成变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=y</span><br><span class="line">y=z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure><h3 id="override-指示符">override 指示符</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;</span><br></pre></td></tr></table></figure><h3 id="多行变量-define-关键字">多行变量 define 关键字</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><h3 id="环境变量">环境变量</h3><ol type="1"><li>CFLAGS 环境变量<ul><li>全局</li></ul></li><li>Makefile 中定义了 CFLAGS<ul><li>局部</li></ul></li></ol><h3 id="目标变量">目标变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;;</span><br><span class="line"></span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure><h3 id="模式变量">模式变量</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure><h2 id="使用条件判断">使用条件判断</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>更简洁一些:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">    libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure><h3 id="语法">语法</h3><p>条件表达式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">    &lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">    &lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h4 id="if">if</h4><p>koijm,l;[p;l,]</p><h2 id="使用函数">使用函数</h2><p>函数调用，很像变量的使用，也是以 <code>$</code> 来标识的，其语法如下:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$&#123;&lt;function&gt; &lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure><p>Demo</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure><h3 id="字符串处理函数">字符串处理函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串替换</span></span><br><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br><span class="line"><span class="comment"># 模式字符串替换</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br><span class="line"><span class="comment"># 去空格函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">strip</span> a b c )</span></span><br><span class="line"><span class="comment"># 查找字符串</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="comment"># 过滤</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line">sources := foo.c bar.c baz.s ugh.h</span><br><span class="line"><span class="section">foo: <span class="variable">$(sources)</span></span></span><br><span class="line">    cc <span class="variable">$(<span class="built_in">filter</span> %.c %.s,<span class="variable">$(sources)</span>)</span> -o foo</span><br><span class="line"><span class="comment"># 反过滤</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br><span class="line"><span class="comment"># 取单词</span></span><br><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">word</span> 2, foo bar baz)</span> <span class="comment"># bar</span></span><br><span class="line"><span class="comment"># 取单词串</span></span><br><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;ss&gt;,&lt;e&gt;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment"># 单词个数统计</span></span><br><span class="line"><span class="variable">$(words &lt;text&gt;)</span></span><br><span class="line"><span class="variable">$(words foo bar baz)</span> <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 首单词</span></span><br><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用</span></span><br><span class="line"><span class="comment"># 搜索路径来指定编译器对头文件的搜索路径参数 CFLAGS </span></span><br><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-I%,$(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure><h3 id="文件名操作函数">文件名操作函数</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目录</span></span><br><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span> <span class="comment"># src/./</span></span><br><span class="line"><span class="comment"># 取文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span> <span class="comment"># foo.chacks</span></span><br><span class="line"><span class="comment"># 后缀</span></span><br><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span> <span class="comment"># .c .c</span></span><br><span class="line"><span class="comment"># 取前缀</span></span><br><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar.c hacks)</span> <span class="comment"># src/foos rc-1.0/bar hacks</span></span><br><span class="line"><span class="comment"># 加后缀</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c, foo bar)</span> <span class="comment"># foo.c bar.c</span></span><br><span class="line"><span class="comment"># 加前缀</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;,&lt;names...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/, foo bar)</span> <span class="comment"># src/foo src/bar</span></span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;,&lt;list2&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">join</span> aaa bbb,111 222 333)</span> <span class="comment"># aaa111 bbb222 333</span></span><br><span class="line"><span class="comment"># foreach</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br><span class="line">names := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br><span class="line"><span class="comment"># if</span></span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span></span><br><span class="line"><span class="comment"># call</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,...,&lt;parmn&gt;)</span></span><br><span class="line">reverse = $(1) $(2)</span><br><span class="line"><span class="comment"># call 函数提供参数时，最安全的做法是去除所有多余的空格</span></span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> reverse,a,b)</span></span><br><span class="line"><span class="comment"># origin 变量是哪里来的</span></span><br><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br><span class="line"><span class="comment"># &lt;variable&gt; 是变量的名字，不应该是引用。所以你最好不要在 &lt;variable&gt; 中使用 $ 字符</span></span><br><span class="line"><span class="keyword">ifdef</span> bletch</span><br><span class="line">    <span class="keyword">ifeq</span> <span class="string">"$(origin bletch)"</span> <span class="string">"environment"</span></span><br><span class="line">        bletch = barf, gag, etc. </span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># shell == ``</span></span><br><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br><span class="line"><span class="comment"># 控制 make 的函数</span></span><br><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text ...&gt;)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br><span class="line"><span class="comment"># demo 1</span></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># demo 2</span></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"><span class="section">err: <span class="variable">$(ERR)</span></span></span><br></pre></td></tr></table></figure><h2 id="make-的运行">make 的运行</h2><h3 id="make-的退出码">make 的退出码</h3><p>make 命令执行后有三个退出码:</p><ol type="1"><li>0 表示成功执行。</li><li>1 如果 make 运行时出现任何错误，其返回 1。</li><li>2 如果你使用了 make 的“-q”选项，并且 make 使得一些目标不需要更新，那么返回 2。</li></ol><h3 id="指定-makefile">指定 Makefile</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –f subdir.mk</span><br></pre></td></tr></table></figure><h3 id="指定目标">指定目标</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br></pre></td></tr></table></figure><p>GNU 这种开源软件</p><ul><li><code>all</code>: 这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</li><li><code>clean</code>: 这个伪目标功能是删除所有被 make 创建的文件。</li><li><code>install</code>: 这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</li><li><code>print</code>: 这个伪目标的功能是例出改变过的源文件。</li><li><code>tar</code>: 这个伪目标功能是把源程序打包备份。也就是一个 tar 文件。</li><li><code>dist</code>: 这个伪目标功能是创建一个压缩文件，一般是把 tar 文件压成 Z 文件。或是 gz 文件。</li><li><code>TAGS</code>: 这个伪目标功能是更新所有的目标，以备完整地重编译使用。</li><li><code>check</code> 和 <code>test</code>: 这两个伪目标一般用来测试 makefile 的流程。</li></ul><h3 id="检查规则">检查规则</h3><ul><li>-n, --just-print, --dry-run, --recon 不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试 makefile 很有用处。</li><li>-t, --touch 这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make 假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</li><li>-q, --question 这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出， 当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</li><li>-W <file>, --what-if=<file>, --assume-new=<file>, --new-file=<file> 这个参数需要指定一个 文件。一般是是源文件(或依赖文件)，Make 会根据规则推导来运行依赖于这个文件的命令，一般 来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</li></ul><p>另外一个很有意思的用法是结合 -p 和 -v 来输出 makefile 被执行时的信息。</p><h3 id="make-的参数">make 的参数</h3><p>-debug[=<options>] 输出 make 的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是 输出最简单的调试信息。下面是 <options> 的取值:</p><ul><li>a: 也就是 all，输出所有的调试信息。(会非常的多)</li><li>b: 也就是 basic，只输出简单的调试信息。即输出不需要重编译的目标。</li><li>v: 也就是 verbose，在 b 选项的级别之上。输出的信息包括哪个 makefile 被解析，不需要被 重编译的依赖文件(或是依赖目标)等。</li><li>i: 也就是 implicit，输出所以的隐含规则。</li><li>j: 也就是 jobs，输出执行规则中命令的详细信息，如命令的 PID、返回码等。</li><li>m: 也就是 makefile，输出 make 读取 makefile，更新 makefile，执行 makefile 的信息。</li></ul><h2 id="隐含规则">隐含规则</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">    cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="comment"># 没有必要写下下面的两条规则，可以隐含推出</span></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure><h3 id="隐含规则一览">隐含规则一览</h3><p>默认的后缀列表是: <code>.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el</code>。</p><ol type="1"><li>编译 C 程序的隐含规则。<ul><li><n>.o 的目标的依赖目标会自动推导为 <n>.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS) $(CFLAGS)</li></ul></li><li>编译 C++ 程序的隐含规则。<ul><li><n>.o 的目标的依赖目标会自动推导为 <n>.cc 或是 <n>.C ，并且其生成命令是 $(CXX) –c $(CPPFLAGS) $(CFLAGS) 。(建议使用 .cc 作为 C++ 源文件的后缀，而不是 .C ) 编译 Pascal 程序的隐含规则。</li></ul></li><li>编译 Pascal 程序的隐含规则。<ul><li><n>.o 的目标的依赖目标会自动推导为 <n>.p ，并且其生成命令是 $(PC) –c $(PFLAGS) 。</li></ul></li><li>编译 Fortran/Ratfor 程序的隐含规则。<ul><li><n>.o 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 或 <n>.f ，并且其生成命令是: * .f $(FC) –c $(FFLAGS)</li><li>.F $(FC) –c $(FFLAGS) $(CPPFLAGS)</li><li>.f $(FC) –c $(FFLAGS) $(RFLAGS)</li></ul></li><li>预处理 Fortran/Ratfor 程序的隐含规则。<ul><li><n>.f 的目标的依赖目标会自动推导为 <n>.r 或 <n>.F 。这个规则只是转换 Ratfor 或有预处理的 Fortran 程序到一个标准的 Fortran 程序。其使用的命令是:</li><li>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)</li><li>.r $(FC) –F $(FFLAGS) $(RFLAGS)</li></ul></li><li>编译 Modula-2 程序的隐含规则。<ul><li><n>.sym 的目标的依赖目标会自动推导为 <n>.def ，并且其生成命令是:$(M2C) $(M2FLAGS) <span class="math inline">\((DEFFLAGS) 。&lt;n&gt;.o 的目标的依赖目标会自动推导为 &lt;n&gt;.mod ，并且其生成命令是:\)</span>(M2C) $(M2FLAGS) $(MODFLAGS) 。</li></ul></li><li>汇编和汇编预处理的隐含规则。<ul><li><n>.o 的目标的依赖目标会自动推导为 <n>.s ，默认使用编译器 as ，并且其生成命令是:$ (AS) <span class="math inline">\((ASFLAGS) 。&lt;n&gt;.s 的目标的依赖目标会自动推导为 &lt;n&gt;.S ，默认使用 C 预编译器 cpp ，并且 其生成命令是:\)</span>(AS) $(ASFLAGS) 。</li></ul></li><li>链接 Object 文件的隐含规则。<ul><li><n> 目标依赖于 <n>.o ，通过运行 C 的编译器来运行链接程序生成(一般是 ld )，其生成命令 是:$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程 有效，同时也对多个 Object 文件(由不同的源文件生成)的也有效。例如如下规则:<br /><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x : y.o z.o</span><br></pre></td></tr></table></figure></li><li>并且 x.c 、y.c 和 z.c 都存在时，隐含规则将执行如下命令:<br /><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure></li><li>如果没有一个源文件(如上例中的 x.c)和你的目标名字(如上例中的 x)相关联，那么，你最好写 出自己的生成规则，不然，隐含规则会报错的。</li></ul></li><li>Yacc C 程序时的隐含规则。<ul><li><n>.c 的依赖文件被自动推导为 n.y (Yacc 生成的文件)，其生成命令是:$(YACC) $(YFALGS)<br />。(“Yacc”是一个语法分析器，关于其细节请查看相关资料)</li></ul></li><li>Lex C 程序时的隐含规则。<ul><li><n>.c 的依赖文件被自动推导为 n.l(Lex 生成的文件)，其生成命令是:$(LEX) $(LFALGS) 。(关 于“Lex”的细节请查看相关资料)</li></ul></li><li>Lex Ratfor 程序时的隐含规则。<ul><li><n>.r 的依赖文件被自动推导为 n.l (Lex 生成的文件)，其生成命令是:$(LEX) $(LFALGS) 。</li></ul></li><li>从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则。<ul><li><n>.ln(lint 生成的文件)的依赖文件被自动推导为 n.c ，其生成命令是:$(LINT) $(LINTFALGS) $(CPPFLAGS) -i 。对于 <n>.y 和 <n>.l 也是同样的规则。</li></ul></li></ol><h3 id="隐含规则使用的变量">隐含规则使用的变量</h3><p>例如，第一条隐含规则——编译 C 程序的隐含规则的命令是 $(CC) –c $(CFLAGS) $(CPPFLAGS) 。 Make 默认的编译命令是 cc ，如果你把变量 $(CC) 重定义成 gcc ，把变量 $(CFLAGS) 重定义成 -g ，那 么，隐含规则中的命令全部会以 gcc –c -g $(CPPFLAGS) 的样子来执行了。</p><p>我们可以把隐含规则中使用的变量分成两种:一种是命令相关的，如 CC ;一种是参数相的关，如 CFLAGS 。下面是所有隐含规则中会用到的变量:</p><h4 id="关于命令的变量">关于命令的变量</h4><ul><li><code>AR</code> : 函数库打包程序。默认命令是 ar</li><li><code>AS</code> : 汇编语言编译程序。默认命令是 as</li><li><code>CC</code> : C 语言编译程序。默认命令是 cc</li><li><code>CXX</code> : C++ 语言编译程序。默认命令是 g++</li><li><code>CO</code> : 从 RCS 文件中扩展文件程序。默认命令是 co</li><li><code>CPP</code> : C 程序的预处理器(输出是标准输出设备)。默认命令是 $(CC) –E</li><li><code>FC</code> : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77</li><li><code>GET</code> : 从 SCCS 文件中扩展文件的程序。默认命令是 get</li><li><code>LEX</code> : Lex 方法分析器程序(针对于 C 或 Ratfor)。默认命令是 lex</li><li><code>PC</code> : Pascal 语言编译程序。默认命令是 pc</li><li><code>YACC</code> : Yacc 文法分析器(针对于 C 程序)。默认命令是 yacc</li><li><code>YACCR</code> : Yacc 文法分析器(针对于 Ratfor 程序)。默认命令是 yacc –r</li><li><code>MAKEINFO</code> : 转换 Texinfo 源文件(.texi)到 Info 文件程序。默认命令是 makeinfo</li><li><code>TEX</code> : 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是 tex</li><li><code>TEXI2DVI</code> : 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是 texi2dvi</li><li><code>WEAVE</code> : 转换 Web 到 TeX 的程序。默认命令是 weave</li><li><code>CWEAVE</code> : 转换 C Web 到 TeX 的程序。默认命令是 cweave</li><li><code>TANGLE</code> : 转换 Web 到 Pascal 语言的程序。默认命令是 tangle</li><li><code>CTANGLE</code> : 转换 C Web 到 C。默认命令是 ctangle</li><li><code>RM</code> : 删除文件命令。默认命令是 rm –f</li></ul><h4 id="关于命令参数的变量">关于命令参数的变量</h4><p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p><ul><li><code>ARFLAGS</code> : 函数库打包程序 AR 命令的参数。默认值是 rv</li><li><code>ASFLAGS</code> : 汇编语言编译器参数。(当明显地调用 .s 或 .S 文件时)</li><li><code>CFLAGS</code> : C 语言编译器参数。</li><li><code>CXXFLAGS</code> : C++ 语言编译器参数。</li><li><code>COFLAGS</code> : RCS 命令参数。</li><li><code>CPPFLAGS</code> : C 预处理器参数。(C 和 Fortran 编译器也会用到)。</li><li><code>FFLAGS</code> : Fortran 语言编译器参数。</li><li><code>GFLAGS</code> : SCCS “get”程序参数。</li><li><code>LDFLAGS</code> : 链接器参数。(如:ld )</li><li><code>LFLAGS</code> : Lex 文法分析器参数。</li><li><code>PFLAGS</code> : Pascal 语言编译器参数。</li><li><code>RFLAGS</code> : Ratfor 程序的 Fortran 编译器参数。</li><li><code>YFLAGS</code> : Yacc 文法分析器参数。</li></ul><h3 id="隐含规则链">隐含规则链</h3><p>一个目标可能被一系列的隐含规则所作用。例如，一个 .o 的文件生成，可能会是先被<br />Yacc 的 [.y] 文件先成 .c ，然后再被 C 的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p><h2 id="使用-make-更新函数库文件">使用 make 更新函数库文件</h2><p>函数库文件的成员</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure><p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了 ar 命令来服务 的。如:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) : hack.o ar</span><br><span class="line">    cr foolib hack.o</span><br></pre></td></tr></table></figure><h3 id="函数库文件的后缀规则">函数库文件的后缀规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.a:</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure><p>等效于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(%.o) : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(AR)</span> r <span class="variable">$@</span> <span class="variable">$*</span>.o</span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$*</span>.o</span><br></pre></td></tr></table></figure><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/seisman/how-to-write-makefile" target="_blank" rel="noopener" class="uri">https://github.com/seisman/how-to-write-makefile</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《跟我一起写Makefile》&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 是 陈皓 发表在其 CSDN 博客上的系列文章。该系列文章翻译整理自 GNU Make Manual ，一直受到读者的推荐，是很多人学习Makefile的首选文档。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="linux" scheme="https://2020.iosdevlog.com/tags/linux/"/>
    
      <category term="makefile" scheme="https://2020.iosdevlog.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>51.com</title>
    <link href="https://2020.iosdevlog.com/2020/04/29/51/"/>
    <id>https://2020.iosdevlog.com/2020/04/29/51/</id>
    <published>2020-04-29T07:33:43.000Z</published>
    <updated>2020-05-01T15:25:58.903Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/yili.jpg" /></p><p>高中毕业的时候，零志愿要去伊梨体验，这是从博乐去伊梨途中经过 <strong>赛里木湖</strong>，在这里拍的照片。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/offline.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/enqueue.png" /></p><h2 id="常见问题答疑">常见问题答疑</h2><p>问题1：哪些用户有相册业务？<br />&gt; 答：2014年10月28日之前注册的部分用户有相册业务</p><p>问题2：我怎样才能查看到我的相册，核实有没有相册？<br />&gt; 答：登录 &lt;51.com&gt;，然后进入 <a href="http://my.51.com" target="_blank" rel="noopener" class="uri">http://my.51.com</a>，查看左侧导航栏，如果有“打包相册”按钮，说明有相册业务，可以“打包下载”。</p><p>问题3：相册打包大概多长时间可以下载？<br />&gt; 答：由于最近申请“打包下载相册”的用户比较多，从申请打包，到能够下载的时间大约在3天。</p><p>问题4：我不记得51.com的用户名了，怎么办？<br />&gt; 答：先在官网用你的用户名注册一下试试，如果注册成功了，说明您想的用户名是不存在的（存在的话是不可能注册成功的）；如果注册时提示用户名已存在,您可以尝试找回密码。</p><p>问题5：我没有绑定手机号，也没有绑定Email，无法通过“找回密码”的方式找回密码怎么办？<br />&gt; 答：如果您还记得您的注册日期（大概月份），玩过游戏的角色的话， 您可以走密码申诉通道来申诉密码。</p><p>问题6：请问你们真的会下线嘛？<br />&gt; 答：我们会按照公告时间准时下线。</p><p>问题7：下线之后相册还能找回嘛？<br />&gt; 答：很抱歉下线之后相册就无法找回了。</p><p>问题8：请问后续你们还开放相册功能吗？<br />&gt; 答：具体的请留意官网通知。</p><p>问题9：去打包为什么提示“打包完成”？<br />&gt; 答：可能因为玩家以前打包过，直接点击“打包完成”下载即可？</p><p>问题10：为什么我打包之后发现照片少了？<br />&gt; 答：请提供您的51账号联系客服人员帮您看下。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/dequeue.png" /></p><h2 id="纪念">纪念</h2><p>这里面有我许多在伊梨桥拍的照片，一直以为再也找不到了。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/museum.jpg" /></p><p>这是大一去 <strong>陕西</strong> 的时候拍的，当前门票才 35 元，当前的头发也是非常的长。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/ice.jpg" /></p><p>这是在高中在博乐 <strong>西部回归广场</strong> 拍的，当时还有奥运 5 环的照片，就不放上了。</p><p>放几张照片也算是纪念一下自己逝去的青春。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/yili.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;高中毕业的时候，零志愿要去伊梨体验，这是从博乐去伊梨途中经过 &lt;strong&gt;赛里木湖&lt;/strong&gt;，在这里拍的照片。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人" scheme="https://2020.iosdevlog.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="website" scheme="https://2020.iosdevlog.com/tags/website/"/>
    
  </entry>
  
  <entry>
    <title>详解EXIF-数码相机可交换的图像文件格式</title>
    <link href="https://2020.iosdevlog.com/2020/04/25/exif/"/>
    <id>https://2020.iosdevlog.com/2020/04/25/exif/</id>
    <published>2020-04-25T09:07:30.000Z</published>
    <updated>2020-04-25T14:05:35.769Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/RAW.png" /></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/EXIF.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/TIFF.png" /></p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>缩写</th><th>English</th><th>中文</th></tr></thead><tbody><tr class="odd"><td>DSC</td><td>Digital still camera</td><td>数码相机</td></tr><tr class="even"><td>DVC</td><td>Digital video camera</td><td>数码摄像机</td></tr><tr class="odd"><td>DTV</td><td>Digital television</td><td>数字电视</td></tr><tr class="even"><td>Primary image</td><td>The main image data</td><td>主要图像数据</td></tr><tr class="odd"><td>Thumbnail</td><td>A small image used to index the primary image</td><td>用于索引主图像的小图像</td></tr><tr class="even"><td>Compressed data</td><td>Data referred to in the JPEG Standard as “entropy coded data”</td><td>JPEG标准中称为“熵编码数据”的数据</td></tr><tr class="odd"><td>Tag</td><td>A field recording ancillary data about an image. Corresponds to “field” in TIFF</td><td>记录有关图像的辅助数据的字段。对应于TIFF中的“字段”</td></tr><tr class="even"><td>Tag information</td><td>A description of the tag contents</td><td>标签内容的说明</td></tr><tr class="odd"><td>Exif</td><td>An abbreviation of “Exchange image file format,” used here as the general term for this standard and earlier versions of this standard</td><td>“ Exchange映像文件格式”的缩写，在此用作本标准和本标准早期版本的总称</td></tr><tr class="even"><td>DCF</td><td>An abbreviation of “Design rule for Camera File System”; it defines folder structures based on Exif-JPEG and formats for recording in memory, and is the camera file system standard that guarantees interoperability among devices of different types.</td><td>根据DCF记录的可移动内存，或 文件系统可以移动的和不可移动的内存通过IF从外部设备进行访问（无论有线或有线无线）</td></tr><tr class="odd"><td>DCF media</td><td>Removable memory recorded in compliance with the DCF or, removable and non-removable memory that a file system can access from an external device through IF (regardless of wired or wireless)</td><td>根据DCF记录的可移动内存，或 文件系统可以移动的和不可移动的内存通过IF从外部设备进行访问（无论有线或有线无线）</td></tr><tr class="even"><td>Exif/DCF Writer</td><td>A digital still camera (DSC) or other device or application software that can output an Exif/DCF file</td><td>数码相机（DSC）或其他可以输出一个Exif / DCF文件</td></tr><tr class="odd"><td>Exif/DCF Editor</td><td>A device or application that edits (i.e., makes partial additions, changes, deletions) existing Exif/DCF files (Alternatively, image-editing application; includes some DTV, photo frames, and DSC)</td><td>进行编辑（即进行部分添加，更改，删除）现有的Exif / DCF文件 （或者，图像编辑应用程序；包括一些DTV，相框，和DSC）</td></tr><tr class="even"><td>Exif/DCF Reader</td><td>A device, such as a printer with a memory card slot, capable of directly reading an Exif/DCF file and printing or performing other output processing, as well as application software that uses Exif tags to perform image processing for output. (with playback function in conformity with the DCF Reader 1 and Reader 2 specifications described in 2.1 “Definition of Terms” of the DCF Standard)</td><td>一种设备，例如带有存储卡插槽的打印机，可以直接读取Exif / DCF文件并打印或执行其他输出处理，以及使用Exif标签执行图像的应用程序软件处理输出。（具有符合DCF的播放功能阅读器1和阅读器2的规范在2.1“术语的定义”中进行了描述DCF标准）</td></tr></tbody></table><h2 id="basic-structure-of-uncompressed-rgb-data">Basic Structure of Uncompressed RGB Data</h2><figure><img src="https://upload-images.jianshu.io/upload_images/910914-45a43320cfc1ee4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>Uncompressed</figcaption></figure><h2 id="basic-structure-of-jpeg-compressed-data">Basic Structure of JPEG Compressed Data</h2><figure><img src="https://upload-images.jianshu.io/upload_images/910914-994a8ee8d5e8fe2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" /><figcaption>Compressed</figcaption></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F </span><br><span class="line">00000000: FF D8 FF E1 BC 6E 45 78 69 66 00 00 49 49 2A 00    .X.a&lt;nExif..II*.</span><br><span class="line">00000010: 08 00 00 00 0E 00 0E 01 02 00 1B 00 00 00 F4 03    ..............t.</span><br><span class="line">00000020: 00 00 0F 01 02 00 1E 00 00 00 0F 04 00 00 10 01    ................</span><br><span class="line">00000030: 02 00 1E 00 00 00 2D 04 00 00 12 01 03 00 01 00    ......-.........</span><br><span class="line">00000040: 00 00 01 00 00 00 1A 01 05 00 01 00 00 00 4B 04    ..............K.</span><br><span class="line">00000050: 00 00 1B 01 05 00 01 00 00 00 53 04 00 00 28 01    ..........S...(.</span><br><span class="line">00000060: 03 00 01 00 00 00 02 00 00 00 31 01 02 00 18 00    ..........1.....</span><br><span class="line">00000070: 00 00 5B 04 00 00 32 01 02 00 14 00 00 00 73 04    ..[...2.......s.</span><br><span class="line">00000080: 00 00 13 02 03 00 01 00 00 00 01 00 00 00 69 87    ..............i.</span><br><span class="line">00000090: 04 00 01 00 00 00 B6 00 00 00 25 88 04 00 01 00    ......6...%.....</span><br><span class="line">000000a0: 00 00 AE 02 00 00 9C 9C 01 00 80 00 00 00 87 04    ................</span><br><span class="line">000000b0: 00 00 9E 9C 01 00 10 00 00 00 07 05 00 00 08 03    ................</span><br><span class="line">000000c0: 00 00 27 00 9A 82 05 00 01 00 00 00 17 05 00 00    ..&#39;.............</span><br><span class="line">000000d0: 9D 82 05 00 01 00 00 00 1F 05 00 00 22 88 03 00    ............&quot;...</span><br><span class="line">000000e0: 01 00 00 00 02 00 00 00 27 88 03 00 01 00 00 00    ........&#39;.......</span><br><span class="line">000000f0: 64 00 00 00 00 90 07 00 04 00 00 00 30 32 33 30    d...........0230</span><br><span class="line">00000100: 03 90 02 00 14 00 00 00 27 05 00 00 04 90 02 00    ........&#39;.......</span><br><span class="line">00000110: 14 00 00 00 3B 05 00 00 01 91 07 00 04 00 00 00    ....;...........</span><br><span class="line">00000120: 00 03 02 01 02 91 05 00 01 00 00 00 4F 05 00 00    ............O...</span><br><span class="line">00000130: 01 92 0A 00 01 00 00 00 57 05 00 00 02 92 05 00    ........W.......</span><br><span class="line">00000140: 01 00 00 00 5F 05 00 00 04 92 0A 00 01 00 00 00    ...._...........</span><br><span class="line">00000150: 67 05 00 00 05 92 05 00 01 00 00 00 6F 05 00 00    g...........o...</span><br><span class="line">00000160: 06 92 05 00 01 00 00 00 77 05 00 00 07 92 03 00    ........w.......</span><br><span class="line">00000170: 01 00 00 00 02 00 00 00 08 92 03 00 01 00 00 00    ................</span><br><span class="line">00000180: 00 00 00 00 09 92 03 00 01 00 00 00 20 00 00 00    ................</span><br><span class="line">00000190: 0A 92 05 00 01 00 00 00 7F 05 00 00 7C 92 07 00    ............|...</span><br><span class="line">000001a0: 00 01 00 00 87 05 00 00 00 A0 07 00 04 00 00 00    ................</span><br><span class="line">000001b0: 30 30 31 30 01 A0 03 00 01 00 00 00 01 00 00 00    0010............</span><br><span class="line">000001c0: 02 A0 04 00 01 00 00 00 A0 0F 00 00 03 A0 04 00    ................</span><br><span class="line">000001d0: 01 00 00 00 CA 08 00 00 05 A0 04 00 01 00 00 00    ....J...........</span><br><span class="line">000001e0: 90 02 00 00 15 A2 05 00 01 00 00 00 87 06 00 00    .....&quot;..........</span><br><span class="line">000001f0: 00 A3 07 00 01 00 00 00 03 00 00 00 01 A3 07 00    .#...........#..</span><br><span class="line">00000200: 01 00 00 00 00 00 00 00 01 A4 03 00 01 00 00 00    .........$......</span><br><span class="line">00000210: 00 00 00 00 02 A4 03 00 01 00 00 00 00 00 00 00    .....$..........</span><br><span class="line">00000220: 03 A4 03 00 01 00 00 00 00 00 00 00 04 A4 05 00    .$...........$..</span><br><span class="line">00000230: 01 00 00 00 8F 06 00 00 05 A4 03 00 01 00 00 00    .........$......</span><br><span class="line">00000240: 1A 00 00 00 06 A4 03 00 01 00 00 00 00 00 00 00    .....$..........</span><br><span class="line">00000250: 07 A4 03 00 01 00 00 00 00 00 00 00 08 A4 03 00    .$...........$..</span><br><span class="line">00000260: 01 00 00 00 00 00 00 00 09 A4 03 00 01 00 00 00    .........$......</span><br><span class="line">00000270: 00 00 00 00 0A A4 03 00 01 00 00 00 00 00 00 00    .....$..........</span><br><span class="line">00000280: 0B A4 07 00 04 00 00 00 00 00 00 00 0C A4 03 00    .$...........$..</span><br><span class="line">00000290: 01 00 00 00 00 00 00 00 00 00 00 00 02 00 01 00    ................</span><br><span class="line">000002a0: 02 00 04 00 00 00 52 39 38 00 02 00 07 00 04 00    ......R98.......</span><br><span class="line">000002b0: 00 00 30 31 30 30 00 00 00 00 07 00 00 00 01 00    ..0100..........</span><br><span class="line">000002c0: 04 00 00 00 03 02 00 00 01 00 02 00 02 00 00 00    ................</span><br><span class="line">000002d0: 4E 00 86 0E 02 00 05 00 03 00 00 00 97 06 00 00    N...............</span><br><span class="line">000002e0: 03 00 02 00 02 00 00 00 45 00 86 0E 04 00 05 00    ........E.......</span><br><span class="line">000002f0: 03 00 00 00 AF 06 00 00 05 00 01 00 01 00 00 00    ....&#x2F;...........</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>官方文档：<a href="http://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf" target="_blank" rel="noopener" class="uri">http://www.cipa.jp/std/documents/e/DC-008-2012_E.pdf</a></p><p>Perl 工具：<a href="https://exiftool.org" target="_blank" rel="noopener" class="uri">https://exiftool.org</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/RAW.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="camera" scheme="https://2020.iosdevlog.com/categories/camera/"/>
    
    
      <category term="protocal" scheme="https://2020.iosdevlog.com/tags/protocal/"/>
    
  </entry>
  
  <entry>
    <title>《视觉笔记入门课》笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/24/Visual-notes/"/>
    <id>https://2020.iosdevlog.com/2020/04/24/Visual-notes/</id>
    <published>2020-04-24T13:57:16.000Z</published>
    <updated>2020-04-24T14:45:05.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424215838.png" /></p><p>第一步，看轮廓，确定组成部分的几何形状。</p><p>第二步，做定位，观察各个组成部分之间衔接点的位置在哪里，然后下笔画出来。</p><p>第三步，补细节，如果你不是刻意追求扁平化的效果，“阴影”这类的细节补充可以为你的作品增添一些“高级感”。</p><a id="more"></a><h2 id="基础点线面1">基础：点线面<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><h3 id="点">点</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424215942.png" /></p><ol type="1"><li>常用形式，功能等同于我们在文档中的无序列表，可以用在一段文字前面。</li><li>标题的两端作为休止符号来用。</li><li>在笔记中可以指代任意的一点，比如 A 点、B 点等。</li></ol><h3 id="线">线</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424220041.png" /></p><ul><li>直线<ul><li>肯定的表达</li><li>链接</li></ul></li><li>波浪线（曲线）</li><li>折线<ul><li>剧烈起伏</li></ul></li><li>电话线<ul><li>纠结</li></ul></li><li>虚线<ul><li>不肯定</li></ul></li><li>弹簧线<ul><li>张力和拉力</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424220338.png" /></p><ol type="1"><li>表示一些很抽象的概念。</li><li>分割和划定边界的作用。</li><li>链接的作用。</li></ol><h3 id="面">面</h3><p>圆形</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424220845.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424220753.png" /></p><p>三角形</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424220926.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221528.png" /></p><p>方形</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221610.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221548.png" /></p><h2 id="人">人</h2><h3 id="单线人">单线人</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230530.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230556.png" /></p><h3 id="线框人">线框人</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230638.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230653.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230741.png" /></p><h3 id="动态人物">动态人物</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230807.png" /></p><h3 id="人物身份">人物身份</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221801.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221813.png" /></p><h3 id="人物头部和表情">人物头部和表情</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221841.png" /></p><p>鼻子有很多种类型：</p><ul><li>高鼻梁：挺直的 L 型；</li><li>蒜头鼻：倒写的问号；</li><li>小翘鼻：突出鼻尖，女生常用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424221944.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222003.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222016.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222031.png" /></p><h3 id="人物手势">人物手势</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222054.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222112.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222131.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222158.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222213.png" /></p><h3 id="多人场景">多人场景</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222236.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222307.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222320.png" /></p><h3 id="动手练习">动手练习</h3><ul><li>初级：临摹“单线人”。</li><li>中级：用单线人画出 3 种不同的姿势。</li><li>高级：为你的视觉笔记配上有表情的分享者头像。</li></ul><h2 id="动态容器">动态容器</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222603.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222625.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222703.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222725.png" /></p><h3 id="对话框">对话框</h3><p>先记录文字内容，再去用对话框把文字装起来。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223759.png" /></p><h3 id="会议开场">会议开场</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222806.png" /></p><h3 id="领导讲话">领导讲话</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424222902.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223319.png" /></p><h3 id="内容讨论">内容讨论</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223348.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223407.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223419.png" /></p><ul><li>产生矛盾冲突</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223528.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223547.png" /></p><ul><li>对话中产生激烈情绪或意外的信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223609.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223624.png" /></p><ul><li>意见不平衡</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223648.png" /></p><h3 id="会议结果">会议结果</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223722.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424223744.png" /></p><h3 id="动手练习-1">动手练习</h3><ul><li>初级：临摹方形、圆形、云朵形对话框。</li><li>中级：临摹这一讲中出现的所有容器元素，并理解它们的用处。</li><li>高级：为你最近参加的一个小型会议（或讨论）做个简单的视觉笔记。</li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/306" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/306</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424215838.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一步，看轮廓，确定组成部分的几何形状。&lt;/p&gt;
&lt;p&gt;第二步，做定位，观察各个组成部分之间衔接点的位置在哪里，然后下笔画出来。&lt;/p&gt;
&lt;p&gt;第三步，补细节，如果你不是刻意追求扁平化的效果，“阴影”这类的细节补充可以为你的作品增添一些“高级感”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="视觉笔记" scheme="https://2020.iosdevlog.com/categories/%E8%A7%86%E8%A7%89%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="visual" scheme="https://2020.iosdevlog.com/tags/visual/"/>
    
  </entry>
  
  <entry>
    <title>数码相机的成像原理</title>
    <link href="https://2020.iosdevlog.com/2020/04/24/cmos/"/>
    <id>https://2020.iosdevlog.com/2020/04/24/cmos/</id>
    <published>2020-04-24T07:35:39.000Z</published>
    <updated>2020-04-24T15:43:58.640Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424164830.png" /></p><a id="more"></a><h2 id="cmos1">CMOS<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><ol type="1"><li>像敏单元阵列</li><li>行驱动器</li><li>列时序控制逻辑</li><li>A/D 转换器</li><li>数据部线输出接口</li><li>控制接口</li></ol><p>硅片</p><h3 id="分类">分类</h3><ol type="1"><li>PPS 无源<ol type="1"><li>噪音大</li><li>效率低</li></ol></li><li>APS 有源</li></ol><h3 id="coms-成像流程">COMS 成像流程</h3><p>光电效应</p><ul><li>1887 年/德国/赫兹</li><li>光的频率 / 电子动能 <span class="math inline">\(E{k}\)</span> 成正比</li><li>光的频率不够大，不发生光电效应</li></ul><h2 id="结构">结构</h2><ul><li>像素阵列</li><li>多路输出器</li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://www.bilibili.com/video/BV1u7411F7rR" target="_blank" rel="noopener" class="uri">https://www.bilibili.com/video/BV1u7411F7rR</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200424164830.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="camera" scheme="https://2020.iosdevlog.com/categories/camera/"/>
    
    
      <category term="cmos" scheme="https://2020.iosdevlog.com/tags/cmos/"/>
    
  </entry>
  
  <entry>
    <title>如何画人</title>
    <link href="https://2020.iosdevlog.com/2020/04/23/people/"/>
    <id>https://2020.iosdevlog.com/2020/04/23/people/</id>
    <published>2020-04-23T15:04:16.000Z</published>
    <updated>2020-04-23T15:33:18.822Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230327.png" /></p><a id="more"></a><p>这几天看极课时间上的一门新课程：《视觉笔记入门课》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>开篇就讲：一图胜千言，我非常赞同这个观点。</p><p>不过我一般是在电脑上使用 MindMaster 制作思维导图，比如之前写的读书笔记：《一张图搞定《人民的名义》里错综复杂的人物关系图》<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p><p><img src="https://2020.iosdevlog.com/2020/02/14/people/1.svg" /></p><p>可放大观看。</p><p>课程里面主要是手绘的，我的绘画水平还不如小朋友呢。</p><p>如果能从人物图 <strong>转</strong> <code>手绘图</code>，或者手绘 <strong>转</strong> 真实人物就方便我练习了。</p><p>于是找出 Tensorflow Lite，测试一下效果。</p><p>识别出来是线框图，不过没有头，就这样吧，明天可以参照着练习手绘了。</p><h2 id="单线人的绘画方法">单线人的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230530.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230556.png" /></p><h2 id="线框人的绘画方法">线框人的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230638.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230653.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230741.png" /></p><h2 id="动态人物">动态人物</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230807.png" /></p><h2 id="多人场景的绘画方法">多人场景的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230919.png" /></p><p>具体绘制方法请到《视觉笔记入门课》查看。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/article/227210" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/article/227210</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://2020.iosdevlog.com/2020/02/14/people/" class="uri">https://2020.iosdevlog.com/2020/02/14/people/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230327.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="tf" scheme="https://2020.iosdevlog.com/tags/tf/"/>
    
      <category term="pose" scheme="https://2020.iosdevlog.com/tags/pose/"/>
    
  </entry>
  
  <entry>
    <title>话说软件工程</title>
    <link href="https://2020.iosdevlog.com/2020/04/22/software-engineering/"/>
    <id>https://2020.iosdevlog.com/2020/04/22/software-engineering/</id>
    <published>2020-04-22T01:55:04.000Z</published>
    <updated>2020-04-23T11:18:22.008Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103325.png" /></p><a id="more"></a><h2 id="维基百科自由的百科全书-1">维基百科，自由的百科全书 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>软件工程（英语：software engineering），是软件开发领域里对工程方法的系统应用。</p><p>1968 年秋季，NATO（北约）的科技委员会召集了近50名一流的编程人员、计算机科学家和工业界巨头，讨论和制定摆脱“软件危机”的对策。在那次会议上第一次提出了软件工程（software engineering）这个概念，研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。其后的几十年里，各种有关软件工程的技术、思想、方法和概念不断被提出，软件工程逐步发展为一门独立的科学。</p><p>1993年，电气电子工程师学会（IEEE）给出了一个更加综合的定义："将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中"。此后，IEEE多次给出软件工程的定义。</p><p>在现代社会中，软件应用于多个方面。典型的软件比如有电子邮件、嵌入式系统、人机界面、办公包、操作系统、网页、编译器、数据库、游戏等。同时，各个行业几乎都有计算机软件的应用，比如工业、农业、银行、航空、政府部门等。这些应用促进了经济和社会的发展，提高人们的工作效率，同时提升了生活质量。</p><p>软件工程师是对应用软件创造软件的人们的统称，软件工程师按照所处的领域不同可以分为系统分析师、系统架构师、前端和后端工程师、程序员、测试工程师、用户界面设计师等等。各种软件工程师人们俗称程序员。</p><h3 id="定义">定义</h3><p>关于软件工程的定义，在GB/T11457-2006《信息技术 软件工程术语》中将其定义为</p><blockquote><p>"应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科"。</p></blockquote><p>包括：<br />1. 创立与使用健全的工程原则，以便经济地获得可靠且高效率的软件。<br />1. 应用系统化，遵从原则，可被计量的方法来发展、操作及维护软件；也就是把工程应用到软件上。<br />1. 与开发、管理及更新软件产品有关的理论、方法及工具。<br />1. 一种知识或学科，目标是生产质量良好、准时交货、符合预算，并满足用户所需的软件。<br />1. 实际应用科学知识在设计、建构计算机程序，与相伴而来所产生的文件，以及后续的操作和维护上。<br />1. 使用与系统化生产和维护软件产品有关之技术与管理的知识，使软件开发与修改可在有限的时间与费用下进行。<br />1. 建造由工程师团队所开发之大型软件系统有关的知识学科。<br />1. 对软件分析、设计、实施及维护的一种系统化方法。<br />1. 系统化地应用工具和技术于开发以计算机为主的应用。<br />1. 软件工程是关于设计和开发优质软件。</p><h3 id="没有银弹与人月神话">没有银弹与人月神话</h3><p>在1986年，IBM大型机之父佛瑞德·布鲁克斯发表了他的著名论文《没有银弹》，在这篇著名的论文中他断言：“在10年内无法找到解决软件危机的灵丹妙药”。从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等。佛瑞德·布鲁克斯著名作品还有《人月神话》。</p><p>布鲁克斯在《人月神话：软件项目管理之道（The Mythical Man-Month）》提到，将没有灵丹妙药（silver bullet）可以一蹴而就，开发软件的困难是内生的，只能渐进式的改善。整体环境没有改变以前，唯一可能的解，是依靠人的素质，培养优秀的工程师。</p><h3 id="软件工程的发展方向">软件工程的发展方向</h3><p>“敏捷开发”（Agile Development）被认为是软件工程的一个重要的发展。它强调软件开发应当是能够对未来可能出现的变化和不确定性作出全面反应的。<br />敏捷开发被认为是一种“轻量级”的方法。在轻量级方法中最负盛名的应该是“极限编程”（Extreme Programming，简称为XP）。而与轻量级方法相对应的是“重量级方法”的存在。重量级方法强调以开发过程为中心，而不是以人为中心。重量级方法的例子比如CMM/PSP/TSP。</p><p>面向方面的程序设计（Aspect Oriented Programming，简称AOP）被认为是近年来软件工程的另外一个重要发展。这里的方面指的是完成一个功能的对象和函数的集合。在这一方面相关的内容有泛型编程（Generic Programming）和模板。</p><h2 id="软件工程之美2">软件工程之美<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p>软件工程学让我知道，软件项目的开发其实是一个工程，整个开发过程是可以有效组织起来的；对于开发过程的各个阶段，已经有很多解决问题的最佳实践，有很多方法来帮助我们高效完成任务；我们还可以借助工具来协助管理，提升开发效率。</p><ol type="1"><li>“器”就是软件工程中的各种工具。</li><li>“术”就是软件工程中的各种方法。<ul><li>例如如何做需求分析？</li><li>如何对需求变更做变更管理？</li></ul></li><li>“道”就是软件工程知识的核心思想、本质规律。<ul><li>例如为什么要有需求分析？</li><li>需求变更产生的深层次原因是什么？</li><li>项目中决策的依据是什么？</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104028.png" /></p><p>——《软件工程——实践者的研究方法》Roger S.Pressman</p><p>聚焦于质量，构建和维护高质量的软件</p><p>软件工程 = 工具 + 方法 + 过程</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104406.png" /></p><p>学习软件工程的四重境界</p><ol type="1"><li>用器：工具<ul><li>原型设计工具</li><li>持续集成工具</li></ul></li><li>学术：方法<ul><li>需求分析方法</li></ul></li><li>悟道：本源<ul><li>核心思想</li><li>本质规律</li></ul></li><li>传道<ul><li>教学</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104750.png" /></p><h3 id="基础理论">基础理论</h3><p>从宏观的角度建立起软件工程的知识结构，展现软件工程学的全景图，让你掌握从软件工程的基础概念到主流的软件过程方法论。</p><p>去尝试用工程化的思维模式，去分析和解决工作和生活中的问题。</p><p>工程</p><blockquote><p>有人参与、有计划、有步骤地造一件产品，我们通常称为“工程”。</p></blockquote><p>软件危机</p><blockquote><p>软件产品质量低劣、软件维护工作量大、成本不断上升、进度不可控、程序人员无限度地增加。</p></blockquote><p>软件工程，它是为研究和克服软件危机而生。</p><p>要用工程化方法去规范软件开发，让项目可以按时完成、成本可控、质量有保证。</p><p>工程方法</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422165654.png" /></p><p>Engineering Method<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><p>工程方法通常会分成六个阶段：想法、概念、计划、设计、开发和发布。</p><ol type="1"><li><strong>想法</strong>：想法阶段通常是想要解决问题。最开始问题通常是模糊的，所以需要清晰地定义好问题，研究其可行性，检查是否有可行的解决方案。</li><li><strong>概念</strong>：概念阶段就是用图纸、草图、模型等方式，提出一些概念性的解决方案。这些方案可能有多个，最终会确定一个解决方案。</li><li><strong>计划</strong>：计划阶段是关于如何实施的计划，通常会包含人员、任务、任务持续时间、任务的依赖关系，以及完成项目所需要的预算。</li><li><strong>设计</strong>：设计阶段就是要针对产品需求，将解决方案进一步细化，设计整体架构和划分功能模块，作为分工合作和开发实施的一个依据和参考。</li><li><strong>开发</strong>：开发阶段就是根据设计方案，将解决方案构建实施。开发阶段通常是一个迭代的过程，这个阶段通常会有构建、测试、调试和重新设计的迭代。</li><li><strong>发布</strong>：将最终结果包括文档发布。</li></ol><p>瀑布模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422105710.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422171515.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422171838.png" /></p><p>V 模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174616.png" /></p><p>螺旋模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174710.png" /></p><p>统一软件开发过程（Rational Unified Process，RUP）-《构建之法》</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174829.png" /></p><p>框架或指南：敏捷开发</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422105759.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422175150.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422180442.png" /></p><p>Jira<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422180930.png" /></p><p>每日站立会议</p><p>重点是要高效沟通反馈</p><h3 id="项目过程">项目过程</h3><p>软件生命周期，把知识点拆成：规划、需求分析、设计、编码、测试、运行维护这六个阶段，了解每个阶段要侧重做哪些事；分析每个阶段常见的问题，找到解决方法；了解各个阶段有哪些工具可以对项目有帮助，从而学会应用它们。</p><h3 id="案例分析">案例分析</h3><p>大公司是怎么应用软件工程的。</p><h2 id="参考书目">参考书目</h2><ul><li>《构建之法》</li></ul><p>作者邹欣是微软的研发总监，同时在多所高校进行了软件工程的教学实践，在此基础上对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。也是本专栏很多很好的补充。<br />* 《人月神话》</p><p>这是软件工程历史上的经典著作，内容发人深省，40 年来一直畅销不衰，里面的观点即使到现在也不过时。这本书即使你以前看过，隔一段时间再翻看一遍，可能都会有新的感悟。</p><ul><li>《人件》</li></ul><p>如果说《人月神话》关注“软件开发”本身，《人件》则关注软件开发中的“人”。作者指出知识型企业的核心是人，而不是技术。</p><ul><li>《知行合一： 实现价值驱动的敏捷和精益开发》</li></ul><p>作者丛斌有二十多年从事软件工程教学、咨询和研究的经验，所以书写的特别接地气，文章有很多真实案例，对敏捷开发和 CMMI 都有很深入描述。</p><ul><li>《软件工程——实践者的研究方法》</li></ul><p>这是大部分高校采用的软件工程标准教材，可以作为一个参考。《持续交付》讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。</p><ul><li>《走出软件作坊》</li></ul><p>这本书生动的描述了国内小型 IT 企业在发展过程中遇到的一系列项目管理问题，以及作者是如何去解决这些问题的。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/软件工程" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/软件工程</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/158" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/158</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="http://sites.tufts.edu/eeseniordesignhandbook/2013/engineering-method/" target="_blank" rel="noopener" class="uri">http://sites.tufts.edu/eeseniordesignhandbook/2013/engineering-method/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p><a href="https://www.atlassian.com/zh/software/jira/features" target="_blank" rel="noopener" class="uri">https://www.atlassian.com/zh/software/jira/features</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103325.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="software" scheme="https://2020.iosdevlog.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>i-Book.in：一个索引IPFS链接的搜索引擎</title>
    <link href="https://2020.iosdevlog.com/2020/04/21/IPFS/"/>
    <id>https://2020.iosdevlog.com/2020/04/21/IPFS/</id>
    <published>2020-04-20T16:00:05.000Z</published>
    <updated>2020-04-23T11:18:40.873Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103547.png" /></p><a id="more"></a><p>i-Book.in 是一个索引IPFS链接的搜索引擎 (beta_0.5)。</p><p>i-Book.in旨在为IPFS网络内储存的零散文件做一个索引，除描述外仅包含指向IPFS网络内的链接。本站索引的全部信息均从可公开获取的Internet资料中收集，仅用于提供信息的目的，它不储存任何文件。</p><p>i-Book.in尊重版权持有者的权利，并尊重DMCA，如您觉得本站包含的索引侵犯了您的权利，您可参照 该页面 提交版权声明，我们会在48小时内审核，核实后会做移除处理。</p><p>域名第一个字符 i 是有特殊含义的，代表着IPFS的 i 。本站索引指向的文件全部储存在IPFS网络上，这些链接由无数热心网友自主上传分享而来，我们只是做了一些微小的工作，将其整合到一个索引之中而已。</p><p>本搜索引擎不会采取强制收费制，以前、现在、未来都不会。但为了维持服务的正常运转，我们限制了游客跳转的次数(试图抵抗爬虫)。</p><p>并且为了支付服务器、CDN等必要开销，我们在内页设置了广告。请将本站加入【广告过滤插件】白名单以支持我们，当然，你也可以直接 捐赠 我们，让本站能够持续稳定的发展。</p><p>如果你觉得这个搜索引擎还不错，不妨分享给其他爱读书的朋友们。</p><p>i-Book.in 已经在 GitHub 开源了索引数据，有兴趣的可以 <a href="https://github.com/SaltyLeo/i-book.in" target="_blank" rel="noopener">点此</a> 访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103547.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="book" scheme="https://2020.iosdevlog.com/categories/book/"/>
    
    
      <category term="search" scheme="https://2020.iosdevlog.com/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>iData for iOS</title>
    <link href="https://2020.iosdevlog.com/2020/04/20/iData/"/>
    <id>https://2020.iosdevlog.com/2020/04/20/iData/</id>
    <published>2020-04-20T15:50:26.000Z</published>
    <updated>2020-04-20T16:04:12.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Detail.png" /></p><p>iData: <a href="https://www.cn-ki.net" target="_blank" rel="noopener" class="uri">https://www.cn-ki.net</a><br />iData for iOS: <a href="https://github.com/iOSDevLog/iData" target="_blank" rel="noopener" class="uri">https://github.com/iOSDevLog/iData</a></p><a id="more"></a><h2 id="screenshots">## Screenshots</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/About.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/List.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Empty.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Search.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Downloaded.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Open.png" /></p><h2 id="licence">## Licence</h2><p><code>iData</code> is released under the MIT license. See <a href="LICENSE">LICENSE</a> for details.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/Detail.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;iData: &lt;a href=&quot;https://www.cn-ki.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; class=&quot;uri&quot;&gt;https://www.cn-ki.net&lt;/a&gt;&lt;br /&gt;
iData for iOS: &lt;a href=&quot;https://github.com/iOSDevLog/iData&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; class=&quot;uri&quot;&gt;https://github.com/iOSDevLog/iData&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="data" scheme="https://2020.iosdevlog.com/categories/data/"/>
    
    
      <category term="paper" scheme="https://2020.iosdevlog.com/tags/paper/"/>
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>编译时修改 iOS icon</title>
    <link href="https://2020.iosdevlog.com/2020/04/20/icon/"/>
    <id>https://2020.iosdevlog.com/2020/04/20/icon/</id>
    <published>2020-04-20T06:49:14.000Z</published>
    <updated>2020-04-20T16:05:21.971Z</updated>
    
    <content type="html"><![CDATA[<p>Build informations on top of your app icon. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>How To Change Your App Icon at Build Time <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><a id="more"></a><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/krzysztofzablocki/IconOverlaying" target="_blank" rel="noopener" class="uri">https://github.com/krzysztofzablocki/IconOverlaying</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://www.raywenderlich.com/1716-how-to-change-your-app-icon-at-build-time" target="_blank" rel="noopener" class="uri">https://www.raywenderlich.com/1716-how-to-change-your-app-icon-at-build-time</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Build informations on top of your app icon. &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;How To Change Your App Icon at Build Time &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/categories/iOS/"/>
    
    
      <category term="icon" scheme="https://2020.iosdevlog.com/tags/icon/"/>
    
  </entry>
  
  <entry>
    <title>OSI 七层模型</title>
    <link href="https://2020.iosdevlog.com/2020/04/19/osi/"/>
    <id>https://2020.iosdevlog.com/2020/04/19/osi/</id>
    <published>2020-04-19T15:59:42.000Z</published>
    <updated>2020-04-20T16:08:06.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/OSI.jpg" /></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/TCP_IP.jpg" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/OSI.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>适用于 iOS 的虚拟机</title>
    <link href="https://2020.iosdevlog.com/2020/04/18/utm/"/>
    <id>https://2020.iosdevlog.com/2020/04/18/utm/</id>
    <published>2020-04-18T15:49:23.000Z</published>
    <updated>2020-04-18T15:56:04.033Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/utmapp/UTM/master/screen.png" /></p><blockquote><p>It is possible to invent a single machine which can be used to compute any computable sequence.</p></blockquote><p>-- Alan Turing, 1936</p><blockquote><p>有可能发明一台可以用来计算任何可计算序列的机器。</p></blockquote><p>-艾伦·图灵（Alan Turing），1936年</p><p>UTM 是 <code>iOS</code> 的功能齐全的虚拟机主机。简而言之，它使您可以在 <code>iPhone</code> 和 <code>iPad</code> 上运行 <code>Windows</code>，<code>Android</code> 等。有关更多信息，请访问https://getutm.app/</p><a id="more"></a><h2 id="特征">特征</h2><ul><li>借助 <code>qemu</code> 作为后端，支持 30 多种处理器，包括 <code>x86_64</code>，<code>ARM64</code> 和 <code>RISC-V</code></li><li>借助 <code>SPICE</code>，可通过半虚拟化实现快速本地图形处理</li><li>使用 <code>Qemu TCG</code> 的基于JIT的加速</li><li>使用最新和最出色的 <code>API</code> 从头开始为 <code>iOS11+</code> 设计的前端</li><li>直接从设备创建，管理，运行 <code>VM</code></li><li>无需越狱！</li></ul><h2 id="安装">安装</h2><p><a href="https://getutm.app/install/" target="_blank" rel="noopener" class="uri">https://getutm.app/install/</a></p><h2 id="github">GitHub</h2><p><a href="https://github.com/utmapp/UTM" target="_blank" rel="noopener" class="uri">https://github.com/utmapp/UTM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/utmapp/UTM/master/screen.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is possible to invent a single machine which can be used to compute any computable sequence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-- Alan Turing, 1936&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有可能发明一台可以用来计算任何可计算序列的机器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-艾伦·图灵（Alan Turing），1936年&lt;/p&gt;
&lt;p&gt;UTM 是 &lt;code&gt;iOS&lt;/code&gt; 的功能齐全的虚拟机主机。简而言之，它使您可以在 &lt;code&gt;iPhone&lt;/code&gt; 和 &lt;code&gt;iPad&lt;/code&gt; 上运行 &lt;code&gt;Windows&lt;/code&gt;，&lt;code&gt;Android&lt;/code&gt; 等。有关更多信息，请访问https://getutm.app/&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/categories/iOS/"/>
    
    
      <category term="github" scheme="https://2020.iosdevlog.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>首届 微软在线技术峰会 的云原生、开源与 DevOps 专场</title>
    <link href="https://2020.iosdevlog.com/2020/04/16/Microsoft/"/>
    <id>https://2020.iosdevlog.com/2020/04/16/Microsoft/</id>
    <published>2020-04-16T14:26:37.000Z</published>
    <updated>2020-04-16T15:10:16.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Microsoft.png" /></p><a id="more"></a><p>最敏捷的业务创新协作，最低成本的业务迭代落地，这才是云原生、开源与 DevOps。</p><p>Microsoft Azure 为您推荐首届 微软在线技术峰会 的云原生、开源与DevOps专场。</p><p>本专场将以微软的开源代码协作为基础，深入讲解如何利用云原生、开源以及DevOps来实现最敏捷的业务创新协作流程，帮助企业实现最低成本的业务需求。</p><p>4月18日 专场详情 ：</p><p>10：20-10：50 开源在企业中的应用与发展趋势<br />Chris Aniszczyk CNCF - CTO</p><p>10：50-11：40 Azure 无服务器与微服务治理模式<br />Alan Liu</p><p>11：40-12：30 简化K8s开发！OAM与DAPR云原生应用的全流程研发实战</p><p>13：00-13：50 Azure Spring Cloud: 在Kubernetes上运行spring boot微服务的新方式<br />梁莉 微软Cloud + AI Group首席产品经理Lead</p><p>13：50-14：40 DevOps与GitHub在企业中的最佳实践<br />庄俊乾 微软云计算开发领域专家</p><p>14：40-15：30 生产应用程序的 Debugging 和Interacting<br />Thomas Huang TW</p><p>15：30-16：20 为什么 VS Code 如此流行？<br />韩骏 微软开发工具事业部资深开发工程师</p><p>16：20-17：10 Azure Synapse在游戏数据分析中的最佳实践<br />杨永波 微软资深云计算架构师</p><p>同时，在最值得期待的峰会 Keynote 部分，Microsoft Azure 邀请到了微软CEO Satya Nadella 以及来自微软 Azure， Power Platform，Microsoft 365 及 GitHub 的全球CTO及 CVP 为大家带来6场深度 Keynote 演讲，共同展望前沿技术的当下与未来。</p><p>Microsoft Azure 诚挚的邀请您与来自两岸三地的 5W+ 技术达人、众多行业顶级媒体平台共同参与，实时解锁最新技术动态！让我们一同弯道超车，开启这趟数字化转型之旅 ！</p><p>PS: 开发者 免费使用 Office 365</p><p><a href="https://developer.microsoft.com/zh-cn/microsoft-365/dev-program" target="_blank" rel="noopener" class="uri">https://developer.microsoft.com/zh-cn/microsoft-365/dev-program</a></p><p>Get a free Microsoft 365 E5 developer subscription​</p><p>Be your own administrator and prototype apps and solutions on your sandbox subscription.</p><ul><li>Includes 25 user licenses for development purposes</li><li>Access core Microsoft 365 workloads and capabilities (Windows not included), including:<ul><li>All Office 365 apps including SharePoint, OneDrive, Outlook/Exchange, Teams, Planner, Word, Excel, PowerPoint, and more</li><li>Office 365 Advanced Threat Protection</li><li>Advanced analytics with Power BI</li><li>Enterprise Mobility + Security (EMS) for compliance and information protection</li><li>Azure Active Directory for building advanced identity and access management solutions</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/welcom_365.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/join.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/subscribe.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/onmicrosoft.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/Microsoft.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="open source" scheme="https://2020.iosdevlog.com/categories/open-source/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="microsoft" scheme="https://2020.iosdevlog.com/tags/microsoft/"/>
    
      <category term="tech" scheme="https://2020.iosdevlog.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/15/Data-structure/"/>
    <id>https://2020.iosdevlog.com/2020/04/15/Data-structure/</id>
    <published>2020-04-15T15:40:21.000Z</published>
    <updated>2020-04-15T18:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/1-7-2.jpg" /></p><h2 id="数据结构">数据结构</h2><blockquote><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><ol type="1"><li>逻辑结构<ol type="1"><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ol></li><li>物理结构<ol type="1"><li>顺序存储结构（数组）</li><li>链接存储结构（指针/引用）</li></ol></li></ol><a id="more"></a><h2 id="算法">算法</h2><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h3 id="算法的特性">算法的特性</h3><ol type="1"><li>输入</li><li>输出</li><li>有穷性</li><li>确定性</li><li>可行性</li></ol><h3 id="算法设计的要求">算法设计的要求</h3><ol type="1"><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高 &amp; 存储量低</li></ol><h3 id="算法效率的度量方法">算法效率的度量方法</h3><ol type="1"><li>事后统计方法<ul><li>通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</li><li>不科学、不准确</li></ul></li><li>事前分析估算方法<ul><li>在计算机程序编制前，依据统计方法对算法进行估算</li></ul></li></ol><p>因素：</p><ol type="1"><li>算法采用的策略、方法<ul><li>算法好坏的根本</li></ul></li><li>编译产生的代码质量<ul><li>软件支持</li></ul></li><li>问题的输入规模</li><li>机器执行指令的速度<ul><li>硬件性能</li></ul></li></ol><p>通过算法时间复杂度来估算算法时间效率。</p><h4 id="算法时间复杂度">算法时间复杂度</h4><blockquote><p>在进行算法分析时，语句总的执行次数 <span class="math inline">\(T(n)\)</span> 是关于问题规模 <span class="math inline">\(n\)</span> 的函数，进而分析 <span class="math inline">\(T(n)\)</span> 随 <span class="math inline">\(n\)</span> 的变化情况并确定 <span class="math inline">\(T(n)\)</span> 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：<span class="math inline">\(T(n)=O(f(n))\)</span>。</p></blockquote><p>这样用大写 <span class="math inline">\(O()\)</span> 来体现算法时间复杂度的记法，我们称之为 <strong>大O记法</strong>。</p><p>推导大O阶方法</p><ol type="1"><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li></ol><ul><li>常数阶：<span class="math inline">\(O(1)\)</span></li><li>线性阶：<span class="math inline">\(O(n)\)</span></li><li>对数阶：<span class="math inline">\(O(\log n)\)</span></li><li>平方阶：<span class="math inline">\(O(n^2)\)</span>，<span class="math inline">\(O(m×n)\)</span></li></ul><h4 id="算法空间复杂度">算法空间复杂度</h4><p>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为 <strong>原地工作</strong>，空间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h2 id="线性表list">线性表（List）</h2><blockquote><p>零个或多个数据元素的有限序列。</p></blockquote><h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><ul><li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度 MaxSize。</li><li>线性表的当前长度：length。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets//3-5-3.jpg" /></p><h3 id="线性表的链式存储结构">线性表的链式存储结构</h3><p>除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。</p><p>我们把存储数据元素信息的域称为 <code>数据域</code>，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素 ai 的存储映像，称为 <code>结点（Node）</code>。</p><p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-4.jpg" /></p><p>链表中第一个结点的存储位置叫做 <code>头指针</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-5.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/* 定义LinkList */</span></span><br></pre></td></tr></table></figure><p>若线性表为空表，则头结点的指针域为“空”。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-6.jpg" /></p><p>带有头结点的单链表</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-8.jpg" /></p><h3 id="单链表结构与顺序存储结构优缺点">单链表结构与顺序存储结构优缺点</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-11-1.jpg" /></p><p>经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。</li><li>若需要频繁插入和删除时，宜采用单链表结构。</li><li>比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚。</li><li>当然，这只是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li><li>而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。</li></ul><h3 id="静态链表">静态链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-12-5.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的静态链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">/* 游标(Cursor) ，为0时表示无指向 */</span></span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。</p><h3 id="循环链表">循环链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-13-3.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-13-4.jpg" /></p><h3 id="双向链表">双向链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-14-3.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-14-4.jpg" /></p><h3 id="线性表总结">线性表总结</h3><p>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。</p><p>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。</p><p>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。</p><p>总的来说，线性表的这两种结构，其实是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-15-1.jpg" /></p><h2 id="栈stack">栈（stack）</h2><blockquote><p>限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><ul><li>允许插入和删除的一端称为栈顶（top）</li><li>另一端称为栈底（bottom）</li><li>不含任何数据元素的栈称为空栈</li><li>栈又称为后进先出（LastIn First Out）的线性表，简称LIFO结构。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-2-2.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-2-3.jpg" /></p><h3 id="栈的顺序存储结构及实现">栈的顺序存储结构及实现</h3><h4 id="栈的顺序存储结构">栈的顺序存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 顺序栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        SElemType data[MAXSIZE];</span><br><span class="line">        <span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-4-2.jpg" /></p><p>进栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-4-3.jpg" /></p><h4 id="两栈共享空间">两栈共享空间</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-5-1.jpg" /></p><h4 id="栈的链式存储结构及实现链栈">栈的链式存储结构及实现（链栈）</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        SElemType data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        LinkStackPtr top;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">&#125; LinkStack;</span><br></pre></td></tr></table></figure><p>进栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-2.jpg" /></p><p>出栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-3.jpg" /></p><h3 id="栈的作用">栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p><p>所以现在的许多高级语言，比如 <code>Java</code>、<code>C#</code> 等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用Stack的 <code>push</code> 和 <code>pop</code> 方法，非常方便。</p><h3 id="栈的应用">栈的应用</h3><h4 id="递归">递归</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-8-3.jpg" /></p><p>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做 <strong>递归函数</strong>。</p><p>迭代和递归的区别是：</p><ul><li>迭代使用的是循环结构</li><li>递归使用的是选择结构</li></ul><p>递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。</p><h4 id="四则运算表达式求值">四则运算表达式求值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + (<span class="number">3</span> - <span class="number">1</span>) × <span class="number">3</span> + <span class="number">10</span> ÷ <span class="number">2</span></span><br></pre></td></tr></table></figure><p>后缀（逆波兰）表示法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</span><br></pre></td></tr></table></figure><ul><li>所有的符号都是在要运算数字的后面出现</li><li>没有括号</li></ul><p>中缀表达式转后缀表达式</p><ul><li>从左到右遍历中缀表达式的每个数字和符号<ul><li>若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，则判断其与栈顶符号的优先级<ul><li>是右括号或优先级不高于栈顶符号（乘除优先加减）<ul><li>则栈顶元素依次出栈并输出，并将当前符号进栈</li></ul></li></ul></li></ul></li><li>一直到最终输出后缀表达式为止。</li></ul><h2 id="队列queue">队列（queue）</h2><blockquote><p>只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p></blockquote><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。</p><p>允许插入的一端称为队尾，允许删除的一端称为队头。</p><p>假设队列是 <span class="math inline">\(q=(a_1,a_2,......,a_n)\)</span>，那么 <span class="math inline">\(a_1\)</span> 就是队头元素，而 <span class="math inline">\(a_n\)</span> 是队尾元素。</p><p>这样我们就可以删除时，总是从 <span class="math inline">\(a_1\)</span> 开始，而插入时，列在最后。</p><p>这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-10-1.jpg" /></p><h3 id="队列的抽象数据类型">队列的抽象数据类型</h3><p>入队列操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-1.jpg" /></p><p>出队列</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-2.jpg" /></p><h4 id="循环队列的顺序存储结构">循环队列的顺序存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-8.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">int</span> rear;  <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构及实现链队列">队列的链式存储结构及实现（链队列）</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-1.jpg" /></p><p>空队列时，front和rear都指向头结点</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-2.jpg" /></p><p>入队操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-3.jpg" /></p><p>出队操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-4.jpg" /></p><h3 id="总结">总结</h3><p>栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。</p><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。</p><p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p><p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p><p>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-14-1.jpg" /></p><h3 id="串字符串string">串/字符串（string）</h3><blockquote><p>由零个或多个字符组成的有限序列</p></blockquote><p>回文诗</p><blockquote><p>儿忆父兮妻忆夫，寂寥长守夜灯孤。迟回寄雁无音讯，久别离人阻路途。诗韵和成难下笔，酒杯一酌怕空壶。知心几见曾来往，水隔山遥望眼枯。</p></blockquote><p>一般记为 <span class="math inline">\(s=&quot;a_1a_2......a_n&quot; (n≥0)\)</span>，其中，s 是字符串的名称.</p><p>零个字符的串称为空串（nullstring），它的长度为零，可以直接用两双引号 "" 表示。</p><p><code>子串</code> 与 <code>主串</code>，串中任意个数的连续字符组成的子序列称为该串的 <code>子串</code>，相应地，包含子串的串称为 <code>主串</code>。</p><p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><h3 id="串的比较">串的比较</h3><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><h3 id="串的抽象数据类型">串的抽象数据类型</h3><h4 id="串的顺序存储结构">串的顺序存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-5-1.jpg" /></p><h4 id="串的链式存储结构">串的链式存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-5-3.jpg" /></p><h3 id="朴素的模式匹配算法">朴素的模式匹配算法</h3><p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 朴素的模式匹配法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;<span class="comment">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) <span class="comment">/* 两字母相等则继续 */</span></span><br><span class="line">      &#123;</span><br><span class="line">++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">      &#123;  </span><br><span class="line">         i = i-j+<span class="number">2</span>;<span class="comment">/* i退回到上次匹配首位的下一位 */</span></span><br><span class="line">         j = <span class="number">1</span>; <span class="comment">/* j退回到子串T的首位 */</span></span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp-模式匹配算法">KMP 模式匹配算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-2.jpg" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-3.jpg" /></p><p>子串有与首字符相等的字符</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-5.jpg" /></p><p>关键就取决于子串的结构中是否有重复的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-0-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过计算返回子串T的next数组。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">  i=<span class="number">1</span>;</span><br><span class="line">  j=<span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i&lt;T[<span class="number">0</span>])  <span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span> || T[i]== T[j]) <span class="comment">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span></span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++j;  </span><br><span class="line">next[i] = j;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">j= next[j];<span class="comment">/* 若字符不相同，则j值回溯 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span></span><br><span class="line"><span class="comment">/*  T非空，1≤pos≤StrLength(S)。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;<span class="comment">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">255</span>];<span class="comment">/* 定义一next数组 */</span></span><br><span class="line">get_next(T, next);<span class="comment">/* 对串T作分析，得到next数组 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">0</span> || S[i] == T[j]) <span class="comment">/* 两字母相等则继续，与朴素算法增加了j=0判断 */</span></span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">       j = next[j];<span class="comment">/* j退回合适的位置，i值不变 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP 算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显。</p><h3 id="总结-1">总结</h3><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p><p>本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。</p><p>现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如 KMP 模式匹配算法的学习，就是更有效地去理解 index 函数当中的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/1-7-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构是相互之间存在一种或多种特定关系的数据元素的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;逻辑结构
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;集合结构&lt;/li&gt;
&lt;li&gt;线性结构&lt;/li&gt;
&lt;li&gt;树形结构&lt;/li&gt;
&lt;li&gt;图形结构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;物理结构
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;顺序存储结构（数组）&lt;/li&gt;
&lt;li&gt;链接存储结构（指针/引用）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
      <category term="cs" scheme="https://2020.iosdevlog.com/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 组织也可以免费创建私有仓库</title>
    <link href="https://2020.iosdevlog.com/2020/04/15/github/"/>
    <id>https://2020.iosdevlog.com/2020/04/15/github/</id>
    <published>2020-04-15T13:49:49.000Z</published>
    <updated>2020-04-15T14:08:43.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/15/github/github.png" /></p><p>2019 年 GitHub 用户可以免费创建私有仓库，组织不行。</p><p>从今天开始，组织也可以免费创建私有仓库。</p><a id="more"></a><p>订阅 GitHub 邮件的都应该收到以 2 封邮件。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_2.png" /></p><p>GitHub 将永久性对用户和团队免费开放私有仓库的使用，并且不限制项目协作人数。</p><p>同时 GitHub 上当前拥有的一些核心功能，也将对所有人免费开放，以便开发者可以更好的使用 GitHub 来进行日常团队协作，无需再受价格阻碍。</p><p>每个项目的团队人员，现在可以在 GitHub 上自由使用 CI/CD，项目管理，代码审查，软件包管理等日常项目开发工作。</p><p>打开 GitHub，从主页也可以看到提示。</p><p>点击查看 <a href="https://github.blog/2020-04-14-github-is-now-free-for-teams/" target="_blank" rel="noopener" class="uri">https://github.blog/2020-04-14-github-is-now-free-for-teams/</a>。</p><p>拿组织 <a href="https://github.com/iOSDevLog" target="_blank" rel="noopener">iOSDevLog</a> 测试一下。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/new.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/assets.png" /></p><p>确定可以创建私有仓库了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/15/github/github.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2019 年 GitHub 用户可以免费创建私有仓库，组织不行。&lt;/p&gt;
&lt;p&gt;从今天开始，组织也可以免费创建私有仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://2020.iosdevlog.com/categories/github/"/>
    
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
      <category term="git" scheme="https://2020.iosdevlog.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://2020.iosdevlog.com/2020/04/13/network/"/>
    <id>https://2020.iosdevlog.com/2020/04/13/network/</id>
    <published>2020-04-12T16:27:21.000Z</published>
    <updated>2020-04-14T17:04:41.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png" /></p><p>维基百科<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener" title="TCP/IP协议族">网际网路协议套组</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener" title="应用层">应用层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Border_Gateway_Protocol" target="_blank" rel="noopener" title="Border Gateway Protocol">BGP</a></li><li><a href="https://zh.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener" title="Dynamic Host Configuration Protocol">DHCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener" title="Domain Name System">DNS</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="档案传输协定">FTP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="超文本传输协议">HTTP</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener" title="HTTPS">HTTPS</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Message_Access_Protocol" target="_blank" rel="noopener" title="Internet Message Access Protocol">IMAP</a></li><li><a href="https://zh.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener" title="Lightweight Directory Access Protocol">LDAP</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%AA%92%E9%AB%94%E9%96%98%E9%81%93%E6%8E%A7%E5%88%B6%E5%8D%94%E5%AE%9A&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">MGCP</a></li><li><a href="https://zh.wikipedia.org/wiki/MQTT" target="_blank" rel="noopener" title="MQTT">MQTT</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_News_Transfer_Protocol" target="_blank" rel="noopener" title="Network News Transfer Protocol">NNTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener" title="Network Time Protocol">NTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Post_Office_Protocol" target="_blank" rel="noopener" title="Post Office Protocol">POP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call" target="_blank" rel="noopener" title="Open Network Computing Remote Procedure Call">ONC/RPC</a></li><li><a href="https://zh.wikipedia.org/wiki/Real-time_Transport_Protocol" target="_blank" rel="noopener" title="Real-time Transport Protocol">RTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Real_Time_Streaming_Protocol" target="_blank" rel="noopener" title="Real Time Streaming Protocol">RTSP</a></li><li><a href="https://zh.wikipedia.org/wiki/Routing_Information_Protocol" target="_blank" rel="noopener" title="Routing Information Protocol">RIP</a></li><li><a href="https://zh.wikipedia.org/wiki/Session_Initiation_Protocol" target="_blank" rel="noopener" title="Session Initiation Protocol">SIP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="简单邮件传输协议">SMTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_blank" rel="noopener" title="Simple Network Management Protocol">SNMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener" title="Secure Shell">SSH</a></li><li><a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener" title="Telnet">Telnet</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E4%B8%8E%E5%AD%98%E5%9C%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="可扩展消息与存在协议">XMPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:应用层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener" title="传输层">传输层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener" title="Transmission Control Protocol">TCP</a></li><li><a href="https://zh.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener" title="User Datagram Protocol">UDP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="传输层安全性协定">TLS／SSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol" target="_blank" rel="noopener" title="Datagram Congestion Control Protocol">DCCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Stream_Control_Transmission_Protocol" target="_blank" rel="noopener" title="Stream Control Transmission Protocol">SCTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Resource_Reservation_Protocol" target="_blank" rel="noopener" title="Resource Reservation Protocol">RSVP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:传输层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%B1%A4" target="_blank" rel="noopener" title="网络层">网路层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener" title="Internet Protocol">IP</a> <ul><li><a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener" title="IPv4">IPv4</a></li><li><a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener" title="IPv6">IPv6</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="noopener" title="Internet Control Message Protocol">ICMP</a></li><li><a href="https://zh.wikipedia.org/wiki/ICMPv6" target="_blank" rel="noopener" title="ICMPv6">ICMPv6</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E7%A2%BA%E6%93%81%E5%A1%9E%E9%80%9A%E7%9F%A5" target="_blank" rel="noopener" title="明确拥塞通知">ECN</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Group_Management_Protocol" target="_blank" rel="noopener" title="Internet Group Management Protocol">IGMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Shortest_Path_First" target="_blank" rel="noopener" title="Open Shortest Path First">OSPF</a></li><li><a href="https://zh.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener" title="IPsec">IPsec</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:网络层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%A3%E7%B5%90%E5%B1%A4&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">连结层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="noopener" title="Address Resolution Protocol">ARP</a></li><li><a href="https://zh.wikipedia.org/wiki/Neighbor_Discovery_Protocol" target="_blank" rel="noopener" title="Neighbor Discovery Protocol">NDP</a></li><li><a href="https://zh.wikipedia.org/wiki/Tunneling_protocol" target="_blank" rel="noopener" title="Tunneling protocol">Tunnels</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener" title="Layer 2 Tunneling Protocol">L2TP</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Point-to-Point_Protocol" target="_blank" rel="noopener" title="Point-to-Point Protocol">PPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Media_access_control" target="_blank" rel="noopener" title="Media access control">MAC</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Ethernet" target="_blank" rel="noopener" title="Ethernet">Ethernet</a></li><li><a href="https://zh.wikipedia.org/wiki/Digital_subscriber_line" target="_blank" rel="noopener" title="Digital subscriber line">DSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Integrated_Services_Digital_Network" target="_blank" rel="noopener" title="Integrated Services Digital Network">ISDN</a></li><li><a href="https://zh.wikipedia.org/wiki/Fiber_Distributed_Data_Interface" target="_blank" rel="noopener" title="Fiber Distributed Data Interface">FDDI</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:链路协议"><em>更多...</em></a></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/0.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/1.png" /></p><h2 id="网络分层的真实含义是什么2">网络分层的真实含义是什么?<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p><img src="https://2020.iosdevlog.com/2020/04/13/network/2.jpg" /></p><ol type="1"><li>始终想象自己是一个处理网络包的程序:<ul><li>如何拿到网络包，如何根据规则进行处理，如何发出去;</li></ul></li><li>始终牢记一个原则:<ul><li>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li></ul></li></ol><p>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然 是发不出去的。</p><h2 id="ifconfig">ifconfig</h2><ul><li>Windows<ul><li>ifconfig</li></ul></li><li>Linux<ul><li>net-tools<ul><li>ifconfig</li></ul></li><li>iproute2<ul><li>ip addr</li></ul></li></ul></li></ul><blockquote><p><code>IP 地址</code> 是一个网卡在网络世界的 <strong>通讯地址</strong>，相当于我们现实世界的门牌号码。</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/04/13/network/3.jpg" /></p><h3 id="无类型域间选路cidr">无类型域间选路(CIDR)</h3><p>于是有了一个折中的方式叫作无类型域间选路，简称 CIDR。</p><p>这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。</p><p><code>10.100.122.2/24</code>，这个 IP 地址中有一个 <em>斜杠</em>，斜杠后面有个数字 <code>24</code>。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><blockquote><p>MAC 地址更像是 <strong>身份证</strong>，是一个唯一的标识。</p></blockquote><h3 id="公有-ip-地址和私有-ip-地址">公有 IP 地址和私有 IP 地址</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/4.jpg" /></p><h3 id="排队规则qdisc-queueing-discipline">排队规则（qdisc， queueing discipline）</h3><ul><li>pfifo<ul><li>不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列</li></ul></li><li>pfifo_fast<ul><li>三个波段(band)</li><li>每个波段里面，使用先进先出规则</li><li>band 0 的优先级最高</li></ul></li></ul><p>数据包是按照服务类型(Type of Service，TOS)被分配多三个波段(band)里面的。<code>TOS</code> 是 IP 头里 面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><ul><li>IP 是地址，有定位功能</li><li>MAC 是身份证，无定位功能</li><li>CIDR 可以用来判断是不是本地人</li><li>IP 分公有的 IP 和私有的 IP</li></ul><h3 id="网络设备的状态标识net_device-flags">网络设备的状态标识（net_device flags）</h3><ul><li>UP：网卡处于启动的状态</li><li>BROADCAST：网卡有广播地址，可以发送广播包</li><li>MULTICAST：发送多播包</li><li>LOWER_UP： 网线插着，L1 是启动的</li><li>MTU （二层 MAC 层）1500：最大传输单元 MTU 为 1500，这是以太网的默认值</li></ul><h2 id="dhcp与pxe">DHCP与PXE</h2><p>如何配置 IP 地址</p><p><code>net-tools</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24 </span><br><span class="line">sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure><p><code>iproute2</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line">sudo ip link <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure><p>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发 送到网关。</p><p>配置文件</p><ol type="1"><li>CIDR（IP地址）</li><li>子网掩码</li><li>广播地址</li><li>网关地址</li></ol><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</p><ol type="1"><li>DHCP <strong>D</strong>iscover</li><li>DHCP <strong>O</strong>ffer</li><li>DHCP <strong>R</strong>equest</li><li>DHCP <strong>A</strong>ck</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/5.png" /></p><p>dhcp_protocol<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><h3 id="预启动执行环境preboot-execution-environment-pxe">预启动执行环境（Preboot Execution Environment / <strong>PXE</strong>)</h3><p>操作系统启动</p><ol type="1"><li>BIOS（Basic Input output System)</li><li>读取 MBR(Master Boot Record， 主引导记录)</li><li>启动 GRUB（GRand Unified Bootloader，多重操作系统启动管理器)</li><li>GRUB 加载内核，根文件系统 initramfs</li><li>启动内核</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/6.jpg" /></p><h2 id="从二层到三层">从二层到三层</h2><h3 id="第一层物理层">第一层：物理层</h3><h4 id="最小的局域网lan">最小的局域网（LAN）</h4><p>2 台电脑相连</p><ul><li>网线<ul><li>水晶头</li><li>1,2 收</li><li>3,6 发</li><li>需要 1和3，2和6 交换位置</li></ul></li></ul><h4 id="集线器-hub-广播模式">集线器 / Hub （广播模式）</h4><ul><li>多台电脑相连</li><li>完全复制</li></ul><h3 id="第二层数据链路层mac层-medium-access-control媒体访问控制">第二层：数据链路层（MAC）层 (Medium Access Control，媒体访问控制)</h3><ol type="1"><li>信道化分</li><li>轮流协议</li><li>随机接入协议<ul><li>以太网</li></ul></li></ol><p>第二层的网络包格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/7.jpg" /></p><h5 id="arp">ARP</h5><p>已知 IP 地址，求 MAC 地址的协议</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/8.jpg" /></p><p>报文</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/9.jpg" /></p><h4 id="交换机">交换机</h4><ul><li>转发表</li></ul><ol type="1"><li>MAC 层是用来解决多路访问的堵车问题的;</li><li>ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存;</li><li>交换机是有MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。</li></ol><h3 id="交换机与vlan">交换机与VLAN</h3><p>拓扑结构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/10.jpg" /></p><p>环路问题</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/11.jpg" /></p><p>STP 协议</p><p>在数据结构中，有一个方法叫做 <strong>最小生成树</strong>。有环的我们常称为 <strong>图</strong>。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作 <code>STP</code>，全称 <em>Spanning Tree Protocol</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/12.jpg" /></p><ul><li>Root Bridge，也就是根交换机。这个比较容易理解，可以比喻为“掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li><li>Designated Bridges，有的翻译为指定交换机。这个比较难理解，可以想像成一个“小弟”，对于树来说，就是一棵树的树枝。所谓“指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li><li>Bridge Protocol Data Units （BPDU） ，网桥协议数据单元。可以比喻为“相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU 只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li><li>Priority Vector，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看 Root Bridge ID。拿出老大的 ID 看看，发现掌门一样，那就是师兄弟；再比 Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比 Bridge ID，比我自己的 ID，拿自己的本事比。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/13.jpg" /></p><h3 id="虚拟局域网-vlan">虚拟局域网 (VLAN)</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/14.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/15.jpg" /></p><p>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</p><p>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</p><h3 id="icmp-与-ping">ICMP 与 ping</h3><p>ping 是基于 ICMP 协议工作的（查询报文）。</p><p>ICMP 全称 <strong>Internet Control Message Protocol</strong>，就是互联网控制报文协议。</p><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/16.jpg" /></p><p><code>查询报文</code></p><p>常用的 ping 就是 <strong>查询报文</strong>，是一种主动请求，并且获得主动应答的 ICMP 协议。</p><ul><li>对 ping 的主动请求，进行网络抓包，称为 ICMP ECHO REQUEST。</li><li>主动请求的回复，称为 ICMP ECHO REPLY。</li></ul><p>比起原生的 ICMP，这里面多了两个字段：</p><ul><li>一个是标识符</li><li>另一个是序号</li></ul><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><p><code>差错报文</code></p><ol type="1"><li>终点不可达<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达</li><li>端口不可达</li><li>需要进行分片但设置了不分片位</li></ul></li><li>源站抑制<ul><li>让源站放慢发送速度</li></ul></li><li>时间超时<ul><li>超过网络包的生存时间还是没到</li></ul></li><li>路由重定向<ul><li>让下次发给另一个路由器</li></ul></li></ol><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><p>而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。</p><p><code>ping</code>：查询报文类型的使用</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/17.jpg" /></p><p><code>Traceroute</code>：差错报文类型的使用</p><p>traceroute，现代 Linux系统 称为 tracepath，Windows系统称为 tracert，是一种电脑网络工具。它可显示封包在 IP 网络经过的路由器的 IP 地址。</p><p>它会使用 ICMP 的规则，故意制造一些能够产生错误的场景。</p><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</p><p>Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。</p><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。</p><p>ICMP 相当于网络世界的侦察兵。</p><p>两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文</p><ol type="1"><li>ping 使用查询报文</li><li>Traceroute 使用差错报文</li></ol><h3 id="网关">网关</h3><p>出入门</p><p>路由器会有内网网口和外网网口。</p><p>配置网卡</p><p>当然 DHCP 是可以默认配置的。在进行网卡配置的时候，除了 IP 地址，还需要配置一个 <code>Gateway</code> 的东西，这个就是 <code>网关</code>。</p><figure><img src="https://2020.iosdevlog.com/2020/04/13/network/18.jpg" alt="" /><figcaption>MAC 头和 IP 头</figcaption></figure><p>MAC 头</p><ol type="1"><li>目标 MAC 地址</li><li>源 MAC 地址</li><li>协议类型<ol type="1"><li>IP 协议<br />IP 头</li></ol></li><li>版本号： IPv4</li><li>服务类型 TOS (Type of Service)</li><li>TTL</li><li>协议<ol type="1"><li>TCP</li><li>UDP</li></ol></li><li>源 IP</li><li>目标 IP<ol type="1"><li>CIDR 和子网掩码</li><li>判断是否在同一网段<ol type="1"><li>同一个网段<ol type="1"><li>通过 ARP 获得 MAC 地址</li></ol></li><li>不是同一网段<ol start="2" type="1"><li>需要发往默认网关 Gateway</li></ol></li></ol></li></ol></li></ol><p>网关往往是一个 <code>路由器</code>，是一个 <code>三层</code> 转发的设备。</p><p>一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。</p><p>很多情况下，人们把网关就叫作路由器。</p><p>其实不完全准确。</p><p>路由器是一台设备。</p><h4 id="静态路由">静态路由</h4><p>MAC 地址是一个局域网内才有效的地址。</p><p>因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。</p><p>两者主要的区别在于 IP 地址是否改变。</p><ul><li>不改变 IP 地址的网关，称为 <code>转发网关</code>；</li></ul><p>“欧洲十国游”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/19.jpg" /></p><ul><li>改变 IP 地址的网关，称为 <code>NAT 网关</code>。</li></ul><p>Network Address Translation 地址转换，简称 NAT。<br />网络地址端口转换NAPT（Network Address Port Translation）有端口号。</p><p>“玄奘西行”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/20.jpg" /></p><p>Source Network Address Translation 源地址转换，简称 SNAT。<br />Destination Network Address Translation 目标地址转换，简称 SNAT。</p><p>路由表</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/21.jpg" /></p><ol type="1"><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则；</li><li>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</li></ol><h4 id="动态路由">动态路由</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/22.jpg" /></p><ul><li>距离矢量路由算法</li></ul><p>第一大类的算法称为距离矢量路由（distance vector routing）。它是基于 Bellman-Ford 算法的。</p><p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每</p><p>一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/23.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/24.jpg" /></p><ul><li>链路状态路由算法</li></ul><p>第二大类算法是链路状态路由（link state routing），基于 Dijkstra 算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。</p><p>然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链</p><p>路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。</p><p>每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到</p><p>两点之间的最短路径。</p><p>动态路由协议</p><ul><li>基于链路状态路由算法的 OSPF<br />OSPF（Open Shortest Path First，开放式最短路径优先）就是这样一个基于链路状态路由协议，广泛</li></ul><p>应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为内部网关协议</p><p>（Interior Gateway Protocol，简称IGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><ul><li>基于距离矢量路由算法的 BGP</li></ul><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为外网路由协议（Border Gateway Protocol，简称BGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。</p><p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p><p>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</p><h2 id="最重要的传输层">最重要的传输层</h2><p>MAC 层定义本地局域网传输。<br />IP 层定义了整个网络端到端的传输行为</p><p>这两层基本定义了这样的基因</p><blockquote><p>网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。 我们笼统地称为包。</p></blockquote><p>包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因， 生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="udp">UDP</h3><p>UDP 包头</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/27.jpg" /></p><p>UDP 的三大特点：</p><ol type="1"><li>沟通简单</li><li>轻信他人</li><li>愣头青，做事不懂权变</li></ol><p>UDP 的三大使用场景</p><ol type="1"><li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。</li><li>不需要一对一沟通，建立连接，而是可以广播的应用。</li><li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。</li></ol><p>基于 UDP 定制化的五个例子</p><ol type="1"><li>网页或者 APP 的访问<ol type="1"><li>QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</li></ol></li><li>流媒体的协议</li><li>实时游戏</li><li>IoT 物联网</li><li>移动通信领域</li></ol><p>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；<br />TCP 维护连接，UDP 谁都相信；<br />TCP 会坚持知进退；UDP 愣头青一个，勇往直前；<br />UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</p><h3 id="tcp">TCP</h3><p>TCP 包头格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/28.jpg" /></p><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><p>TCP 的三次握手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/29.jpg" /></p><p>SYN （Synchronize Sequence Number，同步序列编号）<br />ACK （Acknokedgement）用于回复<br />RST （Reset）</p><p>TCP 四次挥手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/30.jpg" /></p><p>FIN （finish）</p><p>TCP 状态机</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/31.jpg" /></p><p>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</p><p>连接的建立是经过三次握手，断开的时候四次挥手。</p><p>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘 录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少;</p><p>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着 石头过河，找到最优值。</p><h3 id="socket">Socket</h3><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根</p><p>网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p><p>Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。</p><p>另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h4 id="基于-tcp-协议的-socket-程序函数调用过程">基于 TCP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/32.jpg" /></p><p>TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。</p><p>除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>文件描述符是一个整数，是这个数组的下标。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/33.jpg" /></p><h4 id="基于-udp-协议的-socket-程序函数调用过程">基于 UDP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/34.jpg" /></p><h4 id="服务器如何接更多的项目">服务器如何接更多的项目？</h4><p>系统会用一个四元组来标识一个 TCP 连接。</p><p>{本机 IP, 本机端口, 对端 IP, 对端端口}</p><ul><li>多进程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/35.jpg" /></p><ul><li>多线程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/36.jpg" /></p><ul><li>IO 多路复用，一个线程维护多个 Socket</li><li>IO 多路复用，从“派人盯着”到“有事通知” epoll</li></ul><p>epoll 被称为解决C10K 问题的利器。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/37.jpg" /></p><p>记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</p><p>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决。</p><h2 id="最常用的应用层">最常用的应用层</h2><h3 id="http-协议">HTTP 协议</h3><p>HTTP 的报文大概分为三大部分。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/38.jpg" /></p><ol type="1"><li>请求行<ol type="1"><li>GET 获取 R</li><li>POST 创建 C</li><li>PUT 修改 U</li><li>DELETE 删除 D</li></ol></li><li>请求的首部<ol type="1"><li>Accept-Charset：客户端可以接受的字符集</li><li>Content-Type：正文的格式</li></ol></li><li>请求的正文实体</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/39.jpg" /></p><p>HTTP 2.0</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/40.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/41.jpg" /></p><p>QUIC 协议</p><p>机制一：自定义连接机制<br />机制二：自定义重传机制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/42.jpg" /></p><p>机制三：无阻塞的多路复用<br />机制四：自定义流量控制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/43.jpg" /></p><p>HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</p><p>HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</p><p>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</p><h3 id="https协议">HTTPS协议</h3><p>加密</p><ol type="1"><li>对称加密</li><li>非对称加密</li></ol><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。</p><p>生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为 CA（ Certifcate Authority）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/44.jpg" /></p><h3 id="流媒体协议">流媒体协议</h3><p>压缩</p><ol type="1"><li>空间冗余</li><li>时间冗余</li><li>视觉冗余</li><li>编码冗余</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/45.jpg" /></p><p>视频编码的两大流派</p><ol type="1"><li>ITU（International Telecommunications Union）的 VECG（Video Coding Experts Group），这个称为国际电联下的 VECG。<ul><li>H.261、 H.262、H.263、H.264、H.265</li></ul></li><li>ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是ISO 旗下的 MPEG，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。<ul><li>MPEG-1、MPEG-2、MPEG-4、MPEG-7</li></ul></li></ol><p>ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/46.jpg" /></p><p>编码：如何将丰富多彩的图片变成二进制流？</p><p><code>I 帧</code>，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。</p><p><code>P 帧</code>，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。</p><p><code>B 帧</code>，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。</p><p>可以看出，I 帧最完整，B 帧压缩率最高，而压缩后帧的序列，应该是在 <code>IBBP</code> 的间隔出现的。这就是通过时序进行编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/47.jpg" /></p><p>在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行空间上的编码。</p><p>尽管时空非常立体的组成了一个序列，但是总归还是要压缩成一个二进制流。这个流是有结构的，是一个个的网络提取层单元（NALU，Network Abstraction Layer Unit）。变成这种格式就是为了传输，因为网络上的传输，默认的是一个个的包，因而这里也就分成了一个个的单元。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/48.jpg" /></p><p>每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据。</p><p>在 NALU 头里面，主要的内容是类型 NAL Type。</p><p><code>0x07</code> 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。</p><p><code>0x08</code> 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/49.jpg" /></p><p>推流：如何把数据流打包传输到对端？</p><p>RTMP 是基于 TCP 的，因而肯定需要双方建立一个 TCP 的连接。</p><p>在有 TCP 的连接的基础上，还需要建立一个 RTMP 的连接，也即在程序里面，你需要调用 RTMP 类库的 Connect 函数，显示创建一个连接。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/50.jpg" /></p><p>一开始双方就要知道对方的时间戳。</p><p>未来沟通这些事情，需要发送六条消息：客户端发送 C0、C1、 C2，服务器发送 S0、 S1、 S2。</p><p>RTMP Packet 包 Message 的格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/51.jpg" /></p><p>流媒体服务器，整个过程就</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/52.jpg" /></p><p>分发网络</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/53.jpg" /></p><p>客户端通过 RTMP 拉流的过程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/54.jpg" /></p><p>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</p><p>压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；</p><p>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成</p><p>Chunk 进行传输；</p><p>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为</p><p>NALU，解码成视频格式进行播放。</p><h3 id="p2p协议">P2P协议</h3><p>下载</p><ol type="1"><li>HTTP</li><li>FTP 文件传输协议<ol type="1"><li>主动模式（PORT）</li><li>被动模式（PASV</li></ol></li><li>P2P (peer-to-peer)</li></ol><p>种子（.torrent）文件</p><ol type="1"><li>announce（tracker URL）</li><li>文件信息<ol type="1"><li>info 区</li><li>Name 字段</li><li>每个段的大小</li><li>段哈希值</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/55.jpg" /></p><p>去中心化网络（DHT）</p><p>DHT 网络是如何查找朋友的？</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/56.jpg" /></p><p>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</p><p>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。</p><h2 id="陌生的数据中心">陌生的数据中心</h2><h3 id="dns协议">DNS协议</h3><p>DNS(Domain Name System,域名系统)_协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送。</p><ol type="1"><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/57.jpg" /></p><p>DNS 解析流程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/58.jpg" /></p><p>负载均衡</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/59.jpg" /></p><p>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</p><p>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="httpdns">HTTPDNS</h3><p>HTTPDNS 服务器的工作模式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/60.jpg" /></p><p>HTTPDNS 服务器的调度设计</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/61.jpg" /></p><h3 id="cdn">CDN</h3><p>Content Delivery Network，即内容分发网络。</p><p>分布在各个地方的各个数据中心的节点，就称为 <code>边缘节点</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/62.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/63.jpg" /></p><ol type="1"><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>用户所处的运营商；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li></ol><p>接入层缓存的架构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/64.jpg" /></p><p>防盗链</p><ol type="1"><li>refer 机制</li><li>时间戳防盗链</li></ol><p>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。</p><p>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。</p><h3 id="数据中心">数据中心</h3><p>数据中心分为三层。</p><p>服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。</p><p>数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过TRILL协议。</p><p>随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。</p><h3 id="vpn">VPN</h3><p>VPN，全名 Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/65.jpg" /></p><p>VPN是如何工作的？</p><p>VPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议：乘客协议、隧道协议和承载协议。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/66.jpg" /></p><p>我们以 IPsec 协议为例来说明。</p><p>一种十分安全的VPN，IPsec VPN。这是基于IP协议的安全隧道协议，为了保证在公网上面信息的安全，因而采取了一定的机制保证安全性。</p><ul><li>机制一：私密性</li><li>机制二：完整性</li><li>机制三：真实性</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/67.jpg" /></p><p>协议簇</p><ul><li>两种协议的区别在于封装网络包的格式不一样<ul><li>AH（Authentication Header），只能进行数据摘要 ，不能实现数据加密。</li><li>ESP（Encapsulating Security Payload），能够进行数据加密和数据摘要</li></ul></li><li>两类算法<ul><li>加密算法</li><li>摘要算法</li></ul></li><li>两大组件<ul><li>用于VPN的双方要进行对称密钥的交换的IKE组件</li><li>VPN的双方要对连接进行维护的SA（Security Association）组件</li></ul></li></ul><p>IPsec VPN的建立过程</p><ol type="1"><li>第一个阶段，建立IKE自己的SA</li><li>建立IPsec SA</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/68.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/69.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/70.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/71.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/72.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/73.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/74.jpg" /></p><h4 id="比较">比较</h4><ul><li>IP 协议：<ul><li>不是面向连接的，是尽力而为的协议，每个 IP 包自由选择路径，依赖于上一层 TCP 的重发来保证可靠性</li><li>优点：一条道路崩溃时，可以自动换其他路</li><li>缺点：不断的路由查找，效率低下</li></ul></li><li>IPSec VPN 的缺点：<ul><li>由于 IPSec VPN 是基于 IP 协议的，所以速度慢</li></ul></li><li>ATM 协议：<ul><li>这种协议是面向连接的，并且和 IP 是同一个层次，ATM 是在传输之前先建立一个连接，形成一个虚拟的通路</li><li>优点：速度快，因为按照指定路径传输</li><li>缺点：当某个节点故障，连接就会中断，无法传输数据</li></ul></li><li>多协议标签交换「MPLS，Multi-Protocol Label Switching」<ul><li>结合了 IP 和 ATM 协议的优点</li><li>需要标签交换路由器「LSR，Label Switching Router」的支持</li><li>如何动态生成标签 LDP「Label Distribution Protocol」</li></ul></li><li>将 MPLS 和 VPN 结合起来可以提高 VPN 的效率<ul><li>需要解决的问题有：<ul><li>BGP 协议如何处理地址空间重叠的 VPN 的路由</li><li>路由表怎么区分重复的网段</li></ul></li></ul></li></ul><p>IPsec VPN的协议簇</p><p>VPN可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样；</p><p>完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些；</p><p>MPLS-VPN 综合和IP转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买。</p><h3 id="移动网络">移动网络</h3><ul><li>2G：txt</li><li>3G：jpg</li><li>4G：avi</li></ul><h4 id="g-网络">2G 网络</h4><p>手机是通过收发无线信号来通信的，专业名称是 <code>Mobile Station</code>，简称 <code>MS</code>，需要嵌入 <code>SIM</code>。</p><p>手机是客户端，而无线信号的服务端，就是基站子系统（BSS，Base Station SubsystemBSS）。</p><p>基站子系统分两部分</p><ul><li>一部分对外提供无线通信，叫作基站收发信台（BTS，Base Transceiver Station）</li><li>另一部分对内连接有线网络，叫作基站控制器（BSC，Base Station Controller）</li></ul><p>基站收发信台通过无线收到数据后，转发给基站控制器。</p><p>这部分属于无线的部分，统称为无线接入网（RAN，Radio Access Network）。</p><p>基站控制器通过有线网络，连接到提供手机业务的运营商的数据中心，这部分称为核心网（CN，Core Network）。</p><p>核心网还没有真的进入互联网，这部分还是主要提供手机业务，是手机业务的有线部分。</p><p>首先接待基站来的数据的是移动业务交换中心（MSC，Mobile Service Switching Center），它是进入核心网的入口，但是它不会让你直接连接到互联网上。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/75.jpg" /></p><p>因而2G时代的上网如图所示，我们总结一下，有这几个核心点:</p><ul><li>手机通过无线信号连接基站;</li><li>基站一面朝前接无线，一面朝后接核心网;</li><li>核心网一面朝前接到基站请求，一是判断你是否合法，二是判断你是不是本地号，还有没有钱，一面通过网关连接电话网络。</li></ul><h4 id="g-网络-1">2.5G 网络</h4><p>后来从2G到了2.5G，也即在原来电路交换的基础上，加入了分组交换业务，支持Packet的转发，从而支持IP网络。 在上述网络的基础上，基站一面朝前接无线，一面朝后接核心网。在朝后的组件中，多了一个分组控制单元(PCU，Packet Control Unit)，用以提供分组交换通道。 在核心网里面，有个朝前的接待员(SGSN，Service GPRS Supported Node)和朝后连接IP网络的网关型GPRS支持节点(GGSN，Gateway GPRS Supported Node)。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/76.jpg" /></p><h4 id="g-网络-2">3G 网络</h4><p>到了3G时代，主要是无线通信技术有了改进，大大增加了无线的带宽。</p><p>以W-CDMA为例，理论最高2M的下行速度，因而基站改变了，一面朝外的是Node B，一面朝内连接核心网的是无线网络控制器(RNC，Radio Network Controller)。核心网以及连接的IP网 络没有什么变化。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/77.jpg" /></p><h4 id="g-网络-3">4G 网络</h4><p>然后就到了今天的 4G网络，基站为 eNodeB，包含了原来Node B 和 RNC 的功能，下行速度向百兆级别迈进。另外，核心网实现了控制面和数据面的分离，这个怎么理解呢?</p><p>在前面的核心网里面，有接待员 MSC 或者 SGSN，你会发现检查是否合法是它负责，转发数据也是它负责，也即控制面和数据面是合二为一的，这样灵活性比较差，因为控制面主要是指令，多是 小包，往往需要高的及时性;数据面主要是流量，多是大包，往往需要吞吐量。</p><p>于是有了下面这个架构。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/78.jpg" /></p><p>HSS 用于存储用户签约信息的数据库，其实就是你这个号码归属地是哪里的，以及一些认证信息。</p><p>MME 是核心控制网元，是控制面的核心，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息，判断你是否合法。如果允许连上来，MME 不负责具体的数据的流量，而是MME会选择数据 面的 SGW 和 PGW ，然后告诉 eNodeB，我允许你连上来了，你连接它们吧。</p><p>于是手机直接通过 eNodeB 连接 SGW ，连上核心网， SGW 相当于数据面的接待员，并通过 PGW 连到 IP网络。 PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用 来控制上网策略和流量的计费。</p><h4 id="g-网络协议解析">4G 网络协议解析</h4><p>我们来仔细看一下4G网络的协议，真的非常复杂。我们将几个关键组件放大来看。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/79.jpg" /></p><h4 id="控制面协议">控制面协议</h4><p>其中虚线部分是控制面的协议。当一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权。</p><p>S1-MME 协议栈如下图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/80.jpg" /></p><p>UE就是你的手机，eNodeB还是两面派，朝前对接无线网络，朝后对接核心网络，在控制面对接的是MME。</p><p>eNodeB和MME之间的连接就是很正常的IP网络，但是这里面在IP层之上，却既不是TCP，也不是UDP，而是SCTP。这也是传输层的协议，也是面向连接的，但是更加适合移动网络。 它继承了 TCP 较为完善的拥塞控制并改进TCP的一些不足之处。</p><ul><li>SCTP 的第一个特点是 <code>多宿主</code>。</li></ul><p>一台机器可以有多个网卡，而对于TCP连接来讲，虽然服务端可以监听0.0.0.0，也就是从哪个网卡来的连接都能接受，但是一旦建立了连接，就建立了四元组，也就选定了某个网卡。</p><p>SCTP 引入了联合（association）的概念，将多个接口、多条路径放到一个联合中来。当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据。应用程序甚至都不必知道发生了故障、恢复，从而提供更高的可用性和可靠性。</p><ul><li>SCTP 的第二个特点是将一个联合分成多个流。</li></ul><p>一个联合中的所有流都是独立的，但均与该联合相关。每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送。在 TCP 的机制中，由于强制顺序，导致前一个不到达，后一个就得等待，SCTP 的多个流不会相互阻塞。</p><ul><li>SCTP 的第三个特点是四次握手，防止 SYN 攻击。</li></ul><p>在TCP中是三次握手，当服务端收到客户的 SYN 之后，返回一个SYN-ACK 之前，就建立数据结构，并记录下状态，等待客户端发送 ACK 的 ACK。当恶意客户端使用虚假的源地址来伪造大量SYN报文时，服务端需要分配大量的资源，最终耗尽资源，无法处理新的请求。</p><p>SCTP 可以通过四次握手引入 Cookie 的概念，来有效地防止这种攻击的产生。在 SCTP 中，客户机使用一个INIT报文发起一个连接。服务器使用一个 INIT-ACK 报文进行响应，其中就包括了 Cookie。</p><p>然后客户端就使用一个 COOKIE-ECHO 报文进行响应，其中包含了服务器所发送的 Cookie。这个时候，服务器为这个连接分配资源，并通过向客户机发送一个COOKIE-ACK报文对其进行响应。</p><ul><li>SCTP 的第四个特点是将消息分帧。</li></ul><p>TCP 是面向流的，也即发送的数据没头没尾，没有明显的界限。这对于发送数据没有问题，但是对于发送一个个消息类型的数据，就不太方便。有可能客户端写入10个字节，然后再写入20个字节。服务端不是读出10个字节的一个消息，再读出20个字节的一个消息，而有可能读入25个字节，再读入5个字节，需要业务层去组合成消息。</p><p>SCTP 借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同。</p><ul><li>SCTP 的第五个特点是断开连接是三次挥手。</li></ul><p>在 TCP 里面，断开连接是四次挥手，允许另一端处于半关闭的状态。SCTP 选择放弃这种状态，当一端关闭自己的套接字时，对等的两端全部需要关闭，将来任何一端都不允许再进行数据的移动了。</p><p>当MME通过认证鉴权，同意这个手机上网的时候，需要建立一个数据面的数据通路。建立通路的过程还是控制面的事情，因而使用的是控制面的协议 GTP-C。</p><p>建设的数据通路分两段路，其实是两个隧道。一段是从 eNodeB 到 SGW ，这个数据通路由 MME 通过 S1-MME 协议告诉 eNodeB，它是隧道的一端，通过 S11 告诉 SGW ，它是隧道的另一端。第二端是从 SGW 到 PGW ， SGW 通过 S11 协议知道自己是其中一端，并主动通过S5协议，告诉 PGW 它是隧道的另一端。</p><p>GTP-C 协议是基于 UDP 的，这是 UDP 中的一个例子。如果看GTP头，我们可以看到，这里面有隧道的ID，还有序列号。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/81.jpg" /></p><p>通过序列号，不用TCP，GTP-C自己就可以实现可靠性，为每个输出信令消息分配一个依次递增的序列号，以确保信令消息的按序传递，并便于检测重复包。对于每个输出信令消息启动定时器， 在定时器超时前未接收到响应消息则进行重发。</p><h4 id="数据面协议">数据面协议</h4><p>当两个隧道都打通，接在一起的时候， PGW 会给手机分配一个 IP地址，这个 IP地址是隧道内部的 IP地址，可以类比为IPsec协议里面的 IP地址。这个IP地址是归手机运营商管理的。然后，手机可 以使用这个 IP地址，连接 eNodeB，从 eNodeB 经过 S1-U协议，通过第一段隧道到达 SGW ，再从 SGW 经过 S8协议，通过第二段隧道到达 PGW ，然后通过 PGW 连接到互联网。</p><p>数据面的协议都是通过 GTP-U，如图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/82.jpg" /></p><p>手机每发出的一个包，都由 GTP-U 隧道协议封装起来，格式如下。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/83.jpg" /></p><p>和 IPsec 协议很类似，分为乘客协议、隧道协议、承载协议。其中乘客协议是手机发出来的包，IP 是手机的 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，因而需要隧道ID来标 识。承载协议的 IP 地址是 SGW 和 PGW 的IP地址。</p><h4 id="手机上网流程">手机上网流程</h4><p>接下来，我们来看一个手机开机之后上网的流程，这个过程称为 Attach。可以看出来，移动网络还是很复杂的。因为这个过程要建立很多的隧道，分配很多的隧道ID，所以我画了一个图来详细 说明这个过程。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/84.jpg" /></p><ol type="1"><li>手机开机以后，在附近寻找基站eNodeB，找到后给eNodeB发送 Attach Request，说“我来啦，我要上网”。</li><li>eNodeB 将请求发给MME，说“有个手机要上网”。</li><li>MME 去请求手机，一是认证，二是鉴权，还会请求HSS看看有没有钱，看看是在哪里上网。</li><li>当 MME 通过了手机的认证之后，开始分配隧道，先告诉 SGW ，说要创建一个会话(Create Session)。在这里面，会给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道ID。</li><li>SGW 转头向 PGW 请求建立一个会话，为 PGW 的控制面分配一个隧道ID t2，也给 PGW 的数据面分配一个隧道ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道ID。</li><li>PGW 回复 SGW 说“创建会话成功”，使用自己的控制面隧道ID t2，回复里面携带着给 SGW 控制面分配的隧道ID t4和控制面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成。双方请求 对方，都要带着对方给自己分配的隧道ID，从而标志是这个手机的请求。</li><li>接下来 SGW 回复MME说“创建会话成功”，使用自己的隧道ID t1 访问 MME，回复里面有给MME分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7。</li><li>当MME发现后面的隧道都建设成功之后，就告诉eNodeB，“后面的隧道已经建设完毕， SGW 给你分配的隧道ID是t7，你可以开始连上来了，但是你也要给 SGW 分配一个隧道ID”。</li><li>eNodeB 告诉MME自己给 SGW 分配一个隧道，ID为t8。</li><li>MME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW ，从而前面的隧道也建设完毕。</li></ol><p>这样，手机就可以通过建立的隧道成功上网了。</p><h4 id="异地上网问题">异地上网问题</h4><p>接下来我们考虑异地上网的事情。 为什么要分 SGW 和 PGW 呢，一个GW不可以吗? SGW 是你本地的运营商的设备，而 PGW 是你所属的运营商的设备。</p><p>如果你在巴塞罗那，一下飞机，手机开机，周围搜寻到的肯定是巴塞罗那的eNodeB。通过MME去查寻国内运营商的HSS，看你是否合法，是否还有钱。</p><p>如果允许上网，你的手机和巴塞罗那的 SGW 会建立一个隧道，然后巴塞罗那的 SGW 和国内运营商的 PGW 建立一个隧道，然后通过国内运营商的 PGW 上网。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/85.jpg" /></p><p>这样判断你是否能上网的在国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的IP地址也是国内运营商里统计的。</p><p>运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算。</p><p>由于你的上网策略是由国内运营商在PCRF中控制的，因而你还是上不了脸书。</p><ul><li>移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变;</li><li>记住 4G网络的结构，有 eNodeB、MME、 SGW 、 PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程;</li><li>即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书。</li></ul><h2 id="云计算中的网络">云计算中的网络</h2><h3 id="云中网络">云中网络</h3><h3 id="软件定义网络">软件定义网络</h3><h3 id="云中的网络安全">云中的网络安全</h3><h3 id="云中的网络qos">云中的网络QoS</h3><h3 id="云中网络的隔离grevxlan">云中网络的隔离GRE、VXLAN</h3><h2 id="容器技术中的网络">容器技术中的网络</h2><h3 id="容器网络">容器网络</h3><h3 id="flannel">Flannel</h3><h3 id="calico">Calico</h3><h2 id="微服务相关协议">微服务相关协议</h2><h3 id="rpc协议">RPC协议</h3><h3 id="基于-xml-的-soap-协议">基于 XML 的 SOAP 协议</h3><h3 id="基于-json-的-restful-接口协议">基于 JSON 的 RESTful 接口协议</h3><h3 id="二进制类rpc协议">二进制类RPC协议</h3><h3 id="跨语言类rpc协议">跨语言类RPC协议</h3><h2 id="搭建一个网络实验环境">搭建一个网络实验环境</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/网络传输协议" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/网络传输协议</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/85</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/" target="_blank" rel="noopener" class="uri">http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;维基百科&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="protocal" scheme="https://2020.iosdevlog.com/tags/protocal/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 思维导图</title>
    <link href="https://2020.iosdevlog.com/2020/04/12/nginx/"/>
    <id>https://2020.iosdevlog.com/2020/04/12/nginx/</id>
    <published>2020-04-12T15:06:15.000Z</published>
    <updated>2020-04-12T16:31:27.805Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。</p><p>2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。</p><p>Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/12/nginx/nginx.svg" /></p><p>Nginx 思维导图 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h2 id="编译">编译</h2><h3 id="选择官方模块">选择官方模块</h3><ul><li><p>with</p></li><li><p>without</p></li></ul><h3 id="指定运行时路径参数">指定运行时路径、参数</h3><h3 id="添加第三方模块">添加第三方模块</h3><ul><li><p>下载第三方模块</p><ul><li><p>config指定模块位置</p></li><li><p>C源码定义模块</p></li></ul></li></ul><h3 id="添加动态模块">添加动态模块</h3><h3 id="指定编译连接参数">指定编译连接参数</h3><h2 id="命令行">命令行</h2><h3 id="参数">参数</h3><ul><li><p>-s发送信号</p><ul><li><p>stop</p></li><li><p>quit</p></li><li><p>reload</p></li><li><p>reopen</p></li></ul></li><li><p>测试配置</p><ul><li>-t,-T,-q</li></ul></li><li><p>帮助信息</p><ul><li>-h,-?</li></ul></li><li><p>版本信息</p><ul><li>-v,-V</li></ul></li><li><p>指定运行参数</p><ul><li><p>-g</p></li><li><p>-c</p></li><li><p>-p</p></li></ul></li></ul><h2 id="运维监控">运维监控</h2><h3 id="日志">日志</h3><ul><li><p>类型</p><ul><li><p>error日志</p><ul><li>debug_connection对指定连接记日志</li></ul></li><li><p>access日志</p><ul><li><p>压缩</p></li><li><p>缓存</p></li></ul></li></ul></li><li><p>记录日志方式</p><ul><li><p>直写文件</p></li><li><p>syslog</p></li><li><p>循环写内存</p></li></ul></li></ul><h3 id="stub_status">stub_status</h3><ul><li><p>accepted</p></li><li><p>handled</p></li><li><p>requests</p></li><li><p>active</p></li><li><p>reading</p></li><li><p>writing</p></li><li><p>waiting</p></li></ul><h2 id="进程模型">进程模型</h2><h3 id="通讯方式">通讯方式</h3><ul><li><p>信号</p><ul><li><p>TERM, INT</p></li><li><p>QUIT</p></li><li><p>HUP</p></li><li><p>USR1</p></li><li><p>USR2</p></li><li><p>WINCH</p></li></ul></li><li><p>共享内存</p><ul><li><p>slab内存管理</p></li><li><p>互斥锁</p></li></ul></li></ul><h3 id="进程">进程</h3><ul><li><p>master</p></li><li><p>worker</p></li><li><p>cache manager</p></li><li><p>cache loader</p></li></ul><h2 id="对象容器">对象容器</h2><h3 id="数组">数组</h3><h3 id="链表">链表</h3><h3 id="队列">队列</h3><h3 id="红黑树">红黑树</h3><h3 id="基数树">基数树</h3><h3 id="哈希表">哈希表</h3><ul><li>桶大小向上对齐cpu cache line</li></ul><h2 id="内存池">内存池</h2><h3 id="request">request</h3><ul><li>随请求结束释放</li></ul><h3 id="connection">connection</h3><ul><li>随连接断开释放</li></ul><h2 id="连接池">连接池</h2><h3 id="事件池">事件池</h3><h3 id="上下游共享">上下游共享</h3><h3 id="keepalive长连接池">keepalive长连接池</h3><h2 id="模块设计">模块设计</h2><h3 id="模块类型">模块类型</h3><ul><li><p>core模块</p></li><li><p>event模块</p></li><li><p>http模块</p></li><li><p>conf模块</p></li><li><p>stream模块</p></li><li><p>mail模块</p></li></ul><h3 id="模块通用接口">模块通用接口</h3><ul><li><p>init_master</p></li><li><p>init_module</p></li><li><p>init_process</p></li><li><p>init_thread</p></li><li><p>exit_thread</p></li><li><p>exit_process</p></li><li><p>exit_master</p></li></ul><h2 id="请求的处理阶段">请求的处理阶段</h2><h3 id="http">http</h3><ul><li><p>POST_READ阶段</p></li><li><p>SERVER_REWRITE阶段</p></li><li><p>FIND_CONFIG阶段</p></li><li><p>REWRITE阶段</p></li><li><p>POST_REWRITE阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>POST_ACCESS阶段</p></li><li><p>PRECONTENT阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h3 id="stream">stream</h3><ul><li><p>POST_ACCEPT阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>SSL阶段</p></li><li><p>PREREAD阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h2 id="变量">变量</h2><h3 id="按应用场景">按应用场景</h3><ul><li><p>http模块</p></li><li><p>stream模块</p></li></ul><h3 id="按功能">按功能</h3><ul><li><p>框架变量</p><ul><li>upstream变量</li></ul></li><li><p>模块变量</p></li></ul><h3 id="按使用方式">按使用方式</h3><ul><li><p>提供方</p></li><li><p>使用方</p></li></ul><h2 id="反向代理">反向代理</h2><h3 id="http-1">http</h3><ul><li><p>上游</p><ul><li><p>协议</p><ul><li><p>http/https</p></li><li><p>fastcgi</p></li><li><p>scgi</p></li><li><p>uwsgi</p></li><li><p>websocket</p></li><li><p>spdy</p></li><li><p>grpc</p></li><li><p>memcached</p></li><li><p>redis</p></li></ul></li><li><p>限速</p></li></ul></li><li><p>缓存</p><ul><li><p>缓存类型</p><ul><li><p>响应内容缓存</p><ul><li>分片</li></ul></li><li><p>openfile缓存</p></li><li><p>浏览器缓存</p></li></ul></li><li><p>缓存大小</p></li><li><p>更新淘汰方式</p></li></ul></li><li><p>下游</p><ul><li><p>http/https</p></li><li><p>限速</p></li></ul></li><li><p>平衡上下游网速</p><ul><li><p>接收请求包体</p></li><li><p>接收响应包体</p></li></ul></li></ul><h3 id="stream-1">stream</h3><ul><li><p>tcp</p></li><li><p>udp</p></li><li><p>透传客户端地址</p><ul><li><p>proxy_protocol</p></li><li><p>IP地址透传</p></li><li><p>上游服务直接返回报文</p></li></ul></li></ul><h3 id="mail">mail</h3><h3 id="负载均衡">负载均衡</h3><ul><li><p>策略</p><ul><li><p>轮询</p></li><li><p>哈希</p><ul><li>一致性哈希</li></ul></li><li><p>基于第三方服务</p></li></ul></li><li><p>健康检查</p></li><li><p>连接池</p></li><li><p>配置DNS服务</p></li></ul><h2 id="nginx.conf指令">nginx.conf指令</h2><h3 id="类型">类型</h3><ul><li><p>块指令</p><ul><li><p>main</p></li><li><p>http</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>location</p></li><li><p>if</p></li><li><p>limit_except</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li><li><p>event</p></li><li><p>stream</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li></ul></li><li><p>普通指令</p><ul><li><p>脚本类</p></li><li><p>设置动作</p></li><li><p>存储值</p></li></ul></li></ul><h3 id="父子指令块配置合并规则">父子指令块配置合并规则</h3><h3 id="server匹配规则">server匹配规则</h3><ul><li><p>精确匹配</p></li><li><p>泛域名</p></li><li><p>正则表达式</p></li><li><p>默认server</p></li></ul><h3 id="location匹配规则">location匹配规则</h3><ul><li><p>前缀字符串匹配</p></li><li><p>正则表达式匹配</p></li></ul><h3 id="参数单位">参数单位</h3><ul><li><p>时间</p></li><li><p>空间</p></li></ul><h2 id="性能优化">性能优化</h2><h3 id="内存效率">内存效率</h3><ul><li><p>tcp</p><ul><li>linux pressure模式</li></ul></li><li><p>http</p></li></ul><h3 id="cpu效率">CPU效率</h3><ul><li><p>绑定CPU</p></li><li><p>静态优先级</p></li><li><p>谨慎使用消耗CPU过大的模块</p></li><li><p>线程池</p></li><li><p>worker间负载均衡</p><ul><li><p>建连接</p></li><li><p>多网卡队列</p></li></ul></li></ul><h3 id="网络效率">网络效率</h3><ul><li><p>tcp</p><ul><li><p>建立连接</p><ul><li><p>FastOpen</p></li><li><p>backlog</p></li><li><p>超时时间</p></li></ul></li><li><p>传输</p><ul><li><p>缓冲区大小</p><ul><li>BGP</li></ul></li><li><p>拥塞控制</p><ul><li>初始拥塞窗口</li></ul></li><li><p>延迟批量发送</p><ul><li><p>tcp_nodelay</p></li><li><p>tcp_nopush</p></li></ul></li></ul></li><li><p>关闭连接</p><ul><li><p>keepalive释放资源</p></li><li><p>减少time_wait</p></li><li><p>超时时间</p></li></ul></li></ul></li><li><p>http</p><ul><li><p>keepalive长连接</p></li><li><p>应用层缓冲区大小</p><ul><li><p>header</p></li><li><p>body</p></li></ul></li><li><p>lingering_close</p></li><li><p>超时时间</p></li></ul></li><li><p>TLS/SSL</p><ul><li><p>session缓存</p></li><li><p>OCSP</p></li><li><p>会话票据</p></li><li><p>算法选择</p><ul><li><p>对称加密算法</p><ul><li>分组模式</li></ul></li><li><p>非对称加密算法</p></li></ul></li></ul></li><li><p>网卡</p></li></ul><h3 id="磁盘io">磁盘IO</h3><ul><li><p>AIO</p></li><li><p>directio</p></li><li><p>零拷贝</p><ul><li>sendfile</li></ul></li><li><p>日志文件</p><ul><li><p>写入缓存</p></li><li><p>压缩后写入</p></li><li><p>syslog</p></li></ul></li><li><p>减少读取次数</p><ul><li>empty_gif模块</li></ul></li><li><p>磁盘</p></li></ul><h2 id="openresty">openresty</h2><h3 id="指令">指令</h3><ul><li><p>http</p><ul><li><p>处理阶段</p></li><li><p>响应过滤</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>ssl</p></li><li><p>共享内存</p></li></ul></li><li><p>stream</p><ul><li><p>处理阶段</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>共享内存</p></li><li><p>ssl</p></li></ul></li></ul><h3 id="lua模块">lua模块</h3><h3 id="sdk">SDK</h3><ul><li><p>正则表达式</p></li><li><p>流程控制类</p></li><li><p>版本与配置</p></li><li><p>进程信息</p></li><li><p>定时器</p></li><li><p>子请求</p></li><li><p>用户请求</p></li><li><p>时间类API</p></li><li><p>多线程</p><ul><li><p>coroutine</p></li><li><p>thread</p></li></ul></li><li><p>shared_dict</p></li><li><p>socket</p><ul><li><p>tcp</p></li><li><p>udp</p></li></ul></li><li><p>response header</p></li><li><p>内容输出</p></li><li><p>常量</p></li><li><p>其他</p><ul><li><p>var变量</p></li><li><p>arg参数</p></li><li><p>日志</p><ul><li>log</li></ul></li><li><p>get_phase</p></li><li><p>sleep</p></li></ul></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/Nginx" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/Nginx</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://github.com/russelltao/geektime-nginx" target="_blank" rel="noopener" class="uri">https://github.com/russelltao/geektime-nginx</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。&lt;/p&gt;
&lt;p&gt;2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。&lt;/p&gt;
&lt;p&gt;Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="nginx" scheme="https://2020.iosdevlog.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains Academy Knowledge Map</title>
    <link href="https://2020.iosdevlog.com/2020/04/11/jetbrains/"/>
    <id>https://2020.iosdevlog.com/2020/04/11/jetbrains/</id>
    <published>2020-04-11T15:26:38.000Z</published>
    <updated>2020-04-13T05:12:00.211Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png" /></p><p>基础/算法/开发工具/Java/Python/Kotlin/前端​<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><h2 id="java">Java</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Java.png" /></p><h3 id="hello-world">Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello AIDevLog!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/compiling_java.svg" /></p><h3 id="standard-input">Standard Input</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">String line = scanner.nextLine();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Hello, "</span> + name +<span class="string">"!"</span>);</span><br><span class="line">System.out.println(line);</span><br></pre></td></tr></table></figure><h3 id="templete">Templete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kotlin">Kotlin</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Kotlin.png" /></p><h2 id="essentials">Essentials</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Essentials.png" /></p><h2 id="fronted">Fronted</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Fronted.png" /></p><h2 id="python">Python</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Python.png" /></p><h2 id="algorithm">Algorithm</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Algorithm.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://hyperskill.org/knowledge-map" target="_blank" rel="noopener" class="uri">https://hyperskill.org/knowledge-map</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;基础/算法/开发工具/Java/Python/Kotlin/前端​&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="academy" scheme="https://2020.iosdevlog.com/categories/academy/"/>
    
    
      <category term="python" scheme="https://2020.iosdevlog.com/tags/python/"/>
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="jetbrain" scheme="https://2020.iosdevlog.com/tags/jetbrain/"/>
    
      <category term="java" scheme="https://2020.iosdevlog.com/tags/java/"/>
    
      <category term="kotlin" scheme="https://2020.iosdevlog.com/tags/kotlin/"/>
    
      <category term="tool" scheme="https://2020.iosdevlog.com/tags/tool/"/>
    
  </entry>
  
</feed>
