<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-01-22T16:02:25.708Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Earth Chronicles Handbook</title>
    <link href="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/"/>
    <id>https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/</id>
    <published>2020-01-22T15:40:46.000Z</published>
    <updated>2020-01-22T16:02:25.708Z</updated>
    
    <content type="html"><![CDATA[<p>最近想看一些科幻，神话类的小说，发现中国的《山海经》和国外的《地球编年史》不错，介绍一下。</p><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg" alt=""></p><a id="more"></a><p>地球编年史<br>出版社:  重庆出版社<br>册数:  8<br>简介　· · · · · ·　</p><p>撒迦利亚·西琴（Zecharia Sitchin）是一位在国际上备受尊敬的作家和研究者，从1976年起，他陆续出版了一部在全球范围内影起巨大反响的系列作品《地球编年史》。这套多达7册的开创性的大书迄今为止已被译为30种语言出版，印刷近2000万册。</p><p>在书中，作者结合考古学、古文字学、东方学与《圣经》学的最新科学发现，重新编织并复述了整个人类的历史──尤其是史前地球史和人类史。他提供的证据表明，上古神话并不仅仅是传说或幻觉，而是被我们日渐遗忘的遥远的史实。</p><p>7册编年史从45万年以前由太阳系中的第12个天体尼比鲁（Nibiru）──亦即被美国航天局（NASA）在1982年发现并命名为第十大行星（Planet X）的神秘天体──上降临地球的外星高智能生物阿努那奇（Anunnaki）对地球的统治开始，中间经历了人类的崛起以及大洪水的灾难，到公元前2023年近东地区苏美尔人的覆灭为止，重构了人类起源与发展的全部历程。作者的观点新颖而极富冲击力，使该系列图书的影响力持继30余年，至今不衰。</p><p>作为世界上少数能解读苏美尔楔形文字的学者，撒迦利亚·西琴同时也精通希伯来语、塞姆语和欧洲的各种语言。他的研究遍及古巴比伦、古埃及、古印度和玛雅文化等领域，一生致力于人类起源的研究活动。他的研究活动甚至被立为一门独立的学科“西琴学”。当然，最耐人寻味也最有意义的是，他的研究表明，人类在太阳系中并不孤独，因为在经过了3600年的一个轨道运行周期后，第12个天体即将返回并掠过它也许足以再次影响我们的近地点。</p><p>撒迦利亚·西琴1922年出生于俄罗斯阿塞拜疆首府库班，在乌克兰度过幼年时代。年长后在伦敦大学攻读过考古学、历史学、语言学、经济学及神话学等。现居住在美国纽约。</p><p>作者在他的网站（<a href="http://www.sitchin.com）上随时与读者分享其最新研究成果。" target="_blank" rel="noopener">http://www.sitchin.com）上随时与读者分享其最新研究成果。</a></p><h2 id="《地球编年史》指南"><a href="#《地球编年史》指南" class="headerlink" title="《地球编年史》指南"></a>《地球编年史》指南</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》七部书完全手册<br>原作名: The Earth Chronicles Handbook: A Comprehensive Guide to the Seven Books of The Earth Chronicles<br>译者: 黎明<br>出版年: 2012-10<br>页数: 183<br>定价: 32.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229046873</p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>★ 涵盖《地球编年史》七部书所有精华的饕餮盛宴<br>★ 打开地球和人类起源大门的最关键钥匙和指南<br>★ 对《地球编年史》这一巨龙的画龙眼睛之作<br>◎ 《地球编年史》七部书为我们了解地球和人类起源打开了一扇窗，透过这扇窗，我们看到了一个完全出乎我们意料的世界。在这背后，还有哪些是你所不知道的东西？<br>◎《地球编年史》系列中出现的所有与《圣经》、神话、宗教和人类诞生有关的词语，你真的完全了解并理解了吗？<br>◎ 在地球文明即将进入新纪元的崭新时刻，西琴带我们重新回顾地球与人类的历史，解读与地球和人类有关的所有宗教、神话和人物，在这一旅程开始之前，你准备好了吗？</p><hr><p>撒迦利亚•西琴生前留给世人的最宝贵财富，读罢让人难以释怀。<br>——《图书馆杂志》<br>撒迦利亚•西琴怀着专业研究者特有的激情，为我们上演了一场让人眼花瞭乱的表演。<br>——《科克斯书评》</p><hr><p>撒迦利亚•西琴和他的《地球编年史》七部书，必定在人类探索地球和人类起源的历史上，留下浓墨重彩的一笔，他绝无仅有且无与伦比的研究揭示了一个地球和人类起源的古老秘密：有关世界远古文明的神话传说，都是建立在先民对事实的回忆基础上的，而被我们所津津乐道的远古众神，则是地外星球来到地球上的访客。</p><p>《地球编年史》七部书上包天文，下罗地理，囊括地球和人类历史上所有的神话、宗教、文化和考古发现，气势磅礴，让人惊叹，但浩浩荡荡两千多页的恢宏巨制，也让一些人只能望洋兴叹。为此，西琴特地为整部《地球编年史》创作了这个独一无二的百科全书式的导航工具，不仅是对所有涉及的神话、宗教、人物等专用词条的详细诠释，更包含西琴对这些文化的创造性理解。<br>本书是对《地球编年史》七部书的锦上添花之作，是对所有未尽事宜的完全解答，即使把它单独拿来看，也不失为一部优秀的史前全球文明入门手册。</p><h2 id="《第十二个天体》"><a href="#《第十二个天体》" class="headerlink" title="《第十二个天体》"></a>《第十二个天体》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/1.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第一部<br>译者: 宋易<br>出版年: 2009-7-1<br>页数: 299<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229006747</p><h3 id="内容简介-·-·-·-·-·-·"><a href="#内容简介-·-·-·-·-·-·" class="headerlink" title="内容简介  · · · · · ·"></a>内容简介  · · · · · ·</h3><p>年复一年，一震惊世人的证据被不断地发现，它们挑战着早已建立的地球生命起源论，并用这些证据向我们证明，一个更为先进的地外文明曾在我们的星球上居住过。<br>带有革命意义的《地球编年史》丛书的第一部，它提供的不可反驳的证据，强烈地证明了那颗“谜之行星”—一尼此鲁的存在。它告诉我们，其上的宇航员为什么要在数个时代之前来到地球，并通过他们的形象造人。<br>超越30年一丝不苟的探索，《第十二个天体》将《创世纪》中大洪水、巴别塔以及娶人类女儿为妻的纳菲力姆的故事，视作事实而非神话那样进行研究。通过将《圣经》故事与苏美尔、巴比伦泥板文献汇总，它挑战着现存的地球和人类的起源观，并向人类提出了一个不同于传统的历史和史前观。</p><h2 id="《通往天国的阶梯》"><a href="#《通往天国的阶梯》" class="headerlink" title="《通往天国的阶梯》"></a>《通往天国的阶梯》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/2.jpg" alt=""></p><p>作者: [美]撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第二部<br>原作名: The Stairway to Heaven<br>译者: 李良波<br>出版年: 2009-8<br>页数: 289 页<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229011659</p><h3 id="内容简介-1"><a href="#内容简介-1" class="headerlink" title="内容简介"></a>内容简介</h3><p>究竟是谁修建了埃及金字塔？从最早的时候起，人类就思考着宇宙、生命……和来世的不解之谜。一些幸运的凡人是在何时何地加入到诸神行列的？位于吉萨的巨大而复杂的建筑物是埃及法老们通往永生的大门，还是星际旅行者为了登陆地球而修建的脉冲信号站？</p><p>在具有开创性的《地球编年史》丛书的第二部中，撒迦利亚·西琴揭开了金字塔的神秘面纱，他通过来自古代的隐秘线索，向人们展示现存的埃及考古学是建立在一个伟大的赝品之上的，并带领读者去往远古诸神阿努纳奇在地球上的太空站和着陆区。而阿努纳奇——“谜之行星”尼比鲁上的天神，人类的创造者，只有他们才握掌着永生的权柄。</p><p>那么，人类，地球上的凡人，是否过去曾经或未来可能得到永生？</p><h2 id="《众神与人类的战争》"><a href="#《众神与人类的战争》" class="headerlink" title="《众神与人类的战争》"></a>《众神与人类的战争》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/3.jpg" alt=""></p><p>作者: ［美］撒迦利亚·西琴<br>出版社: 重庆出版集团<br>副标题: 《地球编年史》第三部<br>原作名: The Wars of Gods and Men<br>译者: 赵娟 / 宋易<br>出版年: 2009-12<br>页数: 304<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229013752</p><h3 id="内容简介-2"><a href="#内容简介-2" class="headerlink" title="内容简介"></a>内容简介</h3><p>以30种语言畅销25周年的最新修订版<br>是谁摧毁了地球及人类的上一次文明？<br>惊人的书面文献证明了一系列发生在史前的世界大战</p><hr><p>“《地球编年史》继续其伟大的进程，为我们展开了诸神统治地球时发生的世界大战乃至星球大战。这注定是一部最重要也最受争议的史诗性大作……值得一读！”<br>──《述评》杂志（Critical Review）<br>◎ 为什么地球的历史如同一本一章接着一章描述战争的书籍？<br>◎ 人类天生就是战士吗？或者是众神教会了人类如何作战？<br>◎ 外星战神是否应该对人类历史上的重大变故负责？<br>◎ 地球上的战争是开始于天空、然后在地球上延续的吗？<br>◎ 天相的变化会不会真的决定地球上人类的未来？<br>“大洪水……特洛伊战争……罪恶之城索多玛和蛾摩拉的毁灭……西琴全景式的还原了上古时代神与人共同参予的世界混战，其真实性令人震撼。”<br>──《锐评》杂志（Critical Review）</p><hr><p>对地球和人类过往命运的全景式再现：<br>关于一批来自外星的战神<br>以及一场由他们发动并让人类参与的史前世界大战<br>众神与人类的战争<br>在神和人并肩作战的遥远时代……<br>几千年前，地球是一个战场。正是那些诸神借以提高自己权力和威望的战争，彻底改变了人类的命运──激烈的战斗使生命更早地在另一个星球上出现。<br>国际知名学者撒迦利亚·西琴将史前的真实历史从神话中分离出来，带领我们走进了人类历史血腥开端的长卷，那个时候是神而不是人统治着地球。<br>通过重塑这些保存在传说和古代著作中令人心驰神往的史诗般的事件，他追溯了在另一个世界上开始，在地球上延续，并且通过使用核武器而达到高潮的冲突──这个事件在《圣经》里就是罪恶之城所多玛和蛾摩拉的毁灭性剧变。经由这个空前的转捩点，诸神放弃了地球，并在离开之时从外层空间摧毁了西奈半岛的航天发射场，从而中断了与人类的联系，也终结了人类的上一次文明。<br>“通过精确的研究，西琴重新创造了《圣经》的编年表，甚至回到了《圣经》之前的世界……这些发生在上古时代的星球大战，如今通过其强大的洞察力展现在我们眼前，令人震撼。”<br>──《圣约锡安之声》（Bnai Zion Voice）</p><h2 id="《失落的国度》"><a href="#《失落的国度》" class="headerlink" title="《失落的国度》"></a>《失落的国度》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/4.jpg" alt=""></p><p>作者: [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第四部<br>原作名: The Earth Chronicles IV The Lost Realms<br>出版年: 2010-8<br>页数: 238<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229018153</p><h3 id="内容简介-3"><a href="#内容简介-3" class="headerlink" title="内容简介"></a>内容简介</h3><p>在哥伦布之前到达美洲的诸神──<br>来自美洲的难以置信的证据显示：公元前3000年<br>外星巨人用他们的超级文明彻底改变了新大陆<br>◎在哥伦布之前的公元前3000年，是否早已有人到达了美洲？他们是谁？从何而来？<br>◎玛雅、阿兹特克、奥尔梅克、托尔特克、印加……这些突然出现并且突然消失的美洲古代文明是一个孤立系统，还是《圣经》中该隐的迁移之地？<br>◎出于对黄金的需求，降临于苏美尔的外星诸神也成为了美洲的诸神？最终，他们又如何把亚特兰蒂斯的传说带回了地中海？<br>16世纪，西班牙征服者来到新大陆，寻找传说中的黄金城埃尔•杜拉多。然而，无法解释的神秘现象表明，他们并不是第一批来此拓荒的淘金者，因为同样的工作在很多个世纪前早就发生过了──无数巨石建筑群构造在地球上最难以进入的雨林深处，它们错综复杂地记录了整个天穹及地球上发生的各种事件。</p><h2 id="《当时间开始》"><a href="#《当时间开始》" class="headerlink" title="《当时间开始》"></a>《当时间开始》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/5.jpg" alt=""></p><p>作者: [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第五部<br>原作名: When Time Began<br>译者: 宋易<br>出版年: 2010-07-01<br>页数: 257<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229026677</p><h3 id="内容简介-4"><a href="#内容简介-4" class="headerlink" title="内容简介"></a>内容简介</h3><p>以30种语言畅销15周年的最新修订版<br>宇宙中的一切是何时开始以及怎样开始的？<br>一切都将结束吗？而在这之间又会发生些什么？<br>◎史前巨石阵为什么要重建，并在公元前2100年和2000年时重新排列──这与当时发生在苏美尔令人震惊的事实有着怎样的联系？<br>◎在巴西的重大发现证实，人类在这一地区竟已生活了超过32000年！而它与大洋彼岸的文明全然无关吗？<br>◎是什么东西连接着位于马丘比丘的三窗神庙，以及苏美尔和大不列颠的古代建筑？<br>◎神圣时间、天时间和地球时间──过去和未来果真是被这三个周期所指引？是它们推动了地球历史的车轮？<br>惊人的神曲：外来的文明改变了人类发展的轨迹，<br>而人类则改变了众神的谱系──<br>对多神的信仰是如何演变为一神祟拜的？<br>当时间开始<br>谁才是史前巨石阵的神圣工程师？<br>数千年前，他们来到地球，引导人类进入了第一个科学发展和精神启蒙的新纪元。在他们的带领下，人类文明在科学、艺术上开始了繁荣，并分布到了世界上所有可居住的地方。而在人类传承的所有科学技术中，最重要的无疑是建立在数学－天文知识上的对时间的测量。这些古代的天国来客，他们在苏美尔、南美洲、中美洲、不列颠群岛和黑海沿岸留下的巨石阵，作为一种天文计算机（星石），不仅仅是为了被人类用于在数千年中建立“地球时间”的历法表，同时还──甚至是其根本目的──为了计算超级尺度的“天时间”，即连接人类和天国的“黄道时间”。<br>撒迦利亚•西琴在《地球编年史》的第五部中所要讲述的主题，正是时间以及其他与之相关的谜团。他指出了“神圣时间”──天时间和地球时间之间的惊人联系，并毫不隐晦地阐述了古代预言的基础，以及过去、现在、未来之间的联系。</p><h2 id="《宇宙密码》"><a href="#《宇宙密码》" class="headerlink" title="《宇宙密码》"></a>《宇宙密码》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/6.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第六部<br>原作名: The Cosmic Code: Book VI of the Earth Chronicles<br>译者: 徐冬妲 / 宋易<br>出版年: 2011-3<br>页数: 224<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229035945</p><h3 id="内容简介-5"><a href="#内容简介-5" class="headerlink" title="内容简介"></a>内容简介</h3><p>好几千年前，一群来自另一星球的超人领导了地球上生命的进化，决定了人类的存在状态和内在特质，正如我们今天所知道的那样。这些来自天外的天才建造者们如何创造了称为人类的奇迹？宇宙中所有生命的核心中，DNA是一个联系地球与天国、人类与神明之间的“宇宙密码”吗？<br>在精深宏大的《地球编年史》第六部中，撒迦利亚•西琴最突出的发现之一是，由22个符号组成的希伯来字母表是通过模仿22对染色体DNA而设计的；这一发现让我们逐渐认识到，与DNA匹配的希伯来字母表与其字母的数值是如何作为一个密码，承载了人类命运的秘密──作为地球众生的凡人的命运和作为神之造物的人类的天命。</p><p>当一切都揭晓之后，我们终会明白，“创造”我们的神只是从另一个空间来到并连线我们与宇宙的信使。而DNA，既是整个宇宙的生命联结，也是人类与众神的基因纽带。</p><h2 id="《完结日》"><a href="#《完结日》" class="headerlink" title="《完结日》"></a>《完结日》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/7.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第七部<br>原作名: The End of Days: Armageddon and Prophecies of the Return<br>译者: 龚力<br>出版年: 2012-10<br>页数: 215<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229046576</p><h3 id="内容简介-6"><a href="#内容简介-6" class="headerlink" title="内容简介"></a>内容简介</h3><p>★《地球编年史》 第七部，30周年双里程碑庆典终结版！<br>★ 一个早已设定的周期性天文时间是否意味着<br>★ 第十二个天体和其上的众神将又一次的回归？<br>为什么我们所处的公元二十一世纪像极了公元前二十一世纪？<br>历史注定将重演吗？如果是，将在什么时候？<br>第十二个天体──“谜之行星 ”尼比鲁将在下一个3600年回归并影响地球吗？<br>届时，尼比鲁的居民阿努纳奇将会如天神一般再次降临吗？<br>等待人类的会是一场怎样的相遇：毁灭还是新生？</p><hr><p>有太多的人在苦苦等待这本书……<br>—— 《书目》杂志<br>让人翘首以盼的撒迦利亚•西琴经典启示系列的最终卷！在这部花费了30余年 研究而得来的杰作中，西琴展示了“过去即是未来”这一灵性观点引人注目的新证据——人类和他们的地球，从属于一个早已决定好的周期性天空时间。一个伟大的循环即将来临……<br>——《科克斯书评》<br>闪耀的、具有爆炸性的作品！为此，我要向伟大的撒迦利亚•西琴致敬！<br>——埃利希・冯・丹尼肯，《众神之车》作者<br>自撒迦利亚•西琴开创了《第十二个天体》一书已有30余年，后者使苏美尔文明和关于阿努纳奇人的记载苏醒了过来——这些天外来客塑造了人类，并给予人类文明和宗教信仰。在这本终结之书里，西琴向人们展示了禁锢于“开端”中的“终结”，而且一旦当你了解到此“开端”，就有可能预知“未来”。”<br>——《图书馆杂志》<br>太令人激动了……这是一个伟大史诗的完美尾声。西琴应该获得诺贝尔奖！<br>—— 鲍勃•迪恩，星际政治揭秘工程重要成员</p><hr><p>世人期待的经典革命性丛书《地球编年史》终于迎来了终结的第七部。从开山之作《第十二个天体》开始──它唤醒了人们对苏美尔文明和它所记录的外星人阿努纳奇来到地球并创造人类的记忆──至今已超过三十年了。在这部新书里，作者告诉我们，宇宙的终结直通其开端，如果你能精通这个开端，就有可能预知未来。<br>在本书中出现的数据、分析与观点，是一个需要三十年以上不间断研究的大师级工程。其中，作者呈示了令人震惊的新证据，表明我们的过去即未来──人类及其赖以生存的地球必须服从于一个早已设定的周期性的天文时间，而人类的创造者，第十二个天体和其上的众神，将会随着这一大周期的到来重返地球。</p><p>参考：<a href="https://book.douban.com/series/2198" target="_blank" rel="noopener">https://book.douban.com/series/2198</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想看一些科幻，神话类的小说，发现中国的《山海经》和国外的《地球编年史》不错，介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发: Hello World</title>
    <link href="https://2020.iosdevlog.com/2020/01/21/vscode/"/>
    <id>https://2020.iosdevlog.com/2020/01/21/vscode/</id>
    <published>2020-01-21T12:50:48.000Z</published>
    <updated>2020-01-21T14:46:26.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-21.png" alt="2020/01/21"></p><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>VS Code 的插件就是一个 <code>Node.js</code> 的应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yeoman</span></span><br><span class="line">npm -g install yo</span><br><span class="line"><span class="comment"># VS Code 的模板</span></span><br><span class="line">npm install -g generator-code</span><br></pre></td></tr></table></figure><h2 id="创建第一个插件：-Hello-World"><a href="#创建第一个插件：-Hello-World" class="headerlink" title="创建第一个插件： Hello World"></a>创建第一个插件： Hello World</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello world</span></span><br><span class="line">yo code hello_world</span><br><span class="line">     _-----_     ╭──────────────────────────╮</span><br><span class="line">    |       |    │   Welcome to the Visual  │</span><br><span class="line">    |--(o)--|    │   Studio Code Extension  │</span><br><span class="line">   `---------´   │        generator!        │</span><br><span class="line">    ( _´U`_ )    ╰──────────────────────────╯</span><br><span class="line">    /___A___\   /</span><br><span class="line">     |  ~  |     </span><br><span class="line">   __<span class="string">'.___.'</span>__   </span><br><span class="line"> ´   `  |° ´ Y ` </span><br><span class="line"></span><br><span class="line">? What <span class="built_in">type</span> of extension <span class="keyword">do</span> you want to create? </span><br><span class="line">  New Extension (TypeScript) </span><br><span class="line">❯ New Extension (JavaScript) </span><br><span class="line">  New Color Theme </span><br><span class="line">  New Language Support </span><br><span class="line">  New Code Snippets </span><br><span class="line">  New Keymap </span><br><span class="line">  New Extension Pack </span><br><span class="line">(Move up and down to reveal more choices)</span><br></pre></td></tr></table></figure><ol><li>前两个是通过编程来提供插件功能，你可以选择 TypeScript 或者 JavaScript，结果都是类似的</li><li>因为 TypeScript 最后也需要被编译成 JavaScript 再发布；</li><li>第三个是主题插件，你可以将你自己创建的主题分享给其他人；</li><li>第四个是语言支持，也就是语法高亮、语言定义等；</li><li>第五个是代码片段的分享；</li><li>第六个则是分享快捷键；</li><li>第七个就是对多个插件进行组合分享。</li></ol><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><ul><li><code>package.json</code> VS Code 的插件就是一个 Node.js 的应用，    <ul><li>package.json 里记录了这个 Node.js 应用的信息。同时，插件的信息也会被记录在这个文件内。</li></ul></li><li><code>extension.js</code> 这个文件是当前插件的全部代码。</li><li><code>.vscode</code> 脚手架工具已经为我们提供了调试配置、任务配置等，有了它们，我们就不用自己花时间书写了。</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line"><span class="attr">"displayName"</span>: <span class="string">"hello_world"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"Vs code plugin hello world"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line"><span class="attr">"engines"</span>: &#123;</span><br><span class="line"><span class="attr">"vscode"</span>: <span class="string">"^1.41.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"categories"</span>: [</span><br><span class="line"><span class="string">"Other"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"activationEvents"</span>: [</span><br><span class="line"><span class="string">"onCommand:extension.helloWorld"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"main"</span>: <span class="string">"./extension.js"</span>,</span><br><span class="line"><span class="attr">"contributes"</span>: &#123;</span><br><span class="line"><span class="attr">"commands"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.helloWorld"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"scripts"</span>: &#123;</span><br><span class="line"><span class="attr">"test"</span>: <span class="string">"node ./test/runTest.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"@types/glob"</span>: <span class="string">"^7.1.1"</span>,</span><br><span class="line"><span class="attr">"@types/mocha"</span>: <span class="string">"^5.2.7"</span>,</span><br><span class="line"><span class="attr">"@types/node"</span>: <span class="string">"^12.11.7"</span>,</span><br><span class="line"><span class="attr">"@types/vscode"</span>: <span class="string">"^1.41.0"</span>,</span><br><span class="line"><span class="attr">"eslint"</span>: <span class="string">"^6.6.0"</span>,</span><br><span class="line"><span class="attr">"glob"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line"><span class="attr">"mocha"</span>: <span class="string">"^6.2.2"</span>,</span><br><span class="line"><span class="attr">"typescript"</span>: <span class="string">"^3.6.4"</span>,</span><br><span class="line"><span class="attr">"vscode-test"</span>: <span class="string">"^1.2.2"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>engines<ul><li>指定了运行这个插件需要的 VS Code 版本</li></ul></li><li>activationEvents<ul><li>指定了什么情况下这个插件应该被加载并且激活</li></ul></li><li>contributes<ul><li>这个插件给 VS Code 添加了一个 command，这个 command 的 id 是 “extension.sayHello”， 跟 extension.js 中写的一样。而这个命令的名字，叫做 Hello World。</li></ul></li></ol><h3 id="extension-js"><a href="#extension-js" class="headerlink" title="extension.js"></a><code>extension.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The module 'vscode' contains the VS Code extensibility API</span></span><br><span class="line"><span class="comment">// Import the module and reference it with the alias vscode in your code below</span></span><br><span class="line"><span class="keyword">const</span> vscode = <span class="built_in">require</span>(<span class="string">'vscode'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is activated</span></span><br><span class="line"><span class="comment">// your extension is activated the very first time the command is executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;vscode.ExtensionContext&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the console to output diagnostic information (console.log) and errors (console.error)</span></span><br><span class="line"><span class="comment">// This line of code will only be executed once when your extension is activated</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Congratulations, your extension "hello-world" is now active!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The command has been defined in the package.json file</span></span><br><span class="line"><span class="comment">// Now provide the implementation of the command with  registerCommand</span></span><br><span class="line"><span class="comment">// The commandId parameter must match the command field in package.json</span></span><br><span class="line"><span class="keyword">let</span> disposable = vscode.commands.registerCommand(<span class="string">'extension.helloWorld'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// The code you place here will be executed every time your command is executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Display a message box to the user</span></span><br><span class="line">vscode.window.showInformationMessage(<span class="string">'Hello 2020 GameDevLog!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line">exports.activate = activate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is deactivated</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">activate,</span><br><span class="line">deactivate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h2><ol><li><code>F5</code></li><li><code>Ctrl + Shift + P</code></li><li><code>Hello World</code></li></ol><p><img src="https://2020.iosdevlog.com/2020/01/21/vscode/1.png" alt=""></p><p><img src="https://2020.iosdevlog.com/2020/01/21/vscode/2.png" alt=""></p><p>参考：<a href="https://time.geekbang.org/column/article/69768" target="_blank" rel="noopener">玩转VS Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-21.png&quot; alt=&quot;2020/01/21&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="editor" scheme="https://2020.iosdevlog.com/categories/editor/"/>
    
    
      <category term="vscode" scheme="https://2020.iosdevlog.com/tags/vscode/"/>
    
      <category term="plugin" scheme="https://2020.iosdevlog.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-应用场景</title>
    <link href="https://2020.iosdevlog.com/2020/01/20/Scene/"/>
    <id>https://2020.iosdevlog.com/2020/01/20/Scene/</id>
    <published>2020-01-20T13:35:07.000Z</published>
    <updated>2020-01-20T13:37:50.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-20.png" alt="2020/01/20"></p><a id="more"></a><h2 id="嘿-Siri：语音处理"><a href="#嘿-Siri：语音处理" class="headerlink" title="嘿, Siri：语音处理"></a>嘿, Siri：语音处理</h2><hr><p>以 Siri 为例分享了语音处理的一些技术进展。其要点如下：</p><ul><li>语音处理可以分为语音识别和语音合成两类任务；</li><li>语音合成过程包括文本分析、音韵生成、单元选择、波形串联等步骤；</li><li>语音识别过程包括预处理、特征提取、声学模型，语言模型和字典解码等步骤；</li><li>深度学习和迁移学习等技术都已经被应用在语音处理之中。</li></ul><p>语音处理的最终目的不是简单地分析或者合成声音，而是为了更好地和人交互，从而以更简捷的方式解决问题。从交互的角度来看，你认为目前的语音助手还存在着哪些不足呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/1.jpg" alt=""></p><h2 id="心有灵犀一点通：对话系统"><a href="#心有灵犀一点通：对话系统" class="headerlink" title="心有灵犀一点通：对话系统"></a>心有灵犀一点通：对话系统</h2><hr><p>结合 Facebook 公司公开的资料，和分享了对话系统的发展历程与一些最新进展。其要点如下：</p><ul><li>早期的对话系统通过模式匹配和智能短语搜索对人类的合适回复；</li><li>智能个人助理可以帮助用户在多个垂直领域完成任务；</li><li>社交聊天机器人的作用是满足用户的情感需求；</li><li>神经网络能够帮助社交聊天机器人实现通用化的学习。</li></ul><p>社交聊天机器人的发展也带来了关于道德规范的问题，一些机器人从社交网络上学到的想法需要引起注意与警惕。结合人工智能在无人武器中的规模化应用，对人工智能进行法律约束似乎已经迫在眉睫。那么应该如何看待与应对人工智能带来的伦理问题呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/2.jpg" alt=""></p><h2 id="数字巴别塔：机器翻译"><a href="#数字巴别塔：机器翻译" class="headerlink" title="数字巴别塔：机器翻译"></a>数字巴别塔：机器翻译</h2><hr><p>结合谷歌公开发表的论文，和分享了机器翻译的发展历程与一些最新进展。其要点如下：</p><ul><li>早期的机器翻译采用的是逐字对应的方法；</li><li>语言学的进展使机器翻译转而依赖句法规则；</li><li>谷歌将神经网络引入机器翻译之中，利用大量数据提升翻译精确性；</li><li>神经网络可以通过迁移学习“桥接”不同的语言，实现零知识翻译。</li></ul><p>在另一个角度上，机器翻译的进展对语言本身的发展也存在着反作用。语言并不是自然出现的，而是人类社会的产物，其发展也势必会受到人类文化的影响。那么<strong>人工智能的发展到底会对人类自身产生何种反作用呢？</strong></p><p><strong>这是人工智能的终极问题。</strong></p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/3.jpg" alt=""></p><h2 id="左右互搏：生成式对抗网络"><a href="#左右互搏：生成式对抗网络" class="headerlink" title="左右互搏：生成式对抗网络"></a>左右互搏：生成式对抗网络</h2><hr><p>生成式对抗网络的原理与机制。其要点如下：</p><ul><li>生成式对抗网络是一类运行在零和博弈框架下的无监督学习算法，由生成器和判别器构成；</li><li>生成器的目的是精确模拟真实数据的分布，判别器的目的是精确区分真实数据和生成数据；</li><li>生成式对抗网络的主要优点是超越了传统神经网络分类和特征提取的功能，能够按照真实数据的特点生成新的数据；</li><li>生成式对抗网络的主要问题是理论基础的缺失。</li></ul><p>生成式对抗网络的一个重要的潜在应用就是让人工智能在没有明确指导的情况下学习，使算法的学习方式向人类的学习方式转变。那么如何看待生成式对抗网络在通用人工智能研究中的前景呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/4.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-20.png&quot; alt=&quot;2020/01/20&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="Scene" scheme="https://2020.iosdevlog.com/tags/Scene/"/>
    
      <category term="App" scheme="https://2020.iosdevlog.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-深度学习框架下的神经网络总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/19/dl-nn/"/>
    <id>https://2020.iosdevlog.com/2020/01/19/dl-nn/</id>
    <published>2020-01-19T14:40:19.000Z</published>
    <updated>2020-01-20T13:37:31.748Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-19.png" alt="2020/01/19"></p><a id="more"></a><h2 id="枯木逢春：深度信念网络"><a href="#枯木逢春：深度信念网络" class="headerlink" title="枯木逢春：深度信念网络"></a>枯木逢春：深度信念网络</h2><hr><p>深度信念网络的基本概念和基本原理，其要点如下：</p><ul><li>深度信念网络是一种生成模型，能够建立输入和输出的联合概率分布；</li><li>受限玻尔兹曼机是构成深度信念网络的基本单元，是由可见层和隐藏层构成的神经网络；</li><li>受限玻尔兹曼机的训练方法是对比散度法，通过可见层和隐藏层的多轮交互实现；</li><li>深度神经网络的通用训练方式是无监督逐层预训练和有监督微调的结合。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/1.jpg" alt=""></p><h2 id="见微知著：卷积神经网络"><a href="#见微知著：卷积神经网络" class="headerlink" title="见微知著：卷积神经网络"></a>见微知著：卷积神经网络</h2><hr><p>卷积神经网络的原理与机制，其要点如下：</p><ul><li>卷积神经网络是应用了卷积运算的神经网络，适用于处理网格化数据；</li><li>卷积神经网络具有稀疏感知性、参数共享性和平移不变性；</li><li>卷积神经网络的结构包括交替出现的卷积层、激活层和池化层，以及作为输出的全连接层；</li><li>卷积神经网络的作用是逐层提取输入对象的特征。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/2.jpg" alt=""></p><h2 id="昨日重现：循环神经网络"><a href="#昨日重现：循环神经网络" class="headerlink" title="昨日重现：循环神经网络"></a>昨日重现：循环神经网络</h2><hr><p>循环神经网络和递归神经网络的基本原理与简要的工作机制。其要点如下：</p><ul><li>循环神经网络是具有记忆的神经网络，适用于处理序列化数据；</li><li>循环神经网络引入反馈结构，能够在时间上共享参数，从而具有记忆；</li><li>循环神经网络的扩展包括双向循环网络和深度循环网络；</li><li>递归神经网络能够处理具有层次化结构的数据，可以看成循环神经网络的推广。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/3.jpg" alt=""></p><h2 id="左右互搏：生成式对抗网络"><a href="#左右互搏：生成式对抗网络" class="headerlink" title="左右互搏：生成式对抗网络"></a>左右互搏：生成式对抗网络</h2><hr><p>生成式对抗网络的原理与机制。其要点如下：</p><ul><li>生成式对抗网络是一类运行在零和博弈框架下的无监督学习算法，由生成器和判别器构成；</li><li>生成器的目的是精确模拟真实数据的分布，判别器的目的是精确区分真实数据和生成数据；</li><li>生成式对抗网络的主要优点是超越了传统神经网络分类和特征提取的功能，能够按照真实数据的特点生成新的数据；</li><li>生成式对抗网络的主要问题是理论基础的缺失。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/4.jpg" alt=""></p><h2 id="三重门：长短期记忆网络"><a href="#三重门：长短期记忆网络" class="headerlink" title="三重门：长短期记忆网络"></a>三重门：长短期记忆网络</h2><hr><p>长短期记忆网络的基本原理与简单工作机制。其要点如下：</p><ul><li>长短期记忆网络可以实现任意长度的记忆，对信息进行长期而精确的跟踪；</li><li>长短期记忆单元的组成包括记忆模块、输入门、遗忘门和输出门；</li><li>长短期记忆网络根据当前的输入、当前的记忆和前一时刻的输出确定当前的输出；</li><li>长短期记忆网络能够解决梯度弥散的问题。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/5.jpg" alt=""></p><h2 id="一图胜千言：概率图模型"><a href="#一图胜千言：概率图模型" class="headerlink" title="一图胜千言：概率图模型"></a>一图胜千言：概率图模型</h2><hr><p>概率图模型的原理，包括有向的贝叶斯网络和无向的马尔可夫随机场。其要点如下：</p><ul><li>概率图模型是概率论与图论的结合，是用图论表现随机变量之间的条件依赖关系的建模方法；</li><li>贝叶斯网络是有向无环图，侧重于表示随机变量之间的依赖关系；</li><li>马尔可夫随机场是无向图，侧重于表示随机变量之间的相互作用；</li><li>概率图模型体现了“表示 - 推断 - 学习”的问题解决框架。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/6.jpg" alt=""></p><h2 id="乌合之众的逆袭：集群智能"><a href="#乌合之众的逆袭：集群智能" class="headerlink" title="乌合之众的逆袭：集群智能"></a>乌合之众的逆袭：集群智能</h2><hr><p>集群智能方法的现实依据，以及它所代表的研究方向。其要点如下：</p><ul><li>集群智能是由众多简单个体通过自组织和去中心化的简单合作实现的智能；</li><li>集群智能具有可扩展性、并行性和容错性等特点；</li><li>集群智能体现出微观个体之间的相互作用能够实现整体大于部分之和的效果，其实例是蚁群算法；</li><li>集群智能在人工智能中的应用代表的是从宏观模仿到微观解构的方向转变。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/7.jpg" alt=""></p><h2 id="一图胜千言：概率图模型-1"><a href="#一图胜千言：概率图模型-1" class="headerlink" title="一图胜千言：概率图模型"></a>一图胜千言：概率图模型</h2><hr><p>概率图模型的原理，包括有向的贝叶斯网络和无向的马尔可夫随机场。其要点如下：</p><ul><li>概率图模型是概率论与图论的结合，是用图论表现随机变量之间的条件依赖关系的建模方法；</li><li>贝叶斯网络是有向无环图，侧重于表示随机变量之间的依赖关系；</li><li>马尔可夫随机场是无向图，侧重于表示随机变量之间的相互作用；</li><li>概率图模型体现了“表示 - 推断 - 学习”的问题解决框架。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/8.jpg" alt=""></p><h2 id="授人以鱼不如授人以渔：迁移学习"><a href="#授人以鱼不如授人以渔：迁移学习" class="headerlink" title="授人以鱼不如授人以渔：迁移学习"></a>授人以鱼不如授人以渔：迁移学习</h2><hr><p>迁移学习的基本原理和常用方法。其要点如下：</p><ul><li>迁移学习是运用已学习的知识来求解不同但相关领域问题的新的机器学习方法，目的是让机器“学会学习”；</li><li>迁移学习适用于跨领域和小数据的学习任务；</li><li>迁移学习的任务类型可以分为归纳迁移学习，直推式迁移学习和无监督迁移学习；</li><li>迁移学习的学习方法包括基于样本、基于特征、基于模型和基于关系。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/9.jpg" alt=""></p><h2 id="滴水藏海：知识图谱"><a href="#滴水藏海：知识图谱" class="headerlink" title="滴水藏海：知识图谱"></a>滴水藏海：知识图谱</h2><hr><p>知识图谱的基本原理与简单应用。其要点如下：</p><ul><li>知识图谱是由大量的概念实体以及它们之间的关系构成的语义网络；</li><li>用知识图谱实现从特殊到一般的归纳推理，典型的方法是路径排序算法；</li><li>用知识图谱实现从一般到特殊的演绎推理，典型的方法是马尔可夫逻辑网和概率软逻辑；</li><li>用知识图谱实现数值推理，典型的方法是基于分布式知识表示的方法。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/10.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-19.png&quot; alt=&quot;2020/01/19&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
      <category term="NN" scheme="https://2020.iosdevlog.com/tags/NN/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-深度学习总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/18/dl/"/>
    <id>https://2020.iosdevlog.com/2020/01/18/dl/</id>
    <published>2020-01-18T06:29:02.000Z</published>
    <updated>2020-01-20T13:37:40.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-18.png" alt="2020/01/18"></p><a id="more"></a><h2 id="空山鸣响，静水流深：深度学习概述"><a href="#空山鸣响，静水流深：深度学习概述" class="headerlink" title="空山鸣响，静水流深：深度学习概述"></a>空山鸣响，静水流深：深度学习概述</h2><hr><p>深度学习的一些简介，其要点如下：</p><ul><li>深度学习实际上是基于具有多个隐藏层的神经网络的学习；</li><li>深度学习的思想来源于人类处理视觉信息的方式；</li><li>深度学习的发展得益于数据的井喷和计算力的飙升；</li><li>深度学习的理论基础依然有待深入。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/1.jpg" alt=""></p><h2 id="前方有路，未来可期：深度前馈网络"><a href="#前方有路，未来可期：深度前馈网络" class="headerlink" title="前方有路，未来可期：深度前馈网络"></a>前方有路，未来可期：深度前馈网络</h2><hr><p>作为学习模型的深度前馈网络存在的一些共性问题，其要点如下：</p><ul><li>深度前馈网络利用深度架构实现工程上可实现的对任意函数的通用逼近；</li><li>深度前馈网络使用梯度下降的方法进行学习；</li><li>深度前馈网络的损失函数通常是交叉熵或最小均方误差；</li><li>深度前馈网络的隐藏神经元通常使用整流线性单元作为传递函数。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/2.jpg" alt=""></p><h2 id="小树不修不直溜：深度学习中的正则化"><a href="#小树不修不直溜：深度学习中的正则化" class="headerlink" title="小树不修不直溜：深度学习中的正则化"></a>小树不修不直溜：深度学习中的正则化</h2><hr><p>实现正则化的思路，其要点如下：</p><ul><li><p>基于训练数据的正则化方法包括数据集增强和 Dropout；</p></li><li><p>基于网络架构的正则化方法包括参数共享和传递函数正则化；</p></li><li><p>基于误差函数和正则化项的正则化方法包括使用 <em>L²</em> 范数和 <em>L¹</em> 范数；</p></li><li><p>基于最优化过程的正则化方法包括早停。</p></li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/3.jpg" alt=""></p><h2 id="玉不琢不成器：深度学习中的优化"><a href="#玉不琢不成器：深度学习中的优化" class="headerlink" title="玉不琢不成器：深度学习中的优化"></a>玉不琢不成器：深度学习中的优化</h2><hr><p>深度学习中实现优化的思路，其要点如下：</p><ul><li><p>深度学习中的优化需要解决病态矩阵、局部极小值和鞍点等问题；</p></li><li><p>深度学习优化中的降噪方法包括动态采样、梯度聚合和迭代平均；</p></li><li><p>深度学习优化中的二阶导数近似方法是对原始牛顿法的各种改进；</p></li><li><p>其他优化方法包括动量方法、加速下降方法和坐标下降方法。</p></li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/4.jpg" alt=""></p><h2 id="空竹里的秘密：自编码器"><a href="#空竹里的秘密：自编码器" class="headerlink" title="空竹里的秘密：自编码器"></a>空竹里的秘密：自编码器</h2><hr><p>自编码器的原理与特点，其要点如下：</p><ul><li>自编码器是一种无监督学习方式，目的在于学习数据的重新表达；</li><li>多个浅层自编码器级联可以得到深度的栈式自编码器，并使用无监督预训练结合有监督微调的方式加以训练；</li><li>稀疏自编码器利用稀疏的高维表达提取出训练集中隐含的统计规律；</li><li>变分自编码器对隐藏层做参数化处理，可以用于学习数据的生成模型。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/5.jpg" alt=""></p><h2 id="困知勉行者勇：深度强化学习"><a href="#困知勉行者勇：深度强化学习" class="headerlink" title="困知勉行者勇：深度强化学习"></a>困知勉行者勇：深度强化学习</h2><hr><p>深度强化学习（deep reinforcement learning）是深度学习和强化学习的结合，它将深度学习的感知能力和强化学习的决策能力熔于一炉，用深度学习的运行机制达到强化学习的优化目标，从而向通用人工智能迈进。</p><p>深度强化学习的简单原理与方法分类，其要点如下：</p><ul><li>深度强化学习是深度学习和强化学习的结合，有望成为实现通用人工智能的关键技术；</li><li>基于价值的深度强化学习的基本思路是建立价值函数的表示，通过优化价值函数得到最优策略；</li><li>基于策略的深度强化学习的基本思路是直接搜索能够使未来奖励最大化的最优策略；</li><li>基于模型的深度强化学习的基本思路是构造关于环境的转移概率模型，再用这个模型指导策略。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-18.png&quot; alt=&quot;2020/01/18&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="ANN" scheme="https://2020.iosdevlog.com/tags/ANN/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>《假面饭店》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/17/9787544259101/"/>
    <id>https://2020.iosdevlog.com/2020/01/17/9787544259101/</id>
    <published>2020-01-17T04:36:13.000Z</published>
    <updated>2020-01-17T04:47:07.242Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/17/9787544259101/9787544259101.png" class="" title="东野圭吾-《假面饭店》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 南海出版公司<br>原作名: マスカレードホテル<br>译者: 中森<br>出版年: 2012-12<br>页数: 288<br>定价: 39.80元<br>装帧: 精装<br>丛书: 假面系列<br>ISBN: 9787544259101</p><p>四个不相关的 x1-x4 杀人事件，让 x4 误导成连环杀人事件。</p><p>服务业为客人着想。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/17/9787544259101/9787544259101.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《假面饭店》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="假面系列" scheme="https://2020.iosdevlog.com/tags/%E5%81%87%E9%9D%A2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-人工神经网络总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/17/ann/"/>
    <id>https://2020.iosdevlog.com/2020/01/17/ann/</id>
    <published>2020-01-17T04:29:21.000Z</published>
    <updated>2020-01-17T04:34:00.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-17.png" alt="2020/01/17"></p><a id="more"></a><h2 id="道法自然，久藏玄冥：神经网络的生理学背景"><a href="#道法自然，久藏玄冥：神经网络的生理学背景" class="headerlink" title="道法自然，久藏玄冥：神经网络的生理学背景"></a>道法自然，久藏玄冥：神经网络的生理学背景</h2><hr><p>人工神经网络的生理学背景，也对人类认知的物理基础与工作机制做了简单的介绍，其要点如下：</p><ul><li>思维过程是神经元的连接活动过程，由大量突触相互动态联系着的众多神经元协同作用来实现；</li><li>大脑的思维源于从神经元到神经网络再到神经回路的功能逐级整合；</li><li>大脑对信息的加工可以理解为复杂的多次特征提取过程；</li><li>在大脑中，数据的传输和处理是同步进行的。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/1.jpg" alt=""></p><h2 id="一个青年才俊的意外死亡：神经元与感知器"><a href="#一个青年才俊的意外死亡：神经元与感知器" class="headerlink" title="一个青年才俊的意外死亡：神经元与感知器"></a>一个青年才俊的意外死亡：神经元与感知器</h2><hr><p>神经网络的鼻祖感知器的基本原理，其要点如下：</p><ul><li>人工神经网络的神经元用传递函数对输入的线性加权进行非线性处理以产生输出；</li><li>感知器是一种二分类的监督学习算法，通过自适应调整权重解决线性分类问题；</li><li>感知器的神经元之间通过权重传递信息，权重的变化根据误差来进行调节；</li><li>感知器不能解决以异或为代表的线性不可分问题。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/2.jpg" alt=""></p><h2 id="左手信号，右手误差：多层感知器"><a href="#左手信号，右手误差：多层感知器" class="headerlink" title="左手信号，右手误差：多层感知器"></a>左手信号，右手误差：多层感知器</h2><hr><p>多层感知器和反向传播的基本原理，关于反向传播具体的数学细节你可以参考相关文献，其要点如下：</p><ul><li>在感知器的输入层和输出层之间添加隐藏层，就可以得到多层感知器；</li><li>多层感知器是一类前馈神经网络，采用的是反向传播的学习方式；</li><li>反向传播算法要根据误差函数的梯度来调整权重系数，需要应用求导的链式法则；</li><li>单个隐藏层就能使多层感知器以任意精度逼近任意复杂度的连续函数。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/3.jpg" alt=""></p><h2 id="各人自扫门前雪：径向基函数神经网络"><a href="#各人自扫门前雪：径向基函数神经网络" class="headerlink" title="各人自扫门前雪：径向基函数神经网络"></a>各人自扫门前雪：径向基函数神经网络</h2><hr><p>径向基函数神经网络的基本原理，其要点如下：</p><ul><li>径向基网络采用局部逼近方式，每个神经元只对特定的输入信号产生作用；</li><li>径向基网络的隐藏神经元使用径向基函数作为传递函数，常用的径向基函数是高斯函数；</li><li>径向基函数可以将低维空间上的线性不可分问题转化为高维空间上的线性可分问题；</li><li>使用高斯函数的径向基网络可以用 K 均值聚类算法结合递归最小二乘法进行训练。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/4.jpg" alt=""></p><h2 id="看不见的手：自组织特征映射"><a href="#看不见的手：自组织特征映射" class="headerlink" title="看不见的手：自组织特征映射"></a>看不见的手：自组织特征映射</h2><hr><p>自组织特征映射的基本原理，其要点如下：</p><ol><li>自组织映射是一类无监督学习的神经网络，模拟了生物神经系统的竞争性学习机制；</li><li>自组织映射能将任意维度的输入模式转换为一维或二维的离散映射，得到的特征映射是拓扑有序的；</li><li>在拓扑映射中，输出神经元的空间位置对应了输入数据的模式或特征；</li><li>自组织映射网络的训练包括竞争过程、合作过程和自适应过程等几个主要步骤。</li></ol><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/5.jpg" alt=""></p><h2 id="水无至清，人莫至察：模糊神经网络"><a href="#水无至清，人莫至察：模糊神经网络" class="headerlink" title="水无至清，人莫至察：模糊神经网络"></a>水无至清，人莫至察：模糊神经网络</h2><hr><p>模糊神经网络的基本概念，其要点如下：</p><ul><li>模糊神经网络是神经网络和模糊逻辑结合形成的混合智能系统；</li><li>模糊神经网络的输入信号、权重系数和输出信号全都是模糊集合；</li><li>模糊神经网络的主要学习算法包括基于水平集的方法和基于遗传算法的方法；</li><li>模糊神经网络具有和传统神经网络类似的通用逼近特性。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-17.png&quot; alt=&quot;2020/01/17&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="ANN" scheme="https://2020.iosdevlog.com/tags/ANN/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-机器学习总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/16/ml/"/>
    <id>https://2020.iosdevlog.com/2020/01/16/ml/</id>
    <published>2020-01-16T07:58:12.000Z</published>
    <updated>2020-01-16T08:03:22.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-16.png" alt="2020/01/16"></p><a id="more"></a><h2 id="数山有路，学海无涯：机器学习概论"><a href="#数山有路，学海无涯：机器学习概论" class="headerlink" title="数山有路，学海无涯：机器学习概论"></a>数山有路，学海无涯：机器学习概论</h2><hr><p>机器学习的基本原理与基础概念，其要点如下：</p><ul><li>机器学习是计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的学科；</li><li>根据输入输出类型的不同，机器学习可分为分类问题、回归问题、标注问题三类；</li><li>过拟合是机器学习中不可避免的问题，可通过选择合适的模型降低其影响；</li><li>监督学习是目前机器学习的主流任务，包括生成方法和判别方法两类。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/1.jpg" alt=""></p><h2 id="简约而不简单：线性回归"><a href="#简约而不简单：线性回归" class="headerlink" title="简约而不简单：线性回归"></a>简约而不简单：线性回归</h2><hr><p>线性回归的基本原理，其要点如下：</p><ul><li>线性回归假设输出变量是若干输入变量的线性组合，并根据这一关系求解线性组合中的最优系数；</li><li>最小二乘法可用于解决单变量线性回归问题，当误差函数服从正态分布时，它与最大似然估计等价；</li><li>多元线性回归问题也可以用最小二乘法求解，但极易出现过拟合现象；</li><li>岭回归和 LASSO 回归分别通过引入二范数惩罚项和一范数惩罚项抑制过拟合。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/2.jpg" alt=""></p><h2 id="大道至简：朴素贝叶斯方法"><a href="#大道至简：朴素贝叶斯方法" class="headerlink" title="大道至简：朴素贝叶斯方法"></a>大道至简：朴素贝叶斯方法</h2><hr><p>朴素贝叶斯方法的基本原理，其要点如下：</p><ul><li>朴素贝叶斯方法利用后验概率选择最佳分类，后验概率可以通过贝叶斯定理求解；</li><li>朴素贝叶斯方法假定所有属性相互独立，基于这一假设将类条件概率转化为属性条件概率的乘积；</li><li>朴素贝叶斯方法可以使期望风险最小化；</li><li>影响朴素贝叶斯分类的是所有属性之间的依赖关系在不同类别上的分布。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/3.jpg" alt=""></p><h2 id="衍化至繁：逻辑回归"><a href="#衍化至繁：逻辑回归" class="headerlink" title="衍化至繁：逻辑回归"></a>衍化至繁：逻辑回归</h2><hr><p>逻辑回归方法的基本原理，其要点如下：</p><ul><li>逻辑回归模型是对线性回归的改进，用于解决分类问题；</li><li>逻辑回归输出的是实例属于每个类别的似然概率，似然概率最大的类别就是分类结果；</li><li>在一定条件下，逻辑回归模型与朴素贝叶斯分类器是等价的；</li><li>多分类问题时可以通过多次使用二分类逻辑回归或者使用 Softmax 回归解决。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/4.jpg" alt=""></p><h2 id="步步为营，有章可循：决策树"><a href="#步步为营，有章可循：决策树" class="headerlink" title="步步为营，有章可循：决策树"></a>步步为营，有章可循：决策树</h2><hr><p>决策树的基本原理，其要点如下：</p><ul><li>决策树是包含根节点、内部节点和叶节点的树结构，通过判定不同属性的特征来解决分类问题；</li><li>决策树的学习过程包括特征选择、决策树生成、决策树剪枝三个步骤；</li><li>决策树生成的基础是特征选择，特征选择的指标包括信息增益、信息增益比和基尼系数；</li><li>决策树的剪枝策略包括预剪枝和后剪枝。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/5.jpg" alt=""></p><h2 id="穷则变，变则通：支持向量机"><a href="#穷则变，变则通：支持向量机" class="headerlink" title="穷则变，变则通：支持向量机"></a>穷则变，变则通：支持向量机</h2><hr><p>支持向量机的基本原理，其要点如下：</p><ul><li>线性可分支持向量机通过硬间隔最大化求出划分超平面，解决线性分类问题；</li><li>线性支持向量机通过软间隔最大化求出划分超平面，解决线性分类问题；</li><li>非线性支持向量机利用核函数实现从低维原始空间到高维特征空间的转换，在高维空间上解决非线性分类问题；</li><li>支持向量机的学习是个凸二次规划问题，可以用 SMO 算法快速求解。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/6.jpg" alt=""></p><h2 id="三个臭皮匠，赛过诸葛亮：集成学习"><a href="#三个臭皮匠，赛过诸葛亮：集成学习" class="headerlink" title="三个臭皮匠，赛过诸葛亮：集成学习"></a>三个臭皮匠，赛过诸葛亮：集成学习</h2><hr><p>集成学习的基本原理，其要点如下：</p><ul><li>集成学习使用多个个体学习器来获得比每个单独学习器更好的预测性能，包括序列化方法和并行化方法两类；</li><li>多样性要求集成学习中的不同个体学习器之间具有足够的差异性；</li><li>序列化方法采用 Boosting 机制，通过重复使用概率分布不同的训练数据实现集成，可以降低泛化误差中的偏差；</li><li>并行化方法采用 Bagging 机制，通过在训练数据中多次自助抽取不同的采样子集实现集成，可以降低泛化误差中的方差。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/7.jpg" alt=""></p><h2 id="物以类聚，人以群分：聚类分析"><a href="#物以类聚，人以群分：聚类分析" class="headerlink" title="物以类聚，人以群分：聚类分析"></a>物以类聚，人以群分：聚类分析</h2><hr><p>聚类分析的基本原理，其要点如下：</p><ul><li>聚类分析是一种无监督学习方法，通过学习没有分类标记的训练样本发现数据的内在性质和规律；</li><li>数据之间的相似性通常用距离度量，类内差异应尽可能小，类间差异应尽可能大；</li><li>根据形成聚类方式的不同，聚类算法可以分为层次聚类、原型聚类、分布聚类、密度聚类等几类；</li><li>聚类分析的一个重要应用是对用户进行分组与归类。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/8.jpg" alt=""></p><h2 id="好钢用在刀刃上：降维学习"><a href="#好钢用在刀刃上：降维学习" class="headerlink" title="好钢用在刀刃上：降维学习"></a>好钢用在刀刃上：降维学习</h2><hr><p>主成分分析是一种主要的降维方法，另一种更加直观的降维方式则是直接对样本的属性做出筛选，这种降维方法就是“特征选择”，其要点如下：</p><ul><li>主成分分析利用正交变换将可能存在相关性的原始属性转换成一组线性无关的新属性，并通过选择重要的新属性实现降维；</li><li>主成分分析的解满足最大方差和最小均方误差两类约束条件，因而具有最大可分性和最近重构性；</li><li>特征选择则是选取原始特征中的一个子集用于学习任务，是另一种主要的降维技术；</li><li>特征选择的关键问题是对特征子集的评价，主要的特征选择算法包括包裹法、过滤法和嵌入法。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/9.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/10.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-16.png&quot; alt=&quot;2020/01/16&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-数学基础总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/"/>
    <id>https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/</id>
    <published>2020-01-15T11:24:50.000Z</published>
    <updated>2020-01-15T14:46:26.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/0.jpg" alt=""></p><a id="more"></a><h2 id="九层之台，起于累土：线性代数"><a href="#九层之台，起于累土：线性代数" class="headerlink" title="九层之台，起于累土：线性代数"></a>九层之台，起于累土：线性代数</h2><p>必备的数学知识是理解人工智能不可或缺的要素，今天的种种人工智能技术归根到底都建立在数学模型之上，而这些数学模型又都离不开线性代数（linear algebra）的理论框架。</p><p>在线性代数中，由单独的数 a 构成的元素被称为标量（scalar）：一个标量 a 可以是整数、实数或复数。如果多个标量按一定顺序组成一个序列，这样的元素就被称为向量（vector）。显然，向量可以看作标量的扩展。原始的一个数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一地确定向量中的元素。</p><p>相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要使用两个索引（而非一个）确定。同理，如果将矩阵中的每个标量元素再替换为向量的话，得到的就是张量（tensor）。直观地理解，张量就是高阶的矩阵。</p><p>在计算机存储中，标量占据的是零维数组；向量占据的是一维数组，例如语音信号；矩阵占据的是二维数组，例如灰度图像；张量占据的是三维乃至更高维度的数组，例如 RGB 图像和视频。</p><p>线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性；<br>向量的实质是 n 维线性空间中的静止点；<br>线性变换描述了向量或者作为参考系的坐标系的变化，可以用矩阵表示；<br>矩阵的特征值和特征向量描述了变化的速度与方向。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/1.jpg" alt=""></p><h2 id="月有阴晴圆缺，此事古难全：概率论"><a href="#月有阴晴圆缺，此事古难全：概率论" class="headerlink" title="月有阴晴圆缺，此事古难全：概率论"></a>月有阴晴圆缺，此事古难全：概率论</h2><p>概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。</p><p>概率的估计有两种方法：最大似然估计法（maximum likelihood estimation）和最大后验概率法（maximum a posteriori estimation），两者分别体现出频率学派和贝叶斯学派对概率的理解方式。</p><p>概率论基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>概率论关注的是生活中的不确定性或可能性；<br>频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算；<br>贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算；<br>正态分布是最重要的一种随机变量的分布。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/2.jpg" alt=""></p><h2 id="窥一斑而知全豹：数理统计"><a href="#窥一斑而知全豹：数理统计" class="headerlink" title="窥一斑而知全豹：数理统计"></a>窥一斑而知全豹：数理统计</h2><p>人工智能必备的数理统计基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>数理统计的任务是根据可观察的样本反过来推断总体的性质；<br>推断的工具是统计量，统计量是样本的函数，是个随机变量；<br>参数估计通过随机抽取的样本来估计总体分布的未知参数，包括点估计和区间估计；<br>假设检验通过随机抽取的样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/3.jpg" alt=""></p><h2 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h2><p>人工智能必备的最优化方法基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>通常情况下，最优化问题是在无约束情况下求解给定目标函数的最小值；<br>在线性搜索中，确定寻找最小值时的搜索方向需要使用目标函数的一阶导数和二阶导数；<br>置信域算法的思想是先确定搜索步长，再确定搜索方向；<br>以人工神经网络为代表的启发式算法是另外一类重要的优化方法。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/4.jpg" alt=""></p><h2 id="万物皆数，信息亦然：信息论"><a href="#万物皆数，信息亦然：信息论" class="headerlink" title="万物皆数，信息亦然：信息论"></a>万物皆数，信息亦然：信息论</h2><p>近年来的科学研究不断证实，不确定性才是客观世界的本质属性。换句话说，上帝还真就掷骰子。不确定性的世界只能使用概率模型来描述，正是对概率的刻画促成了信息论的诞生。</p><p>信息论使用“信息熵”的概念，对单个信源的信息量和通信中传递信息的数量与效率等问题做出了解释，并在世界的不确定性和信息的可测量性之间搭建起一座桥梁。</p><p>人工智能必备的数理统计基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>数理统计的任务是根据可观察的样本反过来推断总体的性质；<br>推断的工具是统计量，统计量是样本的函数，是个随机变量；<br>参数估计通过随机抽取的样本来估计总体分布的未知参数，包括点估计和区间估计；<br>假设检验通过随机抽取的样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/5.jpg" alt=""></p><h2 id="明日黄花迹难寻：形式逻辑"><a href="#明日黄花迹难寻：形式逻辑" class="headerlink" title="明日黄花迹难寻：形式逻辑"></a>明日黄花迹难寻：形式逻辑</h2><p>人工智能必备的形式逻辑基础，以及采用形式逻辑进行自动推理的基本原理，其要点如下：</p><p>如果将认知过程定义为对符号的逻辑运算，人工智能的基础就是形式逻辑；<br>谓词逻辑是知识表示的主要方法；<br>基于谓词逻辑系统可以实现具有自动推理能力的人工智能；<br>不完备性定理向“认知的本质是计算”这一人工智能的基本理念提出挑战。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="Math" scheme="https://2020.iosdevlog.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>《圣女的救济》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/15/9787509005125/"/>
    <id>https://2020.iosdevlog.com/2020/01/15/9787509005125/</id>
    <published>2020-01-15T04:12:23.000Z</published>
    <updated>2020-01-15T11:20:57.600Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/15/9787509005125/9787509005125.png" class="" title="东野圭吾-《圣女的救济》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 当代世界出版社<br>译者: 袁斌<br>出版年: 2009-5<br>页数: 399<br>定价: 30.00<br>装帧: 精装<br>丛书: 乐读文库<br>ISBN: 9787509005125</p><p>好友的自杀的原因，轮到自己身上，因爱生恨，既然无法挽回，那你就去死吧！</p><p><code>死道友不死贫道</code></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/15/9787509005125/9787509005125.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《圣女的救济》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="伽利略系列" scheme="https://2020.iosdevlog.com/tags/%E4%BC%BD%E5%88%A9%E7%95%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>实现一门脚本语言-原理篇</title>
    <link href="https://2020.iosdevlog.com/2020/01/14/Construction/"/>
    <id>https://2020.iosdevlog.com/2020/01/14/Construction/</id>
    <published>2020-01-14T05:58:32.000Z</published>
    <updated>2020-01-14T09:26:24.341Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/14/Construction/Compiler.jpg" class="" title="宫文学- 编译原理"><a id="more"></a><h2 id="理解代码：编译器的前端技术"><a href="#理解代码：编译器的前端技术" class="headerlink" title="理解代码：编译器的前端技术"></a>理解代码：编译器的前端技术</h2><ul><li><code>前端（Front End）</code>: 编译器对程序代码的分析和理解过程<ul><li>词法分析（Lexical Analysis）<ul><li><code>程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现</code></li><li>识别一个个的单词</li><li><code>词法记号（Token）</code></li><li>Lex（或其 GNU 版本，Flex）<ul><li>正则文法（Regular Grammar）<ul><li>符合正则文法的表达式</li></ul></li><li>有限自动机（Finite-state Automaton，FSA，or Finite Automaton） 算法</li></ul></li></ul></li><li>语法分析 （Syntactic Analysis, or Parsing）<ul><li><code>把程序的结构识别出来，并形成一棵便于由计算机处理的抽象语法树。可以用递归下降的算法来实现</code>。*`</li><li>别出程序的语法结构</li><li>Yacc（或 GNU 的版本，Bison）、Antlr、JavaCC</li><li><code>抽象语法树（Abstract Syntax Tree，AST</code>）</li><li><code>clang -cc1 -ast-dump hello.c</code></li><li>递归下降算法（Recursive Descent Parsing）</li></ul></li><li>语义分析（Semantic Analysis）<ul><li><code>消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。</code></li></ul></li></ul></li><li><code>后端（Back End）</code>: 生成目标代码的过程，跟目标机器有关</li></ul><h2 id="正则文法和有限自动机：纯手工打造词法分析器"><a href="#正则文法和有限自动机：纯手工打造词法分析器" class="headerlink" title="正则文法和有限自动机：纯手工打造词法分析器"></a>正则文法和有限自动机：纯手工打造词法分析器</h2><ul><li><code>关键字</code>: 语言设计中作为语法要素的词汇</li><li><code>保留字</code>: 当前的语言设计中还没用到，但是保留下来，因为将来会用到</li></ul><img src="/2020/01/14/Construction/Token.jpg" class="" title="Token"><blockquote><p>关键字和保留字跟标识符区分开呢？</p></blockquote><ul><li>识别普通的 <code>标识符</code> 之前，是否 <code>关键字</code> / <code>保留字</code></li></ul><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><img src="/2020/01/14/Construction/AST.jpg" class="" title="AST"><h3 id="纯手工打造公式计算器"><a href="#纯手工打造公式计算器" class="headerlink" title="纯手工打造公式计算器"></a>纯手工打造公式计算器</h3><p>推导（Derivation）过程</p><ul><li><code>左边</code>：非终结符（Non-terminal）</li><li><code>右边</code>：产生式（Production Rule）</li><li>语法解析的过程中，左边会被右边替代</li><li>如果替代之后还有非终结符，那么继续这个替代过程，直到最后全部都是终结符（Terminal），也就是 Token。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intDeclaration : <span class="function">Int <span class="title">Identifier</span> <span class="params">(<span class="string">'='</span> additiveExpression)</span>?</span>;</span><br></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MatchIntDeclare() &#123;</span><br><span class="line">  MatchToken(Int)；        <span class="comment">// 匹配Int关键字</span></span><br><span class="line">  MatchIdentifier();       <span class="comment">// 匹配标识符</span></span><br><span class="line">  MatchToken(equal);       <span class="comment">// 匹配等号</span></span><br><span class="line">  MatchExpression();       <span class="comment">// 匹配表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“下降”的含义</p><ol><li>上级文法嵌套下级文法</li><li>上级的算法调用下级的算法</li></ol><ul><li>上下文无关文法</li><li>正则文法(不允许递归调用)</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>初步了解上下文无关文法，知道它能表达主流的计算机语言，以及与正则文法的区别。</li><li>理解递归下降算法中的 <strong>下降</strong> 和 <strong>递归</strong> 两个特点。</li><li>它跟文法规则基本上是同构的，通过文法一定能写出算法。通过遍历 AST 对表达式求值，加深对计算机程序执行机制的理解。</li></ul><h3 id="解决二元表达式中的难点"><a href="#解决二元表达式中的难点" class="headerlink" title="解决二元表达式中的难点"></a>解决二元表达式中的难点</h3><p><code>左递归（Left Recursive）</code>：产生式的第一个元素是它自身，那么程序就会无限地递归下去</p><ul><li><code>优先级（Priority）</code></li><li><code>结合性（Associativity）</code></li><li><code>产生式</code>: 一组替换规则</li></ul><p>巴科斯范（BNF):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add ::&#x3D; mul | add + mul</span><br><span class="line">mul ::&#x3D; pri | mul * pri</span><br><span class="line">pri ::&#x3D; Id | Num | (add)</span><br></pre></td></tr></table></figure><p>扩展巴科斯范式 (EBNF)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul (+ mul)*</span><br></pre></td></tr></table></figure><h3 id="确保正确的优先级"><a href="#确保正确的优先级" class="headerlink" title="确保正确的优先级"></a>确保正确的优先级</h3><ul><li>括号</li></ul><h3 id="确保正确的结合性"><a href="#确保正确的结合性" class="headerlink" title="确保正确的结合性"></a>确保正确的结合性</h3><ul><li>左结合的运算符，递归项放在左边</li><li>右结合的运算符，递归项放在右边</li></ul><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>左递归文法 <code>-&gt;</code> 非左递归的文法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul add&#39;</span><br><span class="line">add&#39; -&gt; + mul add&#39; | ε</span><br></pre></td></tr></table></figure><ul><li>ε（读作 epsilon）:空集</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><code>优先级</code> 是通过在语法推导中的层次来决定的，优先级越低的，越先尝试推导。</li><li><code>结合性</code> 是跟左递归还是右递归有关的，左递归导致左结合，右递归导致右结合。</li><li><code>左递归</code> 可以通过改写语法规则来避免，而改写后的语法又可以表达成简洁的 EBNF 格式，从而启发我们用循环代替右递归。</li></ul><h3 id="实现一门简单的脚本语言"><a href="#实现一门简单的脚本语言" class="headerlink" title="实现一门简单的脚本语言"></a>实现一门简单的脚本语言</h3><p><code>回溯</code>: 尝试一个规则不成功之后，恢复到原样，再去尝试另外的规则<br><code>REPL（Read-Eval-Print Loop）</code>: 输入、执行、打印的循环过程</p><h2 id="编译器前端工具"><a href="#编译器前端工具" class="headerlink" title="编译器前端工具"></a>编译器前端工具</h2><h3 id="用Antlr生成词法、语法分析器"><a href="#用Antlr生成词法、语法分析器" class="headerlink" title="用Antlr生成词法、语法分析器"></a>用Antlr生成词法、语法分析器</h3><p><code>Antlr:</code> Antlr 是一个开源的工具，支持根据规则文件生成词法分析器和语法分析器，它自身是用 <code>Java</code> 实现的。</p><p><a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank" rel="noopener">https://github.com/antlr/antlr4/blob/master/doc/getting-started.md</a></p><h4 id="用-Antlr-生成词法分析器"><a href="#用-Antlr-生成词法分析器" class="headerlink" title="用 Antlr 生成词法分析器"></a>用 Antlr 生成词法分析器</h4><p><code>Hello.g4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Hello;  &#x2F;&#x2F; lexer关键字意味着这是一个词法规则文件，名称是Hello，要与文件名相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键字</span><br><span class="line">If :               &#39;if&#39;;</span><br><span class="line">Int :              &#39;int&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字面量</span><br><span class="line">IntLiteral:        [0-9]+;</span><br><span class="line">StringLiteral:      &#39;&quot;&#39; .*? &#39;&quot;&#39; ;  &#x2F;&#x2F; 字符串字面量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作符</span><br><span class="line">AssignmentOP:       &#39;&#x3D;&#39; ;    </span><br><span class="line">RelationalOP:       &#39;&gt;&#39;|&#39;&gt;&#x3D;&#39;|&#39;&lt;&#39; |&#39;&lt;&#x3D;&#39; ;    </span><br><span class="line">Star:               &#39;*&#39;;</span><br><span class="line">Plus:               &#39;+&#39;;</span><br><span class="line">Sharp:              &#39;#&#39;;</span><br><span class="line">SemiColon:          &#39;;&#39;;</span><br><span class="line">Dot:                &#39;.&#39;;</span><br><span class="line">Comm:               &#39;,&#39;;</span><br><span class="line">LeftBracket :       &#39;[&#39;;</span><br><span class="line">RightBracket:       &#39;]&#39;;</span><br><span class="line">LeftBrace:          &#39;&#123;&#39;;</span><br><span class="line">RightBrace:         &#39;&#125;&#39;;</span><br><span class="line">LeftParen:          &#39;(&#39;;</span><br><span class="line">RightParen:         &#39;)&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 标识符</span><br><span class="line">Id :                [a-zA-Z_] ([a-zA-Z_] | [0-9])*;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 空白字符，抛弃</span><br><span class="line">Whitespace:         [ \t]+ -&gt; skip;</span><br><span class="line">Newline:            ( &#39;\r&#39; &#39;\n&#39;?|&#39;\n&#39;)-&gt; skip;</span><br></pre></td></tr></table></figure><h5 id="编译词法规则"><a href="#编译词法规则" class="headerlink" title="编译词法规则"></a>编译词法规则</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr Hello.g4</span><br></pre></td></tr></table></figure><h5 id="编译-Hello-java"><a href="#编译-Hello-java" class="headerlink" title="编译 Hello.java"></a>编译 Hello.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac *.java</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p><code>hello.play</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 45;</span><br><span class="line">if (age &gt;&#x3D; 17+8+20) &#123;</span><br><span class="line">    printf(&quot;Hello old man!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>词法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grun Hello tokens -tokens hello.play</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:2&#x3D;&#39;int&#39;,&lt;&#39;int&#39;&gt;,1:0]</span><br><span class="line">[@1,4:6&#x3D;&#39;age&#39;,&lt;Id&gt;,1:4]</span><br><span class="line">[@2,8:8&#x3D;&#39;&#x3D;&#39;,&lt;&#39;&#x3D;&#39;&gt;,1:8]</span><br><span class="line">[@3,10:11&#x3D;&#39;45&#39;,&lt;IntLiteral&gt;,1:10]</span><br><span class="line">[@4,12:12&#x3D;&#39;;&#39;,&lt;&#39;;&#39;&gt;,1:12]</span><br><span class="line">[@5,14:15&#x3D;&#39;if&#39;,&lt;&#39;if&#39;&gt;,2:0]</span><br><span class="line">[@6,17:17&#x3D;&#39;(&#39;,&lt;&#39;(&#39;&gt;,2:3]</span><br><span class="line">[@7,18:20&#x3D;&#39;age&#39;,&lt;Id&gt;,2:4]</span><br><span class="line">[@8,22:23&#x3D;&#39;&gt;&#x3D;&#39;,&lt;RelationalOP&gt;,2:8]</span><br><span class="line">[@9,25:26&#x3D;&#39;17&#39;,&lt;IntLiteral&gt;,2:11]</span><br><span class="line">[@10,27:27&#x3D;&#39;+&#39;,&lt;&#39;+&#39;&gt;,2:13]</span><br><span class="line">[@11,28:28&#x3D;&#39;8&#39;,&lt;IntLiteral&gt;,2:14]</span><br><span class="line">[@12,29:29&#x3D;&#39;+&#39;,&lt;&#39;+&#39;&gt;,2:15]</span><br><span class="line">[@13,30:31&#x3D;&#39;20&#39;,&lt;IntLiteral&gt;,2:16]</span><br><span class="line">[@14,32:32&#x3D;&#39;)&#39;,&lt;&#39;)&#39;&gt;,2:18]</span><br><span class="line">[@15,34:34&#x3D;&#39;&#123;&#39;,&lt;&#39;&#123;&#39;&gt;,2:20]</span><br><span class="line">[@16,40:45&#x3D;&#39;printf&#39;,&lt;Id&gt;,3:4]</span><br><span class="line">[@17,46:46&#x3D;&#39;(&#39;,&lt;&#39;(&#39;&gt;,3:10]</span><br><span class="line">[@18,47:62&#x3D;&#39;&quot;Hello old man!&quot;&#39;,&lt;StringLiteral&gt;,3:11]</span><br><span class="line">[@19,63:63&#x3D;&#39;)&#39;,&lt;&#39;)&#39;&gt;,3:27]</span><br><span class="line">[@20,64:64&#x3D;&#39;;&#39;,&lt;&#39;;&#39;&gt;,3:28]</span><br><span class="line">[@21,66:66&#x3D;&#39;&#125;&#39;,&lt;&#39;&#125;&#39;&gt;,4:0]</span><br><span class="line">[@22,68:67&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,5:0]</span><br></pre></td></tr></table></figure><h4 id="用-Antlr-生成语法分析器"><a href="#用-Antlr-生成语法分析器" class="headerlink" title="用 Antlr 生成语法分析器"></a>用 Antlr 生成语法分析器</h4><p><code>PlayScript.g4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">grammar PlayScript;</span><br><span class="line">import CommonLexer;   &#x2F;&#x2F;导入词法定义</span><br><span class="line"></span><br><span class="line">&#x2F;*下面的内容加到所生成的Java源文件的头部，如包名称，import语句等。*&#x2F;</span><br><span class="line">@header &#123;</span><br><span class="line">package antlrtest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expression</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   expression &#39;,&#39; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentExpression</span><br><span class="line">    :   additiveExpression</span><br><span class="line">    |   Identifier assignmentOperator additiveExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentOperator</span><br><span class="line">    :   &#39;&#x3D;&#39;</span><br><span class="line">    |   &#39;*&#x3D;&#39;</span><br><span class="line">    |  &#39;&#x2F;&#x3D;&#39;</span><br><span class="line">    |   &#39;%&#x3D;&#39;</span><br><span class="line">    |   &#39;+&#x3D;&#39;</span><br><span class="line">    |   &#39;-&#x3D;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">additiveExpression</span><br><span class="line">    :   multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#39;+&#39; multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#39;-&#39; multiplicativeExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">multiplicativeExpression</span><br><span class="line">    :   primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;*&#39; primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;&#x2F;&#39; primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;%&#39; primaryExpression</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h5 id="生成语法分析器"><a href="#生成语法分析器" class="headerlink" title="生成语法分析器"></a>生成语法分析器</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">antlr PlayScript.g4</span><br><span class="line">javac antlrtest/*.java</span><br></pre></td></tr></table></figure><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grun antlrtest.PlayScript expression -gui</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age + 10 * 2  + 10</span><br><span class="line">^D</span><br></pre></td></tr></table></figure><p><strong>懂得基础原理，会让你站得更高</strong></p><h3 id="用Antlr重构脚本语言"><a href="#用Antlr重构脚本语言" class="headerlink" title="用Antlr重构脚本语言"></a>用Antlr重构脚本语言</h3><ul><li><p>完善表达式（Expression）的语法</p></li><li><p>完善各类语句（Statement）的语法</p></li><li><p>语句</p><ul><li>条件语句<ul><li>if 语句</li><li>switch 语句</li></ul></li><li>循环语句<ul><li>for 循环语句</li><li>while 循环语句</li></ul></li><li>return 语句</li></ul></li><li><p>表达式语句</p><ul><li>表达式后面加一个分号</li></ul></li></ul><p>用 <code>Vistor</code> 模式升级脚本解释器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr -visitor PlayScript.g4</span><br></pre></td></tr></table></figure><h2 id="作用域和生存期：实现块作用域和函数"><a href="#作用域和生存期：实现块作用域和函数" class="headerlink" title="作用域和生存期：实现块作用域和函数"></a>作用域和生存期：实现块作用域和函数</h2><p><code>作用域（Scope）</code>: 计算机语言中变量、函数、类等起作用的范围<br><code>生存期（Extent）</code>: 变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间</p><ol><li>实现作用域和栈</li><li>实现块作用域</li><li>实现函数功能: 参数<ul><li>建立一个栈桢</li><li>计算所有参数的值，并放入栈桢</li><li>执行函数声明中的函数体。</li></ul></li></ol><h2 id="面向对象：实现数据和方法的封装"><a href="#面向对象：实现数据和方法的封装" class="headerlink" title="面向对象：实现数据和方法的封装"></a>面向对象：实现数据和方法的封装</h2><p>语法规则</p><ul><li>类声明以 class 关键字开头，有一个标识符是类型名称，后面跟着类的主体。</li><li>类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。</li><li>类的方法也叫做 function，而不是 method，是想把对象方法和函数做一些统一的设计。</li><li>函数声明现在的角色是类的方法。类的成员变量的声明和普通变量声明在语法上没什么区别。</li></ul><blockquote><p>如何在内存里管理对象的数据</p></blockquote><p>把对象的数据像其他数据一样，保存在栈</p><blockquote><p>访问对象的属性和方法</p></blockquote><p>点操作符来</p><h2 id="闭包：-理解了原理，它就不反直觉了"><a href="#闭包：-理解了原理，它就不反直觉了" class="headerlink" title="闭包： 理解了原理，它就不反直觉了"></a>闭包： 理解了原理，它就不反直觉了</h2><p>对于初学者来讲是一个挑战。其实，闭包就是把函数在静态作用域中所访问的变量的生存期拉长，形成一份可以由这个函数单独访问的数据。正因为这些数据只能被闭包函数访问，所以也就具备了对信息进行封装、隐藏内部细节的特性。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h3 id="如何建立一个完善的类型系统？"><a href="#如何建立一个完善的类型系统？" class="headerlink" title="如何建立一个完善的类型系统？"></a>如何建立一个完善的类型系统？</h3><ul><li><code>静态类型语言</code>: 全部或者几乎全部的类型检查是在编译期进行的</li><li><code>动态类型语言</code>: 类型的检查是在运行期进行的</li><li><code>强类型语言</code>: 变量的类型一旦声明就不能改变</li><li><code>弱类型语言</code>: 变量类型在运行期时可以改变</li></ul><p>如何做类型检查、类型推导和类型转换</p><ul><li>类型推导（Type Inference）</li><li>类型检查（Type Checking）<ul><li>赋值语句（检查赋值操作左边和右边的类型是否匹配）</li><li>变量声明语句（因为变量声明语句中也会有初始化部分，所以也需要类型匹配）</li><li>函数传参（调用函数的时候，传入的参数要符合形参的要求）</li><li>函数返回值（从函数中返回一个值的时候，要符合函数返回值的规定）。</li></ul></li><li>类型转换（Type Conversion）</li></ul><h3 id="如何做上下文相关情况的处理？"><a href="#如何做上下文相关情况的处理？" class="headerlink" title="如何做上下文相关情况的处理？"></a>如何做上下文相关情况的处理？</h3><p><code>语义分析的本质，就是针对上下文相关的情况做处理。</code></p><h4 id="语义分析场景：引用的消解"><a href="#语义分析场景：引用的消解" class="headerlink" title="语义分析场景：引用的消解"></a>语义分析场景：引用的消解</h4><h4 id="语义分析场景：左值和右值"><a href="#语义分析场景：左值和右值" class="headerlink" title="语义分析场景：左值和右值"></a>语义分析场景：左值和右值</h4><ul><li><code>左值（L-value）</code>：最早是在 C 语言中提出的，通常出现在表达式的左边，如赋值语句的左边。左值取的是变量的地址（或者说变量的引用），获得地址以后，我们就可以把新值写进去了。</li><li><code>右值（R-value）</code>：通常所说的值，不是地址。</li></ul><p>语义分析过程</p><ol><li>类型和作用域解析（TypeAndScopeScanner.java）</li><li>类型的消解（TypeResolver.java</li><li>引用的消解和 S 属性的类型的推导（RefResolver.java）</li><li>做类型检查（TypeChecker.java）</li><li>做一些语义合法性的检查（SematicValidator.java）</li></ol><h2 id="继承和多态：面向对象运行期的动态特性"><a href="#继承和多态：面向对象运行期的动态特性" class="headerlink" title="继承和多态：面向对象运行期的动态特性"></a>继承和多态：面向对象运行期的动态特性</h2><p>从类型体系的角度理解继承和多态</p><ul><li><code>继承</code>: 一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的。</li><li><code>多态</code>: 同一个类的不同子类，在调用同一个方法时会执行不同的动作。</li></ul><p><code>子类型</code>:  is-a 的操作</p><ul><li>名义子类型（Nominal Subtyping）<ul><li>像 Java 和 C++ 语言，需要显式声明继承了什么类，或者实现了什么接口</li></ul></li><li>结构化子类型（Structural Subtyping），又叫鸭子类型（Duck Type）<ul><li>一个类不需要显式地说自己是什么类型，只要它实现了某个类型的所有方法，那就属于这个类型</li></ul></li></ul><p>如何对继承和多态的特性做语义分析</p><ol><li>识别出新的类型</li><li>设置正确的作用域</li><li>变量和函数做类型的引用消解</li></ol><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol><li>从类型的角度，面向对象的继承和多态是一种叫做子类型的现象，子类型能够放宽对类型的检查，从而支持多态。</li><li>在编译期，无法准确地完成对象方法和属性的消解，因为无法确切知道对象的子类型。在运行期，我们能够获得对象的确切的子类型信息，从而绑定正确的方法和属性，实现继承和多态。</li><li>另一个需要注意的运行期的特征，是对象的逐级初始化过程。</li></ol><p>参考：<a href="https://time.geekbang.org/column/intro/219" target="_blank" rel="noopener">编译原理之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/14/Construction/Compiler.jpg&quot; class=&quot;&quot; title=&quot;宫文学- 编译原理&quot;&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://2020.iosdevlog.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Compiler" scheme="https://2020.iosdevlog.com/tags/Compiler/"/>
    
      <category term="Construction" scheme="https://2020.iosdevlog.com/tags/Construction/"/>
    
  </entry>
  
  <entry>
    <title>为什么你要学习编译原理？</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/Compiler-Construction/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/Compiler-Construction/</id>
    <published>2020-01-13T14:14:34.000Z</published>
    <updated>2020-01-14T09:26:03.548Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/13/Compiler-Construction/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E.jpg" class="" title="宫文学-《编译原理之美》"><a id="more"></a><p>编译技术并不难学</p><blockquote><p>“我知道编译技术很重要，我也很想把它啃下，可是我每次鼓起勇气拿起《编译原理》，啃不了多少页就放下了。编译原理已经成了我的心魔……”</p></blockquote><ul><li>具体的案例带你理解抽象的原理</li><li>真正运用到编译技术<ul><li>实现一门脚本语言<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>实现一门编译型语言<ul><li>目标代码生成</li><li>代码优化</li></ul></li><li>面向未来的编程语言<ul><li>人工智能编程</li><li>云编程的新模式</li></ul></li></ul></li></ul><p>参考：<a href="https://time.geekbang.org/column/intro/219" target="_blank" rel="noopener">编译原理之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/13/Compiler-Construction/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E.jpg&quot; class=&quot;&quot; title=&quot;宫文学-《编译原理之美》&quot;&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://2020.iosdevlog.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Compiler" scheme="https://2020.iosdevlog.com/tags/Compiler/"/>
    
      <category term="Construction" scheme="https://2020.iosdevlog.com/tags/Construction/"/>
    
  </entry>
  
  <entry>
    <title>《只差一个谎言》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/9787544261678/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/9787544261678/</id>
    <published>2020-01-13T07:00:45.000Z</published>
    <updated>2020-01-15T04:13:46.267Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/13/9787544261678/9787544261678.png" class="" title="东野圭吾-《只差一个谎言》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 南海出版公司<br>副标题: 加贺探案集6<br>原作名: 嘘をもうひとつだけ<br>译者: 黄真<br>出版年: 2013-4<br>页数: 198<br>定价: 25.00元<br>装帧: 平装<br>丛书: 加贺探案集<br>ISBN: 9787544261678</p><img src="/2020/01/13/9787544261678/9787544261678-2.png" class="" title="东野圭吾-《只差一个谎言》">]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/13/9787544261678/9787544261678.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《只差一个谎言》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="加贺恭一郎系列" scheme="https://2020.iosdevlog.com/tags/%E5%8A%A0%E8%B4%BA%E6%81%AD%E4%B8%80%E9%83%8E%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《名侦探的守则》</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/9787544246873/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/9787544246873/</id>
    <published>2020-01-13T06:43:07.000Z</published>
    <updated>2020-01-13T06:58:49.503Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/zh/2/22/Wrules.jpg" alt="名侦探的守则"></p><a id="more"></a><p>作者: (日) 东野圭吾<br>出版社: 南海出版公司<br>副标题: 东野圭吾作品09<br>原作名: 名探偵の掟<br>译者: 岳远坤<br>出版年: 2010-4<br>页数: 240<br>定价: 22<br>装帧: 平装<br>丛书: 新经典文库·东野圭吾作品<br>ISBN: 9787544246873</p><p><strong>感觉是《名侦探柯南》里面的 <code>毛利小五郎</code> 在吐槽。</strong></p><h2 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h2><ul><li>天下一 大五郎（天下一てんかいち 大五郎だいごろう，Tenkaichi Daigorou）<ul><li>自认“头脑清晰、博学多才、行动力拔群的名侦探”。大河原警部似乎对他有敬而远之的感觉，但在舞台背后会和从作品世界抽离角色的警部一起讨论推理小说的问题点。如果对案件有不明白的地方，会悄悄从大河原警部那里获得提示。因为某个案件而对大型密室感到厌恶。</li></ul></li><li>大河原 番三（大河原おおがわら 番三ばんぞう，Oogawara Banzou） 县警搜查一课警部，42岁。<ul><li>一直饰演和名侦探天下一相对的、在推理小说中必定出现的蹩脚警部。但实际上他会比天下一更早解决案件，但故意装出怀疑并非真凶的嫌疑人的样子。在《名侦探的诅咒》中也有出场。</li></ul></li></ul><p>推理小说的核心在于解谜，解谜的真髓在于逻辑，逻辑的对象则在于诡计。</p><p>迄今涌现的无数大师终其一生都在想一个问题：如何写出千古奇绝的诡计？</p><p>密室之谜、不在场证明、叙述性诡计、童谣杀人、死亡密码、暴风雪山庄、消失的凶器……所有推理模式都已被人写尽，推理世界还剩下什么？当真一定要扑朔迷离、峰回路转、异想天开，才能令人感到刺激有趣？</p><p>一部由东野圭吾系统“研究”诡计的作品，一部开拓推理小说疆域的作品，整理种种可能，道出种种不能，涉及诡计之广、意外之深，无不令人瞠目……</p><p>《名侦探的守则》以幽默讽刺的口吻，解构本格推理小说创作模式，将历来耳熟能详的诡计与作案手法彻底颠覆，别出心裁令人击节赞叹，用心良苦让人掩卷深思。正如作家自己所述：“我想要读者大吃一惊，才无视所有小说的套路……”</p><blockquote><p>我个人实在是不太能明白，身为现代的作家，究竟为什么还要去写诸如金田一耕助那种带着复古风的推理小说？ </p></blockquote><p>——东野圭吾</p><blockquote><p>年轻的我们，重复过去的大师们历经思考所编织的各种诡计与模式，真的有意义吗？就创作者来说，是否是一种投机取巧？</p></blockquote><p>——东野圭吾</p><blockquote><p>当我带着批判讽刺的意念，着手写出了《名侦探的守则》最早的短篇时，万万没有想到会意外得到周遭如此的好评。</p></blockquote><p>——东野圭吾</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/zh/2/22/Wrules.jpg&quot; alt=&quot;名侦探的守则&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="天下一大五郎系列" scheme="https://2020.iosdevlog.com/tags/%E5%A4%A9%E4%B8%8B%E4%B8%80%E5%A4%A7%E4%BA%94%E9%83%8E%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《红手指》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/9787544255899/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/9787544255899/</id>
    <published>2020-01-13T02:54:16.000Z</published>
    <updated>2020-01-15T04:13:46.257Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/13/9787544255899/9787544255899.png" class="" title="东野圭吾-《红手指》"><a id="more"></a><p>作者: [日] 东野圭吾<br>出版社: 南海出版公司<br>出品方: 新经典文化<br>副标题: 加贺探案集07<br>原作名: 赤い指<br>译者: 于壮<br>出版年: 2011-10<br>页数: 211<br>定价: 25.00元<br>装帧: 平装<br>丛书: 加贺探案集<br>ISBN: 9787544255899</p><blockquote><p>养不教，父之过。</p><p>教不严，师之惰。</p><p>子不学，非所宜。</p><p>幼不学，老何为。</p></blockquote><p>–三字经</p><p><code>逃避</code> 并不能解决问题。</p><p>小的过错不及及时纠正，只会引来无法挽回的过错。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/13/9787544255899/9787544255899.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《红手指》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="加贺恭一郎系列" scheme="https://2020.iosdevlog.com/tags/%E5%8A%A0%E8%B4%BA%E6%81%AD%E4%B8%80%E9%83%8E%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《麒麟之翼》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/9787544266161/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/9787544266161/</id>
    <published>2020-01-13T02:41:51.000Z</published>
    <updated>2020-01-15T04:13:46.266Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/13/9787544266161/9787544266161.png" class="" title="东野圭吾-《麒麟之翼》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 南海出版公司<br>副标题: 加贺探案集9<br>原作名: 麒麟の翼<br>译者: 田秀娟<br>出版年: 2013-8-1<br>页数: 288<br>定价: 33<br>装帧: 平装<br>丛书: 加贺探案集<br>ISBN: 9787544266161</p><p>“够了！说什么不想伤害孩子。你根本不明白自己做错了什么！杉野刺杀了青柳先生之后，为什么不自首？你知道吗？就是因为你把他教错了！即使 <code>犯了错误，也能蒙混过关</code> ——这就是三年前你教给他们的。所以，杉野会做相同的事情，会<code>犯相同的错误</code>。而青柳先生，看到自己的儿子如此误入歧途，他想告诉儿子什么才是正确的。你如果连这点都不明白，就别当老师！你这样的人，根本没有资格教育别人！”</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/13/9787544266161/9787544266161.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《麒麟之翼》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="加贺恭一郎系列" scheme="https://2020.iosdevlog.com/tags/%E5%8A%A0%E8%B4%BA%E6%81%AD%E4%B8%80%E9%83%8E%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《祈祷落幕时》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/12/9787544274692/"/>
    <id>https://2020.iosdevlog.com/2020/01/12/9787544274692/</id>
    <published>2020-01-12T13:02:40.000Z</published>
    <updated>2020-01-15T04:13:46.267Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/12/9787544274692/9787544274692.png" class="" title="东野圭吾-《祈祷落幕时》"><a id="more"></a><p>祈祷落幕时 </p><p>作者: (日)东野圭吾<br>出版社: 南海出版公司<br>原作名: 祈りの幕が下りる时<br>译者: 代珂<br>出版年: 2015-1<br>页数: 296<br>定价: 39.50元<br>装帧: 精装<br>丛书: 新经典文库·东野圭吾作品<br>ISBN: 9787544274692</p><p>两个离异家庭，一个父亲为了女儿，杀了两个无辜的人。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/12/9787544274692/9787544274692.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《祈祷落幕时》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="加贺恭一郎系列" scheme="https://2020.iosdevlog.com/tags/%E5%8A%A0%E8%B4%BA%E6%81%AD%E4%B8%80%E9%83%8E%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>游戏热点剖析</title>
    <link href="https://2020.iosdevlog.com/2020/01/12/hot/"/>
    <id>https://2020.iosdevlog.com/2020/01/12/hot/</id>
    <published>2020-01-12T12:57:16.000Z</published>
    <updated>2020-01-12T14:08:47.826Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/12/hot/%E5%BC%95%E6%93%8E.jpg" class="" title="引擎"><a id="more"></a><h2 id="HTML5技术是如何取代Flash的？"><a href="#HTML5技术是如何取代Flash的？" class="headerlink" title="HTML5技术是如何取代Flash的？"></a>HTML5技术是如何取代Flash的？</h2><ul><li>H5 游戏拥有比 Flash 更好用更开放的规范，开发和发布也更方便，修改代码后放到网上，只需要刷新一下页面就可以看到修改的内容</li><li>另外，Flash 技术需要安装一个插件，而 H5 技术直接在浏览器就可以呈现。所以 H5 技术完全替代 Flash 只是时间问题</li></ul><h2 id="如何选择一款HTML5引擎？"><a href="#如何选择一款HTML5引擎？" class="headerlink" title="如何选择一款HTML5引擎？"></a>如何选择一款HTML5引擎？</h2><ul><li>如果美术熟悉 Cocos2d-JS，或者想要快速上手 2D 游戏，可以选择 Cocos2d-JS</li><li>如果对编程不太熟练，可以选择 Construct 2</li><li>如果是拥有完整流程的开发公司，Cocos2d-JS 和白鹭都可以选择</li></ul><h2 id="试试看，你也可以编写一款HTML5小游戏！"><a href="#试试看，你也可以编写一款HTML5小游戏！" class="headerlink" title="试试看，你也可以编写一款HTML5小游戏！"></a>试试看，你也可以编写一款HTML5小游戏！</h2><p><code>lufylegend</code></p><h2 id="安卓端和苹果端游戏开发有什么区别？"><a href="#安卓端和苹果端游戏开发有什么区别？" class="headerlink" title="安卓端和苹果端游戏开发有什么区别？"></a>安卓端和苹果端游戏开发有什么区别？</h2><ul><li>从游戏角度讲，手机、掌上游戏机、iPad 都属于移动端设备。而进入智能机时代之后，掌上游戏机逐渐退居幕后，成为少部分游戏发烧友的选择。</li><li>安卓端和苹果端在开发游戏中的区别，主要体现在开发语言上。苹果系统大量使用 Objective-C、Swift，而安卓大量使用的是 Java。</li><li>苹果端的比较流行的引擎 SpriteKit 以及适用于各种平台的 libGDX。使用 libGDX 在各个平台编写出的游戏，表现几乎是一样的，除了执行效率或者耗电水平会有细微的差别，但这和引擎其实关系不大。</li></ul><h2 id="如何选择移动端的游戏引擎？"><a href="#如何选择移动端的游戏引擎？" class="headerlink" title="如何选择移动端的游戏引擎？"></a>如何选择移动端的游戏引擎？</h2><p>我决定用 Godot。</p><h2 id="AR和人工智能在游戏领域有哪些应用？"><a href="#AR和人工智能在游戏领域有哪些应用？" class="headerlink" title="AR和人工智能在游戏领域有哪些应用？"></a>AR和人工智能在游戏领域有哪些应用？</h2><ul><li><code>VR</code>：虚拟现实（Virual Reality ）</li><li><code>AR</code>：增强现实（Augmented Reality）</li><li><code>MR</code>：混合现实（Mixed Reality）</li><li><code>SLAM</code>：同时定位与映射（Simultaneously Localization And Mapping）</li></ul><h2 id="谈谈微信小游戏的成功点"><a href="#谈谈微信小游戏的成功点" class="headerlink" title="谈谈微信小游戏的成功点"></a>谈谈微信小游戏的成功点</h2><ul><li>微信小游戏、小程序都是基于 HTML5 技术的，而微信小游戏的技术就是 HTML5 技术，只是在小游戏中运用的框架并不是普通的 HTML5 的框架。</li><li>微信小程序用的是基于 WebView 的技术；小游戏却没有用到 WebView 技术，而是修改了 HTML5 规范的一些接口内容，成为腾讯自己的内容。</li><li>微信平台之所以要自定义自己的一套体系，比如 Web 标准、开发标准等等，是因为可以结合微信本身的特性，在此基础上制作出更契合腾讯生态的产品，一句话就是，为了方便自己开发、优化和管理。</li><li>微信小游戏基于微信的底层获取功能、广告接入优势和打击拷贝的能力，塑造了一个更好的微信小程序生态。</li></ul><h2 id="谈谈移动游戏的未来发展"><a href="#谈谈移动游戏的未来发展" class="headerlink" title="谈谈移动游戏的未来发展"></a>谈谈移动游戏的未来发展</h2><ul><li>移动端游戏将往更加精品、高画质、高品位的游戏转型。3D、VR、AR 等游戏也会层出不穷，移动端和大屏幕之间的阻隔也会逐渐模糊，两边都可以互相游戏。</li><li>如果摆脱了电池的掣肘，那么移动端游戏将往 PC 端游戏的方向发展，更高质量的 3D 游戏也不用担心电池耗尽而半途无法玩了。</li></ul><h2 id="谈谈独立开发者的未来发展"><a href="#谈谈独立开发者的未来发展" class="headerlink" title="谈谈独立开发者的未来发展"></a>谈谈独立开发者的未来发展</h2><p>职责</p><ul><li><p>策划</p></li><li><p>美工</p></li><li><p>原画</p></li><li><p>推广</p></li><li><p>DOS 时代的时候，一个人或者一个小团队就可以做出一款游戏，但是这种时代已经过去了。游戏开发难度变小了，但是游戏制作难度变得越来越大了。</p></li><li><p>尽管 Steam 依旧是目前最大的发布平台，但是由于它本身没有对上架的游戏进行分类、整理，有选择的展示。对独立开发者其实是不利的。加上 Switch、XBOX 等主机游戏相继都推出了自己的独立游戏计划，我其实更看好主机游戏的发展。</p></li><li><p>其实不管基于什么平台，把游戏本身做好，才是最重要的。</p></li></ul><p>参考：<a href="https://time.geekbang.org/column/intro/87" target="_blank" rel="noopener">从0开始学游戏开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/12/hot/%E5%BC%95%E6%93%8E.jpg&quot; class=&quot;&quot; title=&quot;引擎&quot;&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="热点" scheme="https://2020.iosdevlog.com/tags/%E7%83%AD%E7%82%B9/"/>
    
      <category term="AR" scheme="https://2020.iosdevlog.com/tags/AR/"/>
    
      <category term="VR" scheme="https://2020.iosdevlog.com/tags/VR/"/>
    
  </entry>
  
  <entry>
    <title>服务器开发</title>
    <link href="https://2020.iosdevlog.com/2020/01/11/Server-Development/"/>
    <id>https://2020.iosdevlog.com/2020/01/11/Server-Development/</id>
    <published>2020-01-11T10:51:36.000Z</published>
    <updated>2020-01-11T11:34:19.052Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-01.png" alt="2020/01/01"></p><a id="more"></a><h2 id="如何选择合适的开发语言？"><a href="#如何选择合适的开发语言？" class="headerlink" title="如何选择合适的开发语言？"></a>如何选择合适的开发语言？</h2><ol><li>系统级编程语言，诸如汇编、C、C++<ul><li>这种编程语言执行效率快，并发量也比较高，作为编写网络服务的第一语言，一台服务器就能支撑许多人。缺点是开发效率不够高，需要几年以上经验的程序员才能搞定。</li></ul></li><li>专门为网络服务器开发的语言，诸如 Go、Erlang<ul><li>这种语言编写高并发和开发效率都不是问题，有很好的折中效果。缺点就是语言比较新，有许多的坑等着后来的程序员去填，而且语言、语法等系统机制要随着进一步的发展才能稳定下来。</li></ul></li><li>解释型脚本语言，诸如 Python、Ruby。<ul><li>这类语言的开发效率非常高效，在现在的服务器硬件上，也能支撑不少用户，但是唯一的缺点是，运行效率低下。虽然也有解决方案，但仍然不能对抗高性能的系统编程语言和专业网络开发的语言。如何选择一种合适的语言来编写网络服务？</li></ul></li></ol><h3 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h3><ul><li>Web 服务</li><li>Socket 服务</li><li>混合模式</li></ul><h2 id="如何定制合适的开发协议？"><a href="#如何定制合适的开发协议？" class="headerlink" title="如何定制合适的开发协议？"></a>如何定制合适的开发协议？</h2><p><code>一种客户端和服务器端的网络沟通协议（Protocol）。</code></p><h3 id="三种最流行的开发协议"><a href="#三种最流行的开发协议" class="headerlink" title="三种最流行的开发协议"></a>三种最流行的开发协议</h3><ol><li>XML<ol><li>PULL 方式：专门为安卓设备解析 XML 文件设计的解析方式</li><li>SAX 方式：SAX（Simple API for XML）采用事件驱动型方式</li><li>DOM 方式：DOM（Document Object Model）是最传统的解析方式</li></ol></li><li>JSON</li><li>ProtoBuf<ol><li>Google Protocol Buffer</li><li>ProtoBuf 适合用作数据存储或 RPC 数据交换格式，缺点是保存比较麻烦，但是总体来讲还是比较方便的</li></ol></li></ol><h3 id="自己定义协议"><a href="#自己定义协议" class="headerlink" title="自己定义协议"></a>自己定义协议</h3><p>自己定义协议包需要考虑完整性和安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议头][协议体][协议结尾分隔符]</span><br></pre></td></tr></table></figure><p>接收方需要知道协议的长度，或者知道协议的尾部在哪里，就可以保证协议包的完整性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议长度2字节][协议体]</span><br></pre></td></tr></table></figure><p>而最直接的给协议包加密，就可以保证安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议长度2字节][加密协议体]</span><br></pre></td></tr></table></figure><h2 id="不可忽视的多线程及并发问题"><a href="#不可忽视的多线程及并发问题" class="headerlink" title="不可忽视的多线程及并发问题"></a>不可忽视的多线程及并发问题</h2><ol><li><code>并发</code> 是单个 CPU 之间切换多线程任务的操作</li><li><code>并行</code> 是多个 CPU 同时分配和运行多线程任务的操作</li><li><code>线程</code> 是进程内的独立任务单元，但是共享这个进程的所有资源</li></ol><h2 id="如何判断心跳包是否离线？"><a href="#如何判断心跳包是否离线？" class="headerlink" title="如何判断心跳包是否离线？"></a>如何判断心跳包是否离线？</h2><ol><li>判断非阻塞模型的网络是否断开，可以使用心跳包和计算超时的方式进行断开操作，比如 30 秒没收到心跳包，则可以强制关闭 Socket 句柄断开。</li><li>心跳包是一种服务器之间交互的方法，也可以用作服务器数据调试和回滚的策略方案。</li><li>心跳包有两种策略<ol><li>第一种就是运算时间 A 和心跳时间 B 相对固定</li><li>第二种策略是运算时间 A 和心跳时间 B 是实时调整</li></ol></li></ol><p>CPU 的负载很高的时候用策略一，CPU 负载并不是那么严重的情况下，策略二是比较好的选择。</p><h2 id="如何用网关服务器进行负载均衡？"><a href="#如何用网关服务器进行负载均衡？" class="headerlink" title="如何用网关服务器进行负载均衡？"></a>如何用网关服务器进行负载均衡？</h2><p>两种常用的负载均衡技术</p><h3 id="软件模式"><a href="#软件模式" class="headerlink" title="软件模式"></a>软件模式</h3><p>LVS、Nginx、HAProxy。</p><ul><li>LVS 是四层负载均衡，根据目标地址和端口选择内部服务器</li><li>Nginx 这种负载均衡工具是七层负载均衡</li><li>而 HAProxy 同时支持四层、七层负载均衡，还可以根据报文内容选择内部服务器</li></ul><p>因此，LVS 分发路径优于 Nginx 和 HAProxy，性能上也要高些。但 Nginx 和 HAProxy 则更具配置性，比如说可以用来做动静分离。</p><p>所谓动静分离，就是根据请求协议的特征，去选择静态资源服务器还是应用服务器。</p><h3 id="硬件模式"><a href="#硬件模式" class="headerlink" title="硬件模式"></a>硬件模式</h3><p>其中，硬件模式用得比较多的是 F5。</p><p>F5 是 F5 Networks 公司提供的一个负载均衡器专用设备， F5 BIG-IP LTM 的官方名称叫本地流量管理器，可以做 4～7 层负载均衡，具有负载均衡、应用交换、会话交换、状态监控等等全备的强大网络功能。</p><p>F5 硬件负载均衡的优点是，负载均衡能直接通过智能交换机实现, 处理能力更强，与操作系统无关，负载性能强，适用于一大堆设备、大访问量，其缺点也是很明显的，那就是购买成本高，设备的配置冗余，有些用不上的都给默认配置了。</p><p>另外，由于设备只有单个，所以单个负载均衡配置无法有效掌握所有服务器及应用状态。硬件的负载均衡，是从网络层来判断负载规则，所以有时候软件的系统处理能力出现问题，网络硬件还可以作出负载的动作。</p><h3 id="网关服务器有哪些功能？"><a href="#网关服务器有哪些功能？" class="headerlink" title="网关服务器有哪些功能？"></a>网关服务器有哪些功能？</h3><ol><li>中转功能</li><li>负载均衡</li></ol><h2 id="如何制作游戏内容保存和缓存处理？"><a href="#如何制作游戏内容保存和缓存处理？" class="headerlink" title="如何制作游戏内容保存和缓存处理？"></a>如何制作游戏内容保存和缓存处理？</h2><p>Redis 不仅是内存缓存</p><p>Redis 是一种 <code>key-value</code> 型的存储系统。它支持存储的 value 类型很多，包括字符串、链表、集合、有序集合和哈希类型。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都具有原子性。</p><ul><li>Redis 不仅仅可以用作普通的缓存机制使用，也可以当作正常的数据库使用，Redis 也支持主从同步，要按照应用场景不同来配置不同的 Redis 使用场景。</li><li>缓存机制不仅仅针对读取游戏保存文件这么一种方案，也可以用作各种数据文件的读取和写入操作。</li><li>使用现成的 Redis 等缓存数据软件，是一个好的方案。<br>而设计好的框架、好的缓存机制、好的网络模型，是一款好网游必不可少的条件。</li></ul><p>参考：<a href="https://time.geekbang.org/column/intro/87" target="_blank" rel="noopener">从0开始学游戏开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-01.png&quot; alt=&quot;2020/01/01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>Lua 脚本语言</title>
    <link href="https://2020.iosdevlog.com/2020/01/10/Script-Language/"/>
    <id>https://2020.iosdevlog.com/2020/01/10/Script-Language/</id>
    <published>2020-01-10T11:07:54.000Z</published>
    <updated>2020-01-10T11:47:37.654Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Lua-logo-nolabel.svg/1200px-Lua-logo-nolabel.svg.png" alt="Lua"></p><a id="more"></a><h2 id="如何嵌入脚本语言"><a href="#如何嵌入脚本语言" class="headerlink" title="如何嵌入脚本语言?"></a>如何嵌入脚本语言?</h2><ol><li>因为 <code>Lua</code> 脚本足够轻量级，几乎没有冗余的代码。Lua 虚拟机的执行效率几乎可以媲美 C/C++ 的执行效率。所以我们选择使用 Lua 脚本来嵌入 C/C++ 硬代码。</li><li>Lua 脚本在 C/C++ 语言里面嵌入，需要先声明一个虚拟机并且赋值给指针。</li><li>Lua 脚本需要先 loadfile 再 pcall 调用脚本文件，loadfile 会检查最基本的脚本文件内容，比如文件是否存在，比如脚本代码是否出错，而 pcall 会在运行时出错的时候将错误压至栈顶。</li><li>Lua 错误会将错误压制栈顶，我们要取出来，需要使用 -1 下标取出栈顶的内容，并转成 string 打印。</li></ol><h2 id="脚本语言在游戏开发中有哪些应用？"><a href="#脚本语言在游戏开发中有哪些应用？" class="headerlink" title="脚本语言在游戏开发中有哪些应用？"></a>脚本语言在游戏开发中有哪些应用？</h2><ul><li>在 Lua 与 C 的结合过程中，C 语言需要新建一个 Lua 虚拟机，然后使用虚拟机的指针来操作 Lua 函数。</li><li>在程序的应用中，使用 C 语言中的一些宏的技巧，可以使代码能够便利地应用在程序里。</li></ul><h2 id="如何使用脚本语言编写周边工具？"><a href="#如何使用脚本语言编写周边工具？" class="headerlink" title="如何使用脚本语言编写周边工具？"></a>如何使用脚本语言编写周边工具？</h2><ol><li><code>利用 C/C++ 语言和 Lua 源代码进行交互，从 Lua 代码中获取数据并且在 C 语言里面进行算法的封装和计算，最后将结果返回给 Lua。</code>我们在 C/C++ 语言里面进行大量的封装和算法提取，并且也利用 C/C++ 进行调用和结果的呈现，这是一种常用的方式，也就是 C 语言占比 60%～70%，Lua 代码占比 30%～40%。</li><li>另一种比较好的方式是，<code>使用 C/C++ 编写底层实现逻辑，随后将数据传输给 Lua，让 Lua 来做逻辑运算，最终将结果返回给 C 语言并且呈现出来。</code>这是很多人在游戏开发中都会做的事情，比如我们编写地图编辑器，先在 Lua 中编写好逻辑，用 C 语言在界面中呈现出来即可。如果反过来做的话，那就会出现大量的硬代码，是很不合适的。所以这种情况下，C 语言占比 30%～40%，Lua 代码占比 60%～70%。</li><li><code>Lua 可以是一种胶水语言。严谨地说，像 Python、Ruby 等脚本语言，都是合格的胶水语言。</code> 在这种情况下，胶水语言起到的作用就是粘合系统语言（C/C++）和上层脚本逻辑。所以，使用胶水语言，就像是一种动态的配置文件。按照普通的配置文件来讲，你需要手工解析比如类似 INI、XML、JSON 等配置文件，随后按照这些文件的内容来做出一系列的配置，但是胶水语言不需要，它本身就是一种动态的语言。</li></ol><p>参考：<a href="https://time.geekbang.org/column/intro/87" target="_blank" rel="noopener">从0开始学游戏开发</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Lua-logo-nolabel.svg/1200px-Lua-logo-nolabel.svg.png&quot; alt=&quot;Lua&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Language" scheme="https://2020.iosdevlog.com/tags/Language/"/>
    
      <category term="Lua" scheme="https://2020.iosdevlog.com/tags/Lua/"/>
    
  </entry>
  
</feed>
