<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-04-15T14:08:43.506Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub 组织也可以免费创建私有仓库</title>
    <link href="https://2020.iosdevlog.com/2020/04/15/github/"/>
    <id>https://2020.iosdevlog.com/2020/04/15/github/</id>
    <published>2020-04-15T13:49:49.000Z</published>
    <updated>2020-04-15T14:08:43.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/15/github/github.png" /></p><p>2019 年 GitHub 用户可以免费创建私有仓库，组织不行。</p><p>从今天开始，组织也可以免费创建私有仓库。</p><a id="more"></a><p>订阅 GitHub 邮件的都应该收到以 2 封邮件。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_2.png" /></p><p>GitHub 将永久性对用户和团队免费开放私有仓库的使用，并且不限制项目协作人数。</p><p>同时 GitHub 上当前拥有的一些核心功能，也将对所有人免费开放，以便开发者可以更好的使用 GitHub 来进行日常团队协作，无需再受价格阻碍。</p><p>每个项目的团队人员，现在可以在 GitHub 上自由使用 CI/CD，项目管理，代码审查，软件包管理等日常项目开发工作。</p><p>打开 GitHub，从主页也可以看到提示。</p><p>点击查看 <a href="https://github.blog/2020-04-14-github-is-now-free-for-teams/" target="_blank" rel="noopener" class="uri">https://github.blog/2020-04-14-github-is-now-free-for-teams/</a>。</p><p>拿组织 <a href="https://github.com/iOSDevLog" target="_blank" rel="noopener">iOSDevLog</a> 测试一下。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/new.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/assets.png" /></p><p>确定可以创建私有仓库了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/15/github/github.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2019 年 GitHub 用户可以免费创建私有仓库，组织不行。&lt;/p&gt;
&lt;p&gt;从今天开始，组织也可以免费创建私有仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://2020.iosdevlog.com/categories/github/"/>
    
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
      <category term="git" scheme="https://2020.iosdevlog.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://2020.iosdevlog.com/2020/04/13/network/"/>
    <id>https://2020.iosdevlog.com/2020/04/13/network/</id>
    <published>2020-04-12T16:27:21.000Z</published>
    <updated>2020-04-14T17:04:41.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png" /></p><p>维基百科<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener" title="TCP/IP协议族">网际网路协议套组</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener" title="应用层">应用层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Border_Gateway_Protocol" target="_blank" rel="noopener" title="Border Gateway Protocol">BGP</a></li><li><a href="https://zh.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener" title="Dynamic Host Configuration Protocol">DHCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener" title="Domain Name System">DNS</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="档案传输协定">FTP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="超文本传输协议">HTTP</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener" title="HTTPS">HTTPS</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Message_Access_Protocol" target="_blank" rel="noopener" title="Internet Message Access Protocol">IMAP</a></li><li><a href="https://zh.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener" title="Lightweight Directory Access Protocol">LDAP</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%AA%92%E9%AB%94%E9%96%98%E9%81%93%E6%8E%A7%E5%88%B6%E5%8D%94%E5%AE%9A&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">MGCP</a></li><li><a href="https://zh.wikipedia.org/wiki/MQTT" target="_blank" rel="noopener" title="MQTT">MQTT</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_News_Transfer_Protocol" target="_blank" rel="noopener" title="Network News Transfer Protocol">NNTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener" title="Network Time Protocol">NTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Post_Office_Protocol" target="_blank" rel="noopener" title="Post Office Protocol">POP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call" target="_blank" rel="noopener" title="Open Network Computing Remote Procedure Call">ONC/RPC</a></li><li><a href="https://zh.wikipedia.org/wiki/Real-time_Transport_Protocol" target="_blank" rel="noopener" title="Real-time Transport Protocol">RTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Real_Time_Streaming_Protocol" target="_blank" rel="noopener" title="Real Time Streaming Protocol">RTSP</a></li><li><a href="https://zh.wikipedia.org/wiki/Routing_Information_Protocol" target="_blank" rel="noopener" title="Routing Information Protocol">RIP</a></li><li><a href="https://zh.wikipedia.org/wiki/Session_Initiation_Protocol" target="_blank" rel="noopener" title="Session Initiation Protocol">SIP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="简单邮件传输协议">SMTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_blank" rel="noopener" title="Simple Network Management Protocol">SNMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener" title="Secure Shell">SSH</a></li><li><a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener" title="Telnet">Telnet</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E4%B8%8E%E5%AD%98%E5%9C%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="可扩展消息与存在协议">XMPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:应用层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener" title="传输层">传输层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener" title="Transmission Control Protocol">TCP</a></li><li><a href="https://zh.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener" title="User Datagram Protocol">UDP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="传输层安全性协定">TLS／SSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol" target="_blank" rel="noopener" title="Datagram Congestion Control Protocol">DCCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Stream_Control_Transmission_Protocol" target="_blank" rel="noopener" title="Stream Control Transmission Protocol">SCTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Resource_Reservation_Protocol" target="_blank" rel="noopener" title="Resource Reservation Protocol">RSVP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:传输层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%B1%A4" target="_blank" rel="noopener" title="网络层">网路层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener" title="Internet Protocol">IP</a> <ul><li><a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener" title="IPv4">IPv4</a></li><li><a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener" title="IPv6">IPv6</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="noopener" title="Internet Control Message Protocol">ICMP</a></li><li><a href="https://zh.wikipedia.org/wiki/ICMPv6" target="_blank" rel="noopener" title="ICMPv6">ICMPv6</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E7%A2%BA%E6%93%81%E5%A1%9E%E9%80%9A%E7%9F%A5" target="_blank" rel="noopener" title="明确拥塞通知">ECN</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Group_Management_Protocol" target="_blank" rel="noopener" title="Internet Group Management Protocol">IGMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Shortest_Path_First" target="_blank" rel="noopener" title="Open Shortest Path First">OSPF</a></li><li><a href="https://zh.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener" title="IPsec">IPsec</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:网络层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%A3%E7%B5%90%E5%B1%A4&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">连结层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="noopener" title="Address Resolution Protocol">ARP</a></li><li><a href="https://zh.wikipedia.org/wiki/Neighbor_Discovery_Protocol" target="_blank" rel="noopener" title="Neighbor Discovery Protocol">NDP</a></li><li><a href="https://zh.wikipedia.org/wiki/Tunneling_protocol" target="_blank" rel="noopener" title="Tunneling protocol">Tunnels</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener" title="Layer 2 Tunneling Protocol">L2TP</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Point-to-Point_Protocol" target="_blank" rel="noopener" title="Point-to-Point Protocol">PPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Media_access_control" target="_blank" rel="noopener" title="Media access control">MAC</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Ethernet" target="_blank" rel="noopener" title="Ethernet">Ethernet</a></li><li><a href="https://zh.wikipedia.org/wiki/Digital_subscriber_line" target="_blank" rel="noopener" title="Digital subscriber line">DSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Integrated_Services_Digital_Network" target="_blank" rel="noopener" title="Integrated Services Digital Network">ISDN</a></li><li><a href="https://zh.wikipedia.org/wiki/Fiber_Distributed_Data_Interface" target="_blank" rel="noopener" title="Fiber Distributed Data Interface">FDDI</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:链路协议"><em>更多...</em></a></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/0.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/1.png" /></p><h2 id="网络分层的真实含义是什么2">网络分层的真实含义是什么?<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p><img src="https://2020.iosdevlog.com/2020/04/13/network/2.jpg" /></p><ol type="1"><li>始终想象自己是一个处理网络包的程序:<ul><li>如何拿到网络包，如何根据规则进行处理，如何发出去;</li></ul></li><li>始终牢记一个原则:<ul><li>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li></ul></li></ol><p>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然 是发不出去的。</p><h2 id="ifconfig">ifconfig</h2><ul><li>Windows<ul><li>ifconfig</li></ul></li><li>Linux<ul><li>net-tools<ul><li>ifconfig</li></ul></li><li>iproute2<ul><li>ip addr</li></ul></li></ul></li></ul><blockquote><p><code>IP 地址</code> 是一个网卡在网络世界的 <strong>通讯地址</strong>，相当于我们现实世界的门牌号码。</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/04/13/network/3.jpg" /></p><h3 id="无类型域间选路cidr">无类型域间选路(CIDR)</h3><p>于是有了一个折中的方式叫作无类型域间选路，简称 CIDR。</p><p>这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。</p><p><code>10.100.122.2/24</code>，这个 IP 地址中有一个 <em>斜杠</em>，斜杠后面有个数字 <code>24</code>。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><blockquote><p>MAC 地址更像是 <strong>身份证</strong>，是一个唯一的标识。</p></blockquote><h3 id="公有-ip-地址和私有-ip-地址">公有 IP 地址和私有 IP 地址</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/4.jpg" /></p><h3 id="排队规则qdisc-queueing-discipline">排队规则（qdisc， queueing discipline）</h3><ul><li>pfifo<ul><li>不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列</li></ul></li><li>pfifo_fast<ul><li>三个波段(band)</li><li>每个波段里面，使用先进先出规则</li><li>band 0 的优先级最高</li></ul></li></ul><p>数据包是按照服务类型(Type of Service，TOS)被分配多三个波段(band)里面的。<code>TOS</code> 是 IP 头里 面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><ul><li>IP 是地址，有定位功能</li><li>MAC 是身份证，无定位功能</li><li>CIDR 可以用来判断是不是本地人</li><li>IP 分公有的 IP 和私有的 IP</li></ul><h3 id="网络设备的状态标识net_device-flags">网络设备的状态标识（net_device flags）</h3><ul><li>UP：网卡处于启动的状态</li><li>BROADCAST：网卡有广播地址，可以发送广播包</li><li>MULTICAST：发送多播包</li><li>LOWER_UP： 网线插着，L1 是启动的</li><li>MTU （二层 MAC 层）1500：最大传输单元 MTU 为 1500，这是以太网的默认值</li></ul><h2 id="dhcp与pxe">DHCP与PXE</h2><p>如何配置 IP 地址</p><p><code>net-tools</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24 </span><br><span class="line">sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure><p><code>iproute2</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line">sudo ip link <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure><p>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发 送到网关。</p><p>配置文件</p><ol type="1"><li>CIDR（IP地址）</li><li>子网掩码</li><li>广播地址</li><li>网关地址</li></ol><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</p><ol type="1"><li>DHCP <strong>D</strong>iscover</li><li>DHCP <strong>O</strong>ffer</li><li>DHCP <strong>R</strong>equest</li><li>DHCP <strong>A</strong>ck</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/5.png" /></p><p>dhcp_protocol<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><h3 id="预启动执行环境preboot-execution-environment-pxe">预启动执行环境（Preboot Execution Environment / <strong>PXE</strong>)</h3><p>操作系统启动</p><ol type="1"><li>BIOS（Basic Input output System)</li><li>读取 MBR(Master Boot Record， 主引导记录)</li><li>启动 GRUB（GRand Unified Bootloader，多重操作系统启动管理器)</li><li>GRUB 加载内核，根文件系统 initramfs</li><li>启动内核</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/6.jpg" /></p><h2 id="从二层到三层">从二层到三层</h2><h3 id="第一层物理层">第一层：物理层</h3><h4 id="最小的局域网lan">最小的局域网（LAN）</h4><p>2 台电脑相连</p><ul><li>网线<ul><li>水晶头</li><li>1,2 收</li><li>3,6 发</li><li>需要 1和3，2和6 交换位置</li></ul></li></ul><h4 id="集线器-hub-广播模式">集线器 / Hub （广播模式）</h4><ul><li>多台电脑相连</li><li>完全复制</li></ul><h3 id="第二层数据链路层mac层-medium-access-control媒体访问控制">第二层：数据链路层（MAC）层 (Medium Access Control，媒体访问控制)</h3><ol type="1"><li>信道化分</li><li>轮流协议</li><li>随机接入协议<ul><li>以太网</li></ul></li></ol><p>第二层的网络包格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/7.jpg" /></p><h5 id="arp">ARP</h5><p>已知 IP 地址，求 MAC 地址的协议</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/8.jpg" /></p><p>报文</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/9.jpg" /></p><h4 id="交换机">交换机</h4><ul><li>转发表</li></ul><ol type="1"><li>MAC 层是用来解决多路访问的堵车问题的;</li><li>ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存;</li><li>交换机是有MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。</li></ol><h3 id="交换机与vlan">交换机与VLAN</h3><p>拓扑结构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/10.jpg" /></p><p>环路问题</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/11.jpg" /></p><p>STP 协议</p><p>在数据结构中，有一个方法叫做 <strong>最小生成树</strong>。有环的我们常称为 <strong>图</strong>。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作 <code>STP</code>，全称 <em>Spanning Tree Protocol</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/12.jpg" /></p><ul><li>Root Bridge，也就是根交换机。这个比较容易理解，可以比喻为“掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li><li>Designated Bridges，有的翻译为指定交换机。这个比较难理解，可以想像成一个“小弟”，对于树来说，就是一棵树的树枝。所谓“指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li><li>Bridge Protocol Data Units （BPDU） ，网桥协议数据单元。可以比喻为“相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU 只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li><li>Priority Vector，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看 Root Bridge ID。拿出老大的 ID 看看，发现掌门一样，那就是师兄弟；再比 Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比 Bridge ID，比我自己的 ID，拿自己的本事比。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/13.jpg" /></p><h3 id="虚拟局域网-vlan">虚拟局域网 (VLAN)</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/14.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/15.jpg" /></p><p>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</p><p>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</p><h3 id="icmp-与-ping">ICMP 与 ping</h3><p>ping 是基于 ICMP 协议工作的（查询报文）。</p><p>ICMP 全称 <strong>Internet Control Message Protocol</strong>，就是互联网控制报文协议。</p><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/16.jpg" /></p><p><code>查询报文</code></p><p>常用的 ping 就是 <strong>查询报文</strong>，是一种主动请求，并且获得主动应答的 ICMP 协议。</p><ul><li>对 ping 的主动请求，进行网络抓包，称为 ICMP ECHO REQUEST。</li><li>主动请求的回复，称为 ICMP ECHO REPLY。</li></ul><p>比起原生的 ICMP，这里面多了两个字段：</p><ul><li>一个是标识符</li><li>另一个是序号</li></ul><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><p><code>差错报文</code></p><ol type="1"><li>终点不可达<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达</li><li>端口不可达</li><li>需要进行分片但设置了不分片位</li></ul></li><li>源站抑制<ul><li>让源站放慢发送速度</li></ul></li><li>时间超时<ul><li>超过网络包的生存时间还是没到</li></ul></li><li>路由重定向<ul><li>让下次发给另一个路由器</li></ul></li></ol><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><p>而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。</p><p><code>ping</code>：查询报文类型的使用</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/17.jpg" /></p><p><code>Traceroute</code>：差错报文类型的使用</p><p>traceroute，现代 Linux系统 称为 tracepath，Windows系统称为 tracert，是一种电脑网络工具。它可显示封包在 IP 网络经过的路由器的 IP 地址。</p><p>它会使用 ICMP 的规则，故意制造一些能够产生错误的场景。</p><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</p><p>Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。</p><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。</p><p>ICMP 相当于网络世界的侦察兵。</p><p>两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文</p><ol type="1"><li>ping 使用查询报文</li><li>Traceroute 使用差错报文</li></ol><h3 id="网关">网关</h3><p>出入门</p><p>路由器会有内网网口和外网网口。</p><p>配置网卡</p><p>当然 DHCP 是可以默认配置的。在进行网卡配置的时候，除了 IP 地址，还需要配置一个 <code>Gateway</code> 的东西，这个就是 <code>网关</code>。</p><figure><img src="https://2020.iosdevlog.com/2020/04/13/network/18.jpg" alt="" /><figcaption>MAC 头和 IP 头</figcaption></figure><p>MAC 头</p><ol type="1"><li>目标 MAC 地址</li><li>源 MAC 地址</li><li>协议类型<ol type="1"><li>IP 协议<br />IP 头</li></ol></li><li>版本号： IPv4</li><li>服务类型 TOS (Type of Service)</li><li>TTL</li><li>协议<ol type="1"><li>TCP</li><li>UDP</li></ol></li><li>源 IP</li><li>目标 IP<ol type="1"><li>CIDR 和子网掩码</li><li>判断是否在同一网段<ol type="1"><li>同一个网段<ol type="1"><li>通过 ARP 获得 MAC 地址</li></ol></li><li>不是同一网段<ol start="2" type="1"><li>需要发往默认网关 Gateway</li></ol></li></ol></li></ol></li></ol><p>网关往往是一个 <code>路由器</code>，是一个 <code>三层</code> 转发的设备。</p><p>一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。</p><p>很多情况下，人们把网关就叫作路由器。</p><p>其实不完全准确。</p><p>路由器是一台设备。</p><h4 id="静态路由">静态路由</h4><p>MAC 地址是一个局域网内才有效的地址。</p><p>因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。</p><p>两者主要的区别在于 IP 地址是否改变。</p><ul><li>不改变 IP 地址的网关，称为 <code>转发网关</code>；</li></ul><p>“欧洲十国游”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/19.jpg" /></p><ul><li>改变 IP 地址的网关，称为 <code>NAT 网关</code>。</li></ul><p>Network Address Translation 地址转换，简称 NAT。<br />网络地址端口转换NAPT（Network Address Port Translation）有端口号。</p><p>“玄奘西行”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/20.jpg" /></p><p>Source Network Address Translation 源地址转换，简称 SNAT。<br />Destination Network Address Translation 目标地址转换，简称 SNAT。</p><p>路由表</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/21.jpg" /></p><ol type="1"><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则；</li><li>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</li></ol><h4 id="动态路由">动态路由</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/22.jpg" /></p><ul><li>距离矢量路由算法</li></ul><p>第一大类的算法称为距离矢量路由（distance vector routing）。它是基于 Bellman-Ford 算法的。</p><p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每</p><p>一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/23.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/24.jpg" /></p><ul><li>链路状态路由算法</li></ul><p>第二大类算法是链路状态路由（link state routing），基于 Dijkstra 算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。</p><p>然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链</p><p>路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。</p><p>每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到</p><p>两点之间的最短路径。</p><p>动态路由协议</p><ul><li>基于链路状态路由算法的 OSPF<br />OSPF（Open Shortest Path First，开放式最短路径优先）就是这样一个基于链路状态路由协议，广泛</li></ul><p>应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为内部网关协议</p><p>（Interior Gateway Protocol，简称IGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><ul><li>基于距离矢量路由算法的 BGP</li></ul><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为外网路由协议（Border Gateway Protocol，简称BGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。</p><p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p><p>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</p><h2 id="最重要的传输层">最重要的传输层</h2><p>MAC 层定义本地局域网传输。<br />IP 层定义了整个网络端到端的传输行为</p><p>这两层基本定义了这样的基因</p><blockquote><p>网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。 我们笼统地称为包。</p></blockquote><p>包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因， 生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="udp">UDP</h3><p>UDP 包头</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/27.jpg" /></p><p>UDP 的三大特点：</p><ol type="1"><li>沟通简单</li><li>轻信他人</li><li>愣头青，做事不懂权变</li></ol><p>UDP 的三大使用场景</p><ol type="1"><li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。</li><li>不需要一对一沟通，建立连接，而是可以广播的应用。</li><li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。</li></ol><p>基于 UDP 定制化的五个例子</p><ol type="1"><li>网页或者 APP 的访问<ol type="1"><li>QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</li></ol></li><li>流媒体的协议</li><li>实时游戏</li><li>IoT 物联网</li><li>移动通信领域</li></ol><p>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；<br />TCP 维护连接，UDP 谁都相信；<br />TCP 会坚持知进退；UDP 愣头青一个，勇往直前；<br />UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</p><h3 id="tcp">TCP</h3><p>TCP 包头格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/28.jpg" /></p><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><p>TCP 的三次握手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/29.jpg" /></p><p>SYN （Synchronize Sequence Number，同步序列编号）<br />ACK （Acknokedgement）用于回复<br />RST （Reset）</p><p>TCP 四次挥手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/30.jpg" /></p><p>FIN （finish）</p><p>TCP 状态机</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/31.jpg" /></p><p>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</p><p>连接的建立是经过三次握手，断开的时候四次挥手。</p><p>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘 录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少;</p><p>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着 石头过河，找到最优值。</p><h3 id="socket">Socket</h3><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根</p><p>网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p><p>Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。</p><p>另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h4 id="基于-tcp-协议的-socket-程序函数调用过程">基于 TCP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/32.jpg" /></p><p>TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。</p><p>除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>文件描述符是一个整数，是这个数组的下标。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/33.jpg" /></p><h4 id="基于-udp-协议的-socket-程序函数调用过程">基于 UDP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/34.jpg" /></p><h4 id="服务器如何接更多的项目">服务器如何接更多的项目？</h4><p>系统会用一个四元组来标识一个 TCP 连接。</p><p>{本机 IP, 本机端口, 对端 IP, 对端端口}</p><ul><li>多进程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/35.jpg" /></p><ul><li>多线程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/36.jpg" /></p><ul><li>IO 多路复用，一个线程维护多个 Socket</li><li>IO 多路复用，从“派人盯着”到“有事通知” epoll</li></ul><p>epoll 被称为解决C10K 问题的利器。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/37.jpg" /></p><p>记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</p><p>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决。</p><h2 id="最常用的应用层">最常用的应用层</h2><h3 id="http-协议">HTTP 协议</h3><p>HTTP 的报文大概分为三大部分。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/38.jpg" /></p><ol type="1"><li>请求行<ol type="1"><li>GET 获取 R</li><li>POST 创建 C</li><li>PUT 修改 U</li><li>DELETE 删除 D</li></ol></li><li>请求的首部<ol type="1"><li>Accept-Charset：客户端可以接受的字符集</li><li>Content-Type：正文的格式</li></ol></li><li>请求的正文实体</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/39.jpg" /></p><p>HTTP 2.0</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/40.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/41.jpg" /></p><p>QUIC 协议</p><p>机制一：自定义连接机制<br />机制二：自定义重传机制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/42.jpg" /></p><p>机制三：无阻塞的多路复用<br />机制四：自定义流量控制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/43.jpg" /></p><p>HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</p><p>HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</p><p>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</p><h3 id="https协议">HTTPS协议</h3><p>加密</p><ol type="1"><li>对称加密</li><li>非对称加密</li></ol><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。</p><p>生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为 CA（ Certifcate Authority）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/44.jpg" /></p><h3 id="流媒体协议">流媒体协议</h3><p>压缩</p><ol type="1"><li>空间冗余</li><li>时间冗余</li><li>视觉冗余</li><li>编码冗余</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/45.jpg" /></p><p>视频编码的两大流派</p><ol type="1"><li>ITU（International Telecommunications Union）的 VECG（Video Coding Experts Group），这个称为国际电联下的 VECG。<ul><li>H.261、 H.262、H.263、H.264、H.265</li></ul></li><li>ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是ISO 旗下的 MPEG，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。<ul><li>MPEG-1、MPEG-2、MPEG-4、MPEG-7</li></ul></li></ol><p>ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/46.jpg" /></p><p>编码：如何将丰富多彩的图片变成二进制流？</p><p><code>I 帧</code>，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。</p><p><code>P 帧</code>，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。</p><p><code>B 帧</code>，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。</p><p>可以看出，I 帧最完整，B 帧压缩率最高，而压缩后帧的序列，应该是在 <code>IBBP</code> 的间隔出现的。这就是通过时序进行编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/47.jpg" /></p><p>在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行空间上的编码。</p><p>尽管时空非常立体的组成了一个序列，但是总归还是要压缩成一个二进制流。这个流是有结构的，是一个个的网络提取层单元（NALU，Network Abstraction Layer Unit）。变成这种格式就是为了传输，因为网络上的传输，默认的是一个个的包，因而这里也就分成了一个个的单元。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/48.jpg" /></p><p>每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据。</p><p>在 NALU 头里面，主要的内容是类型 NAL Type。</p><p><code>0x07</code> 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。</p><p><code>0x08</code> 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/49.jpg" /></p><p>推流：如何把数据流打包传输到对端？</p><p>RTMP 是基于 TCP 的，因而肯定需要双方建立一个 TCP 的连接。</p><p>在有 TCP 的连接的基础上，还需要建立一个 RTMP 的连接，也即在程序里面，你需要调用 RTMP 类库的 Connect 函数，显示创建一个连接。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/50.jpg" /></p><p>一开始双方就要知道对方的时间戳。</p><p>未来沟通这些事情，需要发送六条消息：客户端发送 C0、C1、 C2，服务器发送 S0、 S1、 S2。</p><p>RTMP Packet 包 Message 的格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/51.jpg" /></p><p>流媒体服务器，整个过程就</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/52.jpg" /></p><p>分发网络</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/53.jpg" /></p><p>客户端通过 RTMP 拉流的过程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/54.jpg" /></p><p>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</p><p>压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；</p><p>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成</p><p>Chunk 进行传输；</p><p>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为</p><p>NALU，解码成视频格式进行播放。</p><h3 id="p2p协议">P2P协议</h3><p>下载</p><ol type="1"><li>HTTP</li><li>FTP 文件传输协议<ol type="1"><li>主动模式（PORT）</li><li>被动模式（PASV</li></ol></li><li>P2P (peer-to-peer)</li></ol><p>种子（.torrent）文件</p><ol type="1"><li>announce（tracker URL）</li><li>文件信息<ol type="1"><li>info 区</li><li>Name 字段</li><li>每个段的大小</li><li>段哈希值</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/55.jpg" /></p><p>去中心化网络（DHT）</p><p>DHT 网络是如何查找朋友的？</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/56.jpg" /></p><p>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</p><p>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。</p><h2 id="陌生的数据中心">陌生的数据中心</h2><h3 id="dns协议">DNS协议</h3><p>DNS(Domain Name System,域名系统)_协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送。</p><ol type="1"><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/57.jpg" /></p><p>DNS 解析流程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/58.jpg" /></p><p>负载均衡</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/59.jpg" /></p><p>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</p><p>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="httpdns">HTTPDNS</h3><p>HTTPDNS 服务器的工作模式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/60.jpg" /></p><p>HTTPDNS 服务器的调度设计</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/61.jpg" /></p><h3 id="cdn">CDN</h3><p>Content Delivery Network，即内容分发网络。</p><p>分布在各个地方的各个数据中心的节点，就称为 <code>边缘节点</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/62.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/63.jpg" /></p><ol type="1"><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>用户所处的运营商；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li></ol><p>接入层缓存的架构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/64.jpg" /></p><p>防盗链</p><ol type="1"><li>refer 机制</li><li>时间戳防盗链</li></ol><p>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。</p><p>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。</p><h3 id="数据中心">数据中心</h3><p>数据中心分为三层。</p><p>服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。</p><p>数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过TRILL协议。</p><p>随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。</p><h3 id="vpn">VPN</h3><p>VPN，全名 Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/65.jpg" /></p><p>VPN是如何工作的？</p><p>VPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议：乘客协议、隧道协议和承载协议。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/66.jpg" /></p><p>我们以 IPsec 协议为例来说明。</p><p>一种十分安全的VPN，IPsec VPN。这是基于IP协议的安全隧道协议，为了保证在公网上面信息的安全，因而采取了一定的机制保证安全性。</p><ul><li>机制一：私密性</li><li>机制二：完整性</li><li>机制三：真实性</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/67.jpg" /></p><p>协议簇</p><ul><li>两种协议的区别在于封装网络包的格式不一样<ul><li>AH（Authentication Header），只能进行数据摘要 ，不能实现数据加密。</li><li>ESP（Encapsulating Security Payload），能够进行数据加密和数据摘要</li></ul></li><li>两类算法<ul><li>加密算法</li><li>摘要算法</li></ul></li><li>两大组件<ul><li>用于VPN的双方要进行对称密钥的交换的IKE组件</li><li>VPN的双方要对连接进行维护的SA（Security Association）组件</li></ul></li></ul><p>IPsec VPN的建立过程</p><ol type="1"><li>第一个阶段，建立IKE自己的SA</li><li>建立IPsec SA</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/68.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/69.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/70.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/71.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/72.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/73.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/74.jpg" /></p><h4 id="比较">比较</h4><ul><li>IP 协议：<ul><li>不是面向连接的，是尽力而为的协议，每个 IP 包自由选择路径，依赖于上一层 TCP 的重发来保证可靠性</li><li>优点：一条道路崩溃时，可以自动换其他路</li><li>缺点：不断的路由查找，效率低下</li></ul></li><li>IPSec VPN 的缺点：<ul><li>由于 IPSec VPN 是基于 IP 协议的，所以速度慢</li></ul></li><li>ATM 协议：<ul><li>这种协议是面向连接的，并且和 IP 是同一个层次，ATM 是在传输之前先建立一个连接，形成一个虚拟的通路</li><li>优点：速度快，因为按照指定路径传输</li><li>缺点：当某个节点故障，连接就会中断，无法传输数据</li></ul></li><li>多协议标签交换「MPLS，Multi-Protocol Label Switching」<ul><li>结合了 IP 和 ATM 协议的优点</li><li>需要标签交换路由器「LSR，Label Switching Router」的支持</li><li>如何动态生成标签 LDP「Label Distribution Protocol」</li></ul></li><li>将 MPLS 和 VPN 结合起来可以提高 VPN 的效率<ul><li>需要解决的问题有：<ul><li>BGP 协议如何处理地址空间重叠的 VPN 的路由</li><li>路由表怎么区分重复的网段</li></ul></li></ul></li></ul><p>IPsec VPN的协议簇</p><p>VPN可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样；</p><p>完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些；</p><p>MPLS-VPN 综合和IP转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买。</p><h3 id="移动网络">移动网络</h3><ul><li>2G：txt</li><li>3G：jpg</li><li>4G：avi</li></ul><h4 id="g-网络">2G 网络</h4><p>手机是通过收发无线信号来通信的，专业名称是 <code>Mobile Station</code>，简称 <code>MS</code>，需要嵌入 <code>SIM</code>。</p><p>手机是客户端，而无线信号的服务端，就是基站子系统（BSS，Base Station SubsystemBSS）。</p><p>基站子系统分两部分</p><ul><li>一部分对外提供无线通信，叫作基站收发信台（BTS，Base Transceiver Station）</li><li>另一部分对内连接有线网络，叫作基站控制器（BSC，Base Station Controller）</li></ul><p>基站收发信台通过无线收到数据后，转发给基站控制器。</p><p>这部分属于无线的部分，统称为无线接入网（RAN，Radio Access Network）。</p><p>基站控制器通过有线网络，连接到提供手机业务的运营商的数据中心，这部分称为核心网（CN，Core Network）。</p><p>核心网还没有真的进入互联网，这部分还是主要提供手机业务，是手机业务的有线部分。</p><p>首先接待基站来的数据的是移动业务交换中心（MSC，Mobile Service Switching Center），它是进入核心网的入口，但是它不会让你直接连接到互联网上。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/75.jpg" /></p><p>因而2G时代的上网如图所示，我们总结一下，有这几个核心点:</p><ul><li>手机通过无线信号连接基站;</li><li>基站一面朝前接无线，一面朝后接核心网;</li><li>核心网一面朝前接到基站请求，一是判断你是否合法，二是判断你是不是本地号，还有没有钱，一面通过网关连接电话网络。</li></ul><h4 id="g-网络-1">2.5G 网络</h4><p>后来从2G到了2.5G，也即在原来电路交换的基础上，加入了分组交换业务，支持Packet的转发，从而支持IP网络。 在上述网络的基础上，基站一面朝前接无线，一面朝后接核心网。在朝后的组件中，多了一个分组控制单元(PCU，Packet Control Unit)，用以提供分组交换通道。 在核心网里面，有个朝前的接待员(SGSN，Service GPRS Supported Node)和朝后连接IP网络的网关型GPRS支持节点(GGSN，Gateway GPRS Supported Node)。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/76.jpg" /></p><h4 id="g-网络-2">3G 网络</h4><p>到了3G时代，主要是无线通信技术有了改进，大大增加了无线的带宽。</p><p>以W-CDMA为例，理论最高2M的下行速度，因而基站改变了，一面朝外的是Node B，一面朝内连接核心网的是无线网络控制器(RNC，Radio Network Controller)。核心网以及连接的IP网 络没有什么变化。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/77.jpg" /></p><h4 id="g-网络-3">4G 网络</h4><p>然后就到了今天的 4G网络，基站为 eNodeB，包含了原来Node B 和 RNC 的功能，下行速度向百兆级别迈进。另外，核心网实现了控制面和数据面的分离，这个怎么理解呢?</p><p>在前面的核心网里面，有接待员 MSC 或者 SGSN，你会发现检查是否合法是它负责，转发数据也是它负责，也即控制面和数据面是合二为一的，这样灵活性比较差，因为控制面主要是指令，多是 小包，往往需要高的及时性;数据面主要是流量，多是大包，往往需要吞吐量。</p><p>于是有了下面这个架构。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/78.jpg" /></p><p>HSS 用于存储用户签约信息的数据库，其实就是你这个号码归属地是哪里的，以及一些认证信息。</p><p>MME 是核心控制网元，是控制面的核心，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息，判断你是否合法。如果允许连上来，MME 不负责具体的数据的流量，而是MME会选择数据 面的 SGW 和 PGW ，然后告诉 eNodeB，我允许你连上来了，你连接它们吧。</p><p>于是手机直接通过 eNodeB 连接 SGW ，连上核心网， SGW 相当于数据面的接待员，并通过 PGW 连到 IP网络。 PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用 来控制上网策略和流量的计费。</p><h4 id="g-网络协议解析">4G 网络协议解析</h4><p>我们来仔细看一下4G网络的协议，真的非常复杂。我们将几个关键组件放大来看。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/79.jpg" /></p><h4 id="控制面协议">控制面协议</h4><p>其中虚线部分是控制面的协议。当一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权。</p><p>S1-MME 协议栈如下图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/80.jpg" /></p><p>UE就是你的手机，eNodeB还是两面派，朝前对接无线网络，朝后对接核心网络，在控制面对接的是MME。</p><p>eNodeB和MME之间的连接就是很正常的IP网络，但是这里面在IP层之上，却既不是TCP，也不是UDP，而是SCTP。这也是传输层的协议，也是面向连接的，但是更加适合移动网络。 它继承了 TCP 较为完善的拥塞控制并改进TCP的一些不足之处。</p><ul><li>SCTP 的第一个特点是 <code>多宿主</code>。</li></ul><p>一台机器可以有多个网卡，而对于TCP连接来讲，虽然服务端可以监听0.0.0.0，也就是从哪个网卡来的连接都能接受，但是一旦建立了连接，就建立了四元组，也就选定了某个网卡。</p><p>SCTP 引入了联合（association）的概念，将多个接口、多条路径放到一个联合中来。当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据。应用程序甚至都不必知道发生了故障、恢复，从而提供更高的可用性和可靠性。</p><ul><li>SCTP 的第二个特点是将一个联合分成多个流。</li></ul><p>一个联合中的所有流都是独立的，但均与该联合相关。每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送。在 TCP 的机制中，由于强制顺序，导致前一个不到达，后一个就得等待，SCTP 的多个流不会相互阻塞。</p><ul><li>SCTP 的第三个特点是四次握手，防止 SYN 攻击。</li></ul><p>在TCP中是三次握手，当服务端收到客户的 SYN 之后，返回一个SYN-ACK 之前，就建立数据结构，并记录下状态，等待客户端发送 ACK 的 ACK。当恶意客户端使用虚假的源地址来伪造大量SYN报文时，服务端需要分配大量的资源，最终耗尽资源，无法处理新的请求。</p><p>SCTP 可以通过四次握手引入 Cookie 的概念，来有效地防止这种攻击的产生。在 SCTP 中，客户机使用一个INIT报文发起一个连接。服务器使用一个 INIT-ACK 报文进行响应，其中就包括了 Cookie。</p><p>然后客户端就使用一个 COOKIE-ECHO 报文进行响应，其中包含了服务器所发送的 Cookie。这个时候，服务器为这个连接分配资源，并通过向客户机发送一个COOKIE-ACK报文对其进行响应。</p><ul><li>SCTP 的第四个特点是将消息分帧。</li></ul><p>TCP 是面向流的，也即发送的数据没头没尾，没有明显的界限。这对于发送数据没有问题，但是对于发送一个个消息类型的数据，就不太方便。有可能客户端写入10个字节，然后再写入20个字节。服务端不是读出10个字节的一个消息，再读出20个字节的一个消息，而有可能读入25个字节，再读入5个字节，需要业务层去组合成消息。</p><p>SCTP 借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同。</p><ul><li>SCTP 的第五个特点是断开连接是三次挥手。</li></ul><p>在 TCP 里面，断开连接是四次挥手，允许另一端处于半关闭的状态。SCTP 选择放弃这种状态，当一端关闭自己的套接字时，对等的两端全部需要关闭，将来任何一端都不允许再进行数据的移动了。</p><p>当MME通过认证鉴权，同意这个手机上网的时候，需要建立一个数据面的数据通路。建立通路的过程还是控制面的事情，因而使用的是控制面的协议 GTP-C。</p><p>建设的数据通路分两段路，其实是两个隧道。一段是从 eNodeB 到 SGW ，这个数据通路由 MME 通过 S1-MME 协议告诉 eNodeB，它是隧道的一端，通过 S11 告诉 SGW ，它是隧道的另一端。第二端是从 SGW 到 PGW ， SGW 通过 S11 协议知道自己是其中一端，并主动通过S5协议，告诉 PGW 它是隧道的另一端。</p><p>GTP-C 协议是基于 UDP 的，这是 UDP 中的一个例子。如果看GTP头，我们可以看到，这里面有隧道的ID，还有序列号。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/81.jpg" /></p><p>通过序列号，不用TCP，GTP-C自己就可以实现可靠性，为每个输出信令消息分配一个依次递增的序列号，以确保信令消息的按序传递，并便于检测重复包。对于每个输出信令消息启动定时器， 在定时器超时前未接收到响应消息则进行重发。</p><h4 id="数据面协议">数据面协议</h4><p>当两个隧道都打通，接在一起的时候， PGW 会给手机分配一个 IP地址，这个 IP地址是隧道内部的 IP地址，可以类比为IPsec协议里面的 IP地址。这个IP地址是归手机运营商管理的。然后，手机可 以使用这个 IP地址，连接 eNodeB，从 eNodeB 经过 S1-U协议，通过第一段隧道到达 SGW ，再从 SGW 经过 S8协议，通过第二段隧道到达 PGW ，然后通过 PGW 连接到互联网。</p><p>数据面的协议都是通过 GTP-U，如图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/82.jpg" /></p><p>手机每发出的一个包，都由 GTP-U 隧道协议封装起来，格式如下。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/83.jpg" /></p><p>和 IPsec 协议很类似，分为乘客协议、隧道协议、承载协议。其中乘客协议是手机发出来的包，IP 是手机的 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，因而需要隧道ID来标 识。承载协议的 IP 地址是 SGW 和 PGW 的IP地址。</p><h4 id="手机上网流程">手机上网流程</h4><p>接下来，我们来看一个手机开机之后上网的流程，这个过程称为 Attach。可以看出来，移动网络还是很复杂的。因为这个过程要建立很多的隧道，分配很多的隧道ID，所以我画了一个图来详细 说明这个过程。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/84.jpg" /></p><ol type="1"><li>手机开机以后，在附近寻找基站eNodeB，找到后给eNodeB发送 Attach Request，说“我来啦，我要上网”。</li><li>eNodeB 将请求发给MME，说“有个手机要上网”。</li><li>MME 去请求手机，一是认证，二是鉴权，还会请求HSS看看有没有钱，看看是在哪里上网。</li><li>当 MME 通过了手机的认证之后，开始分配隧道，先告诉 SGW ，说要创建一个会话(Create Session)。在这里面，会给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道ID。</li><li>SGW 转头向 PGW 请求建立一个会话，为 PGW 的控制面分配一个隧道ID t2，也给 PGW 的数据面分配一个隧道ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道ID。</li><li>PGW 回复 SGW 说“创建会话成功”，使用自己的控制面隧道ID t2，回复里面携带着给 SGW 控制面分配的隧道ID t4和控制面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成。双方请求 对方，都要带着对方给自己分配的隧道ID，从而标志是这个手机的请求。</li><li>接下来 SGW 回复MME说“创建会话成功”，使用自己的隧道ID t1 访问 MME，回复里面有给MME分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7。</li><li>当MME发现后面的隧道都建设成功之后，就告诉eNodeB，“后面的隧道已经建设完毕， SGW 给你分配的隧道ID是t7，你可以开始连上来了，但是你也要给 SGW 分配一个隧道ID”。</li><li>eNodeB 告诉MME自己给 SGW 分配一个隧道，ID为t8。</li><li>MME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW ，从而前面的隧道也建设完毕。</li></ol><p>这样，手机就可以通过建立的隧道成功上网了。</p><h4 id="异地上网问题">异地上网问题</h4><p>接下来我们考虑异地上网的事情。 为什么要分 SGW 和 PGW 呢，一个GW不可以吗? SGW 是你本地的运营商的设备，而 PGW 是你所属的运营商的设备。</p><p>如果你在巴塞罗那，一下飞机，手机开机，周围搜寻到的肯定是巴塞罗那的eNodeB。通过MME去查寻国内运营商的HSS，看你是否合法，是否还有钱。</p><p>如果允许上网，你的手机和巴塞罗那的 SGW 会建立一个隧道，然后巴塞罗那的 SGW 和国内运营商的 PGW 建立一个隧道，然后通过国内运营商的 PGW 上网。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/85.jpg" /></p><p>这样判断你是否能上网的在国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的IP地址也是国内运营商里统计的。</p><p>运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算。</p><p>由于你的上网策略是由国内运营商在PCRF中控制的，因而你还是上不了脸书。</p><ul><li>移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变;</li><li>记住 4G网络的结构，有 eNodeB、MME、 SGW 、 PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程;</li><li>即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书。</li></ul><h2 id="云计算中的网络">云计算中的网络</h2><h3 id="云中网络">云中网络</h3><h3 id="软件定义网络">软件定义网络</h3><h3 id="云中的网络安全">云中的网络安全</h3><h3 id="云中的网络qos">云中的网络QoS</h3><h3 id="云中网络的隔离grevxlan">云中网络的隔离GRE、VXLAN</h3><h2 id="容器技术中的网络">容器技术中的网络</h2><h3 id="容器网络">容器网络</h3><h3 id="flannel">Flannel</h3><h3 id="calico">Calico</h3><h2 id="微服务相关协议">微服务相关协议</h2><h3 id="rpc协议">RPC协议</h3><h3 id="基于-xml-的-soap-协议">基于 XML 的 SOAP 协议</h3><h3 id="基于-json-的-restful-接口协议">基于 JSON 的 RESTful 接口协议</h3><h3 id="二进制类rpc协议">二进制类RPC协议</h3><h3 id="跨语言类rpc协议">跨语言类RPC协议</h3><h2 id="搭建一个网络实验环境">搭建一个网络实验环境</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/网络传输协议" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/网络传输协议</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/85</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/" target="_blank" rel="noopener" class="uri">http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;维基百科&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="protocal" scheme="https://2020.iosdevlog.com/tags/protocal/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 思维导图</title>
    <link href="https://2020.iosdevlog.com/2020/04/12/nginx/"/>
    <id>https://2020.iosdevlog.com/2020/04/12/nginx/</id>
    <published>2020-04-12T15:06:15.000Z</published>
    <updated>2020-04-12T16:31:27.805Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。</p><p>2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。</p><p>Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/12/nginx/nginx.svg" /></p><p>Nginx 思维导图 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h2 id="编译">编译</h2><h3 id="选择官方模块">选择官方模块</h3><ul><li><p>with</p></li><li><p>without</p></li></ul><h3 id="指定运行时路径参数">指定运行时路径、参数</h3><h3 id="添加第三方模块">添加第三方模块</h3><ul><li><p>下载第三方模块</p><ul><li><p>config指定模块位置</p></li><li><p>C源码定义模块</p></li></ul></li></ul><h3 id="添加动态模块">添加动态模块</h3><h3 id="指定编译连接参数">指定编译连接参数</h3><h2 id="命令行">命令行</h2><h3 id="参数">参数</h3><ul><li><p>-s发送信号</p><ul><li><p>stop</p></li><li><p>quit</p></li><li><p>reload</p></li><li><p>reopen</p></li></ul></li><li><p>测试配置</p><ul><li>-t,-T,-q</li></ul></li><li><p>帮助信息</p><ul><li>-h,-?</li></ul></li><li><p>版本信息</p><ul><li>-v,-V</li></ul></li><li><p>指定运行参数</p><ul><li><p>-g</p></li><li><p>-c</p></li><li><p>-p</p></li></ul></li></ul><h2 id="运维监控">运维监控</h2><h3 id="日志">日志</h3><ul><li><p>类型</p><ul><li><p>error日志</p><ul><li>debug_connection对指定连接记日志</li></ul></li><li><p>access日志</p><ul><li><p>压缩</p></li><li><p>缓存</p></li></ul></li></ul></li><li><p>记录日志方式</p><ul><li><p>直写文件</p></li><li><p>syslog</p></li><li><p>循环写内存</p></li></ul></li></ul><h3 id="stub_status">stub_status</h3><ul><li><p>accepted</p></li><li><p>handled</p></li><li><p>requests</p></li><li><p>active</p></li><li><p>reading</p></li><li><p>writing</p></li><li><p>waiting</p></li></ul><h2 id="进程模型">进程模型</h2><h3 id="通讯方式">通讯方式</h3><ul><li><p>信号</p><ul><li><p>TERM, INT</p></li><li><p>QUIT</p></li><li><p>HUP</p></li><li><p>USR1</p></li><li><p>USR2</p></li><li><p>WINCH</p></li></ul></li><li><p>共享内存</p><ul><li><p>slab内存管理</p></li><li><p>互斥锁</p></li></ul></li></ul><h3 id="进程">进程</h3><ul><li><p>master</p></li><li><p>worker</p></li><li><p>cache manager</p></li><li><p>cache loader</p></li></ul><h2 id="对象容器">对象容器</h2><h3 id="数组">数组</h3><h3 id="链表">链表</h3><h3 id="队列">队列</h3><h3 id="红黑树">红黑树</h3><h3 id="基数树">基数树</h3><h3 id="哈希表">哈希表</h3><ul><li>桶大小向上对齐cpu cache line</li></ul><h2 id="内存池">内存池</h2><h3 id="request">request</h3><ul><li>随请求结束释放</li></ul><h3 id="connection">connection</h3><ul><li>随连接断开释放</li></ul><h2 id="连接池">连接池</h2><h3 id="事件池">事件池</h3><h3 id="上下游共享">上下游共享</h3><h3 id="keepalive长连接池">keepalive长连接池</h3><h2 id="模块设计">模块设计</h2><h3 id="模块类型">模块类型</h3><ul><li><p>core模块</p></li><li><p>event模块</p></li><li><p>http模块</p></li><li><p>conf模块</p></li><li><p>stream模块</p></li><li><p>mail模块</p></li></ul><h3 id="模块通用接口">模块通用接口</h3><ul><li><p>init_master</p></li><li><p>init_module</p></li><li><p>init_process</p></li><li><p>init_thread</p></li><li><p>exit_thread</p></li><li><p>exit_process</p></li><li><p>exit_master</p></li></ul><h2 id="请求的处理阶段">请求的处理阶段</h2><h3 id="http">http</h3><ul><li><p>POST_READ阶段</p></li><li><p>SERVER_REWRITE阶段</p></li><li><p>FIND_CONFIG阶段</p></li><li><p>REWRITE阶段</p></li><li><p>POST_REWRITE阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>POST_ACCESS阶段</p></li><li><p>PRECONTENT阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h3 id="stream">stream</h3><ul><li><p>POST_ACCEPT阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>SSL阶段</p></li><li><p>PREREAD阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h2 id="变量">变量</h2><h3 id="按应用场景">按应用场景</h3><ul><li><p>http模块</p></li><li><p>stream模块</p></li></ul><h3 id="按功能">按功能</h3><ul><li><p>框架变量</p><ul><li>upstream变量</li></ul></li><li><p>模块变量</p></li></ul><h3 id="按使用方式">按使用方式</h3><ul><li><p>提供方</p></li><li><p>使用方</p></li></ul><h2 id="反向代理">反向代理</h2><h3 id="http-1">http</h3><ul><li><p>上游</p><ul><li><p>协议</p><ul><li><p>http/https</p></li><li><p>fastcgi</p></li><li><p>scgi</p></li><li><p>uwsgi</p></li><li><p>websocket</p></li><li><p>spdy</p></li><li><p>grpc</p></li><li><p>memcached</p></li><li><p>redis</p></li></ul></li><li><p>限速</p></li></ul></li><li><p>缓存</p><ul><li><p>缓存类型</p><ul><li><p>响应内容缓存</p><ul><li>分片</li></ul></li><li><p>openfile缓存</p></li><li><p>浏览器缓存</p></li></ul></li><li><p>缓存大小</p></li><li><p>更新淘汰方式</p></li></ul></li><li><p>下游</p><ul><li><p>http/https</p></li><li><p>限速</p></li></ul></li><li><p>平衡上下游网速</p><ul><li><p>接收请求包体</p></li><li><p>接收响应包体</p></li></ul></li></ul><h3 id="stream-1">stream</h3><ul><li><p>tcp</p></li><li><p>udp</p></li><li><p>透传客户端地址</p><ul><li><p>proxy_protocol</p></li><li><p>IP地址透传</p></li><li><p>上游服务直接返回报文</p></li></ul></li></ul><h3 id="mail">mail</h3><h3 id="负载均衡">负载均衡</h3><ul><li><p>策略</p><ul><li><p>轮询</p></li><li><p>哈希</p><ul><li>一致性哈希</li></ul></li><li><p>基于第三方服务</p></li></ul></li><li><p>健康检查</p></li><li><p>连接池</p></li><li><p>配置DNS服务</p></li></ul><h2 id="nginx.conf指令">nginx.conf指令</h2><h3 id="类型">类型</h3><ul><li><p>块指令</p><ul><li><p>main</p></li><li><p>http</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>location</p></li><li><p>if</p></li><li><p>limit_except</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li><li><p>event</p></li><li><p>stream</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li></ul></li><li><p>普通指令</p><ul><li><p>脚本类</p></li><li><p>设置动作</p></li><li><p>存储值</p></li></ul></li></ul><h3 id="父子指令块配置合并规则">父子指令块配置合并规则</h3><h3 id="server匹配规则">server匹配规则</h3><ul><li><p>精确匹配</p></li><li><p>泛域名</p></li><li><p>正则表达式</p></li><li><p>默认server</p></li></ul><h3 id="location匹配规则">location匹配规则</h3><ul><li><p>前缀字符串匹配</p></li><li><p>正则表达式匹配</p></li></ul><h3 id="参数单位">参数单位</h3><ul><li><p>时间</p></li><li><p>空间</p></li></ul><h2 id="性能优化">性能优化</h2><h3 id="内存效率">内存效率</h3><ul><li><p>tcp</p><ul><li>linux pressure模式</li></ul></li><li><p>http</p></li></ul><h3 id="cpu效率">CPU效率</h3><ul><li><p>绑定CPU</p></li><li><p>静态优先级</p></li><li><p>谨慎使用消耗CPU过大的模块</p></li><li><p>线程池</p></li><li><p>worker间负载均衡</p><ul><li><p>建连接</p></li><li><p>多网卡队列</p></li></ul></li></ul><h3 id="网络效率">网络效率</h3><ul><li><p>tcp</p><ul><li><p>建立连接</p><ul><li><p>FastOpen</p></li><li><p>backlog</p></li><li><p>超时时间</p></li></ul></li><li><p>传输</p><ul><li><p>缓冲区大小</p><ul><li>BGP</li></ul></li><li><p>拥塞控制</p><ul><li>初始拥塞窗口</li></ul></li><li><p>延迟批量发送</p><ul><li><p>tcp_nodelay</p></li><li><p>tcp_nopush</p></li></ul></li></ul></li><li><p>关闭连接</p><ul><li><p>keepalive释放资源</p></li><li><p>减少time_wait</p></li><li><p>超时时间</p></li></ul></li></ul></li><li><p>http</p><ul><li><p>keepalive长连接</p></li><li><p>应用层缓冲区大小</p><ul><li><p>header</p></li><li><p>body</p></li></ul></li><li><p>lingering_close</p></li><li><p>超时时间</p></li></ul></li><li><p>TLS/SSL</p><ul><li><p>session缓存</p></li><li><p>OCSP</p></li><li><p>会话票据</p></li><li><p>算法选择</p><ul><li><p>对称加密算法</p><ul><li>分组模式</li></ul></li><li><p>非对称加密算法</p></li></ul></li></ul></li><li><p>网卡</p></li></ul><h3 id="磁盘io">磁盘IO</h3><ul><li><p>AIO</p></li><li><p>directio</p></li><li><p>零拷贝</p><ul><li>sendfile</li></ul></li><li><p>日志文件</p><ul><li><p>写入缓存</p></li><li><p>压缩后写入</p></li><li><p>syslog</p></li></ul></li><li><p>减少读取次数</p><ul><li>empty_gif模块</li></ul></li><li><p>磁盘</p></li></ul><h2 id="openresty">openresty</h2><h3 id="指令">指令</h3><ul><li><p>http</p><ul><li><p>处理阶段</p></li><li><p>响应过滤</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>ssl</p></li><li><p>共享内存</p></li></ul></li><li><p>stream</p><ul><li><p>处理阶段</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>共享内存</p></li><li><p>ssl</p></li></ul></li></ul><h3 id="lua模块">lua模块</h3><h3 id="sdk">SDK</h3><ul><li><p>正则表达式</p></li><li><p>流程控制类</p></li><li><p>版本与配置</p></li><li><p>进程信息</p></li><li><p>定时器</p></li><li><p>子请求</p></li><li><p>用户请求</p></li><li><p>时间类API</p></li><li><p>多线程</p><ul><li><p>coroutine</p></li><li><p>thread</p></li></ul></li><li><p>shared_dict</p></li><li><p>socket</p><ul><li><p>tcp</p></li><li><p>udp</p></li></ul></li><li><p>response header</p></li><li><p>内容输出</p></li><li><p>常量</p></li><li><p>其他</p><ul><li><p>var变量</p></li><li><p>arg参数</p></li><li><p>日志</p><ul><li>log</li></ul></li><li><p>get_phase</p></li><li><p>sleep</p></li></ul></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/Nginx" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/Nginx</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://github.com/russelltao/geektime-nginx" target="_blank" rel="noopener" class="uri">https://github.com/russelltao/geektime-nginx</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。&lt;/p&gt;
&lt;p&gt;2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。&lt;/p&gt;
&lt;p&gt;Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="nginx" scheme="https://2020.iosdevlog.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains Academy Knowledge Map</title>
    <link href="https://2020.iosdevlog.com/2020/04/11/jetbrains/"/>
    <id>https://2020.iosdevlog.com/2020/04/11/jetbrains/</id>
    <published>2020-04-11T15:26:38.000Z</published>
    <updated>2020-04-13T05:12:00.211Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png" /></p><p>基础/算法/开发工具/Java/Python/Kotlin/前端​<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><h2 id="java">Java</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Java.png" /></p><h3 id="hello-world">Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello AIDevLog!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/compiling_java.svg" /></p><h3 id="standard-input">Standard Input</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">String line = scanner.nextLine();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Hello, "</span> + name +<span class="string">"!"</span>);</span><br><span class="line">System.out.println(line);</span><br></pre></td></tr></table></figure><h3 id="templete">Templete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kotlin">Kotlin</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Kotlin.png" /></p><h2 id="essentials">Essentials</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Essentials.png" /></p><h2 id="fronted">Fronted</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Fronted.png" /></p><h2 id="python">Python</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Python.png" /></p><h2 id="algorithm">Algorithm</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Algorithm.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://hyperskill.org/knowledge-map" target="_blank" rel="noopener" class="uri">https://hyperskill.org/knowledge-map</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;基础/算法/开发工具/Java/Python/Kotlin/前端​&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="academy" scheme="https://2020.iosdevlog.com/categories/academy/"/>
    
    
      <category term="python" scheme="https://2020.iosdevlog.com/tags/python/"/>
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="jetbrain" scheme="https://2020.iosdevlog.com/tags/jetbrain/"/>
    
      <category term="java" scheme="https://2020.iosdevlog.com/tags/java/"/>
    
      <category term="kotlin" scheme="https://2020.iosdevlog.com/tags/kotlin/"/>
    
      <category term="tool" scheme="https://2020.iosdevlog.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>人人都是产口经理 3.0</title>
    <link href="https://2020.iosdevlog.com/2020/04/10/pm/"/>
    <id>https://2020.iosdevlog.com/2020/04/10/pm/</id>
    <published>2020-04-10T15:51:20.000Z</published>
    <updated>2020-04-10T15:59:16.408Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/10/pm/pm.png" /></p><p><a href="https://time.geekbang.org/column/article/215594" target="_blank" rel="noopener">苏杰的产品创新课</a></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/10/pm/network.png" /></p><p><a href="https://time.geekbang.org/column/article/92378" target="_blank" rel="noopener">深入浅出计算机组成原理</a></p><p><img src="https://2020.iosdevlog.com/2020/04/10/pm/computer.png" /></p><p><a href="https://time.geekbang.org/column/article/14905" target="_blank" rel="noopener">趣谈网络协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/10/pm/pm.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/215594&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苏杰的产品创新课&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="manager" scheme="https://2020.iosdevlog.com/tags/manager/"/>
    
      <category term="pm" scheme="https://2020.iosdevlog.com/tags/pm/"/>
    
      <category term="cs" scheme="https://2020.iosdevlog.com/tags/cs/"/>
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://2020.iosdevlog.com/2020/04/09/Design-pattern/"/>
    <id>https://2020.iosdevlog.com/2020/04/09/Design-pattern/</id>
    <published>2020-04-09T12:55:32.000Z</published>
    <updated>2020-04-09T14:33:18.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/Design-pattern.svg" /></p><a id="more"></a><h2 id="种经典的设计模式">23 种经典的设计模式</h2><ul><li>创建型<ul><li><ol type="1"><li>单例模式</li></ol></li><li><ol start="2" type="1"><li>工厂模式-工厂方法</li></ol></li><li><ol start="3" type="1"><li>工厂模式-抽象工厂</li></ol></li><li><ol start="4" type="1"><li>建造者模式</li></ol></li><li><ol start="5" type="1"><li>原型模式</li></ol></li></ul></li><li>结构型<ul><li><ol start="6" type="1"><li>代理模式</li></ol></li><li><ol start="7" type="1"><li>桥接模式</li></ol></li><li><ol start="8" type="1"><li>装饰者模式</li></ol></li><li><ol start="9" type="1"><li>适配器模式</li></ol></li><li><ol start="10" type="1"><li>门面模式</li></ol></li><li><ol start="11" type="1"><li>组合模式</li></ol></li><li><ol start="12" type="1"><li>享元模式</li></ol></li></ul></li><li>行为型<ul><li><ol start="13" type="1"><li>观察者模式</li></ol></li><li><ol start="14" type="1"><li>模板模式</li></ol></li><li><ol start="15" type="1"><li>策略模式</li></ol></li><li><ol start="16" type="1"><li>职责链模式</li></ol></li><li><ol start="17" type="1"><li>迭代器模式</li></ol></li><li><ol start="18" type="1"><li>状态模式</li></ol></li><li><ol start="19" type="1"><li>访问者模式</li></ol></li><li><ol start="20" type="1"><li>备忘录模式</li></ol></li><li><ol start="21" type="1"><li>命令模式</li></ol></li><li><ol start="22" type="1"><li>解释器模式</li></ol></li><li><ol start="23" type="1"><li>中介模式</li></ol></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/gof-23-design-patterns.png" /></p><p>设计模式中设计的可变方面<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/1.png" /></p><h2 id="设计原则">设计原则</h2><ul><li>SOLID 设计模式的六大原则<ul><li>SRP 单一职责原则<ul><li>Single Responsibility Principle</li></ul></li><li>OCP 开闭原则<ul><li>Open Closed Principle</li></ul></li><li>LSP 里式替换原则<ul><li>Liskov Substitution Principle</li></ul></li><li>LOD 法则<ul><li>Law of Demeter</li></ul></li><li>ISP 接口隔离原则<ul><li>Interface Segregation Principle</li></ul></li><li>DIP 依赖倒置原则<ul><li>Dependence Inversion Principle</li></ul></li></ul></li><li>DRY 原则<ul><li>Don't Repeat Yourself</li></ul></li><li>KISS 原则<ul><li>Keep it Simple and Stupid</li></ul></li><li>YAGNI 适可而止原则<ul><li>You Ain’t Gonna Need It</li></ul></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="http://yuweijun.github.io/blog/" target="_blank" rel="noopener" class="uri">http://yuweijun.github.io/blog/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/09/Design-pattern/Design-pattern.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="code" scheme="https://2020.iosdevlog.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>算法思想</title>
    <link href="https://2020.iosdevlog.com/2020/04/09/algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/09/algorithm/</id>
    <published>2020-04-09T06:09:13.000Z</published>
    <updated>2020-04-09T12:06:54.824Z</updated>
    
    <content type="html"><![CDATA[<p>不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p><ul><li>贪心算法<ul><li>霍夫曼编码（Huffman Coding）</li><li>Prim 和 Kruskal 最小生成树算法</li><li>Dijkstra 单源最短路径算法</li></ul></li><li>分治算法<ul><li>MapRedue</li></ul></li><li>回溯算法</li><li>动态规划</li></ul><a id="more"></a><h2 id="贪心算法">贪心算法</h2><ol type="1"><li>定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</li><li>是否可以用贪心算法解决<ul><li>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</li></ul></li><li>贪心算法产生的结果是否是最优的</li></ol><p>贪心算法实战分析</p><ol type="1"><li>分糖果</li><li>付钱<ul><li>99 = 50 + 2 * 20 + 10 + 5 + 4 * 1</li></ul></li><li>区间覆盖</li></ol><h3 id="霍夫曼编码">霍夫曼编码</h3><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在20%～90%之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。</p><p>霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？</p><p>根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.1.jpg" /></p><p>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A、B的父节点。最后再把C节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.2.jpg" /></p><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为0，指向右子节点的边，我们统统标记为1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.3.jpg" /></p><p>贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，我们只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="分治算法">分治算法</h2><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong></p><p>分治算法一般都比较适合用递归来实现。</p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ol type="1"><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ol type="1"><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><p>分治算法应用举例分析</p><ul><li>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</li><li>有两个 <span class="math inline">\(n\*n\)</span> 的矩阵 A，B，如何快速求解两个矩阵的乘积 <span class="math inline">\(C=A\*B\)</span>？</li><li>求出一组数据的有序对个数或者逆序对个数？</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.1.jpg" /></p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。</p><p>我们用分治算法来试试。我们套用分治的思想来求数组A的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.2.jpg" /></p><p>实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分治算法用四个字概括就是“分而治之”，将原问题划分成n个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><h2 id="回溯算法">回溯算法</h2><ul><li>软件开发<ul><li>正则表达式匹配</li><li>编译原理中的语法分析</li></ul></li><li>数学问题<ul><li>数独</li><li>八皇后</li><li>0-1背包</li><li>图的着色</li><li>旅行商问题</li><li>全排列</li></ul></li></ul><h3 id="八皇后问题">八皇后问题</h3><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/39.1.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">"* "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包">0-1背包</h3><p>有一个背包，背包总的承载重量是Wkg。现在我们有n个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><ol type="1"><li>“*”匹配任意多个（大于等于0个）任意字符</li><li>“?”匹配零个或者一个任意字符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。</p><h2 id="动态规划dynamic-programming">动态规划（Dynamic Programming）</h2><h3 id="初识动态规划">初识动态规划</h3><p>大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。</p><p>动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p><h3 id="动态规划理论">动态规划理论</h3><h4 id="最优子结构">最优子结构</h4><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h4 id="无后效性">无后效性</h4><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><h4 id="重复子问题">重复子问题</h4><p>这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h3 id="动态规划实战">动态规划实战</h3><p>如何量化两个字符串的相似度？</p><p>有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。</p><p>编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。</p><ul><li>莱文斯坦距离允许增加、删除、替换字符这三个编辑操作</li><li>最长公共子串长度只允许增加、删除字符这两个编辑操作。</li></ul><p>两个字符串 <em>mitcmu</em> 和 <em>mtacnu</em> 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/42.1.jpg" /></p><h2 id="比较">比较</h2><p>贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类。</p><p>前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心算法
&lt;ul&gt;
&lt;li&gt;霍夫曼编码（Huffman Coding）&lt;/li&gt;
&lt;li&gt;Prim 和 Kruskal 最小生成树算法&lt;/li&gt;
&lt;li&gt;Dijkstra 单源最短路径算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分治算法
&lt;ul&gt;
&lt;li&gt;MapRedue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;回溯算法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-5-字符串匹配</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/</id>
    <published>2020-04-08T09:36:23.000Z</published>
    <updated>2020-04-08T10:55:30.824Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th>算法</th><th>预处理时间</th><th>匹配时间</th></tr></thead><tbody><tr class="odd"><td>BF算法 / 朴素算法</td><td>0 (无需预处理)</td><td>Θ(nm)</td></tr><tr class="even"><td>Rabin-Karp算法</td><td>Θ(m)</td><td>平均 Θ(n + m),最差 Θ((n-m)m)</td></tr><tr class="odd"><td>基于有限状态机的搜索</td><td>Θ(mk)</td><td>Θ(n)</td></tr><tr class="even"><td>克努斯-莫里斯-普拉特算法</td><td>Θ(m)</td><td>Θ(n)</td></tr><tr class="odd"><td>Boyer-Moore字符串搜索算法</td><td>Θ(m + k)</td><td>最好Ω(n/m),最坏 O(n)</td></tr><tr class="even"><td>Bitap算法</td><td>Θ(m + k)</td><td>O(mn)</td></tr></tbody></table><a id="more"></a><h2 id="bf算法">BF算法</h2><p>BF算法 中的 <code>BF</code> 是 <em>Brute Force</em> 的缩写，中文叫作 <strong>暴力匹配算</strong>法，也叫 <strong>朴素匹配算法</strong>。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.1.jpg" /></p><ul><li>主串</li><li>模式串</li></ul><p>把主串的长度记作 <code>n</code>，模式串的长度记作 <code>m</code>。</p><p>在主串中查找模式串，所以 <code>n&gt;m</code>。</p><p>BF算法的思想：</p><blockquote><p>在主串中，检查起始位置分别是 <code>0、1、2…n-m</code> 且长度为 <code>m</code> 的 <code>n-m+1</code> 个子串，看有没有跟模式串匹配的。</p></blockquote><p>尽管理论上，BF算法的时间复杂度很高，是O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的 <code>KISS（Keep it Simple and Stupid）</code> 设计原则。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2 id="rk算法">RK算法</h2><p>RK算法的全称叫 <em>Rabin-Karp算法</em>，是由它的两位发明者 <em>Rabin</em> 和 <em>Karp</em> 的名字来命名的。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.4.jpg" /></p><blockquote><p>通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p></blockquote><p>通过查表的方法来提高效率。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.5.jpg" /></p><h2 id="bm算法1">BM算法<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF算法和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.1.jpg" /></p><p>一次性把模式串往后多滑动几位，把模式串移动到c的后面。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.2.jpg" /></p><h3 id="bm算法原理分析">BM算法原理分析</h3><p>坏字符规则（bad character rule）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.3.jpg" /></p><p>没有匹配的字符叫作坏字符（主串中的字符）。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.7.jpg" /></p><p>好后缀规则（good suffix shift）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.10.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.12.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.13.jpg" /></p><p>BM算法代码实现</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.14.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把 <em>BM算法</em> 代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑si-xi计算得到的移动位数可能会出现负数的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.15.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.16.jpg" /></p><p>引入最关键的变量 <code>suffix数组</code></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.17.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.18.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.19.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.20.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.21.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.22.jpg" /></p><p>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp算法基本原理">KMP算法基本原理</h3><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的，算法的全称是Knuth Morris Pratt算法，简称为KMP算法。</p><p>KMP算法的核心思想，跟上一节讲的BM算法非常相近。我们假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>这里我们可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作 <em>坏字符</em>，把已经匹配的那段字符串叫作 <em>好前缀</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.3.jpg" /></p><p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.5.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失效函数计算方法</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.9.jpg" /></p><h2 id="小结">小结</h2><p><em>BF算法</em> 是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是O(n*m)，n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p><em>RK算法</em> 是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，<em>RK算法</em> 的时间复杂度是 <span class="math inline">\(O(n\)</span>)，跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 <span class="math inline">\(O(n*m\)</span>)。</p><p><em>BM算法</em> 尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。如果一遍看不懂的话，你就多看几遍。</p><p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法。</p><p>BM算法有两个规则，坏字符和好后缀。KMP算法借鉴BM算法的思想，可以总结成好前缀规则。这里面最难懂的就是next数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。</p><p>一种类似动态规划的方法，按照下标i从小到大，依次计算 <code>next[i]</code>，并且 <code>next[i]</code> 的计算通过前面已经计算出来的 <code>next[0]，next[1]，……，next[i-1]</code> 来推导。</p><p>KMP算法的时间复杂度是 <span class="math inline">\(O(n+m)\)</span>，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf" target="_blank" rel="noopener" class="uri">http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;预处理时间&lt;/th&gt;
&lt;th&gt;匹配时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;BF算法 / 朴素算法&lt;/td&gt;
&lt;td&gt;0 (无需预处理)&lt;/td&gt;
&lt;td&gt;Θ(nm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Rabin-Karp算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;平均 Θ(n + m),最差 Θ((n-m)m)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;基于有限状态机的搜索&lt;/td&gt;
&lt;td&gt;Θ(mk)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;克努斯-莫里斯-普拉特算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Boyer-Moore字符串搜索算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;最好Ω(n/m),最坏 O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Bitap算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;O(mn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-4-图（Graph）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/graph/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/graph/</id>
    <published>2020-04-08T08:08:48.000Z</published>
    <updated>2020-04-08T11:15:29.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>顶点（vertex）：图中的元素</li><li>边（edge）：一个顶点与任意其他顶点建立连接关系</li><li>度（degree）：跟顶点相连接的边的条数<ul><li>入度（In-degree）</li><li>出度（Out-degree）</li></ul></li><li>有向图：边有方向的图</li><li>无向图：边没有方向的图</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg" /></p><a id="more"></a><h2 id="邻接矩阵存储方法">邻接矩阵存储方法</h2><p>图最直观的一种存储方法就是，邻接矩阵（Adjacency Matrix）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点i与顶点j之间有边，我们就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 <code>1</code>；对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，那我们就将 <code>A[i][j]</code> 标记为 <code>1</code>。同理，如果有一条箭头从顶点 <code>j</code> 指向顶点i的边，我们就将 <code>A[j][i]</code> 标记为 <code>1</code>。对于带权图，数组中就存储相应的权重。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.3.jpg" /></p><p>稀疏图（Sparse Matrix）浪费存储空间。</p><h2 id="邻接表存储方法">邻接表存储方法</h2><h3 id="邻接表adjacency-list">邻接表（Adjacency List）</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.4.jpg" /></p><h3 id="逆邻接表">逆邻接表</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.5.jpg" /></p><h3 id="哈希算法等数据分片方">哈希算法等数据分片方</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.6.jpg" /></p><h3 id="数据库存储">数据库存储</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.7.jpg" /></p><h2 id="无向图代码">无向图代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q被访问，那相应的 <code>visited[q]</code> 会被设置为 <code>true</code>。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第 <code>k+1</code> 层的顶点。当我们访问到第k层的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第 <code>k+1</code> 层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。<code>prev[w]</code> 存储的是，顶点 <code>w</code> 是从哪个前驱顶点遍历过来的。比如，我们通过顶点2的邻接表访问到顶点3，那 <code>prev[3]</code> 就等于 <code>2</code>。为了正向打印出路径，我们需要递归地来打印，你可以看下 <code>print()</code> 函数的实现方式。</p><p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。</p><h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称DFS。最直观的例子就是“走迷宫”。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 <code>O(E)</code>，E表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 <code>visited</code>、<code>prev</code> 数组和递归调用栈。</p><p><code>visited</code>、<code>prev</code> 数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 <code>O(V)</code>。</p><h2 id="小结">小结</h2><p>无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。</p><p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><ul><li>深度：栈</li><li>广度：队列</li></ul><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如A<em>、IDA</em>等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点（vertex）：图中的元素&lt;/li&gt;
&lt;li&gt;边（edge）：一个顶点与任意其他顶点建立连接关系&lt;/li&gt;
&lt;li&gt;度（degree）：跟顶点相连接的边的条数
&lt;ul&gt;
&lt;li&gt;入度（In-degree）&lt;/li&gt;
&lt;li&gt;出度（Out-degree）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有向图：边有方向的图&lt;/li&gt;
&lt;li&gt;无向图：边没有方向的图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-3-堆（heap）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/heap/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/heap/</id>
    <published>2020-04-08T05:31:30.000Z</published>
    <updated>2020-04-08T11:14:59.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><a id="more"></a><h2 id="堆完全二叉树">堆（完全二叉树）</h2><p>比较适合用数组来存储</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.2.jpg" /></p><p>插入一个元素</p><p>堆化（heapify）</p><ul><li>从下往上</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.3.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) &#123; <span class="keyword">return</span>; &#125; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>删除堆顶元素</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.5.jpg" /></p><ul><li>从上往下</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含 <span class="math inline">\(n\)</span> 个节点的完全二叉树，树的高度不会超过 <span class="math inline">\(\log_{2}n\)</span>。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <span class="math inline">\(O(\log n)\)</span>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><h2 id="堆排序">堆排序</h2><h3 id="建堆">建堆</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.7.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.8.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下标从 <span class="math inline">\(\frac{n}{2}\)</span> 开始到 <span class="math inline">\(1\)</span> 的数据进行堆化，下标是 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点是叶子节点，不需要堆化。</p><p>对于完全二叉树来说，下标从 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.9.jpg" /></p><h3 id="排序">排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。它跟最后一个元素交换，那最大元素就放到了下标为 <span class="math inline">\(n\)</span> 的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，下标为 <span class="math inline">\(n\)</span> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <span class="math inline">\(n-1\)</span> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <span class="math inline">\(n-1\)</span> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <span class="math inline">\(1\)</span> 的一个元素，排序工作就完成了。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.10.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序要比堆排序性能好">快速排序要比堆排序性能好？</h2><ul><li>堆排序数据访问的方式没有快速排序友好</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.11.jpg" /></p><ul><li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</li></ul><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.12.jpg" /></p><h2 id="堆的应用">堆的应用</h2><ul><li>优先级队列<ul><li>依赖<ul><li>赫夫曼编码</li><li>图的最短路径</li><li>最小生成树算法</li></ul></li><li>具体<ul><li>合并有序小文件</li><li>高性能定时器</li></ul></li></ul></li><li>利用堆求 <code>Top K</code><ul><li><span class="math inline">\(n\)</span> 个数据的数组中，查找前 <span class="math inline">\(K\)</span> 大数据<ul><li>维护一个大小为 K 的小顶堆，顺序遍历数组</li></ul></li></ul></li><li>利用堆求中位数<ul><li>1 个大顶堆，1 个小顶堆</li><li>百分位数</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.13.jpg" /></p><p>删除堆顶数据和往堆中插入数据的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>，<span class="math inline">\(n\)</span> 表示堆中的数据个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.14.jpg" /></p><p>=======<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8<br />## 小结</p><p>堆是一种完全二叉树。</p><p>它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br />除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><p>堆的几个重要的应用，它们分别是：优先级队列、求Top K问题和求中位数问题。</p><h1 id="优先级队列是一种特殊的队列优先级高的数据先出队而不再像普通的队列那样先进先出实际上堆就可以看作优先级队列只是称谓不一样罢了求top-k问题又可以分为针对静态数据和针对动态数据只需要利用一个堆就可以做到非常高效率的查询top-k的数据求中位数实际上还有很多变形比如求99百分位数据90百分位数据等处理的思路都是一样的即利用两个堆一个大顶堆一个小顶堆随着数据的动态添加动态调整两个堆中的数据最后大顶堆的堆顶元素就是要求的数据">优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求Top K问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询Top K的数据。求中位数实际上还有很多变形，比如求99百分位数据、90百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</h1><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一个完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-2-树（Tree）</title>
    <link href="https://2020.iosdevlog.com/2020/04/06/tree/"/>
    <id>https://2020.iosdevlog.com/2020/04/06/tree/</id>
    <published>2020-04-06T04:10:33.000Z</published>
    <updated>2020-04-09T04:19:12.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><p>学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p>每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.2.jpg" /></p><p>A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.3.jpg" /></p><ol type="1"><li>高度（Height）</li><li>深度（Depth）</li><li>层（Level）</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.4.jpg" /></p><h2 id="二叉树binary-tree">二叉树（Binary Tree）</h2><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.5.jpg" /></p><p>两个子节点，分别是 <code>左子节点</code> 和 <code>右子节点</code>。</p><p>概念解释</p><ul><li><strong>节点</strong>：树中的每个元素称为节点</li><li><strong>父子关系</strong>：相邻两节点的连线，称为父子关系</li><li><strong>根节点</strong>：没有父节点的节点</li><li><strong>叶子节点</strong>：没有子节点的节点</li><li><strong>父节点</strong>：指向子节点的节点</li><li><strong>子节点</strong>：被父节点指向的节点</li><li><strong>兄弟节点</strong>：具有相同父节点的多个节点称为兄弟节点关系</li><li><strong>节点的高度</strong>：节点到叶子节点的最长路径所包含的边数</li><li><strong>节点的深度</strong>：根节点到节点的路径所包含的边数</li><li><strong>节点的层数</strong>：节点的深度+1（根节点的层数是1）</li><li><strong>树的高度</strong>：等于根节点的高度</li></ul><p>编号2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作 <strong>满二叉树</strong>。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.6.jpg" /></p><p>编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作 <strong>完全二叉树</strong>。</p><p>如何表示（或者存储）一棵二叉树？</p><ul><li>基于指针或者引用的 <code>链式存储法</code></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.7.jpg" /></p><ul><li>基于数组的 <code>顺序存储法</code><ul><li>根节点存储在下标 <code>i = 1</code> 的位置</li><li>那左子节点存储在下标 <code>2 * i</code> 的位置</li><li>右子节点存储在 <code>2 * i + 1</code> 的位置。</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.8.jpg" /></p><p><strong>堆其实就是一种完全二叉树，最常用的存储方式就是数组</strong></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.9.jpg" /></p><p>二叉树的遍历</p><ul><li>深度优先<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.10.jpg" /></p><p>递推公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>。</p><p>树是非线性表数据结构。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>，你需要理解并能用递归代码来实现。</p><h2 id="二叉查找树-二叉搜索树binary-search-tree">二叉查找树 / 二叉搜索树（Binary Search Tree）</h2><p>快速</p><ul><li>查找</li><li>插入</li><li>删除</li></ul><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.1.jpg" /></p><p>查找操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.2.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”。</p><p>快速地查找 <code>最大节点</code> 和 <code>最小节点</code>、<code>前驱节点</code> 和 <code>后继节点</code>。</p><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 <span class="math inline">\(O(n)\)</span>，非常高效。因此，二叉查找树也叫作 <strong>二叉排序树</strong>。</p><p>支持重复数据的二叉查找树</p><ol type="1"><li>对象中的其他字段叫作卫星数据。</li><li>对象的某个字段作为键值（key）来构建二叉查找树。<ol type="1"><li>链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</li><li>插入的数据放到这个节点的右子树。</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.7.jpg" /></p><p>时间复杂度分析</p><p>完全二叉树的高度小于等于 <span class="math inline">\(\log_{2} n\)</span></p><h3 id="散列表-vs-二叉查找树">散列表 vs 二叉查找树</h3><ol type="1"><li>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 <span class="math inline">\(O(1)\)</span>，非常高效。</li><li>叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)。</li></ol><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 <span class="math inline">\(O(n)\)</span> 的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 <span class="math inline">\(O(\log n)\)</span>。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 <span class="math inline">\(O(\log n)\)</span> 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><h3 id="二叉查找树小结">二叉查找树小结</h3><p>它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。</p><p>对于存在重复数据的二叉查找树，两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是O(n)和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，<code>平衡二叉查找树</code>，时间复杂度可以做到稳定的 <span class="math inline">\(O(logn)\)</span>。</p><h2 id="红黑树red-black-tree">红黑树（Red-Black Tree）</h2><p>平衡二叉查找树</p><ul><li>Splay Tree（伸展树）</li><li>Treap（树堆）</li><li>红黑树（简称 R-B Tree）</li></ul><blockquote><p>二叉树中任意一个节点的左右子树的高度相差不能大于1。</p></blockquote><p>从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.1.jpg" /></p><p>最先被发明的平衡二叉查找树是 <a href="https://zh.wikipedia.org/wiki/AVL树" target="_blank" rel="noopener">AVL树</a>。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。</p><ol type="1"><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.2.jpg" /></p><p>画图将黑色的、空的叶子节点都省略</p><blockquote><p>为什么说红黑树是“近似平衡”的？</p></blockquote><ul><li>“平衡”的意思可以等价为性能不退化。</li><li>“近似平衡”就等价为性能不会退化的太严重。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.3.jpg" /></p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。</p><p>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 <span class="math inline">\(\log_{2} n\)</span>，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。</p><h3 id="实现红黑树的基本思想">实现红黑树的基本思想</h3><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的 3、4 点恢复过来。</p><p>左旋（rotate left）：围绕某个节点的左旋<br />右旋（rotate right）：围绕某个节点的右旋</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.1.jpg" /></p><h4 id="插入操作的平衡调整">插入操作的平衡调整</h4><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</p><ul><li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li></ul><p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作 <strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的叔叔节点 d 是红色，我们就依次执行下面的操作：</p><ul><li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑ß色；</li><li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 <code>CASE 2</code> 或者 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.2.jpg" /></p><p><code>CASE 2</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：</p><ul><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点 b 左旋；</li><li>跳到 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.3.jpg" /></p><p><code>CASE 3</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：</p><p>围绕关注节点 a 的祖父节点 c 右旋；<br />将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。<br />调整结束。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.4.jpg" /></p><h4 id="删除操作的平衡调整">删除操作的平衡调整</h4><p>第一步：针对删除节点初步调整</p><p>初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</p><p><code>CASE 1</code>：如果要删除的节点是 a，它只有一个子节点 b</p><ul><li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li><li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li><li>调整结束，不需要进行二次调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.5.jpg" /></p><p><code>CASE 2</code>：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c 。我们就依次进行下面的操作：</p><ul><li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li><li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.6.jpg" /></p><p><code>CASE 3</code>：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点，我们就依次进行下面的操作：</p><ul><li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 <code>CASE 1</code>；</li><li>将节点 a 替换成后继节点 d ；</li><li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.7.jpg" /></p><p>第二步：针对关注节点进行二次调整</p><p>让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><p>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的兄弟节点 c 是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.8.jpg" /></p><p><code>CASE 2</code>：如果关注节点是a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d 、e都是黑色的，我们就依次进行下面的操作：</p><ul><li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红-黑”或者“黑-黑”；</li><li>关注节点从a变成其父节点 b ；</li><li>继续从四种情况中选择符合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.9.jpg" /></p><p><code>CASE 3</code>：如果关注节点是a，它的兄弟节点 c 是黑色，c的左子节点 d 是红色，c的右子节点e是黑色，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变；</li><li>跳转到 <code>CASE 4</code>，继续调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.10.jpg" /></p><p><code>CASE 4</code>：如果关注节点 a 的兄弟节点 c 是黑色的，并且c的右子节点是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li><li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li><li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>将关注节点 a 的叔叔节点e设置为黑色；</li><li>调整结束。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.11.jpg" /></p><blockquote><p>为什么要求叶子节点是黑色的空节点？</p></blockquote><p>为了实现起来方便。</p><p>假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.12.jpg" /></p><p>加上 “叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.13.jpg" /></p><p>会不会比较浪费存储空间呢？答案是不会的。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.14.jpg" /></p><h3 id="trie树-字典树">Trie树 / 字典树</h3><p>它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p><em>Trie树</em> 的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><p><code>how，hi，her，hello，so，see</code></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.1.jpg" /></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.2.jpg" /></p><p>构造过程的每一步，都相当于往Trie树中插入一个字符串。当所有字符串都插入完成之后，Trie树就构造好了。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.3.jpg" /></p><p>“her”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.4.jpg" /></p><p>“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.5.jpg" /></p><p>如何实现一棵 <em>Trie树</em>？</p><ol type="1"><li>将字符串集合构造成 <em>Trie树</em></li><li>在 <em>Trie树</em> 中查询一个字符串</li></ol><p><em>Trie树</em> 是一个多叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  BinaryTreeNode left;</span><br><span class="line">  BinaryTreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串中只有从 a 到 z 这26个小写字母</li><li>组中下标为 0 的位置，存储指向子节点 a 的指针</li><li>下标为 1 的位置存储指向子节点 b 的指针</li><li>某个字符的子节点不存在，对应的下标的位置存储 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在pattern</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 找到pattern</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建Trie树的过程，需要扫描所有的字符串，时间复杂度是O(n)（n表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是k，那我们只需要比对大约k个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好Trie树后，在其中查找字符串的时间复杂度是O(k)，k表示要查找的字符串的长度。</p><p>缩点优化</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.7.jpg" /></p><p>Trie树 与 散列表、红黑树 的比较</p><p>Trie树 比较适合的是查找前缀匹配的字符串</p><p>应用</p><ul><li>自动输入补全<ul><li>输入法自动补全功能</li><li>IDE代码编辑器自动补全功能</li><li>浏览器网址输入的自动补全功能</li></ul></li></ul><h3 id="内容小结">内容小结</h3><p>“红黑树一向都很难学”，有这种想法的人很多。其实主要原因是，很多人试图去记忆它的平衡调整策略。</p><ol type="1"><li><p>第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p></li><li><p>第二点，找准关注节点，不要搞丢、搞错关注节点。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p></li><li><p>第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p></li></ol><p>Trie树是一种解决字符串快速匹配问题的数据结构。如果用来构建Trie树的这一组字符串中，前缀重复的情况不是很多，那Trie树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p><p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 Trie树 中做字符串匹配还是非常高效的，时间复杂度是 <span class="math inline">\(O(k)\)</span>，k表示要匹配的字符串的长度。</p><p>但是，Trie树 的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie树 最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie树 比较经典的应用场景。</p><h2 id="高级">高级</h2><h2 id="实战">实战</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/126</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/05/slm/"/>
    <id>https://2020.iosdevlog.com/2020/04/05/slm/</id>
    <published>2020-04-05T14:41:34.000Z</published>
    <updated>2020-04-05T15:03:01.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/05/slm/2.png" /></p><a id="more"></a><ul><li>统计学习的定义、研究对象与方法</li><li>监督学习，这是本书的主要内容</li><li>统计学习方法的三要素<ul><li>模型</li><li>策略</li><li>算法</li></ul></li><li>模型选择<ul><li>正则化</li><li>交叉验证</li><li>学习的泛化能力</li></ul></li><li>生成模型与判别模型</li><li>监督学习方法的应用<ul><li>分类问题</li><li>标注问题</li><li>回归问题</li></ul></li></ul><h2 id="统计学习">统计学习</h2><h3 id="统计学习的特点">统计学习的特点</h3><p>统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。</p><p><strong>统计学习也称为统计机器学习（statistical machine learning）</strong>。</p><p>统计学习的主要特点是</p><ol type="1"><li>统计学习以计算机及网络为平台，是建立在计算机及网络之上的</li><li>统计学习以数据为研究对象，是数据驱动的学科</li><li>统计学习的目的是对数据进行预测与分析</li><li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析</li><li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论。</li></ol><p>赫尔伯特·西蒙（Herbert A. Simon）曾对“学习”给出以下定义</p><blockquote><p>“如果一个系统能够通过执行某个过程改进它的性能，这就是学习。”</p></blockquote><p>按照这一观点，统计学习就是计算机系统通过运用数据及统计方法提高系统性能的机器学习。<strong>现在，当人们提及机器学习时，往往是指统计机器学习。</strong></p><h3 id="统计学习的对象">统计学习的对象</h3><p>统计学习的对象是<strong>数据（data）</strong>。</p><p>它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。作为统计学习的对象，数据是多样的，包括存在于计算机及网络上的各种数字、文字、图像、视频、音频数据以及它们的组合。</p><p>统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。这里的同类数据是指具有某种共同性质的数据，例如英文文章、互联网网页、数据库中的数据等。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。</p><p>在统计学习过程中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。</p><p><strong>离散变量的方法为主。</strong>另外，本书只涉及利用数据构建模型及利用模型对数据进行 <strong>分析与预测</strong>，对数据的 <strong>观测和收集 </strong>等问题 <strong>不作讨论</strong>。</p><h3 id="统计学习的目的">统计学习的目的</h3><p>统计学习用于对数据进行预测与分析，特别是对未知新数据进行预测与分析。</p><ul><li>对数据的预测可以使计算机更加智能化，或者说使计算机的某些性能得到提高</li><li>对数据的分析可以让人们获取新的知识，给人们带来新的发现。</li></ul><h3 id="统计学习的方法">统计学习的方法</h3><p>统计学习的方法是基于数据构建统计模型从而对数据进行预测与分析。</p><p>统计学习由</p><ul><li>监督学习（supervised learning）</li><li>非监督学习（unsupervised learning）</li><li>半监督学习（semi-supervised learning）</li><li>强化学习（reinforcement learning）</li></ul><p>本书主要讨论 <strong>监督学习</strong>，这种情况下统计学习的方法可以概括如下：</p><ul><li>从给定的、有限的、用于学习的训练数据（training data）集合出发，假设数据是独立同分布产生的</li><li>并且假设要学习的模型属于某个函数的集合，称为假设空间（hypothesis space）</li><li>应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模型，使它对已知训练数据及未知测试数据（test data）在给定的评价准则下有最优的预测</li></ul><p>最优模型的选取由算法实现</p><p>统计学习方法的三要素：<strong>模型（model）、策略（strategy）和算法（algorithm）</strong></p><ul><li>模型： 模型的假设空间</li><li>策略： 模型选择的准则</li><li>算法： 模型学习的算法</li></ul><p>实现统计学习方法的步骤如下：</p><ol type="1"><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的假设空间，即学习模型的集合</li><li>确定模型选择的准则，即学习的策略</li><li>实现求解最优模型的算法，即学习的算法</li><li>通过学习方法选择最优模型</li><li>利用学习的最优模型对新数据进行预测或分析</li></ol><p>本书以介绍 <strong>统计学习方法为主</strong>，特别是 <strong>监督学习方法</strong>，主要包括用于分类、标注与回归问题的方法。这些方法在自然语言处理、信息检索、文本数据挖掘等领域中有着极其广泛的应用。</p><h3 id="统计学习的研究">统计学习的研究</h3><ul><li>统计学习方法（statistical learning method）<ul><li>开发新的学习方法</li></ul></li><li>统计学习理论（statistical learning theory）<ul><li>探求统计学习方法的有效性与效率</li><li>统计学习的基本理论问题</li></ul></li><li>统计学习应用（application of statistical learning）<ul><li>将统计学习方法应用到实际问题中去，解决实际问题</li></ul></li></ul><h3 id="统计学习的重要性">统计学习的重要性</h3><ul><li>统计学习是处理海量数据的有效方法</li><li>统计学习是计算机智能化的有效手段</li><li>统计学习是计算机科学发展的一个重要组成部分</li></ul><h2 id="监督学习">监督学习</h2><ul><li>监督学习</li><li>非监督学习</li><li>半监督学习</li><li>强化学习</li></ul><p>本书主要讨论 <strong>监督学习</strong> 问题。</p><p>监督学习（supervised learning）的 <strong>任务</strong> 是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p><h3 id="基本概念">基本概念</h3><h4 id="输入空间特征空间-与-输出空间"><strong>输入空间</strong>、<strong>特征空间 </strong>与 <strong>输出空间</strong></h4><p>在监督学习中，将输入与输出所有可能取值的集合分别称为 <strong>输入空间（input space）与输出空间（output space）</strong>。</p><ul><li><p>输入与输出空间可以是有限元素的集合，也可以是整个欧氏空间</p></li><li><p>输入空间与输出空间可以是同一个空间，也可以是不同的空间</p></li><li><p>但通常输出空间远远小于输入空间</p></li></ul><p>每个具体的输入是一个<strong>实例（instance）</strong>，通常由 <strong>特征向量（feature vector）</strong> 表示。这时，所有特征向量存在的空间称为 <strong>特征空间（feature space）</strong>。</p><p><strong>模型实际上都是定义在特征空间上的</strong></p><p>输入、输出变量用大写字母表示，习惯上输入变量写作 <span class="math inline">\(X\)</span>，输出变量写作 <span class="math inline">\(Y\)</span>。</p><p>输入、输出变量所取的值用小写字母表示，输入变量的取值写作 <span class="math inline">\(x\)</span>，输出变量的取值写作 <span class="math inline">\(y\)</span>。变量可以是标量或向量，都用相同类型字母表示。</p><p>本书中向量均为 <strong>列向量</strong>，输入实例 <span class="math inline">\(x\)</span> 的特征向量记作<br /><span class="math display">\[x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(i)}, \cdots, x^{(n)}\right)^{\mathrm{T}}\]</span><br /><span class="math inline">\(\mathbf{x}^{(\mathrm{i})}\)</span> 表示 <span class="math inline">\(x\)</span> 的第 <span class="math inline">\(i\)</span> 个特征。注意，<span class="math inline">\(\mathbf{x}^{(\mathrm{i})}\)</span> 与 <span class="math inline">\(\mathbf{x}_{\mathbf{i}}\)</span> 不同，本书通常用 <span class="math inline">\(\mathbf{x}_{\mathbf{i}}\)</span> 表示多个输入变量中的第 <span class="math inline">\(i\)</span> 个，即</p><p><span class="math display">\[x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}\]</span></p><p>监督学习从训练数据（training data）集合中学习模型，对测试数据（test data）进行预测。训练数据由输入（或特征向量）与输出对组成，训练集通常表示为</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>测试数据也由相应的输入与输出对组成。输入与输出对又称为 <strong>样本（sample）</strong> 或 <strong>样本点</strong>。</p><p>输入变量 X 和输出变量 <span class="math inline">\(Y\)</span> 有不同的类型，可以是 <strong>连续</strong> 的，也可以是 <strong>离散</strong> 的。</p><p>人们根据输入、输出变量的不同类型，对预测任务给予不同的名称</p><ul><li>回归问题: 输入变量与输出变量均为连续变量的预测问题</li><li>分类问题: 输出变量为有限个离散变量的预测问题</li><li>标注问题: 输入变量与输出变量均为变量序列的预测问题</li></ul><h4 id="联合概率分布">联合概率分布</h4><p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>。</p><p><span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 表示 <strong>分布函数</strong>，或 <strong>分布密度函数</strong>。注意，在学习过程中，假定这一联合概率分布存在，但对学习系统来说，联合概率分布的具体定义是未知的。训练数据与测试数据被看作是依联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 独立同分布产生的。统计学习假设数据存在一定的统计规律，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 具有联合概率分布的假设就是监督学习关于数据的基本假设。</p><h4 id="假设空间">假设空间</h4><p>监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。换句话说，学习的目的就在于找到最好的这样的模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间（hypothesis space）。假设空间的确定意味着学习范围的确定。</p><p>监督学习的模型可以是概率模型或非概率模型，由 <strong>条件概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{Y} | \mathrm{X})\)</span> 或 决策函数（decision function）<span class="math inline">\(Y=f(X)\)</span> 表示</strong>，随具体学习方法而定。对具体的输入进行相应的输出预测时，写作 <span class="math inline">\(\mathrm{P}(\mathrm{y} | \mathrm{x})\)</span> 或 <span class="math inline">\(Y=f(x)\)</span>。</p><h3 id="问题的形式化">问题的形式化</h3><p>监督学习利用训练数据集学习一个模型，再用模型对测试样本集进行预测（prediction）。</p><p>由于在这个过程中需要训练数据集，而训练数据集往往是人工给出的，所以称为 <strong>监督学习</strong>。</p><p>监督学习分为学习和预测两个过程</p><ul><li>学习系统</li><li>预测系统</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/1.png" /></p><p>图 1.1　监督学习问题</p><p>首先给定一个训练数据集</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>其中 <span class="math inline">\(\left(\mathrm{x}_{\mathrm{i}}, \mathrm{y}_{\mathrm{i}}\right), \quad \mathrm{i}=1,2, \ldots, \mathrm{N}\)</span>，称为样本或样本点。<span class="math inline">\(\mathbf{x}_{\mathbf{i}} \in \mathbf{X} \subseteq \mathbf{R}_{\mathbf{n}}\)</span> 输入的观测值，也称为输入或实例，<span class="math inline">\(\mathrm{y}_{\mathrm{i}} \in \mathcal{Y}\)</span> 是输出的观测值，也称为输出。</p><p>监督学习中，假设训练数据与测试数据是依联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 独立同分布产生的。</p><p>在学习过程中，学习系统利用给定的训练数据集，通过学习（或训练）得到一个模型，表示为条件概率分布 <span class="math inline">\(\hat{P}(\mathrm{Y} | \mathrm{X})\)</span> 或决策函数 <span class="math inline">\(\mathrm{Y}=\hat{f}(\mathrm{X})\)</span>。条件概率分布 <span class="math inline">\(\hat{P}(\mathrm{Y} | \mathrm{X})\)</span> 或决策函数 <span class="math inline">\(\mathrm{Y}=\hat{f}(\mathrm{X})\)</span> 描述输入与输出随机变量之间的映射关系。</p><p>在预测过程中，预测系统对于给定的测试样本集中的输入 <span class="math inline">\(\mathbf{X}_{\mathbf{N}+1}\)</span>，由模型 <span class="math inline">\(y_{N+1}=\arg \max _{y_{N+1}} \hat{P}\left(y_{N+1} | x_{N+1}\right)\)</span> 或 <span class="math inline">\(\mathrm{y}_{\mathrm{N}+1}=\hat{\jmath}\left(\mathrm{x}_{\mathrm{N}+1}\right)\)</span> 给出相应的输出 <span class="math inline">\(\mathbf{y}_{\mathrm{N}+1}\)</span>。</p><p>在学习过程中，<strong>学习系统</strong>（也就是 <strong>学习算法</strong>）试图通过训练数据集中的样本 <span class="math inline">\(\left(\mathbf{x}_{i}, \quad \mathbf{y}_{i}\right)\)</span> 带来的信息学习模型。</p><p>具体地说，</p><ul><li>对输入 <span class="math inline">\(\mathbf{X}_{\mathbf{i}}\)</span>，一个具体的模型 <span class="math inline">\(y=f(x)\)</span> 可以产生一个输出 <span class="math inline">\(\mathrm{f}\left(\mathrm{x}_{\mathrm{i}}\right)\)</span></li><li>训练数据集中对应的输出是 <span class="math inline">\(\mathbf{y}_{\mathrm{i}}\)</span></li><li>如果这个模型有很好的预测能力，训练样本输出 <span class="math inline">\(\mathbf{y}_{\mathrm{i}}\)</span> 和模型输出 <span class="math inline">\(\mathrm{f}\left(\mathrm{x}_{\mathrm{i}}\right)\)</span> 之间的差就应该足够小</li></ul><p>学习系统通过不断的尝试，选取最好的模型，以便对训练数据集有足够好的预测，同时对未知的测试数据集的预测也有尽可能好的推广。</p><h2 id="统计学习三要素">统计学习三要素</h2><p>统计学习方法都是由模型、策略和算法构成的，即统计学习方法由 <strong>三要素</strong> 构成，可以简单地表示为</p><p><strong>方法＝模型＋策略＋算法</strong></p><p>下面论述监督学习中的统计学习三要素。非监督学习、强化学习也同样拥有这三要素。可以说构建一种统计学习方法就是确定具体的统计学习三要素。</p><h3 id="模型">模型</h3><p>统计学习首要考虑的问题是学习什么样的模型。在监督学习过程中，模型就是所要学习的 <strong>条件概率分布</strong> 或 <strong>决策函数</strong>。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。</p><p>例如，假设决策函数是输入变量的线性函数，那么模型的假设空间就是所有这些线性函数构成的函数集合。假设空间中的模型一般有无穷多个。</p><p>假设空间用 <span class="math inline">\(\mathcal{F}\)</span> 表示。假设空间可以定义为决策函数的集合</p><p><span class="math display">\[\mathcal{F}=\{f | Y=f(X)\}\]</span></p><p>其中，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是定义在输入空间 <span class="math inline">\(x\)</span> 和输出空间 <span class="math inline">\(\mathcal{Y}\)</span> 上的变量。这时 <span class="math inline">\(\mathcal{F}\)</span> 通常是由一个参数向量决定的函数族：</p><p><span class="math display">\[\mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}\]</span></p><p>参数向量 <span class="math inline">\(\theta\)</span> 取值于 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(\mathbf{R}_{\mathrm{n}}\)</span>，称为参数空间（parameter space）。假设空间也可以定义为条件概率的集合</p><p><span class="math display">\[\mathcal{F}=\{P|P(Y | X)\}\]</span></p><p>其中，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是定义在输入空间 <span class="math inline">\(x\)</span> 和输出空间上的随 <span class="math inline">\(\mathcal{Y}\)</span> 机变量。这时 <span class="math inline">\(\mathcal{Y}\)</span> 通常是由一个参数向量决定的条件概率分布族：</p><p><span class="math display">\[\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.\]</span></p><p>参数向量 <span class="math inline">\(\theta\)</span> 取值于 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(\mathbf{R}_{\mathrm{n}}\)</span>，也称为参数空间。</p><p>本书中称由决策函数表示的模型为 <strong>非概率模型</strong>，由条件概率表示的模型为 <strong>概率模型</strong>。</p><h3 id="策略">策略</h3><p>有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。</p><p>统计学习的目标: <strong>从假设空间中选取最优模型</strong>。</p><p>首先引入损失函数与风险函数的概念。</p><ul><li>损失函数度量模型一次预测的好坏</li><li>风险函数度量平均意义下模型预测的好坏</li></ul><h4 id="损失函数和风险函数">损失函数和风险函数</h4><p>监督学习问题是在假设空间 <span class="math inline">\(\mathcal{F}\)</span>m中选取模型 <span class="math inline">\(f\)</span> 作为决策函数，对于给定的输入 <span class="math inline">\(X\)</span>，由 <span class="math inline">\(f(X)\)</span> 给出相应的输出 <span class="math inline">\(Y\)</span>，这个输出的预测值 <span class="math inline">\(f(X)\)</span> 与真实值 <span class="math inline">\(Y\)</span> 可能一致也可能不一致，用一个 <strong>损失函数（loss function） </strong>或 <strong>代价函数（cost function） </strong>来度量预测错误的程度。损失函数是 <span class="math inline">\(f(X)\)</span> 和 <span class="math inline">\(Y\)</span> 的非负实值函数，记作 <span class="math inline">\(\mathbf{L}(\mathbf{Y}, \mathrm{f}(\mathbf{X}))\)</span>。</p><p>统计学习常用的损失函数有以下几种：</p><ul><li><strong>0-1 损失函数（0-1 loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=\left\{\begin{array}{ll}{1,} &amp; {Y \neq f(X)} \\ {0,} &amp; {Y=f(X)}\end{array}\right.\]</span></p><ul><li><strong>平方损失函数（quadratic loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=(Y-f(X))^{2}\]</span></p><ul><li><strong>绝对损失函数（absolute loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=|Y-f(X)|\]</span></p><ul><li><strong>对数损失函数（logarithmic loss function）</strong>或 <strong>对数似然损失函数（loglikelihood loss function）</strong></li></ul><p><span class="math display">\[L(Y, P(Y | X))=-\log P(Y | X)\]</span></p><p>损失函数值越小，模型就越好。由于模型的输入、输出 <span class="math inline">\((\mathrm{X}, \mathrm{Y})\)</span> 是随机变量，遵循联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>，所以损失函数的期望是<br /><span class="math display">\[R_{\mathrm{exp}}(f)=E_{p}[L(Y, f(X))]=\int_{X \times y} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y\]</span></p><p>这是理论上模型 <span class="math inline">\(\mathrm{f}(\mathrm{X})\)</span> 关于联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 的平均意义下的损失，称为 <strong>风险函数（risk function）</strong> 或 <strong>期望损失（expected loss）</strong>。</p><p>学习的目标就是选择期望风险最小的模型。由于联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 是未知的，<span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 不能直接计算。实际上，如果知道联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>，可以从联合分布直接求出条件概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{Y} | \mathrm{X})\)</span>，也就不需要学习了。正因为不知道联合概率分布，所以才需要进行学习。</p><p>这样一来，一方面根据期望风险最小学习模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个 <strong>病态问题（ill-formed problem）</strong>。</p><p>给定一个训练数据集</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>模型 <span class="math inline">\(\mathrm{f}(\mathrm{X})\)</span> 关于训练数据集的平均损失称为 <strong>经验风险（empirical risk）</strong>或 <strong>经验损失（empirical loss）</strong>，记作 <span class="math inline">\(\mathbf{R}_{\mathrm{emp}}\)</span>：</p><p><span class="math display">\[R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)\]</span></p><p>期望风险 <span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 是模型关于联合分布的期望损失，经验风险 <span class="math inline">\(\mathrm{R}_{\mathrm{emp}}(\mathrm{f})\)</span> 是模型关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷时，经验风险 <span class="math inline">\(\mathrm{R}_{\mathrm{emp}}(\mathrm{f})\)</span> 趋于期望风险 <span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 。</p><p>这就关系到监督学习的两个基本策略：</p><ul><li>经验风险最小化</li><li>结构风险最小化</li></ul><h4 id="经验风险最小化与结构风险最小化">经验风险最小化与结构风险最小化</h4><p>经验风险最小化（empirical risk minimization，ERM）的策略认为：<strong>经验风险最小的模型是最优的模型</strong>。</p><p>根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：<br /><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)\]</span><br />其中，<span class="math inline">\(\mathcal{F}\)</span> 是假设空间。</p><p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。比如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。</p><p>当模型是 <strong>条件概率</strong> 分布，损失函数是 <strong>对数损失函数</strong> 时，经验风险最小化就等价于 <strong>极大似然估计</strong>。</p><p>但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生后面将要叙述的 <strong>“过拟合(over-fitting)”</strong> 现象。</p><p>结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。</p><p><strong>结构风险最小化</strong> 等价于 <strong>正则化（regularization）</strong>。</p><p><strong>结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）</strong>。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是<br /><span class="math display">\[R_{\mathrm{smn}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)\]</span><br />结构风险最小化的策略认为结构风险最小的模型是最优的模型。所以求最优模型，就是求解最优化问题：</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)\]</span><br />这样，监督学习问题就变成了 <strong>经验风险</strong> 或 <strong>结构风险函数</strong> 的最优化问题。</p><p>经验或结构风险函数是 <strong>最优化的目标函数</strong>。</p><h3 id="算法">算法</h3><p><strong>算法是指学习模型的具体计算方法</strong>。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。</p><p>这时，<strong>统计学习问题归结为最优化问题</strong>，统计学习的算法成为求解最优化问题的算法。如果最优化问题有显式的解析解，这个最优化问题就比较简单。但通常解析解不存在，这就需要用数值计算的方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。统计学习可以利用已有的最优化算法，有时也需要开发独自的最优化算法。</p><p><strong>统计学习方法之间的不同，主要来自其模型、策略、算法的不同。确定了模型、策略、算法，统计学习的方法也就确定了。这也就是将其称为统计学习三要素的原因。</strong></p><h2 id="统计学习方法总结">统计学习方法总结</h2><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/5.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/05/slm/2.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="slm" scheme="https://2020.iosdevlog.com/tags/slm/"/>
    
  </entry>
  
  <entry>
    <title>信息论</title>
    <link href="https://2020.iosdevlog.com/2020/04/05/Information-theory/"/>
    <id>https://2020.iosdevlog.com/2020/04/05/Information-theory/</id>
    <published>2020-04-05T14:20:38.000Z</published>
    <updated>2020-04-07T00:50:03.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/05/Information-theory/1.jpg" /></p><p>信息论（英语：information theory）是应用数学、电子学和计算机科学的一个分支，涉及信息的量化、存储和通信等。信息论是由克劳德·香农发展，用来找出信号处理与通信操作的基本限制，如数据压缩、可靠的存储和数据传输等。自创立以来，它已拓展应用到许多其他领域，包括统计推断、自然语言处理、密码学、神经生物学、进化论和分子编码的功能、生态学的模式选择、热物理、量子计算、语言学、剽窃检测、模式识别、异常检测和其他形式的数据分析。<br />熵是信息的一个关键度量，通常用一条消息中需要存储或传输一个符号的平均比特数来表示。熵衡量了预测随机变量的值时涉及到的不确定度的量。例如，指定掷硬币的结果（两个等可能的结果）比指定掷骰子的结果（六个等可能的结果）所提供的信息量更少（熵更少）。</p><a id="more"></a><p>信息论将信息的传递作为一种统计现象来考虑，给出了估算通信信道容量的方法。信息传输和信息压缩是信息论研究中的两大领域。这两个方面又由信道编码定理、信源－信道隔离定理相互联系。</p><p>信息论的基本内容的应用包括无损数据压缩（如ZIP文件）、有损数据压缩（如MP3和JPEG）、信道编码（如数字用户线路（DSL））。这个领域处在数学、统计学、计算机科学、物理学、神经科学和电机工程学的交叉点上。信息论对航海家深空探测任务的成败、光盘的发明、手机的可行性、互联网的发展、语言学和人类感知的研究、对黑洞的了解，以及许多其他领域都影响深远。信息论的重要子领域有信源编码、信道编码、算法复杂性理论、算法信息论、资讯理论安全性和信息度量等。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><ol type="1"><li>信息产生<ul><li>在面对大量信息时，排除噪音，提取利用有效信息，科学做决 策的能力;</li></ul></li><li>信息传播<ul><li>向外界传递信息时，平衡分配有限资源，增加沟通带宽，放大 影响力的能力;</li></ul></li><li>信息应用<ul><li>看懂信息应用的逻辑和通信发展的趋势，提前抓住新机遇的能力。</li></ul></li></ol><p>探索三件事：</p><ol type="1"><li>我们现在的位置</li><li>我们的目标</li><li>以及通向目标的道路</li></ol><h2 id="信息很重要">信息很重要</h2><ol type="1"><li>信息很重要，甚至比钱更重要，它能四两拨千斤。而信息作用的大小和信息量 有关。</li><li>信息量和不确定性有关，大家都知道的事，就没有什么信息量了。</li><li>对一个未知系统(黑盒子)所作出的估计和真实情况的偏离，就是信息的损失， 偏离越多损失越大。</li></ol><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/信息论" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/信息论</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/05/Information-theory/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;信息论（英语：information theory）是应用数学、电子学和计算机科学的一个分支，涉及信息的量化、存储和通信等。信息论是由克劳德·香农发展，用来找出信号处理与通信操作的基本限制，如数据压缩、可靠的存储和数据传输等。自创立以来，它已拓展应用到许多其他领域，包括统计推断、自然语言处理、密码学、神经生物学、进化论和分子编码的功能、生态学的模式选择、热物理、量子计算、语言学、剽窃检测、模式识别、异常检测和其他形式的数据分析。&lt;br /&gt;
熵是信息的一个关键度量，通常用一条消息中需要存储或传输一个符号的平均比特数来表示。熵衡量了预测随机变量的值时涉及到的不确定度的量。例如，指定掷硬币的结果（两个等可能的结果）比指定掷骰子的结果（六个等可能的结果）所提供的信息量更少（熵更少）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="information" scheme="https://2020.iosdevlog.com/tags/information/"/>
    
      <category term="theory" scheme="https://2020.iosdevlog.com/tags/theory/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-1-线性表</title>
    <link href="https://2020.iosdevlog.com/2020/04/04/algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/04/algorithm/</id>
    <published>2020-04-04T01:06:12.000Z</published>
    <updated>2020-04-08T08:44:43.491Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><p>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>基础架构研发工程师，写出达到开源水平的框架才是你的目标！</p><p>性能好坏起码是其中一个非常重要的评判标准。</p><p>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/algorithm.jpg" /></p><p>重点：</p><ol type="1"><li>首先要掌握一个数据结构与算法中最重要的概念——复杂度分析</li><li>10个数据结构<ol type="1"><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>散列表</li><li>二叉树</li><li>堆</li><li>跳表</li><li>图</li><li>Trie树</li></ol></li><li>10个算法<ol type="1"><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希算法</li><li>贪心算法</li><li>分治算法</li><li>回溯算法</li><li>动态规划</li><li>字符串匹配算法</li></ol></li><li>技巧<ol type="1"><li>边学边练，适度刷题</li><li>多问、多思考、多互动</li><li>打怪升级学习法</li><li>知识需要沉淀，不要想试图一下子掌握所有</li></ol></li></ol><h2 id="复杂度分析">复杂度分析</h2><ol type="1"><li>测试结果非常依赖测试环境</li><li>测试结果受数据规模的影响很大</li></ol><p>不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</p><p>大O复杂度表示法</p><p>在采用大O标记复杂度的时候，可以忽略系数</p><ul><li>大O时间复杂度表示法<ul><li>表示代码执行时间随数据规模增长的变化趋势</li><li>也叫作 <strong>渐进时间复杂度（asymptotic time complexity）</strong></li><li>简称 <strong>时间复杂度</strong></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.1.png" /></p><p><span class="math display">\[T(n)=O(f(n))\]</span></p><ol type="1"><li><code>n</code>：数据规模的大小</li><li><code>T(n)</code>：代码执行时间</li><li><code>f(n)</code>：每行代码执行的次数总和</li><li>公式中的 <code>O</code>，表示代码的执行时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比</li></ol><p>记录一个最大量级</p><p>时间复杂度分析</p><ol type="1"><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><p>几种常见时间复杂度实例分析</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.2.jpg" /></p><ol type="1"><li>多项式量级<ol type="1"><li>常量阶：<span class="math inline">\(O(1)\)</span><ol type="1"><li>不存在循环语句、递归语句</li></ol></li><li>对数阶：<span class="math inline">\(O(\log n)\)</span><ol type="1"><li>忽略对数的“底”</li></ol></li><li>线性阶：<span class="math inline">\(O(n)\)</span><ol type="1"><li><span class="math inline">\(O(m+n)\)</span></li></ol></li><li>线性对数阶： <span class="math inline">\(O(n \log n)\)</span><ol type="1"><li>归并排序</li><li>快速排序</li></ol></li><li>方阶：<ol type="1"><li>平方阶： <span class="math inline">\(O(n^2)\)</span></li><li>立方阶： <span class="math inline">\(O(n^3)\)</span></li><li><span class="math inline">\(k\)</span> 次方阶： <span class="math inline">\(O(n^{k})\)</span></li></ol></li></ol></li><li>非多项式量级（低效）<ol type="1"><li>指数阶：<span class="math inline">\(O(2^{n})\)</span></li><li>阶乘阶：<span class="math inline">\(O(n!)\)</span></li></ol></li></ol><p>空间复杂度分析</p><ul><li>大O时间复杂度表示法<ul><li>算法的存储空间与数据规模之间的增长关系</li><li>也叫作 <strong>渐进空间复杂度（asymptotic space complexity）</strong></li><li>简称 <strong>空间复杂度</strong></li></ul></li></ul><ol type="1"><li><span class="math inline">\(O(1)\)</span></li><li><span class="math inline">\(O(n)\)</span></li><li><span class="math inline">\(O(n^{2})\)</span></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.3.jpg" /></p><p>四个复杂度分析</p><ol type="1"><li>最好情况时间复杂度（best case time complexity）<ol type="1"><li>最理想的情况</li></ol></li><li>最坏情况时间复杂度（worst case time complexity）<ol type="1"><li>最糟糕的情况</li></ol></li><li>平均情况时间复杂度（average case time complexity）<ol type="1"><li>加权平均值</li><li>全称：<strong>加权平均时间复杂度</strong></li><li>期望值</li><li>全称：<strong>期望时间复杂度</strong></li></ol></li><li>均摊时间复杂度（amortized time complexity）<ol type="1"><li>摊还分析 / 平摊分析</li><li><strong>均摊时间复杂度</strong> 就是一种 <code>特殊</code> 的 <strong>平均时间复杂度</strong></li></ol></li></ol><h2 id="基础">基础</h2><h3 id="数组array">数组（Array）</h3><p>数组（Array）是一种 <code>线性表</code> 数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><ul><li>线性表（Linear List）<ul><li>线性表就是数据排成像一条线一样的结构</li><li>每个线性表上的数据最多只有前和后两个方向</li><li>类型<ol type="1"><li><strong>数组</strong></li><li>链表</li><li>队列</li><li>栈</li></ol></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg" /></p><ul><li>非线性表<ol type="1"><li>二叉树</li><li>堆</li><li>图</li></ol></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.2.jpg" /></p><ul><li>连续的内存空间和相同类型的数据<ul><li>随机访问</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.3.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>低效的“插入”和“删除”</p><ul><li>插入操作<ul><li>交换最后</li><li>快排</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.4.jpg" /></p><ul><li>删除操作<ul><li>记录下已经删除的数据</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.5.jpg" /></p><h4 id="警惕数组的访问越界问题">警惕数组的访问越界问题</h4><h4 id="容器能否完全替代数组">容器能否完全替代数组？</h4><p><code>Java</code> ： <code>ArrayList</code><br /><code>C++ STL</code>： <code>vector</code></p><ul><li>将很多数组操作的细节封装起来</li><li>支持动态扩容</li></ul><p>数组 vs 容器：</p><ol type="1"><li>数组<ol type="1"><li>底层开发</li><li>关注性能 / 基本类型</li><li>数据大小事先已知 / 操作简单</li><li>多维数组直观</li></ol></li><li>容器<ol type="1"><li>业务开发</li></ol></li></ol><h4 id="数组要从0开始编号">数组要从0开始编号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><ol type="1"><li>“偏移（offset）”</li><li>习惯：C语言设计者用 <span class="math inline">\(0\)</span> 开始计数数组下标，</li></ol><h4 id="小结">小结</h4><p>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h3 id="链表linked-list">链表（Linked list）</h3><p>缓存</p><ol type="1"><li>CPU缓存</li><li>数据库缓存</li><li>浏览器缓存</li></ol><p>缓存淘汰策略</p><ol type="1"><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ol><p>底层的存储结构</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.1.jpg" /></p><ol type="1"><li>单链表</li><li>循环链表</li><li>双向链表</li></ol><h4 id="单链表">单链表</h4><p>结点： 内存块<br />后继指针 next</p><ol type="1"><li><strong>头结点</strong>：第一个结点</li><li><strong>尾结点</strong>：最后个结点<ul><li>指向一个空地址 <code>NULL</code></li></ul></li></ol><p>查找、插入和删除操作</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.2.jpg" /></p><h4 id="循环链表">循环链表</h4><p>循环链表是一种特殊的单链表</p><p>约瑟夫问题</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.3.jpg" /></p><h4 id="双向链表">双向链表</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.4.jpg" /></p><p>删除操作</p><ul><li>删除结点中“值等于某个给定值”的结点<ul><li><span class="math inline">\(O(n)\)</span></li></ul></li><li>删除给定指针指向的结点<ul><li><span class="math inline">\(O(1)\)</span></li></ul></li></ul><p><strong>用空间换时间</strong> 的 <code>设计思想</code></p><ol type="1"><li>缓存</li><li>双向链表</li></ol><h4 id="双向循环链表">双向循环链表</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.5.jpg" /></p><h4 id="链表-vs-数组性能">链表 VS 数组性能</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.6.jpg" /></p><h4 id="lruleast-recently-used缓存">LRU（Least Recently Used）缓存</h4><ol type="1"><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol type="1"><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol></li></ol><h4 id="代码技巧">代码技巧</h4><ol type="1"><li>理解指针或引用的含义</li><li>警惕指针丢失和内存泄漏<ol type="1"><li>插入结点时，一定要注意操作的顺序</li><li>删除链表结点时，也一定要记得手动释放内存空间</li></ol></li><li>利用哨兵简化实现难度<ol type="1"><li>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</li></ol></li><li>重点留意边界条件处理<ol type="1"><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ol></li><li>举例画图，辅助思考</li><li>多写多练，没有捷径<ol type="1"><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.3.jpg" /></p><h4 id="内容小结">内容小结</h4><p>链表跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h3 id="栈2">栈<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h3><p>后进先出</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.1.jpg" /></p><p>栈是一种“操作受限”的线性表</p><p>操作</p><ul><li>插入：<strong>入栈 push()</strong></li><li>删除：<strong>出栈 pop()</strong></li></ul><p>栈顶指针</p><p>支持动态扩容的顺序栈</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.3.jpg" /></p><p>栈在函数调用中的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.4.jpg" /></p><p>栈在表达式求值中的应用</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.5.jpg" /></p><p>栈在括号匹配中的应用</p><p><span class="math display">\[{[()]}\]</span></p><p>浏览器的前进和后退</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.9.jpg" /></p><h3 id="队列">队列</h3><p>操作受限的线性表数据结构</p><p>操作</p><ul><li>插入：<strong>入队 enqueue()</strong></li><li>删除：<strong>出队 dequeue()</strong></li></ul><p>先进先出</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.1.jpg" /></p><table><thead><tr class="header"><th>实现</th><th>数组</th><th>链表</th></tr></thead><tbody><tr class="odd"><td>栈</td><td>顺序栈</td><td>链式栈</td></tr><tr class="even"><td>队列</td><td>顺序队列</td><td>链式队列</td></tr></tbody></table><ul><li>一个是 <code>head</code> 指针，指向队头</li><li>一个是 <code>tail</code> 指针，指向队尾</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.3.jpg" /></p><p>数据搬移</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.4.jpg" /></p><h4 id="基于链表的队列实现方法">基于链表的队列实现方法</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.5.jpg" /></p><h4 id="循环队列">循环队列</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.8.jpg" /></p><h4 id="阻塞队列和并发队列">阻塞队列和并发队列</h4><p>阻塞队列：生产者-消费者模型</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.10.jpg" /></p><p>并发队列：线程安全的队列</p><p>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h4 id="内容小结-1">内容小结</h4><p>队列：一种跟栈很相似的数据结构。</p><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p><p>循环队列是我们这节的重点。要想写出没有bug的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p><p>除此之外，我们还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h3 id="递归">递归</h3><ul><li>去的过程叫“递”</li><li>回来的过程叫“归”</li></ul><p>递归需要满足的三个条件</p><ol type="1"><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><p>编写递归代码</p><ol type="1"><li>写出递推公式</li><li>找到终止条件</li><li>递推公式 -&gt; 代码</li></ol><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><ul><li><p>递归代码要警惕堆栈溢出</p></li><li><p>递归代码要警惕重复计算</p><ul><li>通过一个数据结构（比如散列表）来保存已经求解过的f(k)</li></ul></li><li><p>递归代码 -&gt; 为非递归代码（迭代循环）</p></li></ul><h4 id="内容小结-2">内容小结</h4><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><h3 id="排序">排序</h3><p>排序比较<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><table><thead><tr class="header"><th>排序</th><th>排序算法</th></tr></thead><tbody><tr class="odd"><td>理论</td><td>计算复杂性理论 大O符号 全序关系 数据结构列表 原地算法 稳定性 比较排序 自适应排序 排序网络 整数排序 X+Y排序 量子排序</td></tr><tr class="even"><td>交换排序</td><td>冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序</td></tr><tr class="odd"><td>选择排序</td><td>选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序 弱堆排序</td></tr><tr class="even"><td>插入排序</td><td>插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序</td></tr><tr class="odd"><td>归并排序</td><td>归并排序 梯级归并排序 振荡归并排序 多相归并排序</td></tr><tr class="even"><td>分布排序</td><td>美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 比較計數排序 插值排序 鸽巢排序 相邻图排序 基数排序 闪电排序</td></tr><tr class="odd"><td>并发排序</td><td>双调排序器 Batcher归并网络 两两排序网络</td></tr><tr class="even"><td>混合排序</td><td>塊排序 Tim排序 内省排序 Spread排序 归并插入排序</td></tr><tr class="odd"><td>其他</td><td>拓扑排序 煎餅排序 意粉排序</td></tr></tbody></table><figure><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.en.png" alt="" /><figcaption>en</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.zh.png" alt="" /><figcaption>zh</figcaption></figure><ul><li>均按从小到大排列</li><li>k 代表数值中的"数位"个数</li><li>n 代表数据规模</li><li>m 代表数据的最大值减最小值</li></ul><p>如何分析一个“排序算法”？</p><ol type="1"><li>排序算法的执行效率<ol type="1"><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ol></li><li>排序算法的内存消耗<ol type="1"><li>原地排序（Sorted in place）</li><li>空间复杂度是O(1)</li></ol></li><li>排序算法的稳定性</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.1.jpg" /></p><h4 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure><p>原子操作：</p><ol type="1"><li>比较</li><li>交换</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.3.jpg" /></p><p>优化</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有序度</p><p>有序元素对：<span class="math inline">\(a[i] &lt;= a[j]\)</span>, 如果 <span class="math inline">\(i &lt; j\)</span>。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.5.jpg" /></p><p>满有序度</p><p><span class="math inline">\(n*(n-1)/2\)</span></p><p><strong>逆序度 = 满有序度 - 有序度</strong></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.6.jpg" /></p><p>交换一次，有序度就加 1。</p><h4 id="插入排序insertion-sort">插入排序（Insertion Sort）</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.7.jpg" /></p><p>数据分为两个区间</p><ol type="1"><li>已排序区间</li><li>未排序区间</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.8.jpg" /></p><p>原子操作：</p><ol type="1"><li>比较</li><li>移动</li></ol><p>移动次数 = 逆序度</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.9.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么插入排序要比冒泡排序更受欢迎？</p></blockquote><p>冒泡排序中数据的交换操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序中数据的移动操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序selection-sort">选择排序（Selection Sort）</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.10.jpg" /></p><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。</p><p>但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><span class="math inline">\(O(n^{2})\)</span> 的排序算法：冒泡排序、插入排序、选择排序</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.11.jpg" /></p><h4 id="归并排序merge-sort">归并排序（Merge Sort）</h4><p>归并排序的核心思想</p><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.1.jpg" /></p><p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><ul><li><code>分治</code> 是一种解决问题的处理思想</li><li><code>递归</code> 是一种编程技巧</li></ul><p>递推公式：</p><p><span class="math inline">\(merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\)</span></p><p>终止条件：</p><p><span class="math inline">\(p &gt;= r\)</span> 不用再继续分解</p><p><code>merge_sort(p…r)</code> 表示，给下标从 <code>p</code> 到 <code>r</code> 之间的数组排序。我们将这个排序问题转化为了两个子问题，<code>merge_sort(p…q)</code> 和 <code>merge_sort(q+1…r)</code>，其中下标 <code>q</code> 等于 <code>p</code> 和 <code>r</code> 的中间位置，也就是 <code>(p+r)/2</code>。当下标从 <code>p</code> 到 <code>q</code> 和从 <code>q+1</code> 到 <code>r</code> 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 <code>p</code> 到 <code>r</code> 之间的数据就也排好序了。</p><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A是数组，n表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.2.jpg" /></p><p><code>merge</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r]) &#123;</span><br><span class="line">  <span class="keyword">var</span> i := p，j := q+<span class="number">1</span>，k := <span class="number">0</span> <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">  <span class="keyword">var</span> tmp := <span class="keyword">new</span> array[<span class="number">0</span>...r-p] <span class="comment">// 申请一个大小跟A[p...r]一样的临时数组</span></span><br><span class="line">  <span class="keyword">while</span> i&lt;=q AND j&lt;=r <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">  <span class="keyword">var</span> start := i，end := q</span><br><span class="line">  <span class="keyword">if</span> j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">  <span class="keyword">while</span> start &lt;= end <span class="keyword">do</span> &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将tmp中的数组拷贝回A[p...r]</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> to r-p <span class="keyword">do</span> &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序-快排quicksort">快速排序 / 快排（Quicksort）</h4><p>快排的思想：</p><p>如果要排序数组中下标从 <code>p</code> 到 <code>r</code> 之间的一组数据，我们选择 <code>p</code> 到 <code>r</code> 之间的任意一个数据作为 <code>pivot（分区点）</code>。</p><p>遍历 <code>p</code> 到 <code>r</code> 之间的数据，将小于 <code>pivot</code> 的放到左边，将大于 <code>pivot</code> 的放到右边，将 <code>pivot</code> 放到中间。经过这一步骤之后，数组 <code>p</code> 到 <code>r</code> 之间的数据就被分成了三个部分，前面 <code>p</code> 到 <code>q-1</code> 之间都是小于 <code>pivot</code> 的，中间是 <code>pivot</code>，后面的 <code>q+1</code> 到 <code>r</code> 之间是大于 <code>pivot</code> 的。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.3.jpg" /></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从 <code>p</code> 到 <code>q-1</code> 之间的数据和下标从 <code>q+1</code> 到 <code>r</code> 之间的数据，直到区间缩小为 <code>1</code>，就说明所有的数据都有序了。</p><p>递推公式：</p><p><span class="math inline">\(quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)\)</span></p><p>终止条件：</p><p><span class="math inline">\(p &gt;= r\)</span></p><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A是数组，n表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">  quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个 <code>merge()</code> 合并函数，我们这里有一个 <code>partition()</code> 分区函数。</p><p><code>partition()</code>分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 <code>pivot</code>（一般情况下，可以选择p到r区间的最后一个元素），然后对 <code>A[p…r]</code> 分区，函数返回 <code>pivot</code> 的下标。</p><p>不考虑空间消耗，申请 2 个新数组</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.4.jpg" /></p><p>考虑空间消耗，原地分区函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot := A[r]</span><br><span class="line">  i := p</span><br><span class="line">  <span class="keyword">for</span> j := p to r-<span class="number">1</span> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i := i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.5.jpg" /></p><p>归并排序 VS 快排</p><ol type="1"><li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。</li><li>快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</li></ol><blockquote><p>为什么 <strong>归并排序</strong> 并没有像 <strong>快排</strong> 应用广泛？</p></blockquote><p>归并排序有一个致命的“弱点”，不是原地排序算法。</p><p>内容小结</p><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 <code>merge()</code> 合并函数。同理，理解快排的重点也是理解递推公式，还有 <code>partition()</code> 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 <span class="math inline">\(O(n)\)</span>。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 <span class="math inline">\(O(n^{2})\)</span>，但是平均情况下时间复杂度都是 <span class="math inline">\(O(n \log n)\)</span>。不仅如此，快速排序算法时间复杂度退化到 <span class="math inline">\(O(n^{2})\)</span> 的概率非常小，我们可以通过合理地选择 <code>pivot</code> 来避免这种情况。</p><h4 id="桶排序bucket-sort">桶排序（Bucket sort）</h4><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.1.jpg" /></p><p>复杂度： <span class="math inline">\(O(n)\)</span></p><p>如果要排序的数据有 <span class="math inline">\(n\)</span> 个，我们把它们均匀地划分到 <span class="math inline">\(m\)</span> 个桶内，每个桶里就有 <span class="math inline">\(k=n/m\)</span> 个元素。每个桶内部使用快速排序，时间复杂度为 <span class="math inline">\(O(k * \log k)\)</span>。m个桶排序的时间复杂度就是 <span class="math inline">\(O(m * k * \log k)\)</span>，因为 <code>k=n/m</code>，所以整个桶排序的时间复杂度就是 <span class="math inline">\(O(n*log(n/m))\)</span>。当桶的个数m接近数据个数 <span class="math inline">\(n\)</span> 时，<span class="math inline">\(log(n/m)\)</span> 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 <span class="math inline">\(O(n)\)</span>。</p><blockquote><p>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</p></blockquote><p>答案当然是否定的。为了让你轻松理解桶排序的核心思想，我刚才做了很多假设。实际上，桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 <code>m</code> 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 <span class="math inline">\(O(n \log n)\)</span> 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><h4 id="计数排序counting-sort桶排序的一种特殊情况">计数排序（Counting sort）：桶排序的一种特殊情况</h4><p>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>示例：高考分数</p><p>满分是 <span class="math inline">\(900\)</span> 分，最小是 <span class="math inline">\(0\)</span> 分，可以分成 <span class="math inline">\(901\)</span> 个桶，对应分数从 <span class="math inline">\(0\)</span> 分到 <span class="math inline">\(900\)</span> 分。</p><p>桶内的数据都是分数相同的考生，所以并不需要再进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">8</span>] = &#123; <span class="number">2</span>，<span class="number">5</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>C[6] 表示桶 ,其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.3.jpg" /></p><blockquote><p>如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？</p></blockquote><p>思路是这样的：我们对C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数k的考生个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.5.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序只能用在数据范围不大的场景中，如果数据范围 <code>k</code> 比要排序的数据 <code>n</code> 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p><h4 id="基数排序radix-sort">基数排序（Radix sort）</h4><p>手机号码从小到大排序</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.6.jpg" /></p><p>按照每位来排序的排序算法要是稳定的。</p><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</p><p>线性排序（Linear sort）/ 复杂度是 <span class="math inline">\(O(n)\)</span> 的排序算法：桶排序、计数排序、基数排序</p><p>它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。</p><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p><h4 id="如何实现一个通用的高性能的排序函数">如何实现一个通用的、高性能的排序函数？</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/14.jpg" /></p><ol type="1"><li>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</li><li>首选时间复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的排序算法<ol type="1"><li>小规模数据进行排序，可以选择时间复杂度是 <span class="math inline">\(O(n^{2})\)</span> 的算法</li><li>大规模数据进行排序，时间复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的算法更加高效</li></ol></li><li>对于小数据量的排序，不需要递归的插入排序算法</li></ol><blockquote><p>如何优化快速排序？</p></blockquote><p>被分区点分开的两个分区中，数据的数量差不多。</p><ol type="1"><li>三数取中法</li><li>随机法</li></ol><p>堆栈溢出</p><ol type="1"><li>限制递归深度<ul><li>超过了我们事先设定的阈值，就停止递归</li></ul></li><li>堆上模拟实现一个函数调用栈<ul><li>手动模拟递归压栈、出栈的过程</li></ul></li></ol><p>分析了一下如何来实现一个工业级的通用的、高效的排序函数，内容比较偏实战，而且贯穿了一些前面几节的内容，你要多看几遍。我们大部分排序函数都是采用O(nlogn)排序算法来实现，但是为了尽可能地提高性能，会做很多优化。</p><p>快速排序的一些优化策略，比如合理选择分区点、避免递归太深等等。</p><p>C语言中 <code>qsort()</code> 的底层实现原理：</p><ol type="1"><li>分区点<ul><li>三数取中法</li></ul></li><li>堆栈溢出<ul><li>实现一个堆上的栈，手动模拟递归</li></ul></li><li>元素的个数 &lt;= 4<ul><li>插入排序</li></ul></li><li>优先使用<ul><li>归并排序</li></ul></li><li>数据量比较大<ul><li>快速排序</li></ul></li></ol><h3 id="二分查找binary-search-折半查找">二分查找（Binary Search）/ 折半查找</h3><p>猜数字游戏</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.2.jpg" /></p><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><p><span class="math inline">\(O(\log n)\)</span> 惊人的查找速度</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.3.jpg" /></p><p><span class="math inline">\(O(\log n)\)</span> 对数时间复杂度</p><p>二分查找的递归与非递归实现</p><p>循环实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="comment">// low+((high-low)&gt;&gt;1)</span></span><br><span class="line">    <span class="comment">// low+(high-low)/2</span></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易出错的3个地方</p><ol type="1"><li>循环退出条件</li><li>mid 的取值</li><li>low 和 high 的更新</li></ol><p>递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找应用场景的局限性</p><ol type="1"><li>二分查找依赖的是顺序表结构，简单点说就是数组</li><li>二分查找针对的是有序数据</li><li>数据量太小不适合二分查找</li><li>数据量太大也不适合二分查找<ul><li>连续内存空间</li></ul></li></ol><p>二分查找是一种针对有序数据的高效查找算法，它的时间复杂度是 <span class="math inline">\(O(\log n)\)</span>。</p><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0 。但是二分查找的代码实现比较容易写错。</p><p>着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><p>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第3卷《排序和查找》中说到：“尽管第一个二分查找算法于1946年出现，然而第一个完全正确的二分查找算法实现直到1962年才出现。”</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/16.1.jpg" /></p><h3 id="跳表">跳表</h3><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.2.jpg" /></p><p>这种链表加多级索引的结构，就是跳表。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.3.jpg" /></p><p>空间换时间</p><p>插入操作</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.4.jpg" /></p><p>跳表索引动态更新</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.5.jpg" /></p><p>随机函数生成了值K</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.6.jpg" /></p><p>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>跳表的空间复杂度是 <span class="math inline">\(O(n)\)</span>。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p><h3 id="散列表-哈希表-hash表hash-table">散列表 / 哈希表 / Hash表（Hash Table）</h3><p><code>散列表</code> 用的是 <code>数组</code> 支持按照 <em>下标随机访问</em> 数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><p>编号我们叫作 <code>键（key）</code> 或者 <code>关键字</code>。</p><p>编号转化为数组下标的映射方法就叫作 <code>散列函数（或“Hash函数”“哈希函数”）</code>。</p><p>而散列函数计算得到的值就叫作 <code>散列值（或“Hash值”“哈希值”）</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.1.jpg" /></p><p>时间复杂度是 <span class="math inline">\(O(1)\)</span></p><p>散列函数</p><p><code>hash(key)</code> 的值表示经过散列函数计算得到的散列值。</p><p>散列函数设计的基本要求：</p><ol type="1"><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)</code>；</li><li>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)</code>。</li></ol><p>散列冲突</p><ul><li>开放寻址法（open addressing）<ul><li>线性探测（Linear Probing）<ul><li><span class="math inline">\(hash(key)+0，hash(key)+1，hash(key)+2……\)</span></li></ul></li><li>二次探测（Quadratic probing）<ul><li><span class="math inline">\(hash(key)+0，hash(key)+1^{2}，hash(key)+2^{2}……\)</span></li></ul></li><li>双重散列（Double hashing）<ul><li><span class="math inline">\(hash1(key)，hash2(key)，hash3(key)……\)</span></li></ul></li></ul></li></ul><p>插入</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.2.jpg" /></p><p>查找</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.3.jpg" /></p><p>删除：特殊标记为 <code>deleted</code></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.4.jpg" /></p><p>装载因子（load factor）来表示空位的多少</p><p><span class="math display">\[散列表的装载因子 = 填入表中的元素个数 / 散列表的长度\]</span></p><ul><li>链表法（chaining）</li></ul><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.5.jpg" /></p><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><h4 id="如何设计散列函数">如何设计散列函数？</h4><ol type="1"><li>散列函数的设计不能太复杂</li><li>散列函数生成的值要尽可能随机并且均匀分布</li></ol><p>方法：</p><ol type="1"><li>数据分析法</li><li>直接寻址法</li><li>平方取中法</li><li>折叠法</li><li>随机数法</li></ol><p>动态扩容的散列表</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.1.jpg" /></p><p>如何避免低效地扩容？</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.2.jpg" /></p><p>如何选择冲突解决方法？</p><ul><li>开放寻址法</li></ul><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p><p><code>Java</code> 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</p><ul><li>链表法</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.3.jpg" /></p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><p>工业级散列表举例分析：<code>Java</code> 中的 <code>HashMap</code></p><ol type="1"><li>初始大小<ul><li>默认的初始大小是16</li></ul></li><li>装载因子和动态扩容<ul><li>最大装载因子默认是0.75</li><li>超过 0.75*capacity（capacity表示散列表的容量）的时候，启动扩容</li><li>每次扩容都会扩容为原来的两倍大小</li></ul></li><li>散列冲突解决方法<ul><li>&lt; 8：链表法</li><li>&gt; 8：红黑树</li></ul></li><li>散列函数<ul><li>简单高效</li><li>分布均匀</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">// capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p><p>为什么散列表和链表经常会一起使用</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/20.1.jpg" /></p><p>使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。</p><p>散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="哈希算法">哈希算法</h3><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是 <code>哈希算法</code>，而通过原始数据映射之后得到的二进制值串就是 <code>哈希值</code>。</p><p>要求：</p><ol type="1"><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ol><p><code>MD5</code> 的哈希值是 <code>128位</code> 的 <code>Bit</code> 长度</p><p>应用 (盐（salt）)</p><ol type="1"><li>安全加密<ul><li>MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）</li><li>SHA（Secure Hash Algorithm，安全散列算法）</li><li>DES（Data Encryption Standard，数据加密标准）</li><li>AES（Advanced Encryption Standard，高级加密标准）</li></ul></li><li>唯一标识<ul><li>完整性和正确性</li><li>信息摘要</li><li>网盘秒传</li></ul></li><li>数据校验<ul><li>下载校验</li></ul></li><li>散列函数<ul><li>简单</li><li>追求效率</li></ul></li><li>负载均衡<ul><li>客户端 IP地址 或者 会话ID 与 服务器编号 映射</li></ul></li><li>数据分片<ul><li>MapReduce</li></ul></li><li>分布式存储<ul><li>一致性哈希算法</li></ul></li></ol><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/126</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener" class="uri">https://github.com/wangzheng0822/algo</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/排序算法" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/排序算法</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基础架构研发工程师，写出达到开源水平的框架才是你的目标！&lt;/p&gt;
&lt;p&gt;性能好坏起码是其中一个非常重要的评判标准。&lt;/p&gt;
&lt;p&gt;数据结构是为算法服务的，算法要作用在特定的数据结构之上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>InfoQ 写作平台</title>
    <link href="https://2020.iosdevlog.com/2020/04/03/infoq/"/>
    <id>https://2020.iosdevlog.com/2020/04/03/infoq/</id>
    <published>2020-04-03T15:47:28.000Z</published>
    <updated>2020-04-03T16:24:14.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/1.png" /></p><a id="more"></a><p>前几天收到 InfoQ 的邮件。</p><p>您已通过审核。</p><p>感谢您的内测申请，很高兴邀请您加入 InfoQ 写作平台。<br />以下是关于入驻平台的相关信息，还请仔细阅读：<br />...<br />（具体操作路径及注意事项将在群中通知，请您务必添加小助手微信）</p><h2 id="infoq-是什么">InfoQ 是什么？</h2><p>去 Google 一下。</p><p><a href="www.infoq.com">www.infoq.com</a><br />InfoQ: Software Development News, Videos &amp; Books<br />Curated and peer-reviewed content covering innovation in professional software development, read by over 1 million developers worldwide.</p><p><a href="www.infoq.cn">www.infoq.cn</a><br />InfoQ - 促进软件开发领域知识与创新的传播-极客邦<br />InfoQ是一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。提供架构，云计算，AI，前端，大数据，Java，软件开发，编程等技术资讯及技术 ...</p><p>baike.baidu.com › item › InfoQ<br />InfoQ_百度百科<br />软件正在改变世界！InfoQ（Information Queue）是一个在线新闻/社区网站，旨在通过促进软件开发领域知识与创新的传播，为软件开发者提供帮助。...</p><h2 id="程序员评价">程序员评价</h2><p>知乎上有一个关于 InfoQ 的提问：<a href="https://www.zhihu.com/question/353239355/answer/883885600" target="_blank" rel="noopener">为什么InfoQ新加的话题模块没什么人讨论？</a></p><p>有且仅有一条回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">infoq 难道不是一个给</span><br><span class="line"></span><br><span class="line">产品经理</span><br><span class="line">不写代码的CTO</span><br><span class="line">大小会议上不断强调自己是“技术出身”的CEO</span><br><span class="line">...</span><br><span class="line">看的，并且在看完网站内容，回头就使用它来指导程序员做设计甚至开发的地方吗？</span><br><span class="line"></span><br><span class="line">那些人和程序员不同，他们不爱和同行讨论。</span><br></pre></td></tr></table></figure><p>——庄严《白话C++》作者</p><h2 id="群公告">群公告</h2><p>今天下午 3 点多终于开始加群了。</p><p>以下群公告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">哈喽，1号创作者们。</span><br><span class="line"></span><br><span class="line">为了方便平台内测信息的同步&amp;交流，请大家把群中备注改为【姓名 &#x2F; 笔名 - 行业领域】，谢谢配合！</span><br><span class="line"></span><br><span class="line">写作平台预计将于【清明假期后】正式向本群的创作者们开放，请大家提前备好【3 篇以上】文章作品，届时大家将首批体验 InfoQ 写作平台编辑器，并自行发布文章。如有任何疑问，可查看 InfoQ 写作平台为大家准备的：《给内容创作者的一封信》：&lt;https:&#x2F;&#x2F;shimo.im&#x2F;docs&#x2F;T9vxKx8qXd688RRX&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">当然，也可以随时艾特或私戳文字君哟~</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/infoq.png" /></p><h2 id="写作经历">写作经历</h2><p>之前在 <a href="https://www.csdn.net" target="_blank" rel="noopener">csdn</a>, <a href="http://www.chinaunix.net" target="_blank" rel="noopener">unixchina</a> 的技术论坛活动。</p><p>2014 年开始自己的博客：<a href="https://www.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://www.iosdevlog.com</a> jekyll。</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/iosdevlog.png" /></p><p>后来开通了 <strong>简书</strong>： <a href="https://www.jianshu.com/u/1577b98c62f4" target="_blank" rel="noopener">iOSDevLog</a>，掘金，知乎，微信公众号：iOSDevLog 和 AIDevLog。</p><p><span class="math inline">\(云^{+}\)</span> 社区是转 <strong>简书</strong> 的。</p><p>小武小久记录: <a href="https://1519.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://1519.iosdevlog.com</a> jekyll<br />游戏开发博客：<a href="https://game.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://game.iosdevlog.com</a> hexo+next<br />2019 年博客：<a href="https://2019.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://2019.iosdevlog.com</a> hexo+next<br />2020 年博客：<a href="https://2020.iosdevlog.com" class="uri">https://2020.iosdevlog.com</a> hexo</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/gamedevlog.png" /></p><p>其中简书参加过几个日更的活动，最近也不怎么在上面更新了。</p><p>最近只在 2020 年博客 和 微信公众号：<em>AI开发日志</em> 上更新。</p><p>现在要准备 InfoQ 上的文章，先写着，再去之前的文章里面找点能用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/03/infoq/1.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://2020.iosdevlog.com/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="infoq" scheme="https://2020.iosdevlog.com/tags/infoq/"/>
    
      <category term="geek" scheme="https://2020.iosdevlog.com/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>《程序员的数学基础课》</title>
    <link href="https://2020.iosdevlog.com/2020/04/02/math/"/>
    <id>https://2020.iosdevlog.com/2020/04/02/math/</id>
    <published>2020-04-02T09:19:25.000Z</published>
    <updated>2020-04-03T14:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg" /></p><blockquote><p>数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力</p></blockquote><p>——《程序员的数学基础课》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>如何学习新技术</p><ol type="1"><li>第一阶段：怎么使用</li><li>第二阶段：如何实现，原理是什么</li><li>第三阶段：为什么这样实现</li></ol><ul><li>明确需求</li><li>用多少学多少</li><li>理解数学的本质</li><li>数学思想与数学逻辑</li></ul><a id="more"></a><h2 id="基础思想">基础思想</h2><h3 id="二进制">二进制</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/1.jpg" /></p><h3 id="余数">余数</h3><p>余数总是在一个固定的范围内。</p><p>同余定理用来 <code>分类/均分</code> 的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/2.jpg" /></p><h3 id="迭代法">迭代法</h3><p>不断地用旧的变量值，递推计算新的变量值。</p><ul><li>求数值的精确或者近似解<ul><li>二分法(Bisection method)</li><li>牛顿迭代法 (Newton’s method)</li></ul></li><li>在一定范围内查找目标值<ul><li>二分查找</li></ul></li><li>机器学习算法中的迭代<ul><li>K- 均值算法(K-means clustering)</li><li>PageRank 的马尔科夫链(Markov chain)</li><li>梯度下降法(Gradient descent)</li></ul></li></ul><p>很多时候机器学习 的过程，就是根据已知的数据和一定的假设，求一个局部最优解</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/3.jpg" /></p><h3 id="数学归纳法">数学归纳法</h3><p>数学归纳法的一般步骤是这样的:</p><ol type="1"><li>证明基本情况(通常是 <span class="math inline">\(n = 1\)</span> 的时候)是否成立;</li><li>假设 <span class="math inline">\(n = k-1\)</span> 成立，再证明 <span class="math inline">\(n=k\)</span> 也是成立的( <span class="math inline">\(k\)</span> 为任意大于 <span class="math inline">\(1\)</span> 的自然数)。</li></ol><p>和使用迭代法的计算相比，数学归纳法 最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正 确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</p><p>递归调用的代码和数学归纳法的逻辑是一致的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/4.jpg" /></p><h3 id="递归">递归</h3><ol type="1"><li>初始状态，也就是 <span class="math inline">\(n=1\)</span> 的时候，命题是否成立;</li><li>如果 <span class="math inline">\(n=k-1\)</span> 的时候，命题成立。那么只要证明 <span class="math inline">\(n=k\)</span> 的时候，命题也成立。其中 <span class="math inline">\(k\)</span> 为大于 <span class="math inline">\(1\)</span> 的自然数。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.jpg" /></p><h3 id="排列">排列</h3><p>排列，一般地，从 <span class="math inline">\(n\)</span> 个不同元素中取出 <span class="math inline">\(m（m≤n）\)</span> 个元素，按照一定的顺序排成一列，叫做从 <span class="math inline">\(n\)</span> 个元素中取出 <span class="math inline">\(m\)</span> 个元素的一个排列(permutation)。特别地，当 <span class="math inline">\(m=n\)</span> 时，这个排列被称作全排列(all permutation)。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/7.jpg" /></p><h3 id="组合">组合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/8.jpg" /></p><h3 id="动态规划">动态规划</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/10.jpg" /></p><h3 id="树的深度优先搜索">树的深度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/12.jpg" /></p><h3 id="树的广度优先搜索">树的广度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/14.jpg" /></p><h3 id="从树到图">从树到图</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.jpg" /></p><h3 id="时间和空间复杂度">时间和空间复杂度</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/16.jpg" /></p><h2 id="概率统计">概率统计</h2><h3 id="概率和统计">概率和统计</h3><p>概率(Probability)</p><ul><li>随机变量(Random Variable)：事件所有可能出现的状态</li><li>概率分布 (Probability Distribution)：每个状态出现的可能性<ul><li>离散 型随机变量(Discrete Random Variable)</li><li>连续型随机变量(Continuous Random Variable)</li></ul></li></ul><p>对于离散型随机变量，通过联合概率 <span class="math inline">\(P(x, y)\)</span> 在 <span class="math inline">\(y\)</span> 上求和，就可以得到 <span class="math inline">\(P(x)\)</span>，这个 <span class="math inline">\(P(x)\)</span> 就 是边缘概率(Marginal Probability)</p><p>概率论研究的就是这些概率之间相互转化的关系，比如联合概率、条件概率和边缘概率。</p><ul><li>决策树(Decision Tree)<ul><li>信息熵(Entropy)/ 香农熵(Shannon Entropy)</li><li>信息增益(Information Gain)</li><li>基尼指数(Gini)</li></ul></li></ul><p>概率和统计 <code>互逆</code></p><ul><li>概率论是对数据产生的过程进行建模，然后研究某种模型所产生的数据有什么特性。</li><li>通过已知的数据，来推导产生这些数据的模型是怎样的。</li></ul><h3 id="概率基础">概率基础</h3><p>概率分布描述的其实就是随机变量的概率规律</p><p>参考：看见统计<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.1.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.3.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.4.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.6.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.png" /></p><h3 id="文本分类">文本分类</h3><p>文本分类系统的基本框架</p><ol type="1"><li>采集训练样本</li><li>预处理自然语言</li><li>训练模型</li><li>实时分类预测</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/23.png" /></p><p>基于自然语言的预处理</p><ol type="1"><li>分词<ol type="1"><li>基于字符串匹配</li><li>基于统计和机器学习<ol type="1"><li>隐马尔科夫模 型(HMM，Hidden Markov Model)</li><li>条件随机场(CRF，Conditional Random Field)</li></ol></li></ol></li><li>取词干和归一化</li><li>停用词</li><li>同义词和扩展词</li></ol><h3 id="语言模型">语言模型</h3><p>语言模型是什么?</p><ul><li>链式法则</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.2.png" /></p><ul><li>马尔科夫假设</li></ul><p>理解了链式法则，我们再来看看马尔可夫假设。</p><p>这个假设的内容是:</p><p>任何一个词 <span class="math inline">\(w_{i}\)</span> 出现的概率只和它前面的 <span class="math inline">\(1\)</span> 个或若干个词有关。</p><p>基于这个假设，我们可以提出 <code>多元文法 (Ngram)模型</code>。Ngram 中的“N”很重要，它表示任何一个词出现的概率，只和它前 面的 <span class="math inline">\(N-1\)</span> 个词有关。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.6.png" /></p><p>语言模型的应用</p><ol type="1"><li>信息检索</li><li>中文分词</li></ol><p>第一，使用联合概率，条件概率和边缘概率的“三角”关系，进行相互推导。链式法则就 是很好的体现。</p><p>第二，使用马尔科夫假设，把受较多随机变量影响的条件概率，简化为受较少随机变量影 响的条件概率，甚至是边缘概率。</p><p>第三，使用贝叶斯定理，通过先验概率推导后验概率。在信息检索中，给定查询的情况下 推导文档的概率，就需要用到这个定理。</p><h3 id="马尔科夫模型">马尔科夫模型</h3><p>假设：每个词出现的概率和 之前的一个或若干个词有关。</p><p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状 态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假 设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是 <code>马尔科夫模型(Markov Model)</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.5.jpg" /></p><p>PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.6.png" /></p><p>隐马尔科夫模型</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.10.jpg" /></p><h3 id="信息熵">信息熵</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.1.jpg" /></p><ul><li>信息量：信息论中的一个度量<ul><li>信息量应该为正数;</li><li>一个事件的信息量和它发生的概率成反比;</li></ul></li><li>信息熵(Entropy)：集合的 纯净度的一个指标<ol type="1"><li>一个集合里的元素全部是属于同一个分组，这个时候就表示最纯净，我们就说熵为 0;</li><li>如果这个集合里的元素是来自不同的分组，那么熵是大于 0 的值。其具体的计算公式 如下:</li></ol></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.2.png" /></p><p>一个集合中所包含的分组越多、元素在这些分组里分布 得越均匀，熵值也越大。</p><p>而熵值表示了纯净的程度，或者从相反的角度来说，是混乱的程 度。</p><p>信息量期望</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.3.png" /></p><p>对于多个小集合而言，其整体的熵等于各个小集合之熵的加权平均。</p><ul><li>信息增益(Information Gain)：划分后整体熵的下降</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.5.png" /></p><h3 id="决策树">决策树</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.1.png" /></p><ol type="1"><li>第一步，根据集合中的样本分类，为每个集合计算信息熵，并通过全部集合的熵之加权平 均，获得整个数据集的熵。注意，一开始集合只有一个，并且包含了所有的样本。</li><li>第二步，根据信息增益，计算每个特征的区分能力。挑选区分能力最强的特征，并对每个 集合进行更细的划分。</li><li>第三步，有了新的划分之后，回到第一步，重复第一步和第二步，直到没有更多的特征， 或者所有的样本都已经被分好类。</li></ol><ul><li>ID3(Iterative Dichotomiser 3，迭代二叉树 3 代)<ul><li>信息增益</li><li>优先考虑具有较多取值的特征</li></ul></li><li>C4.5 算法<ul><li>信息增益率(Information Gain Ratio)</li><li>分裂信息(Split Information)</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.4.png" /></p><ul><li>CART 算法(Classification and Regression Trees，分类与回归 树)<ul><li>基尼指数(Gini)</li><li>二叉树</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/27.6.png" /></p><ul><li>优化<ul><li>剪枝<ul><li>预剪枝</li><li>后剪枝</li></ul></li><li>随机森林</li></ul></li></ul><h3 id="熵信息增益和卡方">熵、信息增益和卡方</h3><p>利用卡方检验进行特征选择</p><p>如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。</p><h3 id="归一化和标准化">归一化和标准化</h3><p>为什么需要特征变换?</p><ul><li>线性回归模型：因变量和自变量为线性关系</li><li>非线性回归分析模型：因变量和自变量为非线性关系</li></ul><p>多元线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.1.png" /></p><p>两种常见的特征变换方法</p><ul><li>归一化(Normalization)。</li></ul><p>它其实就是获取原始数据的最大值和最小值，然后把原始值线性变换到 [0,1] 之间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.2.png" /></p><ul><li>标准化</li></ul><p>基于正态分布的 z 分数(z-score)标准化(Standardization)。</p><p>该方法假设数据呈现标准正态分布。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.3.png" /></p><p><span class="math display">\[x^{\prime}=\frac{(x-\mu)}{\sigma}\]</span></p><p>其中 <span class="math inline">\(x\)</span> 为原始值，<span class="math inline">\(\mu\)</span> 为均值，<span class="math inline">\(\sigma\)</span> 为标准差，<span class="math inline">\(x^{\prime}\)</span> 是变换后的值。</p><h3 id="统计意义">统计意义</h3><p>A/B 测试</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/30.png" /></p><p>显著性差异(Significant Difference)</p><ol type="1"><li>第一，两个分布之间的差异。<ul><li>“有显著性差异”</li></ul></li><li>第二，采样引起的差异。<ul><li>“无显著性差异”</li></ul></li></ol><p>“具有显著性差异”，称为“差异具有统计意义”或者“差异具有显著性”</p><p>统计假设检验和显著性检验</p><p>统计假设检验是指事先对随机变量的参数或总体分布做出一个假设，然后利用样本信息来 判断这个假设是否合理。</p><p>在统计学上，我们称这种假设为虚无假设(Null Hypothesis)，也叫原假设或零假设，通常记作 <code>H0</code>。</p><p>而和虚无假设对立的假设，我们称为对立假设(Alternative Hypothesis)，通常记作 <code>H1</code>。也就是说，如果证明虚无假设不成立，那么就可以推出对立假设成立。</p><p>通常我们把概率不超 过 0.05 的事件称为“小概率事件”</p><p>P 值(P-value)</p><p>P 值中的 P 代表 Probability，就是当 H0 假 设为真时，样本出现的概率，或者换句话说，其实就是我们所观测到的样本数据符合原假 设 H0 的可能性有多大。</p><p>方差分析</p><p>方差分析(Analysis of Variance, ANOVA)，也叫 <strong>F检验</strong>。</p><ul><li>随机性：样本是随机采样的;</li><li>独立性：来自不同组的样本是相互独立的;</li><li>正态分布性：组内样本都来自一个正态分布;</li><li>方差齐性：不同组的方差相等或相近。</li></ul><p>自由度(degree of freedom)，英文缩写是 df，它是指采样中能够自由变化的数据个 数。</p><h3 id="拟合">拟合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/32.png" /></p><ul><li><strong>欠拟合问题</strong> 产生的主要原因 是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大。</li><li><strong>过拟合问题</strong> 产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符 合训练样本，但是无法适应测试样本或者说新的数据。</li></ul><p>交叉验证(Cross Validation)的划分方式来保持训练数 据和测试数据的一致性。</p><h2 id="线性代数">线性代数</h2><h3 id="线性代数-1">线性代数</h3><p>向量和向量空间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.1.png" /></p><p>向量的每个元素就代表 一维特征，而元素的值代表了相应特征的值，我们称这类向量为 <strong>特征向量(Feature Vector)</strong>。</p><p><strong>矩阵的特征向量(Eigenvector)</strong></p><p>向量的运算</p><ul><li>加法</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/33.3.png" /></p><ul><li>乘法(或点乘)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.4.png" /></p><ul><li>距离</li><li>夹角</li></ul><p>矩阵的运算</p><p>矩阵由多个长度相等的向量组成，其中的每列或者每行就是一个向量。</p><p>因此，我们把向量延伸一下就能得到矩阵(Matrix)。</p><p>矩阵乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.6.png" /></p><p>两个矩阵中对应元素进行相乘，称它为 <strong>元素对应乘积</strong>，或者 <strong>Hadamard 乘积</strong></p><p>转置(Transposition)是指矩阵内的元素行索引和纵索引互换</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.7.png" /></p><p>单位矩阵(Identity Matrix)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.8.png" /></p><p>矩阵逆(Matrix Inversion)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.9.png" /></p><h3 id="向量空间模型">向量空间模型</h3><p>向量之间的距离</p><ul><li>曼哈顿距离(Manhattan Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.3.png" /></p><ul><li>欧氏距离(Euclidean Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.5.png" /></p><ul><li>切比雪夫距离(Chebyshev Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.6.png" /></p><p>向量的长度</p><ul><li><span class="math inline">\(L_{1}\)</span> 范数 <span class="math inline">\(\|x\|\)</span> ，它是为 <span class="math inline">\(x\)</span> 向量各个元素绝对值之和，对应于向量和原点之间的曼哈顿距离。<br /><span class="math inline">\(L_{2}\)</span> 范数 <span class="math inline">\(\|x\|_2\)</span> ，它是向量 <span class="math inline">\(x\)</span> 各个元素平方和的 <span class="math inline">\(\frac{1}{2}\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的欧氏距离。<br /><span class="math inline">\(L_{p}\)</span> 范数 <span class="math inline">\(\|x\|_p\)</span> ，为向量各个元素绝对值 <span class="math inline">\(p\)</span> 次方和的 <span class="math inline">\(1/p\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的闵氏距离。<br /><span class="math inline">\(L_{\infty}\)</span> 范数 <span class="math inline">\(\|x\|_{\infty}\)</span>，为 <span class="math inline">\(x\)</span> 向量各个元素绝对值最大那个元素的绝对值，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的切比雪夫距离。</li></ul><p>所以，在讨论向量的长度时，我们需要弄清楚是 <code>L几范数</code>。</p><p>向量之间的夹角</p><p><span class="math display">\[\operatorname{cosine}(X, Y)=\frac{\sum_{i=1}^{n}\left(x_{i} \times y_{i}\right)}{\sqrt{\sum_{i=1}^{n} x_{i}^{2} \times \sum_{i=1}^{n} y_{i}^{2}}}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.7.png" /></p><p>向量空间模型(Vector Space Model)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.8.png" /></p><h3 id="文本检索">文本检索</h3><p>信息检索就是让计算机根据用户信息需求，从大规模、非结构化的数据中，找 出相关的资料。</p><p>信息检索中的向量空间模型</p><ol type="1"><li>第一步，把文档集合都转换成向量的形式。</li><li>第二步，把用户输入的查询转换成向量的形式，然后把这个查询的向量和所有文档的向 量，进行比对，计算出基于距离或者夹角余弦的相似度。</li><li>第三步，根据查询和每个文档的相似度，找出相似度最高的文档，认为它们是和指定查询 最相关的。</li><li>第四步，评估查询结果的相关性。</li></ol><h3 id="文本聚类">文本聚类</h3><p>聚类算法</p><p>K 均值(K-Means)聚类算法</p><p>尽量最大化总的 群组内相似度，同时尽量最小化群组之间的相似度。</p><ol type="1"><li>从 N 个数据对象中随机选取 k 个对象作为质心，这里每个群组的质心定义是，群组内 所有成员对象的平均值。因为是第一轮，所以第 i 个群组的质心就是第 i 个对象，而且 这时候我们只有这一个组员。</li><li>对剩余的对象，测量它和每个质心的相似度，并把它归到最近的质心所属的群组。这里 我们可以说距离，也可以说相似度，只是两者呈现反比关系。</li><li>重新计算已经得到的各个群组的质心。这里质心的计算是关键，如果使用特征向量来表 示的数据对象，那么最基本的方法是取群组内成员的特征向量，将它们的平均值作为质心的向量表示。</li><li>迭代上面的第 2 步和第 3 步，直至新的质心与原质心相等或相差之值小于指定阈值，算法结束。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/36.png" /></p><h3 id="矩阵">矩阵</h3><p>PageRank 链接分析算法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.1.png" /></p><p>简化 PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.2.png" /></p><p>矩阵点乘</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.3.png" /></p><p>拓扑图</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.4.png" /></p><p>原始矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.5.png" /></p><p>归一化</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.6.png" /></p><p>初始值都设为 1</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.7.png" /></p><p>考虑随机跳转</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.9.png" /></p><p>用矩阵实现推荐系统的核心思想</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.1.png" /></p><p>基于用户的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.2.png" /></p><p>基于物品的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.3.png" /></p><h3 id="线性回归">线性回归</h3><p><span class="math display">\[\begin{aligned}&amp;2 x_{1}+x_{2}+x_{3}=0\\&amp;4 x_{1}+2 x_{2}+x_{3}=56\\&amp;2 x_{1}-x_{2}+4 x_{3}=4\end{aligned}\]</span></p><h4 id="高斯消元法">高斯消元法</h4><p>使用矩阵实现高斯消元法</p><p>系数矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.1.png" /></p><p>消元</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.2.png" /></p><p>系数</p><p><span class="math display">\[\begin{array}{l}1 \cdot x_{1}+0 \cdot x_{2}+0 \cdot x_{3}=71 \\0 \cdot x_{1}+1 \cdot x_{2}+0 \cdot x_{3}=-86 \\0 \cdot x_{1}+0 \cdot x_{2}+1 \cdot x_{3}=-56\end{array}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.3.png" /></p><p>增广矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.4.png" /></p><p>线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.1.png" /></p><p>最小二乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.2.png" /></p><h3 id="pca主成分分析principal-component-analysis">PCA主成分分析(Principal Component Analysis)</h3><ol type="1"><li><p>标准化样本矩阵中的原始数据;</p></li><li><p>获取标准化数据的协方差矩阵;</p></li><li><p>计算协方差矩阵的特征值和特征向量;</p></li><li><p>依照特征值的大小，挑选主要的特征向量; 5. 生成新的特征。</p></li><li><p>标准化原始数据</p></li></ol><p><span class="math display">\[x^{\prime}=\frac{x-\mu}{\sigma}\]</span></p><ol start="2" type="1"><li>获取协方差矩阵</li></ol><ul><li>协方差(Covariance)：衡量两个变 量的总体误差</li></ul><p><span class="math display">\[\operatorname{cov}(x, y)=\frac{\sum_{k=1}^{m}\left(x_{k}-\bar{x}\right)\left(y_{k}-\bar{y}\right)}{m-1}\]</span></p><ul><li>协方差矩阵</li></ul><p><span class="math display">\[\operatorname{cov}\left(X_{, i}, X_{, j}\right)=\frac{\sum_{k=1}^{m}\left(x_{k, i}-\bar{X}_{, i}\right)\left(x_{k, j}-\bar{X}_{, j}\right)}{m-1}\]</span></p><p><span class="math display">\[C O V=\left[\begin{array}{ccccc}\operatorname{cov}\left(X_{1}, X_{1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{1}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{n}\right) \\\operatorname{cov}\left(X_{2}, X_{1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{2}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{n}\right) \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\\operatorname{cov}\left(X_{n}, X_{1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{n}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{n}\right)\end{array}\right]\]</span></p><ol start="3" type="1"><li>计算协方差矩阵的特征值和特征向量</li></ol><p><span class="math display">\[X v=\lambda v\]</span></p><p>特征 值的推导过程</p><p><span class="math display">\[\begin{aligned}&amp;X v=\lambda v\\&amp;X v-\lambda v=0\\&amp;X v-\lambda I v=0\\&amp;(X-\lambda I) v=0\end{aligned}\]</span></p><p>矩阵的行列式</p><p><span class="math display">\[|(X-\lambda I)|=\left| \left[ \begin{array}{cccccc}x_{1,1}-\lambda &amp; x_{1,2} &amp; x_{1,3} &amp; \cdots &amp; x_{1, n-1} &amp; x_{1, n} \\x_{2,1} &amp; x_{2,2}-\lambda &amp; x_{2,3} &amp; \cdots &amp; x_{2, n-1} &amp; x_{2, n} \\x_{3,1} &amp; x_{3,2} &amp; x_{3,3}-\lambda &amp; \cdots &amp; x_{3, n-1} &amp; x_{3, n} \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\x_{n-1,1} &amp; x_{n-1,2} &amp; x_{n-1,3} &amp; \cdots &amp; x_{n-1, n-1}-\lambda &amp; x_{n-1, n} \\x_{n, 1} &amp; x_{n, 2} &amp; x_{n, 3} &amp; \cdots &amp; x_{n, n-1} &amp; x_{n, n}-\lambda\end{array}\right] \right| =0\]</span></p><p><span class="math display">\[(\lambda I-X)\left[\begin{array}{l}x_{1} \\x_{2} \\\dots \\x_{n}\end{array}\right]\]</span></p><ol start="4" type="1"><li>挑选主要的特征向量，转换原始数据</li></ol><h3 id="svd-奇异值分解singular-value-decomposition">SVD 奇异值分解(Singular Value Decomposition)</h3><p>方阵的特征分解</p><p><code>方阵(Square Matrix)</code> 是一种特殊的矩阵，它的行数和列数相等。如果一个矩阵的行数和列数 都是 n，那么我们把它称作 n 阶方阵。</p><p>如果一个矩阵和其转置矩阵相乘得到的是单位矩阵，那么它就是一个 <code>酉矩阵(Unitary Matrix)</code>。</p><p><span class="math display">\[X^{\prime} X=I\]</span></p><p>其中 X’表示 X 的转置，I 表示单位矩阵。</p><p>换句话说，矩阵 X 为酉矩阵的充分必要条件是 X 的转 置矩阵和 X 的逆矩阵相等。</p><p><span class="math display">\[X^{\prime}=X^{-1}\]</span></p><p>特征分解(Eigendecomposition)</p><p><span class="math display">\[\begin{aligned}&amp;X V V^{-1}=V \Sigma V^{-1}\\&amp;X I=V \Sigma V^{-1}\\&amp;X=V \Sigma V^{-1}\end{aligned}\]</span></p><p>主要考量因素</p><ol type="1"><li>硬件的性能</li><li>命中率</li><li>更新周期</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.2.png" /></p><h3 id="搜索引擎">搜索引擎</h3><p>搜索引擎的设计框架</p><ul><li>离线的预处理</li><li>在线的查询</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.1.png" /></p><p>倒排索引的设计</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.3.png" /></p><p>向量空间和倒排索引的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.4.png" /></p><p>查询分类和搜索引擎的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/48.png" /></p><h3 id="推荐系统">推荐系统</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/51.jpg" /></p><h2 id="程序员需要读哪些数学书">程序员需要读哪些数学书？</h2><p>基础思想篇推荐书籍:《离散数学及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_1.jpg" /></p><p>概率统计篇推荐书籍:《概率统计》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_2.png" /></p><p>线性代数篇推荐书籍:《线性代数及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_3.png" /></p><p>入门、通识类书籍推荐：《程序员的数学》</p><p>《程序员的数学》<br />《程序员的数 学:概率统计》<br />《程序员的数学:线性代数》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_4.png" /></p><p>计算机领域:《数学之美》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_5.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/235" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/235</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://2020.iosdevlog.com/2020/03/11/seeing-theory/" class="uri">https://2020.iosdevlog.com/2020/03/11/seeing-theory/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——《程序员的数学基础课》&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何学习新技术&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;第一阶段：怎么使用&lt;/li&gt;
&lt;li&gt;第二阶段：如何实现，原理是什么&lt;/li&gt;
&lt;li&gt;第三阶段：为什么这样实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;明确需求&lt;/li&gt;
&lt;li&gt;用多少学多少&lt;/li&gt;
&lt;li&gt;理解数学的本质&lt;/li&gt;
&lt;li&gt;数学思想与数学逻辑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="basic" scheme="https://2020.iosdevlog.com/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>理解机器学习的24本书（免费）</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/ml/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/ml/</id>
    <published>2020-04-01T14:53:31.000Z</published>
    <updated>2020-04-01T15:22:09.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/ml/1.jpg" /></p><a id="more"></a><blockquote><p><em>我们想要的是一台能从经验中学习的机器</em></p></blockquote><p>——艾伦·图灵</p><p>毫无疑问，机器学习已成为当今最受欢迎的主题之一。根据一项<a href="http://blog.indeed.com/2019/03/14/best-jobs-2019/" target="_blank" rel="noopener">研究</a>，机器学习工程师被评为 2019年 美国最佳工作之一。</p><p>展望这一趋势，我们整理了一些最佳（免费）机器学习书籍的清单，这些书籍将证明对有志于在该领域发展职业的每个人都有帮助。</p><h2 id="islr">1. <a href="http://faculty.marshall.usc.edu/gareth-james/ISL/" target="_blank" rel="noopener">ISLR</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/2.jpg" /></p><p>机器学习理论的最佳入门书。甚至付费书籍也不比它好。很好地介绍了数学知识，并在 <code>R</code> 中有练习材料。</p><h2 id="神经网络与深度学习">2. <strong><a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">神经网络与深度学习</a></strong></h2><p>这本免费的在线书是其中最好的和最快的关于深度学习的介绍。阅读只需几天，即可为您提供有关深度学习的所有基础知识。</p><h2 id="模式识别与机器学习">3. <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">模式识别与机器学习</a></h2><p>它是最著名的理论性机器学习书籍之一，因此无需撰写过多的介绍。</p><h2 id="深度学习花书">4. <strong><a href="https://www.deeplearningbook.org/" target="_blank" rel="noopener">深度学习/花书</a></strong></h2><p>这本书是《深度学习》的圣经，是对深度学习算法和方法的介绍，对初学者和从业者都非常有用。</p><h2 id="了解机器学习从理论到算法">5. <a href="https://www.cse.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf" target="_blank" rel="noopener">了解机器学习：从理论<strong>到算法</strong></a></h2><p>关于机器学习理论的文章确实很棒。</p><h2 id="成功的七个步骤实践中的机器学习">6. <strong><a href="https://daoudclarke.github.io/guide.pdf" target="_blank" rel="noopener">成功的七个步骤：实践中的机器学习</a></strong></h2><p>进入该领域的非技术产品经理和非机器学习软件工程师都不应错过本教程。写得很好（略旧，不涉及深度学习，但可以用于所有实际目的）。</p><h2 id="机器学习规则机器学习工程的最佳实践">7. <strong><a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf" target="_blank" rel="noopener">机器学习规则：机器学习工程的最佳实践</a></strong></h2><p>想知道 <code>Google</code> 如何看待其机器学习产品吗？这是一个非常好的机器学习产品管理教程。</p><h2 id="面向工程师的机器学习简介">8. <strong><a href="https://arxiv.org/abs/1709.02840" target="_blank" rel="noopener">面向工程师的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="无需深度学习的机器学习简介">9. <strong><a href="https://docs.google.com/document/d/1Rp6sf129T0j1isIQByyUeby4fwKgwTyiVleNwX7JGmg/edit" target="_blank" rel="noopener">无需深度学习的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="机器学习入门笔记">10. <strong><a href="http://lcsl.mit.edu/courses/ml/1718/MLNotes.pdf" target="_blank" rel="noopener">机器学习入门笔记</a></strong></h2><p>面向绝对初学者的机器学习指南。</p><h2 id="机器学习基础">11. <strong><a href="https://cs.nyu.edu/~mohri/mlbook/" target="_blank" rel="noopener">机器学习基础</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/3.jpg" /></p><p>关于机器学习数学概念的详细论述。</p><h2 id="变量和特征选择简介">12. <strong><a href="https://dl.acm.org/doi/10.5555/944919.944968" target="_blank" rel="noopener">变量和特征选择简介</a></strong></h2><p>特征工程和变量选择可能是传统机器学习算法中最重要的人工输入。（在深度学习方法中不那么重要，但是深度学习并不能解决所有问题）。本教程介绍了不同的要素工程方法。</p><h2 id="automl-frank-hutterlars-kotthoffjoaquin-vanschoren">13. <strong><a href="https://www.automl.org/book/" target="_blank" rel="noopener">AutoML– Frank Hutter，Lars Kotthoff，Joaquin Vanschoren</a></strong></h2><p>在完成功能工程后，近来的传统机器学习实际上已经减少到运行 <code>AutoML</code> 模型（h2o，auto sklearn或tpot，这是ParallelDots的最爱）。（实际上，也有几种方法可以进行自动化的非特定于域的自动要素工程）。本书介绍了AutoML中使用的方法。</p><h2 id="用pytorch进行深度学习">14. <strong><a href="https://pytorch.org/deep-learning-with-pytorch" target="_blank" rel="noopener">用Pytorch进行深度学习</a></strong></h2><p>一本免费的书，可帮助您使用 <code>PyTorch</code> 学习深度学习。<code>PyTorch</code> 是ParallelDots 上我们最喜欢的深度学习库，我们建议所有人进行深度学习的应用研究/开发。</p><h2 id="深度学习">15. <strong><a href="http://d2l.ai/" target="_blank" rel="noopener">深度学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/4.png" /></p><p>另一本有关深度学习的详细书，该书使用亚马逊的 <code>MXN​​et</code> 库教授深度学习。</p><h2 id="kerasbook-github-笔记本">16. <strong><a href="https://github.com/fchollet/deep-learning-with-python-notebooks" target="_blank" rel="noopener">Kerasbook Github 笔记本</a></strong></h2><p>Francois Chollet 是 <code>Keras</code> 库的负责人。他撰写的《用Python进行深度学习》一书在Keras教授《深度学习》，获得了很好的评价。这本书 <strong>不是</strong> 免费提供的，但是它的所有代码都可以在 <code>Github</code> 上以笔记本的形式获得（用深度学习示例构成一本书），并且是很好的资源。几年前我在学习 <code>Keras</code> 时就读了它，这是非常好的资源。</p><h2 id="基于模型的机器学习">17. <strong><a href="http://mbmlbook.com/" target="_blank" rel="noopener">基于模型的机器学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/5.png" /></p><p>贝叶斯机器学习的绝佳资源。使用 <code>Microsoft</code> 的 <code>Infer.Net</code> 库进行教学，因此您可能必须安装 <code>IronPython</code> 才能阅读/实现本书的示例。</p><h2 id="机器学习的贝叶斯模型">18. <strong><a href="http://www.columbia.edu/~jwp2128/Teaching/E6720/BayesianModelsMachineLearning2016.pdf" target="_blank" rel="noopener">机器学习的贝叶斯模型</a></strong></h2><p>另一本书详细介绍了机器学习中的各种贝叶斯方法。</p><h2 id="爱森斯坦自然语言处理笔记">19. <strong><a href="https://github.com/jacobeisenstein/gt-nlp-class/blob/master/notes/eisenstein-nlp-notes.pdf" target="_blank" rel="noopener">爱森斯坦自然语言处理笔记</a></strong></h2><p>自然语言处理是机器学习中最流行的用途。GATech课程中的这些注释很好地概述了如何使用机器学习来解释人类语言。</p><h2 id="强化学习-sutton和barto">20. <strong><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">强化学习– Sutton和Barto</a></strong></h2><p>强化学习的圣经。这是进入强化学习领域的任何人都必须阅读的。</p><h2 id="机器学习的高斯过程">21. <a href="http://www.gaussianprocess.org/gpml/" target="_blank" rel="noopener">机器学习的高斯过程</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/6.gif" /></p><p>使用贝叶斯优化和高斯过程进行机器学习。借助基于变分推理的库（例如Edward / GpyTorch / BOTorch等），此方法正在卷土重来。</p><h2 id="机器学习访谈机器学习系统设计chip-huyen">22. <strong><a href="https://github.com/chiphuyen/machine-learning-systems-design" target="_blank" rel="noopener">机器学习访谈机器学习系统设计Chip Huyen</a></strong></h2><p>要参加机器学习工作的面试吗？这些问题可能有助于在回答机器学习系统问题时找出策略。</p><h2 id="机器学习的算法方面">23. <strong><a href="https://people.csail.mit.edu/moitra/docs/bookex.pdf" target="_blank" rel="noopener">机器学习的算法方面</a></strong></h2><p>本书涉及机器学习的各个部分，其中涉及计算算法和数值方法，以解决诸如分解模型，字典学习和高斯模型之类的问题。</p><h2 id="机器学习的因果关系">24. <strong><a href="https://arxiv.org/abs/1911.10500" target="_blank" rel="noopener">机器学习的因果关系</a></strong></h2><p>随着因果关系进入数据科学领域，机器学习也摆脱了讨论。尽管没有详细的资料可解决，但是这里是一个简短的教程，试图解释机器学习因果关系的关键概念。</p><p>原文：<a href="https://blog.paralleldots.com/data-science/24-best-and-free-books-to-understand-machine-learning/" target="_blank" rel="noopener">24 Best (and Free) Books To Understand Machine Learning</a></p><p>作者：<a href="https://blog.paralleldots.com/author/reashikaa/" target="_blank" rel="noopener">Reashikaa Verma</a></p><p>时间：2020/03/12</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/ml/1.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ml" scheme="https://2020.iosdevlog.com/tags/ml/"/>
    
      <category term="book" scheme="https://2020.iosdevlog.com/tags/book/"/>
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>《艰难的制造》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/9787550298637/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/9787550298637/</id>
    <published>2020-04-01T08:28:03.000Z</published>
    <updated>2020-04-01T08:43:01.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg" /></p><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />副标题: 讲述制造业在政策和市场夹缝中的生存故事<br />出版年: 2017-6<br />页数: 672<br />定价: 69.90<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550298637</p><a id="more"></a><h2 id="内容简介">内容简介</h2><p>宁炒一座楼，不办一家厂，开厂为啥干不过炒房，做实业的为啥干不过搞金融的？作为立国之本、创造财富的制造业发生了什么？市场的大手，政策的大手，究竟在其中起到什么样的作用？</p><p>小说以一家中小型机械制造厂切入，以手术解剖的方式娓娓道来秉持实业理想的柳钧和从事金融的好友钱宏明的典型遭遇。无论是山寨模仿、技术剽窃、恶意抢单、黑社会威胁、税务查账、环保穿小鞋还是信用证诈骗、房地产投机、民间高利贷、非法集资，从起步到发展过程中大到政策，小到员工管理的九九八十一难一一为你呈现。</p><p>本书作者阿耐曾为浙江某著名民营制造业高管，几十年经营管理经验，写出来的都是“实打实的真材实料”。自连载以来，引发珠三角、长三角众多制造业老板及金融从业者的广泛共鸣。</p><h2 id="结局对比">结局对比</h2><p>最后一章里面，这一（2008）年，<strong>柳钧</strong> 失去最好的朋友，却还晦气得在年底前出国洽商的时候撞见宿仇 <strong>杨巡</strong>。</p><p><strong>柳钧</strong> 以为 <strong>杨巡</strong> 要逃，杨巡说：</p><blockquote><p>"人在青山在，只要公司不倒，所有债务都只是账面数字，哪家公司不是负债运行的。"</p></blockquote><p><strong>杨巡</strong> 的世界只有利益相关，<strong>柳钧</strong> 和 <strong>宋运辉</strong> 观点：</p><blockquote><p>“创造力无价。”</p></blockquote><blockquote><p>“你该不会还以为我送了宋总和梁姐很多好处？”两人对视，柳钧从杨巡眼里看出一丝恍惚。“或许，你的世界只有利益相关，但我们的世界里有一些傻傻的东西，比如你近来才意识到知识无价，因为这个社会发展到现阶段，人力成本上升趋势已不可逆转，无论国内外的市场竞争都将越来越靠科研技术。只是眼下的大环境并不支持这种脚踏实地的竞争方式，有很多傻傻的人内心很焦虑，很着急，很想尽一己之力稍微改变一下这样的结构问题。我们都在努力，我非常感谢宋总支持我的努力。他是个很有精神感召力的人。</p></blockquote><p>——第106章 2008年新劳动合同法和新政策带来的负担(14) / 最后一章</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;作者: 阿耐&lt;br /&gt;
出版社: 北京联合出版公司&lt;br /&gt;
副标题: 讲述制造业在政策和市场夹缝中的生存故事&lt;br /&gt;
出版年: 2017-6&lt;br /&gt;
页数: 672&lt;br /&gt;
定价: 69.90&lt;br /&gt;
装帧: 平装&lt;br /&gt;
丛书: 读客·知识小说文库&lt;br /&gt;
ISBN: 9787550298637&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="改革" scheme="https://2020.iosdevlog.com/tags/%E6%94%B9%E9%9D%A9/"/>
    
      <category term="大江大河" scheme="https://2020.iosdevlog.com/tags/%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
  </entry>
  
  <entry>
    <title>《大江东去》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/03/31/9787550230552/"/>
    <id>https://2020.iosdevlog.com/2020/03/31/9787550230552/</id>
    <published>2020-03-31T05:50:41.000Z</published>
    <updated>2020-04-01T09:14:51.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg" /></p><a id="more"></a><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />出品方: 读客文化<br />副标题: 经典收藏版全三册<br />出版年: 2014-7-15<br />页数: 1992<br />定价: 168.00<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550230552</p><h2 id="内容简介">内容简介</h2><p>《大江东去》是著名财经作家阿耐创作的一部全景表现改革开放30年来中国经济和社会生活变迁历史的长篇小说。</p><p>小说以经济改革为主线，全面、细致、深入地表现了1978年以来中国改革开放30年的伟大历史进程。展现了中国改革开放30年来经济领域的改革、社会生活的变化、政治领域的变革 以及人们精神面貌的变化等方方面面；生动而真实地刻画了活跃在改革开放前沿的代表人物，如国营企业的领导、农民企业家、个体户、政府官员、海归派、知识分子等等。人物典型深刻，故事跌宕磅礴。</p><p>从表现历史的深度和广度上来说，在表现中国改革开放历史进程这一题材里，这部作品具有很重的分量和特殊意义，被誉为“描写改革开放30年的第一小说”，荣获中宣部“五个一工程奖”。</p><h2 id="宋运辉">宋运辉</h2><blockquote><p>出国考察和谈判，出差的地方与美国隔个太平洋。开颜一直担心 去见你（宋运辉）那个女学生（梁思申）。</p></blockquote><blockquote><p>宋运辉厌恶地再看一眼他的内裤，调头离开。从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p><p>从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p></blockquote><p>——第143章 1992年(7)</p><blockquote><p>宋运辉愣愣地看着好友，却道：“冰冻三尺非一日之寒，原来我一直看不起她。”</p><p>宋运辉摇头愤怒地道：“没办法，知道这婚姻是程家设计的，我……你让我傻瓜一直当到底？”</p></blockquote><p>——第144章 1992年(8)</p><blockquote><p>那么用与程开颜婚姻和美来洗刷告发。他若想离婚，那就坐实告发。谁让他确实与梁思申认识呢。程父是料定他与梁思申没关联，又更料定他爱事业胜过一切，推定他肯定会不惜代价坚持项目，才会出此下策。程父大概也很清楚，他若真因此与程开颜重修旧好，以后就没脸再提离婚。宋运辉无法不感叹，姜是老的辣，程父打蛇打七寸，落点一分不差。</p></blockquote><p>——第161章 1992年(25)</p><blockquote><p>这一刻，宋运辉意识到，他再找多少理由，都无法掩盖一条事实，结婚至今，他变心了。他犹豫良久，才勉强挤出一句：“没有。”</p><p>可心中也清楚，他心虚，他无法再为自己找任何理由。</p></blockquote><p>——第170章 1993年(9)</p><h2 id="梁思申">梁思申</h2><blockquote><p>“那是你傻。”外公都不要听梁思申的申诉，“我走遍全世界，哪儿都一样，什么事只要跟钱搭一起，都没个干净的。你们那行当算计的都是大钱，即使规则也是黑的，你还什么讲规则，你是给洗脑了才不觉得黑。你跟我说秃鹫，秃鹫是干什么的？你做秃鹫玩得高兴，你想过被秃鹫吃的人是什么想法？股票又是什么？衍生品又是什么？都是内行人空对空玩外行人的游戏。只有你才以为是数字是科学，笨蛋！难怪你一会儿控诉你爸一会儿又控诉小辉，敢情你学校出来还没长大过啊，会不会太弱智，难道以前是我高看你了？”</p></blockquote><p>——第294章 1998年(3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书 - 改革 - 大江大河" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6-%E6%94%B9%E9%9D%A9-%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP 路线图</title>
    <link href="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/"/>
    <id>https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/</id>
    <published>2020-03-30T14:28:50.000Z</published>
    <updated>2020-03-30T15:29:06.909Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png" /></p><p>nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。</p><a id="more"></a><ul><li>关键字之间的关系可以用模棱两可的方式解释，因为它们以语义思维导图的格式表示。请只关注方框中的关键字，并将其视为学习的必要部分。</li><li>仅在图像中包含大量关键字和知识的工作就具有挑战性。因此，请注意，此路线图是建议或想法之一。</li><li>您有资格自由使用材料（包括商业目的），但强烈希望提供参考。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li></ul><h2 id="概率统计">概率统计</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/prob.png" /></p><h2 id="机器学习">机器学习</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/ml.png" /></p><h2 id="文字挖掘">文字挖掘</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/textmining.png" /></p><h2 id="自然语言处理">自然语言处理</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/nlp.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/graykode/nlp-roadmap" target="_blank" rel="noopener" class="uri">https://github.com/graykode/nlp-roadmap</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="nlp" scheme="https://2020.iosdevlog.com/tags/nlp/"/>
    
  </entry>
  
</feed>
