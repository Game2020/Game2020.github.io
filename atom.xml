<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-01-30T14:03:57.350Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wiki 添加 https 支持</title>
    <link href="https://2020.iosdevlog.com/2020/01/30/htttps/"/>
    <id>https://2020.iosdevlog.com/2020/01/30/htttps/</id>
    <published>2020-01-30T07:58:26.000Z</published>
    <updated>2020-01-30T14:03:57.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/30/https/1.png" alt=""></p><a id="more"></a><h2 id="1-安装-acme-sh"><a href="#1-安装-acme-sh" class="headerlink" title="1. 安装 acme.sh"></a>1. 安装 acme.sh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.acme.sh | sh</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="DNSPod-cn-Option"><a href="#DNSPod-cn-Option" class="headerlink" title="DNSPod.cn Option:"></a>DNSPod.cn Option:</h3><p>The DNSPod.cn Domain API option requires that you first login to your account to get a DNSPod API Key and ID.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DP_Id=<span class="string">"1234"</span></span><br><span class="line"><span class="built_in">export</span> DP_Key=<span class="string">"sADDsdasdgdsf"</span></span><br></pre></td></tr></table></figure><p>Ok, let’s issue a cert now:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 775 /etc/letsencrypt</span><br><span class="line">sudo chmod -R 777 /var/www/html/</span><br><span class="line">acme.sh --issue --dns dns_dp -d 1001.iosdevlog.com -w /var/www/html</span><br></pre></td></tr></table></figure><p>The DP_Id and DP_Key will be saved in ~/.acme.sh/account.conf and will be reused when needed.</p><h2 id="2-生成证书"><a href="#2-生成证书" class="headerlink" title="2. 生成证书"></a>2. 生成证书</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/apache2/ssl/</span><br><span class="line">sudo chmod 777 -R /etc/apache2/ssl/</span><br></pre></td></tr></table></figure><p><code>/etc/apache2/sites-available/1001.conf</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLCertificateFile      /etc/apache2/ssl/cert.pem</span><br><span class="line">SSLCertificateKeyFile   /etc/apache2/ssl/key.pem</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --installcert -d 1001.iosdevlog.com \</span><br><span class="line">--cert-file /etc/apache2/ssl/cert.pem \</span><br><span class="line">--key-file /etc/apache2/ssl/key.pem \</span><br><span class="line">--reloadcmd <span class="string">"service apache2 force-reload"</span></span><br></pre></td></tr></table></figure><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>非常关键的一步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo apt install openssl</span></span><br><span class="line"><span class="comment"># 加载 Apache 的 SSL 模块</span></span><br><span class="line">sudo a2enmod ssl</span><br><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><p>访问：<a href="https://1001.iosdevlog.com/mediawiki/" target="_blank" rel="noopener">https://1001.iosdevlog.com/mediawiki/</a></p><h3 id="测试-https"><a href="#测试-https" class="headerlink" title="测试 https"></a>测试 https</h3><p><a href="https://www.ssllabs.com/ssltest" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest</a></p><p><a href="https://console.dnspod.cn/account/token" target="_blank" rel="noopener">https://console.dnspod.cn/account/token</a></p><p>参考：<a href="https://certbot.eff.org/lets-encrypt/ubuntuxenial-apache" target="_blank" rel="noopener">https://certbot.eff.org/lets-encrypt/ubuntuxenial-apache</a></p><p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-30.png" alt="2020/01/30"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/30/https/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="1001" scheme="https://2020.iosdevlog.com/categories/1001/"/>
    
    
      <category term="wiki" scheme="https://2020.iosdevlog.com/tags/wiki/"/>
    
      <category term="MediaWiki" scheme="https://2020.iosdevlog.com/tags/MediaWiki/"/>
    
      <category term="https" scheme="https://2020.iosdevlog.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04 上运行 MediaWiki</title>
    <link href="https://2020.iosdevlog.com/2020/01/29/wiki/"/>
    <id>https://2020.iosdevlog.com/2020/01/29/wiki/</id>
    <published>2020-01-29T13:56:45.000Z</published>
    <updated>2020-01-30T13:29:40.231Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-29.png" alt="2020/01/29"></p><a id="more"></a><p><code>Ubuntu 16.04</code> 上运行 <a href="https://www.mediawiki.org" target="_blank" rel="noopener">MediaWiki</a></p><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="添加用户-iosdevlog"><a href="#添加用户-iosdevlog" class="headerlink" title="添加用户 iosdevlog"></a>添加用户 <code>iosdevlog</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@iosdevlog:~<span class="comment"># adduser iosdevlog</span></span><br><span class="line">Adding user `iosdevlog<span class="string">' ...</span></span><br><span class="line"><span class="string">Adding new group `iosdevlog'</span> (1000) ...</span><br><span class="line">Adding new user `iosdevlog<span class="string">' (1000) with group `iosdevlog'</span> ...</span><br><span class="line">Creating home directory `/home/iosdevlog<span class="string">' ...</span></span><br><span class="line"><span class="string">Copying files from `/etc/skel'</span> ...</span><br><span class="line">Enter new UNIX password:</span><br><span class="line">Retype new UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information <span class="keyword">for</span> iosdevlog</span><br><span class="line">Enter the new value, or press ENTER <span class="keyword">for</span> the default</span><br><span class="line">Full Name []:</span><br><span class="line">Room Number []:</span><br><span class="line">Work Phone []:</span><br><span class="line">Home Phone []:</span><br><span class="line">Other []:</span><br><span class="line">Is the information correct? [Y/n]</span><br></pre></td></tr></table></figure><h3 id="分配-sudo-权限"><a href="#分配-sudo-权限" class="headerlink" title="分配 sudo 权限"></a>分配 sudo 权限</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@iosdevlog:~<span class="comment"># usermod -aG sudo iosdevlog</span></span><br></pre></td></tr></table></figure><h3 id="测试-sudo-权限"><a href="#测试-sudo-权限" class="headerlink" title="测试 sudo 权限"></a>测试 sudo 权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@iosdevlog:~# echo $USER</span><br><span class="line">root</span><br><span class="line">root@iosdevlog:~# su - iosdevlog</span><br><span class="line">To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.</span><br><span class="line">See &quot;man sudo_root&quot; for details.</span><br><span class="line">iosdevlog@iosdevlog:~$ echo $USER</span><br><span class="line">iosdevlog</span><br><span class="line">iosdevlog@iosdevlog:~$ ll</span><br><span class="line">total 28</span><br><span class="line">drwxr-xr-x 4 iosdevlog iosdevlog 4096 Jan 29 10:14 .&#x2F;</span><br><span class="line">drwxr-xr-x 3 root      root      4096 Jan 29 10:13 ..&#x2F;</span><br><span class="line">-rw-r--r-- 1 iosdevlog iosdevlog  220 Jan 29 10:13 .bash_logout</span><br><span class="line">-rw-r--r-- 1 iosdevlog iosdevlog 3771 Jan 29 10:13 .bashrc</span><br><span class="line">drwx------ 2 iosdevlog iosdevlog 4096 Jan 29 10:14 .cache&#x2F;</span><br><span class="line">-rw-r--r-- 1 iosdevlog iosdevlog  655 Jan 29 10:13 .profile</span><br><span class="line">drwx------ 2 iosdevlog iosdevlog 4096 Jan 29 10:14 .ssh&#x2F;</span><br></pre></td></tr></table></figure><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>无密码登录(Client)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C ‘iosdevlog@iosdevlog.com’</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub -p 1519 iosdevlog@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><code>alias wiki</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wiki=<span class="string">'ssh -p 1519 xx.xx.xx.xx'</span></span><br></pre></td></tr></table></figure><p>确保您的 <code>Ubuntu</code> 系统是最新的</p><p>通过运行来仔细检查 <code>Ubuntu</code> 是否是最新的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br><span class="line"><span class="comment"># or in one line</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>添加 <code>ppa:ondrej/php</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"><span class="comment"># 按 Enter 确认.</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>安装LAMP软件栈</p><p>使LAMP（Apache、PHP和MySQL）在安装过程中可供安装。</p><p>在安装步骤中，请确保选择安装LAMP服务器。 或者，您可以使用以下命令从标准安装中安装所有这些软件包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2 mysql-server php7.4 php7.4-mysql libapache2-mod-php7.4 php7.4-xml php7.4-mbstring</span><br></pre></td></tr></table></figure><p>可选的有用软件包</p><table><thead><tr><th>名称</th><th>包名</th><th>说明</th></tr></thead><tbody><tr><td>可选的 PHP 缓存</td><td>php-apcu or php5-apcu</td><td>现代MediaWiki版本将自动利用此安装来提高性能。</td></tr><tr><td>PHP Unicode规范化</td><td>php-intl or php5-intl</td><td>如果不可用，MediaWiki将回退到较慢的PHP实现。</td></tr><tr><td>ImageMagick</td><td>imagemagick</td><td>图像缩略图。</td></tr><tr><td>Inkscape</td><td>inkscape</td><td>SVG缩略图的替代方法，比ImageMagick。 有时，如果最初在Inkscape中创建，它将更好地渲染SVG。</td></tr><tr><td>PHP GD 库</td><td>php-gd 或 php5-gd</td><td>ImageMagick替代图像缩略图。</td></tr><tr><td>PHP command-line</td><td>php-cli 或 php5-cli</td><td>能够从命令行运行PHP命令，这对于调试和运行维护脚本很有用。</td></tr><tr><td>PHP cURL</td><td>php-curl 或 php5-curl</td><td>某些扩展名要求，例如Extension:Math，见Manual:cURL</td></tr><tr><td>git source control version</td><td>git</td><td>如果不存在，配置脚本将告诉您它未安装</td></tr></tbody></table><p>安装所有这些</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php7.4-apcu php7.4-intl imagemagick inkscape php7.4-gd php7.4-cli php7.4-curl git</span><br></pre></td></tr></table></figure><p>如果安装php-apcu，则必须重新加载 <code>apache</code> 配置，以避免在运行配置脚本时出现警告消息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 reload</span><br></pre></td></tr></table></figure><h2 id="安装-MediaWiki"><a href="#安装-MediaWiki" class="headerlink" title="安装 MediaWiki"></a>安装 <code>MediaWiki</code></h2><ul><li>下载官方压缩包。</li></ul><p>这可以通过浏览器或命令行完成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">wget https://releases.wikimedia.org/mediawiki/1.34/mediawiki-1.34.0.tar.gz</span><br></pre></td></tr></table></figure><ul><li>解压到你的Web目录里</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf /tmp/mediawiki-*.tar.gz</span><br><span class="line">sudo mkdir /var/lib/mediawiki</span><br><span class="line">sudo mv mediawiki-*/* /var/lib/mediawiki</span><br></pre></td></tr></table></figure><h2 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h2><ul><li>创建一个新的mysql用户（wiki）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands <span class="keyword">end</span> <span class="keyword">with</span> ; or \g.</span><br><span class="line">Your MySQL connection id is 8</span><br><span class="line">Server version: 5.7.29-0ubuntu0.16.04.1 (Ubuntu)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type '<span class="keyword">help</span>;' or '\h' for help. <span class="keyword">Type</span> <span class="string">'\c'</span> <span class="keyword">to</span> <span class="keyword">clear</span> the <span class="keyword">current</span> <span class="keyword">input</span> statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'wiki'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'THISpasswordSHOULDbeCHANGED'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; quit;</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure><ul><li>创建一个新的 <code>mysql</code> 数据库 <code>wiki</code>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo mysql -u root</span></span><br><span class="line">mysql&gt; CREATE DATABASE wiki;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; use wiki;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><ul><li>授予新的 <code>mysql</code> 用户访问新创建的 <code>mysql</code> 数据库 <code>wiki</code>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL ON wiki.* TO 'wiki'@'localhost';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="内存限制（无需修改）"><a href="#内存限制（无需修改）" class="headerlink" title="内存限制（无需修改）"></a>内存限制（无需修改）</h2><p><code>/etc/php/7.0/apache2/php.ini</code></p><p>一些 PHP 脚本运行时需要很多内存。 要增加脚本可以使用的最大内存量，请向下翻页约21％，并从中更改以下条目（如果找到）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory_limit &#x3D; 8M</span><br></pre></td></tr></table></figure><p>到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory_limit &#x3D; 128M</span><br></pre></td></tr></table></figure><p>如果已设置为 <code>128M</code> 或更高，请保持原样。</p><h2 id="配置MediaWiki"><a href="#配置MediaWiki" class="headerlink" title="配置MediaWiki"></a>配置MediaWiki</h2><p>将浏览器导航到 <a href="http://localhost/mediawiki，并按照给定的步骤进行操作。" target="_blank" rel="noopener">http://localhost/mediawiki，并按照给定的步骤进行操作。</a></p><p>如果这给出了 <code>404</code> 错误，则使用符号链接应解决它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /var/lib/mediawiki /var/www/html/wiki</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/01/29/wiki/1.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/2.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/3.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/4.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/5.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/6.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/7.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/8.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/9.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/10.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/11.png" alt=""><br><img src="https://2020.iosdevlog.com/2020/01/29/wiki/12.png" alt=""></p><p>参考：<a href="https://www.mediawiki.org/wiki/Manual:Running_MediaWiki_on_Debian_or_Ubuntu/zh" target="_blank" rel="noopener">https://www.mediawiki.org/wiki/Manual:Running_MediaWiki_on_Debian_or_Ubuntu/zh</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-29.png&quot; alt=&quot;2020/01/29&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="1001" scheme="https://2020.iosdevlog.com/categories/1001/"/>
    
    
      <category term="wiki" scheme="https://2020.iosdevlog.com/tags/wiki/"/>
    
      <category term="MediaWiki" scheme="https://2020.iosdevlog.com/tags/MediaWiki/"/>
    
  </entry>
  
  <entry>
    <title>写给孩子的冠状病毒绘本</title>
    <link href="https://2020.iosdevlog.com/2020/01/28/Coronavirus/"/>
    <id>https://2020.iosdevlog.com/2020/01/28/Coronavirus/</id>
    <published>2020-01-28T15:34:41.000Z</published>
    <updated>2020-01-28T16:07:56.710Z</updated>
    
    <content type="html"><![CDATA[<p>分享小武幼儿园宣传的 <strong>冠状病毒绘本</strong>。</p><p><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0001.jpg" alt="Coronavirus"></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0002.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0003.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0004.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0005.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0006.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0007.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0008.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0009.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0010.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0011.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0012.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0013.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0014.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0015.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0016.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0017.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0018.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0019.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0020.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0021.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0022.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0023.jpg" alt="Coronavirus"><br><img src="https://2020.iosdevlog.com/2020/01/28/Coronavirus/0024.jpg" alt="Coronavirus"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分享小武幼儿园宣传的 &lt;strong&gt;冠状病毒绘本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/28/Coronavirus/0001.jpg&quot; alt=&quot;Coronavirus&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="小武" scheme="https://2020.iosdevlog.com/categories/%E5%B0%8F%E6%AD%A6/"/>
    
    
      <category term="绘本" scheme="https://2020.iosdevlog.com/tags/%E7%BB%98%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>特征工程</title>
    <link href="https://2020.iosdevlog.com/2020/01/27/Feature-engineering/"/>
    <id>https://2020.iosdevlog.com/2020/01/27/Feature-engineering/</id>
    <published>2020-01-27T13:24:34.000Z</published>
    <updated>2020-01-27T14:11:14.787Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/27/Feature-engineering/1.jpg" alt="Feature engineering"></p><a id="more"></a><p>多明戈斯的观点是：</p><blockquote><p>数据量比算法更重要。</p></blockquote><p>即使算法本身并没有什么精巧的设计，但使用大量数据进行训练也能起到填鸭的效果，获得比用少量数据训练出来的聪明算法更好的性能。这也应了那句老话：</p><blockquote><p>数据决定了机器学习的上限，而算法只是尽可能逼近这个上限。</p></blockquote><p><strong>特征工程（feature engineering）才是机器学习的关键</strong></p><p>通常来说，原始数据并不直接适用于学习，而是特征筛选、构造和生成的基础。一个好的预测模型与高效的特征提取和明确的特征表示息息相关，如果通过特征工程得到很多独立的且与所属类别相关的特征，那学习过程就变成小菜一碟。</p><h2 id="在特征工程之前，数据的特征需要经过哪些必要的预处理（preprocessing）"><a href="#在特征工程之前，数据的特征需要经过哪些必要的预处理（preprocessing）" class="headerlink" title="在特征工程之前，数据的特征需要经过哪些必要的预处理（preprocessing）?"></a>在特征工程之前，数据的特征需要经过哪些必要的预处理（preprocessing）?</h2><h3 id="特征缩放（feature-scaling）"><a href="#特征缩放（feature-scaling）" class="headerlink" title="特征缩放（feature scaling）"></a>特征缩放（feature scaling）</h3><p>可能是最广为人知的预处理技巧了，它的目的是保证所有的特征数值具有相同的数量级。</p><p>特征缩放的作用就是消除特征的不同尺度所造成的偏差，具体的变换方法有以下这两种：</p><ul><li>标准化（standardization）</li></ul><p>$$<br>x_{s t}=\frac{x-\operatorname{mean}(x)}{\operatorname{stdev}(x)}<br>$$</p><ul><li>归一化（normalization）</li></ul><p>$$<br>x_{\text {norm}}=\frac{x-\min (x)}{\max (x)-\min (x)}<br>$$</p><ul><li>特征缩放可以让不同特征的取值具有相同的尺度，方法包括标准化和归一化；</li><li>异常点会导致数据的有偏分布，对数变换和空间标识都可以去除数据的偏度；</li><li>k 近邻方法和线性回归可以用来对特征的缺失值进行人为赋值；</li><li>删除不具备区分度的特征能够降低计算开销，增强可解释性。</li></ul><p>参考：<a href="https://time.geekbang.org/column/article/8530" target="_blank" rel="noopener">https://time.geekbang.org/column/article/8530</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/27/Feature-engineering/1.jpg&quot; alt=&quot;Feature engineering&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯视角下的机器学习</title>
    <link href="https://2020.iosdevlog.com/2020/01/26/Bayes/"/>
    <id>https://2020.iosdevlog.com/2020/01/26/Bayes/</id>
    <published>2020-01-26T13:22:39.000Z</published>
    <updated>2020-01-26T13:28:20.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-26.png" alt="2020/01/26"></p><a id="more"></a><p>为了解决频率主义的问题，贝叶斯学派给出了一种更加通用的概率定义：</p><blockquote><p>概率表示的是客观上事件的可信程度（degree of belief），也可以说成是主观上主体对事件的信任程度，它是建立在对事件的已有知识基础上的。</p></blockquote><p>比方说，当一个球迷提出“明天皇家马德里战胜拉斯帕尔马斯的概率是 86%”的时候，可以理解成他对皇马获胜有 86% 的把握程度，要是买球的话自然就会在独胜上下出重注（其实贝叶斯概率正是来源于对赌博的分析）。</p><p>除了对概率的置信度解释之外，贝叶斯学派中的另一个核心内容是贝叶斯定理（Bayes’ theorem），用来解决“逆向概率问题”（inverse probability problem）。</p><p>机器学习能够解决的问题必然会包含某些显式或者隐式的模式，没有模式的问题就不能通过机器学习解决。完全随机的问题是不可能被求解，也不可能被学习的，就像我们永远也没法预测示波器下一时刻的本底噪声一样。</p><p>一提到模式，你可能会一下子联系到另一个专业词汇——<strong>模式识别（pattern recognition）</strong>。模式识别和机器学习实际上有大量的共通之处，严格地将两者区分开来既没方法也没必要。如果非要找到些不同的话，模式识别是被更广泛地应用在计算机视觉（computer vision）等专门领域之中的专门概念，工程上的意义更浓一些。如果说机器学习侧重于将预先设定的准确率等指标最大化，那模式识别就更注重于潜在模式的提取与解释。</p><p>参考：<a href="https://time.geekbang.org/column/intro/97" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/97</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-26.png&quot; alt=&quot;2020/01/26&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>频率视角下的机器学习</title>
    <link href="https://2020.iosdevlog.com/2020/01/25/Frequency/"/>
    <id>https://2020.iosdevlog.com/2020/01/25/Frequency/</id>
    <published>2020-01-25T12:59:28.000Z</published>
    <updated>2020-01-25T13:09:12.823Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/25/Frequency/1.jpg" alt="Frequency"></p><p> <strong>笑话</strong>: 频率学派 &amp; 贝叶斯学派</p><blockquote><p>有个病人找医生看病，医生检查之后对他说：“你这病说得上是九死一生，但多亏到我这里来看了。不瞒你说，在你之前我已经看了九个得一同样病的患者，结果他们都死了，那你这第十个就一定能看得好啦，妥妥的！”</p></blockquote><a id="more"></a><p>频率学派口中的概率表示的是事件发生频率的极限值，它只有在无限次的独立重复试验之下才有绝对的精确意义。</p><p>在频率学派眼中，当重复试验的次数趋近于无穷大时，事件发生的频率会收敛到真实的概率之上。这种观点背后暗含了一个前提，那就是概率是一个确定的值，并不会受单次观察结果的影响。</p><p>频率统计理论的核心在于认定待估计的参数是固定不变的常量，讨论参数的概率分布是没有意义的；而用来估计参数的数据是随机的变量，每个数据都是参数支配下一次独立重复试验的结果。由于参数本身是确定的，那频率的波动就并非来源于参数本身的不确定性，而是由有限次观察造成的干扰而导致。</p><p>这可以从两个角度来解释：</p><ol><li>一方面，根据这些不精确的数据就可以对未知参数的精确取值做出有效的推断；</li><li>另一方面，数据中包含的只是关于参数不完全的信息，所以从样本估计整体就必然会产生误差。</li></ol><p>统计学的核⼼任务之一是根据从总体中抽取出的样本，也就是数据来估计未知的总体参数。参数的最优估计可以通过样本数据的分布，也就是 <strong>采样分布（sampling distribution）</strong> 来求解，由于频率统计将数据看作随机变量，所以计算采样分布是没有问题的。确定采样分布之后，参数估计可以等效成一个最优化的问题，而频率统计最常使用的最优化方法，就是 <strong>最大似然估计（maximum likelihood estimation）</strong>。</p><p>那么如何来度量作为随机变量的估计值和作为客观常量的真实值之间的偏差呢？<strong>置信区间（confidence interval）</strong> 就是频率学派给出的答案。</p><p>频率主义解决统计问题的基本思路如下：</p><ul><li>参数是确定的，</li><li>数据是随机的，</li><li>利用随机的数据推断确定的参数，</li><li>得到的结果也是随机的。</li></ul><p>将频率主义“参数确定，数据随机”的思路应用在机器学习当中，得到的就是统计机器学习（statistical learning）。</p><p>和参数相关的信息全部来源于数据，输出的则是未知参数唯一的估计结果，这是统计机器学习的核心特征。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>频率学派认为概率是随机事件发生频率的极限值； </li><li>频率学派执行参数估计时，视参数为确定取值，视数据为随机变量；</li><li>频率学派主要使用最大似然估计法，让数据在给定参数下的似然概率最大化；</li><li>频率学派对应机器学习中的统计学习，以经验风险最小化作为模型选择的准则。</li></ol><p>参考：<a href="https://time.geekbang.org/column/article/8530" target="_blank" rel="noopener">https://time.geekbang.org/column/article/8530</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/25/Frequency/1.jpg&quot; alt=&quot;Frequency&quot;&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;笑话&lt;/strong&gt;: 频率学派 &amp;amp; 贝叶斯学派&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有个病人找医生看病，医生检查之后对他说：“你这病说得上是九死一生，但多亏到我这里来看了。不瞒你说，在你之前我已经看了九个得一同样病的患者，结果他们都死了，那你这第十个就一定能看得好啦，妥妥的！”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>打通修炼机器学习的任督二脉</title>
    <link href="https://2020.iosdevlog.com/2020/01/24/ml/"/>
    <id>https://2020.iosdevlog.com/2020/01/24/ml/</id>
    <published>2020-01-24T12:26:11.000Z</published>
    <updated>2020-01-24T12:30:51.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-24.png" alt="2020/01/24"></p><a id="more"></a><h2 id="机器学习概观"><a href="#机器学习概观" class="headerlink" title="机器学习概观"></a>机器学习概观</h2><p>介绍机器学习中超脱于具体模型和方法之上的一些共性问题，将从概率的两大派别开始。</p><p>众所周知，概率在机器学习中扮演着核心角色，而频率学派与贝叶斯学派对概率迥异的认知也将机器学习一分为二，发展出两套完全不同的理论体系。</p><p>正所谓兼听则明偏听则暗，理解机器学习时应该看到这同一枚硬币的两面，以获得完整的认知。除此之外，本模块还涵盖了计算学习等机器学习的理论问题，以及关于模型和特征的一些实验主题。</p><h2 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h2><p>频率学派发展出的机器学习理论——统计学习。</p><p>统计机器学习的核心是数据，它既从数据中来，利用不同的模型去拟合数据背后的规律；也到数据中去，用拟合出的规律去推断和预测未知的结果。</p><p>统计学习中最基础的模型是线性回归，几乎所有其他模型都是从不同角度对线性回归模型做出的扩展与修正。</p><p>因此，在这个模块中，我将以线性模型为主线，和你一起浏览它的万千变化，观察从简单线性回归到复杂深度网络的发展历程。</p><h2 id="符号学习"><a href="#符号学习" class="headerlink" title="符号学习"></a>符号学习</h2><p>贝叶斯学派发展出的机器学习理论，也就是 <strong>概率图模型</strong>。</p><p>和基于数据的统计学习相比，基于关系的图模型更多地代表了因果推理的发展方向。</p><p>贝叶斯主义也需要计算待学习对象的概率分布，但它利用的不是海量的具体数据，而是变量之间的相关关系、每个变量的先验分布和大量复杂的积分技巧。</p><ul><li>表示</li><li>推断</li><li>学习</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-24.png&quot; alt=&quot;2020/01/24&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发: tolower</title>
    <link href="https://2020.iosdevlog.com/2020/01/23/tolower/"/>
    <id>https://2020.iosdevlog.com/2020/01/23/tolower/</id>
    <published>2020-01-23T12:31:18.000Z</published>
    <updated>2020-01-23T13:18:24.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/23/tolower/1.gif" alt=""></p><ol><li>首先，读取文档中的内容。需要使用的 API 是 selection、selections、getText 等。</li><li>其次，对这些内容进行二次加工，这部分就是 business logic 了。</li><li>最后，修改编辑器内的内容。我们可以使用 edit 来修改文本，也可以直接修改 editor.selection 和 editor.selections 来改变光标的位置。</li></ol><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>VS Code 的插件就是一个 <code>Node.js</code> 的应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yeoman</span></span><br><span class="line">npm -g install yo</span><br><span class="line"><span class="comment"># VS Code 的模板</span></span><br><span class="line">npm install -g generator-code</span><br></pre></td></tr></table></figure><h2 id="创建-tolower-插件"><a href="#创建-tolower-插件" class="headerlink" title="创建 tolower 插件"></a>创建 <code>tolower</code> 插件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tolower</span></span><br><span class="line">yo code tolower</span><br><span class="line">     _-----_     ╭──────────────────────────╮</span><br><span class="line">    |       |    │   Welcome to the Visual  │</span><br><span class="line">    |--(o)--|    │   Studio Code Extension  │</span><br><span class="line">   `---------´   │        generator!        │</span><br><span class="line">    ( _´U`_ )    ╰──────────────────────────╯</span><br><span class="line">    /___A___\   /</span><br><span class="line">     |  ~  |</span><br><span class="line">   __<span class="string">'.___.'</span>__</span><br><span class="line"> ´   `  |° ´ Y `</span><br><span class="line"></span><br><span class="line">? What <span class="built_in">type</span> of extension <span class="keyword">do</span> you want to create?</span><br><span class="line">  New Extension (TypeScript)</span><br><span class="line">❯ New Extension (JavaScript)</span><br><span class="line">  New Color Theme</span><br><span class="line">  New Language Support</span><br><span class="line">  New Code Snippets</span><br><span class="line">  New Keymap</span><br><span class="line">  New Extension Pack</span><br><span class="line">(Move up and down to reveal more choices)</span><br></pre></td></tr></table></figure><h2 id="访问编辑器"><a href="#访问编辑器" class="headerlink" title="访问编辑器"></a>访问编辑器</h2><p>既然是编辑器相关的命令，那么我们肯定需要能够访问到编辑器，以及其中的内容。首先我们要获取的就是：当前工作区内，用户正在使用的编辑器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> editor = vscode.window.activeTextEditor;</span><br></pre></td></tr></table></figure><p>如果你是手动敲入上面的代码，你可以看到 VS Code 提示的插件 API 建议。</p><p>有了这个编辑器，我们就能获取非常多的信息了。不过先别急，editor 这个变量并非一定总是有效的值，比如用户现在并没有打开任何文件，编辑器是空的，那么此时 editor 的值就是 undefined。所以， 在正式使用 editor 之前，我们要判断一下，editor 是否为 undefined，是的话就结束命令的运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!editor) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们可以输入 editor.，自动补全立刻给我们提示了不少的属性。</p><p>这其中几个值得一提的有如下：</p><ul><li><code>document</code> :也就是当前编辑器中的文档内容；</li><li><code>edit</code> :用于修改编辑器中的内容；</li><li><code>revealRange</code> :用于将某段代码滚动到当前窗口中；</li><li><code>selection</code> :当前编辑器内的主光标；</li><li><code>selections</code> :当前编辑器中的所有光标，第一个光标就是主光标，后面的则是用户创建出来的多光标；</li><li><code>setDecorations</code> :设置编辑器装饰器</li></ul><p>首先，我们要读取的信息就是当前的文档信息和主光标的信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = editor.document;</span><br><span class="line"><span class="keyword">let</span> selection = editor.selection;</span><br></pre></td></tr></table></figure><p>有了这两个信息，读取光标选中的内容就简单了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">document</span>.getText(selection);</span><br></pre></td></tr></table></figure><p>document 一共哪些 API 这里我就不介绍了，相信你可以自己探索，这里我们使用就是 getText，以获取某段代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = text.toLowerCase();</span><br></pre></td></tr></table></figure><p>最后一步操作就是将原来编辑器内的文本进行替换了。此时我们就要用到 edit 这个 API 了。值得注意的是，这个 API 的第一参数，是一个 callback，callback 的参数是 editBuilder，也就是真正用于修改代码的对象。editBuilder 有以下几个 API：</p><ul><li>delete</li><li>insert</li><li>replace</li><li>setEndOfLine</li></ul><p>这里我们要使用的当然就是 replace 了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">editBuilder.replace(selection, result);</span><br></pre></td></tr></table></figure><p>我们只需将原先的 selection 里的内容，替换成新的 result 即可。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>上面我们介绍了如何去书写一个命令，但是这只是完成了工作的一半，剩下的一半则是为这个命令绑定一个快捷键了。要完成快捷键的绑定，我们需要在 package.json 中的 contributes 片段添加一段新的配置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"contributes": &#123;</span><br><span class="line">"commands": [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.tolower"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"to lower"</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">"keybindings": [</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="attr">"key"</span>: <span class="string">"ctrl+l"</span>,</span><br><span class="line"> <span class="attr">"command"</span>: <span class="string">"extension.tolower"</span>,</span><br><span class="line"> <span class="attr">"when"</span>: <span class="string">"editorTextFocus"</span></span><br><span class="line"> &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们在 contributes 添加了新的字段 “keybindings” ，它的值是一个数组，里面就是所有的快捷键设置了。</p><p>我们给 “extension.sayHello” 这个命令，绑定了 ctrl+t ，同时只有当 editorTextToLower 为真时才会激活这个快捷键。此时如果我们运行这个插件，就可以直接使用 ctrl + l 来转换成小写。</p><h2 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h2><ol><li><code>F5</code></li><li>选中要转换成小写的文本</li><li>运行<ol><li>命令<ol><li><code>Ctrl + Shift + P</code></li><li><code>to lower</code></li></ol></li><li>快捷键<ol><li><code>Ctrl + l</code></li></ol></li></ol></li></ol><p>源码：<a href="https://github.com/Game2020/tolower" target="_blank" rel="noopener">https://github.com/Game2020/tolower</a></p><p>参考：<a href="https://time.geekbang.org/column/article/69768" target="_blank" rel="noopener">玩转VS Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/23/tolower/1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，读取文档中的内容。需要使用的 API 是 selection、selections、getText 等。&lt;/li&gt;
&lt;li&gt;其次，对这些内容进行二次加工，这部分就是 business logic 了。&lt;/li&gt;
&lt;li&gt;最后，修改编辑器内的内容。我们可以使用 edit 来修改文本，也可以直接修改 editor.selection 和 editor.selections 来改变光标的位置。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="editor" scheme="https://2020.iosdevlog.com/categories/editor/"/>
    
    
      <category term="vscode" scheme="https://2020.iosdevlog.com/tags/vscode/"/>
    
      <category term="plugin" scheme="https://2020.iosdevlog.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>《地球编年史》简介</title>
    <link href="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/"/>
    <id>https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/</id>
    <published>2020-01-22T15:40:46.000Z</published>
    <updated>2020-01-22T16:08:00.134Z</updated>
    
    <content type="html"><![CDATA[<p>最近想看一些科幻，神话类的小说，发现中国的《山海经》和国外的《地球编年史》不错，介绍一下。</p><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg" alt=""></p><a id="more"></a><p>地球编年史<br>出版社:  重庆出版社<br>册数:  8</p><p>撒迦利亚·西琴（Zecharia Sitchin）是一位在国际上备受尊敬的作家和研究者，从1976年起，他陆续出版了一部在全球范围内影起巨大反响的系列作品《地球编年史》。这套多达7册的开创性的大书迄今为止已被译为30种语言出版，印刷近2000万册。</p><p>在书中，作者结合考古学、古文字学、东方学与《圣经》学的最新科学发现，重新编织并复述了整个人类的历史──尤其是史前地球史和人类史。他提供的证据表明，上古神话并不仅仅是传说或幻觉，而是被我们日渐遗忘的遥远的史实。</p><p>7册编年史从45万年以前由太阳系中的第12个天体尼比鲁（Nibiru）──亦即被美国航天局（NASA）在1982年发现并命名为第十大行星（Planet X）的神秘天体──上降临地球的外星高智能生物阿努那奇（Anunnaki）对地球的统治开始，中间经历了人类的崛起以及大洪水的灾难，到公元前2023年近东地区苏美尔人的覆灭为止，重构了人类起源与发展的全部历程。作者的观点新颖而极富冲击力，使该系列图书的影响力持继30余年，至今不衰。</p><p>作为世界上少数能解读苏美尔楔形文字的学者，撒迦利亚·西琴同时也精通希伯来语、塞姆语和欧洲的各种语言。他的研究遍及古巴比伦、古埃及、古印度和玛雅文化等领域，一生致力于人类起源的研究活动。他的研究活动甚至被立为一门独立的学科“西琴学”。当然，最耐人寻味也最有意义的是，他的研究表明，人类在太阳系中并不孤独，因为在经过了3600年的一个轨道运行周期后，第12个天体即将返回并掠过它也许足以再次影响我们的近地点。</p><p>撒迦利亚·西琴1922年出生于俄罗斯阿塞拜疆首府库班，在乌克兰度过幼年时代。年长后在伦敦大学攻读过考古学、历史学、语言学、经济学及神话学等。现居住在美国纽约。</p><p>作者在他的网站（<a href="http://www.sitchin.com）上随时与读者分享其最新研究成果。" target="_blank" rel="noopener">http://www.sitchin.com）上随时与读者分享其最新研究成果。</a></p><h2 id="《地球编年史》指南"><a href="#《地球编年史》指南" class="headerlink" title="《地球编年史》指南"></a>《地球编年史》指南</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》七部书完全手册<br>原作名: The Earth Chronicles Handbook: A Comprehensive Guide to the Seven Books of The Earth Chronicles<br>译者: 黎明<br>出版年: 2012-10<br>页数: 183<br>定价: 32.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229046873</p><h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>★ 涵盖《地球编年史》七部书所有精华的饕餮盛宴<br>★ 打开地球和人类起源大门的最关键钥匙和指南<br>★ 对《地球编年史》这一巨龙的画龙眼睛之作<br>◎ 《地球编年史》七部书为我们了解地球和人类起源打开了一扇窗，透过这扇窗，我们看到了一个完全出乎我们意料的世界。在这背后，还有哪些是你所不知道的东西？<br>◎《地球编年史》系列中出现的所有与《圣经》、神话、宗教和人类诞生有关的词语，你真的完全了解并理解了吗？<br>◎ 在地球文明即将进入新纪元的崭新时刻，西琴带我们重新回顾地球与人类的历史，解读与地球和人类有关的所有宗教、神话和人物，在这一旅程开始之前，你准备好了吗？</p><hr><p>撒迦利亚•西琴生前留给世人的最宝贵财富，读罢让人难以释怀。<br>——《图书馆杂志》<br>撒迦利亚•西琴怀着专业研究者特有的激情，为我们上演了一场让人眼花瞭乱的表演。<br>——《科克斯书评》</p><hr><p>撒迦利亚•西琴和他的《地球编年史》七部书，必定在人类探索地球和人类起源的历史上，留下浓墨重彩的一笔，他绝无仅有且无与伦比的研究揭示了一个地球和人类起源的古老秘密：有关世界远古文明的神话传说，都是建立在先民对事实的回忆基础上的，而被我们所津津乐道的远古众神，则是地外星球来到地球上的访客。</p><p>《地球编年史》七部书上包天文，下罗地理，囊括地球和人类历史上所有的神话、宗教、文化和考古发现，气势磅礴，让人惊叹，但浩浩荡荡两千多页的恢宏巨制，也让一些人只能望洋兴叹。为此，西琴特地为整部《地球编年史》创作了这个独一无二的百科全书式的导航工具，不仅是对所有涉及的神话、宗教、人物等专用词条的详细诠释，更包含西琴对这些文化的创造性理解。<br>本书是对《地球编年史》七部书的锦上添花之作，是对所有未尽事宜的完全解答，即使把它单独拿来看，也不失为一部优秀的史前全球文明入门手册。</p><h2 id="《第十二个天体》"><a href="#《第十二个天体》" class="headerlink" title="《第十二个天体》"></a>《第十二个天体》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/1.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第一部<br>译者: 宋易<br>出版年: 2009-7-1<br>页数: 299<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229006747</p><h3 id="内容简介-·-·-·-·-·-·"><a href="#内容简介-·-·-·-·-·-·" class="headerlink" title="内容简介  · · · · · ·"></a>内容简介  · · · · · ·</h3><p>年复一年，一震惊世人的证据被不断地发现，它们挑战着早已建立的地球生命起源论，并用这些证据向我们证明，一个更为先进的地外文明曾在我们的星球上居住过。<br>带有革命意义的《地球编年史》丛书的第一部，它提供的不可反驳的证据，强烈地证明了那颗“谜之行星”—一尼此鲁的存在。它告诉我们，其上的宇航员为什么要在数个时代之前来到地球，并通过他们的形象造人。<br>超越30年一丝不苟的探索，《第十二个天体》将《创世纪》中大洪水、巴别塔以及娶人类女儿为妻的纳菲力姆的故事，视作事实而非神话那样进行研究。通过将《圣经》故事与苏美尔、巴比伦泥板文献汇总，它挑战着现存的地球和人类的起源观，并向人类提出了一个不同于传统的历史和史前观。</p><h2 id="《通往天国的阶梯》"><a href="#《通往天国的阶梯》" class="headerlink" title="《通往天国的阶梯》"></a>《通往天国的阶梯》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/2.jpg" alt=""></p><p>作者: [美]撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第二部<br>原作名: The Stairway to Heaven<br>译者: 李良波<br>出版年: 2009-8<br>页数: 289 页<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229011659</p><h3 id="内容简介-1"><a href="#内容简介-1" class="headerlink" title="内容简介"></a>内容简介</h3><p>究竟是谁修建了埃及金字塔？从最早的时候起，人类就思考着宇宙、生命……和来世的不解之谜。一些幸运的凡人是在何时何地加入到诸神行列的？位于吉萨的巨大而复杂的建筑物是埃及法老们通往永生的大门，还是星际旅行者为了登陆地球而修建的脉冲信号站？</p><p>在具有开创性的《地球编年史》丛书的第二部中，撒迦利亚·西琴揭开了金字塔的神秘面纱，他通过来自古代的隐秘线索，向人们展示现存的埃及考古学是建立在一个伟大的赝品之上的，并带领读者去往远古诸神阿努纳奇在地球上的太空站和着陆区。而阿努纳奇——“谜之行星”尼比鲁上的天神，人类的创造者，只有他们才握掌着永生的权柄。</p><p>那么，人类，地球上的凡人，是否过去曾经或未来可能得到永生？</p><h2 id="《众神与人类的战争》"><a href="#《众神与人类的战争》" class="headerlink" title="《众神与人类的战争》"></a>《众神与人类的战争》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/3.jpg" alt=""></p><p>作者: ［美］撒迦利亚·西琴<br>出版社: 重庆出版集团<br>副标题: 《地球编年史》第三部<br>原作名: The Wars of Gods and Men<br>译者: 赵娟 / 宋易<br>出版年: 2009-12<br>页数: 304<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229013752</p><h3 id="内容简介-2"><a href="#内容简介-2" class="headerlink" title="内容简介"></a>内容简介</h3><p>以30种语言畅销25周年的最新修订版<br>是谁摧毁了地球及人类的上一次文明？<br>惊人的书面文献证明了一系列发生在史前的世界大战</p><hr><p>“《地球编年史》继续其伟大的进程，为我们展开了诸神统治地球时发生的世界大战乃至星球大战。这注定是一部最重要也最受争议的史诗性大作……值得一读！”<br>──《述评》杂志（Critical Review）<br>◎ 为什么地球的历史如同一本一章接着一章描述战争的书籍？<br>◎ 人类天生就是战士吗？或者是众神教会了人类如何作战？<br>◎ 外星战神是否应该对人类历史上的重大变故负责？<br>◎ 地球上的战争是开始于天空、然后在地球上延续的吗？<br>◎ 天相的变化会不会真的决定地球上人类的未来？<br>“大洪水……特洛伊战争……罪恶之城索多玛和蛾摩拉的毁灭……西琴全景式的还原了上古时代神与人共同参予的世界混战，其真实性令人震撼。”<br>──《锐评》杂志（Critical Review）</p><hr><p>对地球和人类过往命运的全景式再现：<br>关于一批来自外星的战神<br>以及一场由他们发动并让人类参与的史前世界大战<br>众神与人类的战争<br>在神和人并肩作战的遥远时代……<br>几千年前，地球是一个战场。正是那些诸神借以提高自己权力和威望的战争，彻底改变了人类的命运──激烈的战斗使生命更早地在另一个星球上出现。<br>国际知名学者撒迦利亚·西琴将史前的真实历史从神话中分离出来，带领我们走进了人类历史血腥开端的长卷，那个时候是神而不是人统治着地球。<br>通过重塑这些保存在传说和古代著作中令人心驰神往的史诗般的事件，他追溯了在另一个世界上开始，在地球上延续，并且通过使用核武器而达到高潮的冲突──这个事件在《圣经》里就是罪恶之城所多玛和蛾摩拉的毁灭性剧变。经由这个空前的转捩点，诸神放弃了地球，并在离开之时从外层空间摧毁了西奈半岛的航天发射场，从而中断了与人类的联系，也终结了人类的上一次文明。<br>“通过精确的研究，西琴重新创造了《圣经》的编年表，甚至回到了《圣经》之前的世界……这些发生在上古时代的星球大战，如今通过其强大的洞察力展现在我们眼前，令人震撼。”<br>──《圣约锡安之声》（Bnai Zion Voice）</p><h2 id="《失落的国度》"><a href="#《失落的国度》" class="headerlink" title="《失落的国度》"></a>《失落的国度》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/4.jpg" alt=""></p><p>作者: [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第四部<br>原作名: The Earth Chronicles IV The Lost Realms<br>出版年: 2010-8<br>页数: 238<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229018153</p><h3 id="内容简介-3"><a href="#内容简介-3" class="headerlink" title="内容简介"></a>内容简介</h3><p>在哥伦布之前到达美洲的诸神──<br>来自美洲的难以置信的证据显示：公元前3000年<br>外星巨人用他们的超级文明彻底改变了新大陆<br>◎在哥伦布之前的公元前3000年，是否早已有人到达了美洲？他们是谁？从何而来？<br>◎玛雅、阿兹特克、奥尔梅克、托尔特克、印加……这些突然出现并且突然消失的美洲古代文明是一个孤立系统，还是《圣经》中该隐的迁移之地？<br>◎出于对黄金的需求，降临于苏美尔的外星诸神也成为了美洲的诸神？最终，他们又如何把亚特兰蒂斯的传说带回了地中海？<br>16世纪，西班牙征服者来到新大陆，寻找传说中的黄金城埃尔•杜拉多。然而，无法解释的神秘现象表明，他们并不是第一批来此拓荒的淘金者，因为同样的工作在很多个世纪前早就发生过了──无数巨石建筑群构造在地球上最难以进入的雨林深处，它们错综复杂地记录了整个天穹及地球上发生的各种事件。</p><h2 id="《当时间开始》"><a href="#《当时间开始》" class="headerlink" title="《当时间开始》"></a>《当时间开始》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/5.jpg" alt=""></p><p>作者: [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第五部<br>原作名: When Time Began<br>译者: 宋易<br>出版年: 2010-07-01<br>页数: 257<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229026677</p><h3 id="内容简介-4"><a href="#内容简介-4" class="headerlink" title="内容简介"></a>内容简介</h3><p>以30种语言畅销15周年的最新修订版<br>宇宙中的一切是何时开始以及怎样开始的？<br>一切都将结束吗？而在这之间又会发生些什么？<br>◎史前巨石阵为什么要重建，并在公元前2100年和2000年时重新排列──这与当时发生在苏美尔令人震惊的事实有着怎样的联系？<br>◎在巴西的重大发现证实，人类在这一地区竟已生活了超过32000年！而它与大洋彼岸的文明全然无关吗？<br>◎是什么东西连接着位于马丘比丘的三窗神庙，以及苏美尔和大不列颠的古代建筑？<br>◎神圣时间、天时间和地球时间──过去和未来果真是被这三个周期所指引？是它们推动了地球历史的车轮？<br>惊人的神曲：外来的文明改变了人类发展的轨迹，<br>而人类则改变了众神的谱系──<br>对多神的信仰是如何演变为一神祟拜的？<br>当时间开始<br>谁才是史前巨石阵的神圣工程师？<br>数千年前，他们来到地球，引导人类进入了第一个科学发展和精神启蒙的新纪元。在他们的带领下，人类文明在科学、艺术上开始了繁荣，并分布到了世界上所有可居住的地方。而在人类传承的所有科学技术中，最重要的无疑是建立在数学－天文知识上的对时间的测量。这些古代的天国来客，他们在苏美尔、南美洲、中美洲、不列颠群岛和黑海沿岸留下的巨石阵，作为一种天文计算机（星石），不仅仅是为了被人类用于在数千年中建立“地球时间”的历法表，同时还──甚至是其根本目的──为了计算超级尺度的“天时间”，即连接人类和天国的“黄道时间”。<br>撒迦利亚•西琴在《地球编年史》的第五部中所要讲述的主题，正是时间以及其他与之相关的谜团。他指出了“神圣时间”──天时间和地球时间之间的惊人联系，并毫不隐晦地阐述了古代预言的基础，以及过去、现在、未来之间的联系。</p><h2 id="《宇宙密码》"><a href="#《宇宙密码》" class="headerlink" title="《宇宙密码》"></a>《宇宙密码》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/6.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第六部<br>原作名: The Cosmic Code: Book VI of the Earth Chronicles<br>译者: 徐冬妲 / 宋易<br>出版年: 2011-3<br>页数: 224<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229035945</p><h3 id="内容简介-5"><a href="#内容简介-5" class="headerlink" title="内容简介"></a>内容简介</h3><p>好几千年前，一群来自另一星球的超人领导了地球上生命的进化，决定了人类的存在状态和内在特质，正如我们今天所知道的那样。这些来自天外的天才建造者们如何创造了称为人类的奇迹？宇宙中所有生命的核心中，DNA是一个联系地球与天国、人类与神明之间的“宇宙密码”吗？<br>在精深宏大的《地球编年史》第六部中，撒迦利亚•西琴最突出的发现之一是，由22个符号组成的希伯来字母表是通过模仿22对染色体DNA而设计的；这一发现让我们逐渐认识到，与DNA匹配的希伯来字母表与其字母的数值是如何作为一个密码，承载了人类命运的秘密──作为地球众生的凡人的命运和作为神之造物的人类的天命。</p><p>当一切都揭晓之后，我们终会明白，“创造”我们的神只是从另一个空间来到并连线我们与宇宙的信使。而DNA，既是整个宇宙的生命联结，也是人类与众神的基因纽带。</p><h2 id="《完结日》"><a href="#《完结日》" class="headerlink" title="《完结日》"></a>《完结日》</h2><p><img src="https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/7.jpg" alt=""></p><p>作者:  [美] 撒迦利亚·西琴<br>出版社: 重庆出版社<br>副标题: 《地球编年史》第七部<br>原作名: The End of Days: Armageddon and Prophecies of the Return<br>译者: 龚力<br>出版年: 2012-10<br>页数: 215<br>定价: 36.00元<br>装帧: 平装<br>丛书: 地球编年史<br>ISBN: 9787229046576</p><h3 id="内容简介-6"><a href="#内容简介-6" class="headerlink" title="内容简介"></a>内容简介</h3><p>★《地球编年史》 第七部，30周年双里程碑庆典终结版！<br>★ 一个早已设定的周期性天文时间是否意味着<br>★ 第十二个天体和其上的众神将又一次的回归？<br>为什么我们所处的公元二十一世纪像极了公元前二十一世纪？<br>历史注定将重演吗？如果是，将在什么时候？<br>第十二个天体──“谜之行星 ”尼比鲁将在下一个3600年回归并影响地球吗？<br>届时，尼比鲁的居民阿努纳奇将会如天神一般再次降临吗？<br>等待人类的会是一场怎样的相遇：毁灭还是新生？</p><hr><p>有太多的人在苦苦等待这本书……<br>—— 《书目》杂志<br>让人翘首以盼的撒迦利亚•西琴经典启示系列的最终卷！在这部花费了30余年 研究而得来的杰作中，西琴展示了“过去即是未来”这一灵性观点引人注目的新证据——人类和他们的地球，从属于一个早已决定好的周期性天空时间。一个伟大的循环即将来临……<br>——《科克斯书评》<br>闪耀的、具有爆炸性的作品！为此，我要向伟大的撒迦利亚•西琴致敬！<br>——埃利希・冯・丹尼肯，《众神之车》作者<br>自撒迦利亚•西琴开创了《第十二个天体》一书已有30余年，后者使苏美尔文明和关于阿努纳奇人的记载苏醒了过来——这些天外来客塑造了人类，并给予人类文明和宗教信仰。在这本终结之书里，西琴向人们展示了禁锢于“开端”中的“终结”，而且一旦当你了解到此“开端”，就有可能预知“未来”。”<br>——《图书馆杂志》<br>太令人激动了……这是一个伟大史诗的完美尾声。西琴应该获得诺贝尔奖！<br>—— 鲍勃•迪恩，星际政治揭秘工程重要成员</p><hr><p>世人期待的经典革命性丛书《地球编年史》终于迎来了终结的第七部。从开山之作《第十二个天体》开始──它唤醒了人们对苏美尔文明和它所记录的外星人阿努纳奇来到地球并创造人类的记忆──至今已超过三十年了。在这部新书里，作者告诉我们，宇宙的终结直通其开端，如果你能精通这个开端，就有可能预知未来。<br>在本书中出现的数据、分析与观点，是一个需要三十年以上不间断研究的大师级工程。其中，作者呈示了令人震惊的新证据，表明我们的过去即未来──人类及其赖以生存的地球必须服从于一个早已设定的周期性的天文时间，而人类的创造者，第十二个天体和其上的众神，将会随着这一大周期的到来重返地球。</p><p>参考：<a href="https://book.douban.com/series/2198" target="_blank" rel="noopener">https://book.douban.com/series/2198</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想看一些科幻，神话类的小说，发现中国的《山海经》和国外的《地球编年史》不错，介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/22/The-Earth-Chronicles-Handbook/0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="地球编年史" scheme="https://2020.iosdevlog.com/tags/%E5%9C%B0%E7%90%83%E7%BC%96%E5%B9%B4%E5%8F%B2/"/>
    
      <category term="西琴" scheme="https://2020.iosdevlog.com/tags/%E8%A5%BF%E7%90%B4/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 插件开发: Hello World</title>
    <link href="https://2020.iosdevlog.com/2020/01/21/vscode/"/>
    <id>https://2020.iosdevlog.com/2020/01/21/vscode/</id>
    <published>2020-01-21T12:50:48.000Z</published>
    <updated>2020-01-21T14:46:26.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-21.png" alt="2020/01/21"></p><a id="more"></a><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>VS Code 的插件就是一个 <code>Node.js</code> 的应用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yeoman</span></span><br><span class="line">npm -g install yo</span><br><span class="line"><span class="comment"># VS Code 的模板</span></span><br><span class="line">npm install -g generator-code</span><br></pre></td></tr></table></figure><h2 id="创建第一个插件：-Hello-World"><a href="#创建第一个插件：-Hello-World" class="headerlink" title="创建第一个插件： Hello World"></a>创建第一个插件： Hello World</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello world</span></span><br><span class="line">yo code hello_world</span><br><span class="line">     _-----_     ╭──────────────────────────╮</span><br><span class="line">    |       |    │   Welcome to the Visual  │</span><br><span class="line">    |--(o)--|    │   Studio Code Extension  │</span><br><span class="line">   `---------´   │        generator!        │</span><br><span class="line">    ( _´U`_ )    ╰──────────────────────────╯</span><br><span class="line">    /___A___\   /</span><br><span class="line">     |  ~  |     </span><br><span class="line">   __<span class="string">'.___.'</span>__   </span><br><span class="line"> ´   `  |° ´ Y ` </span><br><span class="line"></span><br><span class="line">? What <span class="built_in">type</span> of extension <span class="keyword">do</span> you want to create? </span><br><span class="line">  New Extension (TypeScript) </span><br><span class="line">❯ New Extension (JavaScript) </span><br><span class="line">  New Color Theme </span><br><span class="line">  New Language Support </span><br><span class="line">  New Code Snippets </span><br><span class="line">  New Keymap </span><br><span class="line">  New Extension Pack </span><br><span class="line">(Move up and down to reveal more choices)</span><br></pre></td></tr></table></figure><ol><li>前两个是通过编程来提供插件功能，你可以选择 TypeScript 或者 JavaScript，结果都是类似的</li><li>因为 TypeScript 最后也需要被编译成 JavaScript 再发布；</li><li>第三个是主题插件，你可以将你自己创建的主题分享给其他人；</li><li>第四个是语言支持，也就是语法高亮、语言定义等；</li><li>第五个是代码片段的分享；</li><li>第六个则是分享快捷键；</li><li>第七个就是对多个插件进行组合分享。</li></ol><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hello-world</span><br><span class="line">code .</span><br></pre></td></tr></table></figure><ul><li><code>package.json</code> VS Code 的插件就是一个 Node.js 的应用，    <ul><li>package.json 里记录了这个 Node.js 应用的信息。同时，插件的信息也会被记录在这个文件内。</li></ul></li><li><code>extension.js</code> 这个文件是当前插件的全部代码。</li><li><code>.vscode</code> 脚手架工具已经为我们提供了调试配置、任务配置等，有了它们，我们就不用自己花时间书写了。</li></ul><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line"><span class="attr">"displayName"</span>: <span class="string">"hello_world"</span>,</span><br><span class="line"><span class="attr">"description"</span>: <span class="string">"Vs code plugin hello world"</span>,</span><br><span class="line"><span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line"><span class="attr">"engines"</span>: &#123;</span><br><span class="line"><span class="attr">"vscode"</span>: <span class="string">"^1.41.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"categories"</span>: [</span><br><span class="line"><span class="string">"Other"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"activationEvents"</span>: [</span><br><span class="line"><span class="string">"onCommand:extension.helloWorld"</span></span><br><span class="line">],</span><br><span class="line"><span class="attr">"main"</span>: <span class="string">"./extension.js"</span>,</span><br><span class="line"><span class="attr">"contributes"</span>: &#123;</span><br><span class="line"><span class="attr">"commands"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"command"</span>: <span class="string">"extension.helloWorld"</span>,</span><br><span class="line"><span class="attr">"title"</span>: <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"scripts"</span>: &#123;</span><br><span class="line"><span class="attr">"test"</span>: <span class="string">"node ./test/runTest.js"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line"><span class="attr">"@types/glob"</span>: <span class="string">"^7.1.1"</span>,</span><br><span class="line"><span class="attr">"@types/mocha"</span>: <span class="string">"^5.2.7"</span>,</span><br><span class="line"><span class="attr">"@types/node"</span>: <span class="string">"^12.11.7"</span>,</span><br><span class="line"><span class="attr">"@types/vscode"</span>: <span class="string">"^1.41.0"</span>,</span><br><span class="line"><span class="attr">"eslint"</span>: <span class="string">"^6.6.0"</span>,</span><br><span class="line"><span class="attr">"glob"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line"><span class="attr">"mocha"</span>: <span class="string">"^6.2.2"</span>,</span><br><span class="line"><span class="attr">"typescript"</span>: <span class="string">"^3.6.4"</span>,</span><br><span class="line"><span class="attr">"vscode-test"</span>: <span class="string">"^1.2.2"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>engines<ul><li>指定了运行这个插件需要的 VS Code 版本</li></ul></li><li>activationEvents<ul><li>指定了什么情况下这个插件应该被加载并且激活</li></ul></li><li>contributes<ul><li>这个插件给 VS Code 添加了一个 command，这个 command 的 id 是 “extension.sayHello”， 跟 extension.js 中写的一样。而这个命令的名字，叫做 Hello World。</li></ul></li></ol><h3 id="extension-js"><a href="#extension-js" class="headerlink" title="extension.js"></a><code>extension.js</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The module 'vscode' contains the VS Code extensibility API</span></span><br><span class="line"><span class="comment">// Import the module and reference it with the alias vscode in your code below</span></span><br><span class="line"><span class="keyword">const</span> vscode = <span class="built_in">require</span>(<span class="string">'vscode'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is activated</span></span><br><span class="line"><span class="comment">// your extension is activated the very first time the command is executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;vscode.ExtensionContext&#125;</span> <span class="variable">context</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the console to output diagnostic information (console.log) and errors (console.error)</span></span><br><span class="line"><span class="comment">// This line of code will only be executed once when your extension is activated</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Congratulations, your extension "hello-world" is now active!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The command has been defined in the package.json file</span></span><br><span class="line"><span class="comment">// Now provide the implementation of the command with  registerCommand</span></span><br><span class="line"><span class="comment">// The commandId parameter must match the command field in package.json</span></span><br><span class="line"><span class="keyword">let</span> disposable = vscode.commands.registerCommand(<span class="string">'extension.helloWorld'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// The code you place here will be executed every time your command is executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Display a message box to the user</span></span><br><span class="line">vscode.window.showInformationMessage(<span class="string">'Hello 2020 GameDevLog!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">context.subscriptions.push(disposable);</span><br><span class="line">&#125;</span><br><span class="line">exports.activate = activate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this method is called when your extension is deactivated</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deactivate</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">activate,</span><br><span class="line">deactivate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h2><ol><li><code>F5</code></li><li><code>Ctrl + Shift + P</code></li><li><code>Hello World</code></li></ol><p><img src="https://2020.iosdevlog.com/2020/01/21/vscode/1.png" alt=""></p><p><img src="https://2020.iosdevlog.com/2020/01/21/vscode/2.png" alt=""></p><p>参考：<a href="https://time.geekbang.org/column/article/69768" target="_blank" rel="noopener">玩转VS Code</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-21.png&quot; alt=&quot;2020/01/21&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="editor" scheme="https://2020.iosdevlog.com/categories/editor/"/>
    
    
      <category term="vscode" scheme="https://2020.iosdevlog.com/tags/vscode/"/>
    
      <category term="plugin" scheme="https://2020.iosdevlog.com/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-应用场景</title>
    <link href="https://2020.iosdevlog.com/2020/01/20/Scene/"/>
    <id>https://2020.iosdevlog.com/2020/01/20/Scene/</id>
    <published>2020-01-20T13:35:07.000Z</published>
    <updated>2020-01-20T13:37:50.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-20.png" alt="2020/01/20"></p><a id="more"></a><h2 id="嘿-Siri：语音处理"><a href="#嘿-Siri：语音处理" class="headerlink" title="嘿, Siri：语音处理"></a>嘿, Siri：语音处理</h2><hr><p>以 Siri 为例分享了语音处理的一些技术进展。其要点如下：</p><ul><li>语音处理可以分为语音识别和语音合成两类任务；</li><li>语音合成过程包括文本分析、音韵生成、单元选择、波形串联等步骤；</li><li>语音识别过程包括预处理、特征提取、声学模型，语言模型和字典解码等步骤；</li><li>深度学习和迁移学习等技术都已经被应用在语音处理之中。</li></ul><p>语音处理的最终目的不是简单地分析或者合成声音，而是为了更好地和人交互，从而以更简捷的方式解决问题。从交互的角度来看，你认为目前的语音助手还存在着哪些不足呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/1.jpg" alt=""></p><h2 id="心有灵犀一点通：对话系统"><a href="#心有灵犀一点通：对话系统" class="headerlink" title="心有灵犀一点通：对话系统"></a>心有灵犀一点通：对话系统</h2><hr><p>结合 Facebook 公司公开的资料，和分享了对话系统的发展历程与一些最新进展。其要点如下：</p><ul><li>早期的对话系统通过模式匹配和智能短语搜索对人类的合适回复；</li><li>智能个人助理可以帮助用户在多个垂直领域完成任务；</li><li>社交聊天机器人的作用是满足用户的情感需求；</li><li>神经网络能够帮助社交聊天机器人实现通用化的学习。</li></ul><p>社交聊天机器人的发展也带来了关于道德规范的问题，一些机器人从社交网络上学到的想法需要引起注意与警惕。结合人工智能在无人武器中的规模化应用，对人工智能进行法律约束似乎已经迫在眉睫。那么应该如何看待与应对人工智能带来的伦理问题呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/2.jpg" alt=""></p><h2 id="数字巴别塔：机器翻译"><a href="#数字巴别塔：机器翻译" class="headerlink" title="数字巴别塔：机器翻译"></a>数字巴别塔：机器翻译</h2><hr><p>结合谷歌公开发表的论文，和分享了机器翻译的发展历程与一些最新进展。其要点如下：</p><ul><li>早期的机器翻译采用的是逐字对应的方法；</li><li>语言学的进展使机器翻译转而依赖句法规则；</li><li>谷歌将神经网络引入机器翻译之中，利用大量数据提升翻译精确性；</li><li>神经网络可以通过迁移学习“桥接”不同的语言，实现零知识翻译。</li></ul><p>在另一个角度上，机器翻译的进展对语言本身的发展也存在着反作用。语言并不是自然出现的，而是人类社会的产物，其发展也势必会受到人类文化的影响。那么<strong>人工智能的发展到底会对人类自身产生何种反作用呢？</strong></p><p><strong>这是人工智能的终极问题。</strong></p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/3.jpg" alt=""></p><h2 id="左右互搏：生成式对抗网络"><a href="#左右互搏：生成式对抗网络" class="headerlink" title="左右互搏：生成式对抗网络"></a>左右互搏：生成式对抗网络</h2><hr><p>生成式对抗网络的原理与机制。其要点如下：</p><ul><li>生成式对抗网络是一类运行在零和博弈框架下的无监督学习算法，由生成器和判别器构成；</li><li>生成器的目的是精确模拟真实数据的分布，判别器的目的是精确区分真实数据和生成数据；</li><li>生成式对抗网络的主要优点是超越了传统神经网络分类和特征提取的功能，能够按照真实数据的特点生成新的数据；</li><li>生成式对抗网络的主要问题是理论基础的缺失。</li></ul><p>生成式对抗网络的一个重要的潜在应用就是让人工智能在没有明确指导的情况下学习，使算法的学习方式向人类的学习方式转变。那么如何看待生成式对抗网络在通用人工智能研究中的前景呢？</p><p><img src="https://2020.iosdevlog.com/2020/01/20/Scene/4.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-20.png&quot; alt=&quot;2020/01/20&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="Scene" scheme="https://2020.iosdevlog.com/tags/Scene/"/>
    
      <category term="App" scheme="https://2020.iosdevlog.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-深度学习框架下的神经网络总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/19/dl-nn/"/>
    <id>https://2020.iosdevlog.com/2020/01/19/dl-nn/</id>
    <published>2020-01-19T14:40:19.000Z</published>
    <updated>2020-01-20T13:37:31.748Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-19.png" alt="2020/01/19"></p><a id="more"></a><h2 id="枯木逢春：深度信念网络"><a href="#枯木逢春：深度信念网络" class="headerlink" title="枯木逢春：深度信念网络"></a>枯木逢春：深度信念网络</h2><hr><p>深度信念网络的基本概念和基本原理，其要点如下：</p><ul><li>深度信念网络是一种生成模型，能够建立输入和输出的联合概率分布；</li><li>受限玻尔兹曼机是构成深度信念网络的基本单元，是由可见层和隐藏层构成的神经网络；</li><li>受限玻尔兹曼机的训练方法是对比散度法，通过可见层和隐藏层的多轮交互实现；</li><li>深度神经网络的通用训练方式是无监督逐层预训练和有监督微调的结合。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/1.jpg" alt=""></p><h2 id="见微知著：卷积神经网络"><a href="#见微知著：卷积神经网络" class="headerlink" title="见微知著：卷积神经网络"></a>见微知著：卷积神经网络</h2><hr><p>卷积神经网络的原理与机制，其要点如下：</p><ul><li>卷积神经网络是应用了卷积运算的神经网络，适用于处理网格化数据；</li><li>卷积神经网络具有稀疏感知性、参数共享性和平移不变性；</li><li>卷积神经网络的结构包括交替出现的卷积层、激活层和池化层，以及作为输出的全连接层；</li><li>卷积神经网络的作用是逐层提取输入对象的特征。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/2.jpg" alt=""></p><h2 id="昨日重现：循环神经网络"><a href="#昨日重现：循环神经网络" class="headerlink" title="昨日重现：循环神经网络"></a>昨日重现：循环神经网络</h2><hr><p>循环神经网络和递归神经网络的基本原理与简要的工作机制。其要点如下：</p><ul><li>循环神经网络是具有记忆的神经网络，适用于处理序列化数据；</li><li>循环神经网络引入反馈结构，能够在时间上共享参数，从而具有记忆；</li><li>循环神经网络的扩展包括双向循环网络和深度循环网络；</li><li>递归神经网络能够处理具有层次化结构的数据，可以看成循环神经网络的推广。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/3.jpg" alt=""></p><h2 id="左右互搏：生成式对抗网络"><a href="#左右互搏：生成式对抗网络" class="headerlink" title="左右互搏：生成式对抗网络"></a>左右互搏：生成式对抗网络</h2><hr><p>生成式对抗网络的原理与机制。其要点如下：</p><ul><li>生成式对抗网络是一类运行在零和博弈框架下的无监督学习算法，由生成器和判别器构成；</li><li>生成器的目的是精确模拟真实数据的分布，判别器的目的是精确区分真实数据和生成数据；</li><li>生成式对抗网络的主要优点是超越了传统神经网络分类和特征提取的功能，能够按照真实数据的特点生成新的数据；</li><li>生成式对抗网络的主要问题是理论基础的缺失。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/4.jpg" alt=""></p><h2 id="三重门：长短期记忆网络"><a href="#三重门：长短期记忆网络" class="headerlink" title="三重门：长短期记忆网络"></a>三重门：长短期记忆网络</h2><hr><p>长短期记忆网络的基本原理与简单工作机制。其要点如下：</p><ul><li>长短期记忆网络可以实现任意长度的记忆，对信息进行长期而精确的跟踪；</li><li>长短期记忆单元的组成包括记忆模块、输入门、遗忘门和输出门；</li><li>长短期记忆网络根据当前的输入、当前的记忆和前一时刻的输出确定当前的输出；</li><li>长短期记忆网络能够解决梯度弥散的问题。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/5.jpg" alt=""></p><h2 id="一图胜千言：概率图模型"><a href="#一图胜千言：概率图模型" class="headerlink" title="一图胜千言：概率图模型"></a>一图胜千言：概率图模型</h2><hr><p>概率图模型的原理，包括有向的贝叶斯网络和无向的马尔可夫随机场。其要点如下：</p><ul><li>概率图模型是概率论与图论的结合，是用图论表现随机变量之间的条件依赖关系的建模方法；</li><li>贝叶斯网络是有向无环图，侧重于表示随机变量之间的依赖关系；</li><li>马尔可夫随机场是无向图，侧重于表示随机变量之间的相互作用；</li><li>概率图模型体现了“表示 - 推断 - 学习”的问题解决框架。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/6.jpg" alt=""></p><h2 id="乌合之众的逆袭：集群智能"><a href="#乌合之众的逆袭：集群智能" class="headerlink" title="乌合之众的逆袭：集群智能"></a>乌合之众的逆袭：集群智能</h2><hr><p>集群智能方法的现实依据，以及它所代表的研究方向。其要点如下：</p><ul><li>集群智能是由众多简单个体通过自组织和去中心化的简单合作实现的智能；</li><li>集群智能具有可扩展性、并行性和容错性等特点；</li><li>集群智能体现出微观个体之间的相互作用能够实现整体大于部分之和的效果，其实例是蚁群算法；</li><li>集群智能在人工智能中的应用代表的是从宏观模仿到微观解构的方向转变。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/7.jpg" alt=""></p><h2 id="一图胜千言：概率图模型-1"><a href="#一图胜千言：概率图模型-1" class="headerlink" title="一图胜千言：概率图模型"></a>一图胜千言：概率图模型</h2><hr><p>概率图模型的原理，包括有向的贝叶斯网络和无向的马尔可夫随机场。其要点如下：</p><ul><li>概率图模型是概率论与图论的结合，是用图论表现随机变量之间的条件依赖关系的建模方法；</li><li>贝叶斯网络是有向无环图，侧重于表示随机变量之间的依赖关系；</li><li>马尔可夫随机场是无向图，侧重于表示随机变量之间的相互作用；</li><li>概率图模型体现了“表示 - 推断 - 学习”的问题解决框架。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/8.jpg" alt=""></p><h2 id="授人以鱼不如授人以渔：迁移学习"><a href="#授人以鱼不如授人以渔：迁移学习" class="headerlink" title="授人以鱼不如授人以渔：迁移学习"></a>授人以鱼不如授人以渔：迁移学习</h2><hr><p>迁移学习的基本原理和常用方法。其要点如下：</p><ul><li>迁移学习是运用已学习的知识来求解不同但相关领域问题的新的机器学习方法，目的是让机器“学会学习”；</li><li>迁移学习适用于跨领域和小数据的学习任务；</li><li>迁移学习的任务类型可以分为归纳迁移学习，直推式迁移学习和无监督迁移学习；</li><li>迁移学习的学习方法包括基于样本、基于特征、基于模型和基于关系。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/9.jpg" alt=""></p><h2 id="滴水藏海：知识图谱"><a href="#滴水藏海：知识图谱" class="headerlink" title="滴水藏海：知识图谱"></a>滴水藏海：知识图谱</h2><hr><p>知识图谱的基本原理与简单应用。其要点如下：</p><ul><li>知识图谱是由大量的概念实体以及它们之间的关系构成的语义网络；</li><li>用知识图谱实现从特殊到一般的归纳推理，典型的方法是路径排序算法；</li><li>用知识图谱实现从一般到特殊的演绎推理，典型的方法是马尔可夫逻辑网和概率软逻辑；</li><li>用知识图谱实现数值推理，典型的方法是基于分布式知识表示的方法。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/19/dl-nn/10.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-19.png&quot; alt=&quot;2020/01/19&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
      <category term="NN" scheme="https://2020.iosdevlog.com/tags/NN/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-深度学习总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/18/dl/"/>
    <id>https://2020.iosdevlog.com/2020/01/18/dl/</id>
    <published>2020-01-18T06:29:02.000Z</published>
    <updated>2020-01-20T13:37:40.644Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-18.png" alt="2020/01/18"></p><a id="more"></a><h2 id="空山鸣响，静水流深：深度学习概述"><a href="#空山鸣响，静水流深：深度学习概述" class="headerlink" title="空山鸣响，静水流深：深度学习概述"></a>空山鸣响，静水流深：深度学习概述</h2><hr><p>深度学习的一些简介，其要点如下：</p><ul><li>深度学习实际上是基于具有多个隐藏层的神经网络的学习；</li><li>深度学习的思想来源于人类处理视觉信息的方式；</li><li>深度学习的发展得益于数据的井喷和计算力的飙升；</li><li>深度学习的理论基础依然有待深入。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/1.jpg" alt=""></p><h2 id="前方有路，未来可期：深度前馈网络"><a href="#前方有路，未来可期：深度前馈网络" class="headerlink" title="前方有路，未来可期：深度前馈网络"></a>前方有路，未来可期：深度前馈网络</h2><hr><p>作为学习模型的深度前馈网络存在的一些共性问题，其要点如下：</p><ul><li>深度前馈网络利用深度架构实现工程上可实现的对任意函数的通用逼近；</li><li>深度前馈网络使用梯度下降的方法进行学习；</li><li>深度前馈网络的损失函数通常是交叉熵或最小均方误差；</li><li>深度前馈网络的隐藏神经元通常使用整流线性单元作为传递函数。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/2.jpg" alt=""></p><h2 id="小树不修不直溜：深度学习中的正则化"><a href="#小树不修不直溜：深度学习中的正则化" class="headerlink" title="小树不修不直溜：深度学习中的正则化"></a>小树不修不直溜：深度学习中的正则化</h2><hr><p>实现正则化的思路，其要点如下：</p><ul><li><p>基于训练数据的正则化方法包括数据集增强和 Dropout；</p></li><li><p>基于网络架构的正则化方法包括参数共享和传递函数正则化；</p></li><li><p>基于误差函数和正则化项的正则化方法包括使用 <em>L²</em> 范数和 <em>L¹</em> 范数；</p></li><li><p>基于最优化过程的正则化方法包括早停。</p></li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/3.jpg" alt=""></p><h2 id="玉不琢不成器：深度学习中的优化"><a href="#玉不琢不成器：深度学习中的优化" class="headerlink" title="玉不琢不成器：深度学习中的优化"></a>玉不琢不成器：深度学习中的优化</h2><hr><p>深度学习中实现优化的思路，其要点如下：</p><ul><li><p>深度学习中的优化需要解决病态矩阵、局部极小值和鞍点等问题；</p></li><li><p>深度学习优化中的降噪方法包括动态采样、梯度聚合和迭代平均；</p></li><li><p>深度学习优化中的二阶导数近似方法是对原始牛顿法的各种改进；</p></li><li><p>其他优化方法包括动量方法、加速下降方法和坐标下降方法。</p></li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/4.jpg" alt=""></p><h2 id="空竹里的秘密：自编码器"><a href="#空竹里的秘密：自编码器" class="headerlink" title="空竹里的秘密：自编码器"></a>空竹里的秘密：自编码器</h2><hr><p>自编码器的原理与特点，其要点如下：</p><ul><li>自编码器是一种无监督学习方式，目的在于学习数据的重新表达；</li><li>多个浅层自编码器级联可以得到深度的栈式自编码器，并使用无监督预训练结合有监督微调的方式加以训练；</li><li>稀疏自编码器利用稀疏的高维表达提取出训练集中隐含的统计规律；</li><li>变分自编码器对隐藏层做参数化处理，可以用于学习数据的生成模型。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/5.jpg" alt=""></p><h2 id="困知勉行者勇：深度强化学习"><a href="#困知勉行者勇：深度强化学习" class="headerlink" title="困知勉行者勇：深度强化学习"></a>困知勉行者勇：深度强化学习</h2><hr><p>深度强化学习（deep reinforcement learning）是深度学习和强化学习的结合，它将深度学习的感知能力和强化学习的决策能力熔于一炉，用深度学习的运行机制达到强化学习的优化目标，从而向通用人工智能迈进。</p><p>深度强化学习的简单原理与方法分类，其要点如下：</p><ul><li>深度强化学习是深度学习和强化学习的结合，有望成为实现通用人工智能的关键技术；</li><li>基于价值的深度强化学习的基本思路是建立价值函数的表示，通过优化价值函数得到最优策略；</li><li>基于策略的深度强化学习的基本思路是直接搜索能够使未来奖励最大化的最优策略；</li><li>基于模型的深度强化学习的基本思路是构造关于环境的转移概率模型，再用这个模型指导策略。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/18/dl/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-18.png&quot; alt=&quot;2020/01/18&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="ANN" scheme="https://2020.iosdevlog.com/tags/ANN/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>《假面饭店》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/17/9787544259101/"/>
    <id>https://2020.iosdevlog.com/2020/01/17/9787544259101/</id>
    <published>2020-01-17T04:36:13.000Z</published>
    <updated>2020-01-17T04:47:07.242Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/17/9787544259101/9787544259101.png" class="" title="东野圭吾-《假面饭店》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 南海出版公司<br>原作名: マスカレードホテル<br>译者: 中森<br>出版年: 2012-12<br>页数: 288<br>定价: 39.80元<br>装帧: 精装<br>丛书: 假面系列<br>ISBN: 9787544259101</p><p>四个不相关的 x1-x4 杀人事件，让 x4 误导成连环杀人事件。</p><p>服务业为客人着想。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/17/9787544259101/9787544259101.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《假面饭店》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="假面系列" scheme="https://2020.iosdevlog.com/tags/%E5%81%87%E9%9D%A2%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-人工神经网络总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/17/ann/"/>
    <id>https://2020.iosdevlog.com/2020/01/17/ann/</id>
    <published>2020-01-17T04:29:21.000Z</published>
    <updated>2020-01-17T04:34:00.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-17.png" alt="2020/01/17"></p><a id="more"></a><h2 id="道法自然，久藏玄冥：神经网络的生理学背景"><a href="#道法自然，久藏玄冥：神经网络的生理学背景" class="headerlink" title="道法自然，久藏玄冥：神经网络的生理学背景"></a>道法自然，久藏玄冥：神经网络的生理学背景</h2><hr><p>人工神经网络的生理学背景，也对人类认知的物理基础与工作机制做了简单的介绍，其要点如下：</p><ul><li>思维过程是神经元的连接活动过程，由大量突触相互动态联系着的众多神经元协同作用来实现；</li><li>大脑的思维源于从神经元到神经网络再到神经回路的功能逐级整合；</li><li>大脑对信息的加工可以理解为复杂的多次特征提取过程；</li><li>在大脑中，数据的传输和处理是同步进行的。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/1.jpg" alt=""></p><h2 id="一个青年才俊的意外死亡：神经元与感知器"><a href="#一个青年才俊的意外死亡：神经元与感知器" class="headerlink" title="一个青年才俊的意外死亡：神经元与感知器"></a>一个青年才俊的意外死亡：神经元与感知器</h2><hr><p>神经网络的鼻祖感知器的基本原理，其要点如下：</p><ul><li>人工神经网络的神经元用传递函数对输入的线性加权进行非线性处理以产生输出；</li><li>感知器是一种二分类的监督学习算法，通过自适应调整权重解决线性分类问题；</li><li>感知器的神经元之间通过权重传递信息，权重的变化根据误差来进行调节；</li><li>感知器不能解决以异或为代表的线性不可分问题。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/2.jpg" alt=""></p><h2 id="左手信号，右手误差：多层感知器"><a href="#左手信号，右手误差：多层感知器" class="headerlink" title="左手信号，右手误差：多层感知器"></a>左手信号，右手误差：多层感知器</h2><hr><p>多层感知器和反向传播的基本原理，关于反向传播具体的数学细节你可以参考相关文献，其要点如下：</p><ul><li>在感知器的输入层和输出层之间添加隐藏层，就可以得到多层感知器；</li><li>多层感知器是一类前馈神经网络，采用的是反向传播的学习方式；</li><li>反向传播算法要根据误差函数的梯度来调整权重系数，需要应用求导的链式法则；</li><li>单个隐藏层就能使多层感知器以任意精度逼近任意复杂度的连续函数。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/3.jpg" alt=""></p><h2 id="各人自扫门前雪：径向基函数神经网络"><a href="#各人自扫门前雪：径向基函数神经网络" class="headerlink" title="各人自扫门前雪：径向基函数神经网络"></a>各人自扫门前雪：径向基函数神经网络</h2><hr><p>径向基函数神经网络的基本原理，其要点如下：</p><ul><li>径向基网络采用局部逼近方式，每个神经元只对特定的输入信号产生作用；</li><li>径向基网络的隐藏神经元使用径向基函数作为传递函数，常用的径向基函数是高斯函数；</li><li>径向基函数可以将低维空间上的线性不可分问题转化为高维空间上的线性可分问题；</li><li>使用高斯函数的径向基网络可以用 K 均值聚类算法结合递归最小二乘法进行训练。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/4.jpg" alt=""></p><h2 id="看不见的手：自组织特征映射"><a href="#看不见的手：自组织特征映射" class="headerlink" title="看不见的手：自组织特征映射"></a>看不见的手：自组织特征映射</h2><hr><p>自组织特征映射的基本原理，其要点如下：</p><ol><li>自组织映射是一类无监督学习的神经网络，模拟了生物神经系统的竞争性学习机制；</li><li>自组织映射能将任意维度的输入模式转换为一维或二维的离散映射，得到的特征映射是拓扑有序的；</li><li>在拓扑映射中，输出神经元的空间位置对应了输入数据的模式或特征；</li><li>自组织映射网络的训练包括竞争过程、合作过程和自适应过程等几个主要步骤。</li></ol><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/5.jpg" alt=""></p><h2 id="水无至清，人莫至察：模糊神经网络"><a href="#水无至清，人莫至察：模糊神经网络" class="headerlink" title="水无至清，人莫至察：模糊神经网络"></a>水无至清，人莫至察：模糊神经网络</h2><hr><p>模糊神经网络的基本概念，其要点如下：</p><ul><li>模糊神经网络是神经网络和模糊逻辑结合形成的混合智能系统；</li><li>模糊神经网络的输入信号、权重系数和输出信号全都是模糊集合；</li><li>模糊神经网络的主要学习算法包括基于水平集的方法和基于遗传算法的方法；</li><li>模糊神经网络具有和传统神经网络类似的通用逼近特性。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/17/ann/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-17.png&quot; alt=&quot;2020/01/17&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
      <category term="ANN" scheme="https://2020.iosdevlog.com/tags/ANN/"/>
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-机器学习总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/16/ml/"/>
    <id>https://2020.iosdevlog.com/2020/01/16/ml/</id>
    <published>2020-01-16T07:58:12.000Z</published>
    <updated>2020-01-16T08:03:22.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-16.png" alt="2020/01/16"></p><a id="more"></a><h2 id="数山有路，学海无涯：机器学习概论"><a href="#数山有路，学海无涯：机器学习概论" class="headerlink" title="数山有路，学海无涯：机器学习概论"></a>数山有路，学海无涯：机器学习概论</h2><hr><p>机器学习的基本原理与基础概念，其要点如下：</p><ul><li>机器学习是计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的学科；</li><li>根据输入输出类型的不同，机器学习可分为分类问题、回归问题、标注问题三类；</li><li>过拟合是机器学习中不可避免的问题，可通过选择合适的模型降低其影响；</li><li>监督学习是目前机器学习的主流任务，包括生成方法和判别方法两类。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/1.jpg" alt=""></p><h2 id="简约而不简单：线性回归"><a href="#简约而不简单：线性回归" class="headerlink" title="简约而不简单：线性回归"></a>简约而不简单：线性回归</h2><hr><p>线性回归的基本原理，其要点如下：</p><ul><li>线性回归假设输出变量是若干输入变量的线性组合，并根据这一关系求解线性组合中的最优系数；</li><li>最小二乘法可用于解决单变量线性回归问题，当误差函数服从正态分布时，它与最大似然估计等价；</li><li>多元线性回归问题也可以用最小二乘法求解，但极易出现过拟合现象；</li><li>岭回归和 LASSO 回归分别通过引入二范数惩罚项和一范数惩罚项抑制过拟合。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/2.jpg" alt=""></p><h2 id="大道至简：朴素贝叶斯方法"><a href="#大道至简：朴素贝叶斯方法" class="headerlink" title="大道至简：朴素贝叶斯方法"></a>大道至简：朴素贝叶斯方法</h2><hr><p>朴素贝叶斯方法的基本原理，其要点如下：</p><ul><li>朴素贝叶斯方法利用后验概率选择最佳分类，后验概率可以通过贝叶斯定理求解；</li><li>朴素贝叶斯方法假定所有属性相互独立，基于这一假设将类条件概率转化为属性条件概率的乘积；</li><li>朴素贝叶斯方法可以使期望风险最小化；</li><li>影响朴素贝叶斯分类的是所有属性之间的依赖关系在不同类别上的分布。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/3.jpg" alt=""></p><h2 id="衍化至繁：逻辑回归"><a href="#衍化至繁：逻辑回归" class="headerlink" title="衍化至繁：逻辑回归"></a>衍化至繁：逻辑回归</h2><hr><p>逻辑回归方法的基本原理，其要点如下：</p><ul><li>逻辑回归模型是对线性回归的改进，用于解决分类问题；</li><li>逻辑回归输出的是实例属于每个类别的似然概率，似然概率最大的类别就是分类结果；</li><li>在一定条件下，逻辑回归模型与朴素贝叶斯分类器是等价的；</li><li>多分类问题时可以通过多次使用二分类逻辑回归或者使用 Softmax 回归解决。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/4.jpg" alt=""></p><h2 id="步步为营，有章可循：决策树"><a href="#步步为营，有章可循：决策树" class="headerlink" title="步步为营，有章可循：决策树"></a>步步为营，有章可循：决策树</h2><hr><p>决策树的基本原理，其要点如下：</p><ul><li>决策树是包含根节点、内部节点和叶节点的树结构，通过判定不同属性的特征来解决分类问题；</li><li>决策树的学习过程包括特征选择、决策树生成、决策树剪枝三个步骤；</li><li>决策树生成的基础是特征选择，特征选择的指标包括信息增益、信息增益比和基尼系数；</li><li>决策树的剪枝策略包括预剪枝和后剪枝。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/5.jpg" alt=""></p><h2 id="穷则变，变则通：支持向量机"><a href="#穷则变，变则通：支持向量机" class="headerlink" title="穷则变，变则通：支持向量机"></a>穷则变，变则通：支持向量机</h2><hr><p>支持向量机的基本原理，其要点如下：</p><ul><li>线性可分支持向量机通过硬间隔最大化求出划分超平面，解决线性分类问题；</li><li>线性支持向量机通过软间隔最大化求出划分超平面，解决线性分类问题；</li><li>非线性支持向量机利用核函数实现从低维原始空间到高维特征空间的转换，在高维空间上解决非线性分类问题；</li><li>支持向量机的学习是个凸二次规划问题，可以用 SMO 算法快速求解。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/6.jpg" alt=""></p><h2 id="三个臭皮匠，赛过诸葛亮：集成学习"><a href="#三个臭皮匠，赛过诸葛亮：集成学习" class="headerlink" title="三个臭皮匠，赛过诸葛亮：集成学习"></a>三个臭皮匠，赛过诸葛亮：集成学习</h2><hr><p>集成学习的基本原理，其要点如下：</p><ul><li>集成学习使用多个个体学习器来获得比每个单独学习器更好的预测性能，包括序列化方法和并行化方法两类；</li><li>多样性要求集成学习中的不同个体学习器之间具有足够的差异性；</li><li>序列化方法采用 Boosting 机制，通过重复使用概率分布不同的训练数据实现集成，可以降低泛化误差中的偏差；</li><li>并行化方法采用 Bagging 机制，通过在训练数据中多次自助抽取不同的采样子集实现集成，可以降低泛化误差中的方差。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/7.jpg" alt=""></p><h2 id="物以类聚，人以群分：聚类分析"><a href="#物以类聚，人以群分：聚类分析" class="headerlink" title="物以类聚，人以群分：聚类分析"></a>物以类聚，人以群分：聚类分析</h2><hr><p>聚类分析的基本原理，其要点如下：</p><ul><li>聚类分析是一种无监督学习方法，通过学习没有分类标记的训练样本发现数据的内在性质和规律；</li><li>数据之间的相似性通常用距离度量，类内差异应尽可能小，类间差异应尽可能大；</li><li>根据形成聚类方式的不同，聚类算法可以分为层次聚类、原型聚类、分布聚类、密度聚类等几类；</li><li>聚类分析的一个重要应用是对用户进行分组与归类。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/8.jpg" alt=""></p><h2 id="好钢用在刀刃上：降维学习"><a href="#好钢用在刀刃上：降维学习" class="headerlink" title="好钢用在刀刃上：降维学习"></a>好钢用在刀刃上：降维学习</h2><hr><p>主成分分析是一种主要的降维方法，另一种更加直观的降维方式则是直接对样本的属性做出筛选，这种降维方法就是“特征选择”，其要点如下：</p><ul><li>主成分分析利用正交变换将可能存在相关性的原始属性转换成一组线性无关的新属性，并通过选择重要的新属性实现降维；</li><li>主成分分析的解满足最大方差和最小均方误差两类约束条件，因而具有最大可分性和最近重构性；</li><li>特征选择则是选取原始特征中的一个子集用于学习任务，是另一种主要的降维技术；</li><li>特征选择的关键问题是对特征子集的评价，主要的特征选择算法包括包裹法、过滤法和嵌入法。</li></ul><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/9.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><hr><p><img src="https://2020.iosdevlog.com/2020/01/16/ml/10.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/GameDevLog/2020/master/2020/01/2020-01-16.png&quot; alt=&quot;2020/01/16&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>人工智能-数学基础总结</title>
    <link href="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/"/>
    <id>https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/</id>
    <published>2020-01-15T11:24:50.000Z</published>
    <updated>2020-01-15T14:46:26.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/0.jpg" alt=""></p><a id="more"></a><h2 id="九层之台，起于累土：线性代数"><a href="#九层之台，起于累土：线性代数" class="headerlink" title="九层之台，起于累土：线性代数"></a>九层之台，起于累土：线性代数</h2><p>必备的数学知识是理解人工智能不可或缺的要素，今天的种种人工智能技术归根到底都建立在数学模型之上，而这些数学模型又都离不开线性代数（linear algebra）的理论框架。</p><p>在线性代数中，由单独的数 a 构成的元素被称为标量（scalar）：一个标量 a 可以是整数、实数或复数。如果多个标量按一定顺序组成一个序列，这样的元素就被称为向量（vector）。显然，向量可以看作标量的扩展。原始的一个数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一地确定向量中的元素。</p><p>相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要使用两个索引（而非一个）确定。同理，如果将矩阵中的每个标量元素再替换为向量的话，得到的就是张量（tensor）。直观地理解，张量就是高阶的矩阵。</p><p>在计算机存储中，标量占据的是零维数组；向量占据的是一维数组，例如语音信号；矩阵占据的是二维数组，例如灰度图像；张量占据的是三维乃至更高维度的数组，例如 RGB 图像和视频。</p><p>线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性；<br>向量的实质是 n 维线性空间中的静止点；<br>线性变换描述了向量或者作为参考系的坐标系的变化，可以用矩阵表示；<br>矩阵的特征值和特征向量描述了变化的速度与方向。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/1.jpg" alt=""></p><h2 id="月有阴晴圆缺，此事古难全：概率论"><a href="#月有阴晴圆缺，此事古难全：概率论" class="headerlink" title="月有阴晴圆缺，此事古难全：概率论"></a>月有阴晴圆缺，此事古难全：概率论</h2><p>概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。</p><p>概率的估计有两种方法：最大似然估计法（maximum likelihood estimation）和最大后验概率法（maximum a posteriori estimation），两者分别体现出频率学派和贝叶斯学派对概率的理解方式。</p><p>概率论基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>概率论关注的是生活中的不确定性或可能性；<br>频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算；<br>贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算；<br>正态分布是最重要的一种随机变量的分布。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/2.jpg" alt=""></p><h2 id="窥一斑而知全豹：数理统计"><a href="#窥一斑而知全豹：数理统计" class="headerlink" title="窥一斑而知全豹：数理统计"></a>窥一斑而知全豹：数理统计</h2><p>人工智能必备的数理统计基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>数理统计的任务是根据可观察的样本反过来推断总体的性质；<br>推断的工具是统计量，统计量是样本的函数，是个随机变量；<br>参数估计通过随机抽取的样本来估计总体分布的未知参数，包括点估计和区间估计；<br>假设检验通过随机抽取的样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/3.jpg" alt=""></p><h2 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h2><p>人工智能必备的最优化方法基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>通常情况下，最优化问题是在无约束情况下求解给定目标函数的最小值；<br>在线性搜索中，确定寻找最小值时的搜索方向需要使用目标函数的一阶导数和二阶导数；<br>置信域算法的思想是先确定搜索步长，再确定搜索方向；<br>以人工神经网络为代表的启发式算法是另外一类重要的优化方法。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/4.jpg" alt=""></p><h2 id="万物皆数，信息亦然：信息论"><a href="#万物皆数，信息亦然：信息论" class="headerlink" title="万物皆数，信息亦然：信息论"></a>万物皆数，信息亦然：信息论</h2><p>近年来的科学研究不断证实，不确定性才是客观世界的本质属性。换句话说，上帝还真就掷骰子。不确定性的世界只能使用概率模型来描述，正是对概率的刻画促成了信息论的诞生。</p><p>信息论使用“信息熵”的概念，对单个信源的信息量和通信中传递信息的数量与效率等问题做出了解释，并在世界的不确定性和信息的可测量性之间搭建起一座桥梁。</p><p>人工智能必备的数理统计基础，着重于抽象概念的解释而非具体的数学公式，其要点如下：</p><p>数理统计的任务是根据可观察的样本反过来推断总体的性质；<br>推断的工具是统计量，统计量是样本的函数，是个随机变量；<br>参数估计通过随机抽取的样本来估计总体分布的未知参数，包括点估计和区间估计；<br>假设检验通过随机抽取的样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/5.jpg" alt=""></p><h2 id="明日黄花迹难寻：形式逻辑"><a href="#明日黄花迹难寻：形式逻辑" class="headerlink" title="明日黄花迹难寻：形式逻辑"></a>明日黄花迹难寻：形式逻辑</h2><p>人工智能必备的形式逻辑基础，以及采用形式逻辑进行自动推理的基本原理，其要点如下：</p><p>如果将认知过程定义为对符号的逻辑运算，人工智能的基础就是形式逻辑；<br>谓词逻辑是知识表示的主要方法；<br>基于谓词逻辑系统可以实现具有自动推理能力的人工智能；<br>不完备性定理向“认知的本质是计算”这一人工智能的基本理念提出挑战。</p><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/6.jpg" alt=""></p><h2 id="拓展阅读参考书"><a href="#拓展阅读参考书" class="headerlink" title="拓展阅读参考书"></a>拓展阅读参考书</h2><p><img src="https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/7.jpg" alt=""></p><p>总结自：人工智能基础课: <a href="https://time.geekbang.org/column/62" target="_blank" rel="noopener">https://time.geekbang.org/column/62</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/01/15/AI-Basic-Math/0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="Math" scheme="https://2020.iosdevlog.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>《圣女的救济》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/01/15/9787509005125/"/>
    <id>https://2020.iosdevlog.com/2020/01/15/9787509005125/</id>
    <published>2020-01-15T04:12:23.000Z</published>
    <updated>2020-01-15T11:20:57.600Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/15/9787509005125/9787509005125.png" class="" title="东野圭吾-《圣女的救济》"><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 当代世界出版社<br>译者: 袁斌<br>出版年: 2009-5<br>页数: 399<br>定价: 30.00<br>装帧: 精装<br>丛书: 乐读文库<br>ISBN: 9787509005125</p><p>好友的自杀的原因，轮到自己身上，因爱生恨，既然无法挽回，那你就去死吧！</p><p><code>死道友不死贫道</code></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/15/9787509005125/9787509005125.png&quot; class=&quot;&quot; title=&quot;东野圭吾-《圣女的救济》&quot;&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
      <category term="伽利略系列" scheme="https://2020.iosdevlog.com/tags/%E4%BC%BD%E5%88%A9%E7%95%A5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>实现一门脚本语言-原理篇</title>
    <link href="https://2020.iosdevlog.com/2020/01/14/Construction/"/>
    <id>https://2020.iosdevlog.com/2020/01/14/Construction/</id>
    <published>2020-01-14T05:58:32.000Z</published>
    <updated>2020-01-14T09:26:24.341Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/14/Construction/Compiler.jpg" class="" title="宫文学- 编译原理"><a id="more"></a><h2 id="理解代码：编译器的前端技术"><a href="#理解代码：编译器的前端技术" class="headerlink" title="理解代码：编译器的前端技术"></a>理解代码：编译器的前端技术</h2><ul><li><code>前端（Front End）</code>: 编译器对程序代码的分析和理解过程<ul><li>词法分析（Lexical Analysis）<ul><li><code>程序分割成一个个 Token 的过程，可以通过构造有限自动机来实现</code></li><li>识别一个个的单词</li><li><code>词法记号（Token）</code></li><li>Lex（或其 GNU 版本，Flex）<ul><li>正则文法（Regular Grammar）<ul><li>符合正则文法的表达式</li></ul></li><li>有限自动机（Finite-state Automaton，FSA，or Finite Automaton） 算法</li></ul></li></ul></li><li>语法分析 （Syntactic Analysis, or Parsing）<ul><li><code>把程序的结构识别出来，并形成一棵便于由计算机处理的抽象语法树。可以用递归下降的算法来实现</code>。*`</li><li>别出程序的语法结构</li><li>Yacc（或 GNU 的版本，Bison）、Antlr、JavaCC</li><li><code>抽象语法树（Abstract Syntax Tree，AST</code>）</li><li><code>clang -cc1 -ast-dump hello.c</code></li><li>递归下降算法（Recursive Descent Parsing）</li></ul></li><li>语义分析（Semantic Analysis）<ul><li><code>消除语义模糊，生成一些属性信息，让计算机能够依据这些信息生成目标代码。</code></li></ul></li></ul></li><li><code>后端（Back End）</code>: 生成目标代码的过程，跟目标机器有关</li></ul><h2 id="正则文法和有限自动机：纯手工打造词法分析器"><a href="#正则文法和有限自动机：纯手工打造词法分析器" class="headerlink" title="正则文法和有限自动机：纯手工打造词法分析器"></a>正则文法和有限自动机：纯手工打造词法分析器</h2><ul><li><code>关键字</code>: 语言设计中作为语法要素的词汇</li><li><code>保留字</code>: 当前的语言设计中还没用到，但是保留下来，因为将来会用到</li></ul><img src="/2020/01/14/Construction/Token.jpg" class="" title="Token"><blockquote><p>关键字和保留字跟标识符区分开呢？</p></blockquote><ul><li>识别普通的 <code>标识符</code> 之前，是否 <code>关键字</code> / <code>保留字</code></li></ul><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><img src="/2020/01/14/Construction/AST.jpg" class="" title="AST"><h3 id="纯手工打造公式计算器"><a href="#纯手工打造公式计算器" class="headerlink" title="纯手工打造公式计算器"></a>纯手工打造公式计算器</h3><p>推导（Derivation）过程</p><ul><li><code>左边</code>：非终结符（Non-terminal）</li><li><code>右边</code>：产生式（Production Rule）</li><li>语法解析的过程中，左边会被右边替代</li><li>如果替代之后还有非终结符，那么继续这个替代过程，直到最后全部都是终结符（Terminal），也就是 Token。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intDeclaration : <span class="function">Int <span class="title">Identifier</span> <span class="params">(<span class="string">'='</span> additiveExpression)</span>?</span>;</span><br></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MatchIntDeclare() &#123;</span><br><span class="line">  MatchToken(Int)；        <span class="comment">// 匹配Int关键字</span></span><br><span class="line">  MatchIdentifier();       <span class="comment">// 匹配标识符</span></span><br><span class="line">  MatchToken(equal);       <span class="comment">// 匹配等号</span></span><br><span class="line">  MatchExpression();       <span class="comment">// 匹配表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“下降”的含义</p><ol><li>上级文法嵌套下级文法</li><li>上级的算法调用下级的算法</li></ol><ul><li>上下文无关文法</li><li>正则文法(不允许递归调用)</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>初步了解上下文无关文法，知道它能表达主流的计算机语言，以及与正则文法的区别。</li><li>理解递归下降算法中的 <strong>下降</strong> 和 <strong>递归</strong> 两个特点。</li><li>它跟文法规则基本上是同构的，通过文法一定能写出算法。通过遍历 AST 对表达式求值，加深对计算机程序执行机制的理解。</li></ul><h3 id="解决二元表达式中的难点"><a href="#解决二元表达式中的难点" class="headerlink" title="解决二元表达式中的难点"></a>解决二元表达式中的难点</h3><p><code>左递归（Left Recursive）</code>：产生式的第一个元素是它自身，那么程序就会无限地递归下去</p><ul><li><code>优先级（Priority）</code></li><li><code>结合性（Associativity）</code></li><li><code>产生式</code>: 一组替换规则</li></ul><p>巴科斯范（BNF):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add ::&#x3D; mul | add + mul</span><br><span class="line">mul ::&#x3D; pri | mul * pri</span><br><span class="line">pri ::&#x3D; Id | Num | (add)</span><br></pre></td></tr></table></figure><p>扩展巴科斯范式 (EBNF)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul (+ mul)*</span><br></pre></td></tr></table></figure><h3 id="确保正确的优先级"><a href="#确保正确的优先级" class="headerlink" title="确保正确的优先级"></a>确保正确的优先级</h3><ul><li>括号</li></ul><h3 id="确保正确的结合性"><a href="#确保正确的结合性" class="headerlink" title="确保正确的结合性"></a>确保正确的结合性</h3><ul><li>左结合的运算符，递归项放在左边</li><li>右结合的运算符，递归项放在右边</li></ul><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>左递归文法 <code>-&gt;</code> 非左递归的文法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add -&gt; mul add&#39;</span><br><span class="line">add&#39; -&gt; + mul add&#39; | ε</span><br></pre></td></tr></table></figure><ul><li>ε（读作 epsilon）:空集</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><code>优先级</code> 是通过在语法推导中的层次来决定的，优先级越低的，越先尝试推导。</li><li><code>结合性</code> 是跟左递归还是右递归有关的，左递归导致左结合，右递归导致右结合。</li><li><code>左递归</code> 可以通过改写语法规则来避免，而改写后的语法又可以表达成简洁的 EBNF 格式，从而启发我们用循环代替右递归。</li></ul><h3 id="实现一门简单的脚本语言"><a href="#实现一门简单的脚本语言" class="headerlink" title="实现一门简单的脚本语言"></a>实现一门简单的脚本语言</h3><p><code>回溯</code>: 尝试一个规则不成功之后，恢复到原样，再去尝试另外的规则<br><code>REPL（Read-Eval-Print Loop）</code>: 输入、执行、打印的循环过程</p><h2 id="编译器前端工具"><a href="#编译器前端工具" class="headerlink" title="编译器前端工具"></a>编译器前端工具</h2><h3 id="用Antlr生成词法、语法分析器"><a href="#用Antlr生成词法、语法分析器" class="headerlink" title="用Antlr生成词法、语法分析器"></a>用Antlr生成词法、语法分析器</h3><p><code>Antlr:</code> Antlr 是一个开源的工具，支持根据规则文件生成词法分析器和语法分析器，它自身是用 <code>Java</code> 实现的。</p><p><a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank" rel="noopener">https://github.com/antlr/antlr4/blob/master/doc/getting-started.md</a></p><h4 id="用-Antlr-生成词法分析器"><a href="#用-Antlr-生成词法分析器" class="headerlink" title="用 Antlr 生成词法分析器"></a>用 Antlr 生成词法分析器</h4><p><code>Hello.g4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar Hello;  &#x2F;&#x2F; lexer关键字意味着这是一个词法规则文件，名称是Hello，要与文件名相同</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关键字</span><br><span class="line">If :               &#39;if&#39;;</span><br><span class="line">Int :              &#39;int&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字面量</span><br><span class="line">IntLiteral:        [0-9]+;</span><br><span class="line">StringLiteral:      &#39;&quot;&#39; .*? &#39;&quot;&#39; ;  &#x2F;&#x2F; 字符串字面量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 操作符</span><br><span class="line">AssignmentOP:       &#39;&#x3D;&#39; ;    </span><br><span class="line">RelationalOP:       &#39;&gt;&#39;|&#39;&gt;&#x3D;&#39;|&#39;&lt;&#39; |&#39;&lt;&#x3D;&#39; ;    </span><br><span class="line">Star:               &#39;*&#39;;</span><br><span class="line">Plus:               &#39;+&#39;;</span><br><span class="line">Sharp:              &#39;#&#39;;</span><br><span class="line">SemiColon:          &#39;;&#39;;</span><br><span class="line">Dot:                &#39;.&#39;;</span><br><span class="line">Comm:               &#39;,&#39;;</span><br><span class="line">LeftBracket :       &#39;[&#39;;</span><br><span class="line">RightBracket:       &#39;]&#39;;</span><br><span class="line">LeftBrace:          &#39;&#123;&#39;;</span><br><span class="line">RightBrace:         &#39;&#125;&#39;;</span><br><span class="line">LeftParen:          &#39;(&#39;;</span><br><span class="line">RightParen:         &#39;)&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 标识符</span><br><span class="line">Id :                [a-zA-Z_] ([a-zA-Z_] | [0-9])*;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 空白字符，抛弃</span><br><span class="line">Whitespace:         [ \t]+ -&gt; skip;</span><br><span class="line">Newline:            ( &#39;\r&#39; &#39;\n&#39;?|&#39;\n&#39;)-&gt; skip;</span><br></pre></td></tr></table></figure><h5 id="编译词法规则"><a href="#编译词法规则" class="headerlink" title="编译词法规则"></a>编译词法规则</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr Hello.g4</span><br></pre></td></tr></table></figure><h5 id="编译-Hello-java"><a href="#编译-Hello-java" class="headerlink" title="编译 Hello.java"></a>编译 Hello.java</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac *.java</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p><code>hello.play</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 45;</span><br><span class="line">if (age &gt;&#x3D; 17+8+20) &#123;</span><br><span class="line">    printf(&quot;Hello old man!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>词法分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grun Hello tokens -tokens hello.play</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[@0,0:2&#x3D;&#39;int&#39;,&lt;&#39;int&#39;&gt;,1:0]</span><br><span class="line">[@1,4:6&#x3D;&#39;age&#39;,&lt;Id&gt;,1:4]</span><br><span class="line">[@2,8:8&#x3D;&#39;&#x3D;&#39;,&lt;&#39;&#x3D;&#39;&gt;,1:8]</span><br><span class="line">[@3,10:11&#x3D;&#39;45&#39;,&lt;IntLiteral&gt;,1:10]</span><br><span class="line">[@4,12:12&#x3D;&#39;;&#39;,&lt;&#39;;&#39;&gt;,1:12]</span><br><span class="line">[@5,14:15&#x3D;&#39;if&#39;,&lt;&#39;if&#39;&gt;,2:0]</span><br><span class="line">[@6,17:17&#x3D;&#39;(&#39;,&lt;&#39;(&#39;&gt;,2:3]</span><br><span class="line">[@7,18:20&#x3D;&#39;age&#39;,&lt;Id&gt;,2:4]</span><br><span class="line">[@8,22:23&#x3D;&#39;&gt;&#x3D;&#39;,&lt;RelationalOP&gt;,2:8]</span><br><span class="line">[@9,25:26&#x3D;&#39;17&#39;,&lt;IntLiteral&gt;,2:11]</span><br><span class="line">[@10,27:27&#x3D;&#39;+&#39;,&lt;&#39;+&#39;&gt;,2:13]</span><br><span class="line">[@11,28:28&#x3D;&#39;8&#39;,&lt;IntLiteral&gt;,2:14]</span><br><span class="line">[@12,29:29&#x3D;&#39;+&#39;,&lt;&#39;+&#39;&gt;,2:15]</span><br><span class="line">[@13,30:31&#x3D;&#39;20&#39;,&lt;IntLiteral&gt;,2:16]</span><br><span class="line">[@14,32:32&#x3D;&#39;)&#39;,&lt;&#39;)&#39;&gt;,2:18]</span><br><span class="line">[@15,34:34&#x3D;&#39;&#123;&#39;,&lt;&#39;&#123;&#39;&gt;,2:20]</span><br><span class="line">[@16,40:45&#x3D;&#39;printf&#39;,&lt;Id&gt;,3:4]</span><br><span class="line">[@17,46:46&#x3D;&#39;(&#39;,&lt;&#39;(&#39;&gt;,3:10]</span><br><span class="line">[@18,47:62&#x3D;&#39;&quot;Hello old man!&quot;&#39;,&lt;StringLiteral&gt;,3:11]</span><br><span class="line">[@19,63:63&#x3D;&#39;)&#39;,&lt;&#39;)&#39;&gt;,3:27]</span><br><span class="line">[@20,64:64&#x3D;&#39;;&#39;,&lt;&#39;;&#39;&gt;,3:28]</span><br><span class="line">[@21,66:66&#x3D;&#39;&#125;&#39;,&lt;&#39;&#125;&#39;&gt;,4:0]</span><br><span class="line">[@22,68:67&#x3D;&#39;&lt;EOF&gt;&#39;,&lt;EOF&gt;,5:0]</span><br></pre></td></tr></table></figure><h4 id="用-Antlr-生成语法分析器"><a href="#用-Antlr-生成语法分析器" class="headerlink" title="用 Antlr 生成语法分析器"></a>用 Antlr 生成语法分析器</h4><p><code>PlayScript.g4</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">grammar PlayScript;</span><br><span class="line">import CommonLexer;   &#x2F;&#x2F;导入词法定义</span><br><span class="line"></span><br><span class="line">&#x2F;*下面的内容加到所生成的Java源文件的头部，如包名称，import语句等。*&#x2F;</span><br><span class="line">@header &#123;</span><br><span class="line">package antlrtest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expression</span><br><span class="line">    :   assignmentExpression</span><br><span class="line">    |   expression &#39;,&#39; assignmentExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentExpression</span><br><span class="line">    :   additiveExpression</span><br><span class="line">    |   Identifier assignmentOperator additiveExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">assignmentOperator</span><br><span class="line">    :   &#39;&#x3D;&#39;</span><br><span class="line">    |   &#39;*&#x3D;&#39;</span><br><span class="line">    |  &#39;&#x2F;&#x3D;&#39;</span><br><span class="line">    |   &#39;%&#x3D;&#39;</span><br><span class="line">    |   &#39;+&#x3D;&#39;</span><br><span class="line">    |   &#39;-&#x3D;&#39;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">additiveExpression</span><br><span class="line">    :   multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#39;+&#39; multiplicativeExpression</span><br><span class="line">    |   additiveExpression &#39;-&#39; multiplicativeExpression</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">multiplicativeExpression</span><br><span class="line">    :   primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;*&#39; primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;&#x2F;&#39; primaryExpression</span><br><span class="line">    |   multiplicativeExpression &#39;%&#39; primaryExpression</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h5 id="生成语法分析器"><a href="#生成语法分析器" class="headerlink" title="生成语法分析器"></a>生成语法分析器</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">antlr PlayScript.g4</span><br><span class="line">javac antlrtest/*.java</span><br></pre></td></tr></table></figure><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grun antlrtest.PlayScript expression -gui</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age + 10 * 2  + 10</span><br><span class="line">^D</span><br></pre></td></tr></table></figure><p><strong>懂得基础原理，会让你站得更高</strong></p><h3 id="用Antlr重构脚本语言"><a href="#用Antlr重构脚本语言" class="headerlink" title="用Antlr重构脚本语言"></a>用Antlr重构脚本语言</h3><ul><li><p>完善表达式（Expression）的语法</p></li><li><p>完善各类语句（Statement）的语法</p></li><li><p>语句</p><ul><li>条件语句<ul><li>if 语句</li><li>switch 语句</li></ul></li><li>循环语句<ul><li>for 循环语句</li><li>while 循环语句</li></ul></li><li>return 语句</li></ul></li><li><p>表达式语句</p><ul><li>表达式后面加一个分号</li></ul></li></ul><p>用 <code>Vistor</code> 模式升级脚本解释器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">antlr -visitor PlayScript.g4</span><br></pre></td></tr></table></figure><h2 id="作用域和生存期：实现块作用域和函数"><a href="#作用域和生存期：实现块作用域和函数" class="headerlink" title="作用域和生存期：实现块作用域和函数"></a>作用域和生存期：实现块作用域和函数</h2><p><code>作用域（Scope）</code>: 计算机语言中变量、函数、类等起作用的范围<br><code>生存期（Extent）</code>: 变量可以访问的时间段，也就是从分配内存给它，到收回它的内存之间的时间</p><ol><li>实现作用域和栈</li><li>实现块作用域</li><li>实现函数功能: 参数<ul><li>建立一个栈桢</li><li>计算所有参数的值，并放入栈桢</li><li>执行函数声明中的函数体。</li></ul></li></ol><h2 id="面向对象：实现数据和方法的封装"><a href="#面向对象：实现数据和方法的封装" class="headerlink" title="面向对象：实现数据和方法的封装"></a>面向对象：实现数据和方法的封装</h2><p>语法规则</p><ul><li>类声明以 class 关键字开头，有一个标识符是类型名称，后面跟着类的主体。</li><li>类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。</li><li>类的方法也叫做 function，而不是 method，是想把对象方法和函数做一些统一的设计。</li><li>函数声明现在的角色是类的方法。类的成员变量的声明和普通变量声明在语法上没什么区别。</li></ul><blockquote><p>如何在内存里管理对象的数据</p></blockquote><p>把对象的数据像其他数据一样，保存在栈</p><blockquote><p>访问对象的属性和方法</p></blockquote><p>点操作符来</p><h2 id="闭包：-理解了原理，它就不反直觉了"><a href="#闭包：-理解了原理，它就不反直觉了" class="headerlink" title="闭包： 理解了原理，它就不反直觉了"></a>闭包： 理解了原理，它就不反直觉了</h2><p>对于初学者来讲是一个挑战。其实，闭包就是把函数在静态作用域中所访问的变量的生存期拉长，形成一份可以由这个函数单独访问的数据。正因为这些数据只能被闭包函数访问，所以也就具备了对信息进行封装、隐藏内部细节的特性。</p><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h3 id="如何建立一个完善的类型系统？"><a href="#如何建立一个完善的类型系统？" class="headerlink" title="如何建立一个完善的类型系统？"></a>如何建立一个完善的类型系统？</h3><ul><li><code>静态类型语言</code>: 全部或者几乎全部的类型检查是在编译期进行的</li><li><code>动态类型语言</code>: 类型的检查是在运行期进行的</li><li><code>强类型语言</code>: 变量的类型一旦声明就不能改变</li><li><code>弱类型语言</code>: 变量类型在运行期时可以改变</li></ul><p>如何做类型检查、类型推导和类型转换</p><ul><li>类型推导（Type Inference）</li><li>类型检查（Type Checking）<ul><li>赋值语句（检查赋值操作左边和右边的类型是否匹配）</li><li>变量声明语句（因为变量声明语句中也会有初始化部分，所以也需要类型匹配）</li><li>函数传参（调用函数的时候，传入的参数要符合形参的要求）</li><li>函数返回值（从函数中返回一个值的时候，要符合函数返回值的规定）。</li></ul></li><li>类型转换（Type Conversion）</li></ul><h3 id="如何做上下文相关情况的处理？"><a href="#如何做上下文相关情况的处理？" class="headerlink" title="如何做上下文相关情况的处理？"></a>如何做上下文相关情况的处理？</h3><p><code>语义分析的本质，就是针对上下文相关的情况做处理。</code></p><h4 id="语义分析场景：引用的消解"><a href="#语义分析场景：引用的消解" class="headerlink" title="语义分析场景：引用的消解"></a>语义分析场景：引用的消解</h4><h4 id="语义分析场景：左值和右值"><a href="#语义分析场景：左值和右值" class="headerlink" title="语义分析场景：左值和右值"></a>语义分析场景：左值和右值</h4><ul><li><code>左值（L-value）</code>：最早是在 C 语言中提出的，通常出现在表达式的左边，如赋值语句的左边。左值取的是变量的地址（或者说变量的引用），获得地址以后，我们就可以把新值写进去了。</li><li><code>右值（R-value）</code>：通常所说的值，不是地址。</li></ul><p>语义分析过程</p><ol><li>类型和作用域解析（TypeAndScopeScanner.java）</li><li>类型的消解（TypeResolver.java</li><li>引用的消解和 S 属性的类型的推导（RefResolver.java）</li><li>做类型检查（TypeChecker.java）</li><li>做一些语义合法性的检查（SematicValidator.java）</li></ol><h2 id="继承和多态：面向对象运行期的动态特性"><a href="#继承和多态：面向对象运行期的动态特性" class="headerlink" title="继承和多态：面向对象运行期的动态特性"></a>继承和多态：面向对象运行期的动态特性</h2><p>从类型体系的角度理解继承和多态</p><ul><li><code>继承</code>: 一个类的子类，自动具备了父类的属性和方法，除非被父类声明为私有的。</li><li><code>多态</code>: 同一个类的不同子类，在调用同一个方法时会执行不同的动作。</li></ul><p><code>子类型</code>:  is-a 的操作</p><ul><li>名义子类型（Nominal Subtyping）<ul><li>像 Java 和 C++ 语言，需要显式声明继承了什么类，或者实现了什么接口</li></ul></li><li>结构化子类型（Structural Subtyping），又叫鸭子类型（Duck Type）<ul><li>一个类不需要显式地说自己是什么类型，只要它实现了某个类型的所有方法，那就属于这个类型</li></ul></li></ul><p>如何对继承和多态的特性做语义分析</p><ol><li>识别出新的类型</li><li>设置正确的作用域</li><li>变量和函数做类型的引用消解</li></ol><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol><li>从类型的角度，面向对象的继承和多态是一种叫做子类型的现象，子类型能够放宽对类型的检查，从而支持多态。</li><li>在编译期，无法准确地完成对象方法和属性的消解，因为无法确切知道对象的子类型。在运行期，我们能够获得对象的确切的子类型信息，从而绑定正确的方法和属性，实现继承和多态。</li><li>另一个需要注意的运行期的特征，是对象的逐级初始化过程。</li></ol><p>参考：<a href="https://time.geekbang.org/column/intro/219" target="_blank" rel="noopener">编译原理之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/14/Construction/Compiler.jpg&quot; class=&quot;&quot; title=&quot;宫文学- 编译原理&quot;&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://2020.iosdevlog.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Compiler" scheme="https://2020.iosdevlog.com/tags/Compiler/"/>
    
      <category term="Construction" scheme="https://2020.iosdevlog.com/tags/Construction/"/>
    
  </entry>
  
  <entry>
    <title>为什么你要学习编译原理？</title>
    <link href="https://2020.iosdevlog.com/2020/01/13/Compiler-Construction/"/>
    <id>https://2020.iosdevlog.com/2020/01/13/Compiler-Construction/</id>
    <published>2020-01-13T14:14:34.000Z</published>
    <updated>2020-01-14T09:26:03.548Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/13/Compiler-Construction/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E.jpg" class="" title="宫文学-《编译原理之美》"><a id="more"></a><p>编译技术并不难学</p><blockquote><p>“我知道编译技术很重要，我也很想把它啃下，可是我每次鼓起勇气拿起《编译原理》，啃不了多少页就放下了。编译原理已经成了我的心魔……”</p></blockquote><ul><li>具体的案例带你理解抽象的原理</li><li>真正运用到编译技术<ul><li>实现一门脚本语言<ul><li>词法分析</li><li>语法分析</li><li>语义分析</li></ul></li><li>实现一门编译型语言<ul><li>目标代码生成</li><li>代码优化</li></ul></li><li>面向未来的编程语言<ul><li>人工智能编程</li><li>云编程的新模式</li></ul></li></ul></li></ul><p>参考：<a href="https://time.geekbang.org/column/intro/219" target="_blank" rel="noopener">编译原理之美</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/13/Compiler-Construction/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E.jpg&quot; class=&quot;&quot; title=&quot;宫文学-《编译原理之美》&quot;&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://2020.iosdevlog.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="Compiler" scheme="https://2020.iosdevlog.com/tags/Compiler/"/>
    
      <category term="Construction" scheme="https://2020.iosdevlog.com/tags/Construction/"/>
    
  </entry>
  
</feed>
