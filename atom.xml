<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-04-23T15:22:54.795Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何画人</title>
    <link href="https://2020.iosdevlog.com/2020/04/23/people/"/>
    <id>https://2020.iosdevlog.com/2020/04/23/people/</id>
    <published>2020-04-23T15:04:16.000Z</published>
    <updated>2020-04-23T15:22:54.795Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230327.png" /></p><a id="more"></a><p>这几天看极课时间上的一门新课程：《视觉笔记入门课》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>开篇就讲：一图胜千言，我非常赞同这个观点。</p><p>不过我一般是在电脑上使用 MindMaster 制作思维导图，比如之前写的读书笔记：《一张图搞定《人民的名义》里错综复杂的人物关系图》<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p><p><img src="https://2020.iosdevlog.com/2020/02/14/people/1.svg" /></p><p>可放大观看。</p><p>课程里面主要是手绘的，我的绘画水平还不如小朋友呢。</p><p>如果能从人物图 <strong>转</strong> <code>手绘图</code>，或者手绘 <strong>转</strong> 真实人物就方便我练习了。</p><p>于是找出 Tensorflow Lite，测试一下效果。</p><p>识别出来是线框图，不过没有头，就这样吧，明天可以参照着练习手绘了。</p><h2 id="单线人的绘画方法">单线人的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230530.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230556.png" /></p><h2 id="线框人的绘画方法">线框人的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230638.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230653.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230741.png" /></p><h2 id="动态人物">动态人物</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230807.png" /></p><h2 id="多人场景的绘画方法">多人场景的绘画方法</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230919.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/article/227210" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/article/227210</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="http://localhost:4000/2020/02/14/people/" target="_blank" rel="noopener" class="uri">http://localhost:4000/2020/02/14/people/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200423230327.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="tf" scheme="https://2020.iosdevlog.com/tags/tf/"/>
    
      <category term="pose" scheme="https://2020.iosdevlog.com/tags/pose/"/>
    
  </entry>
  
  <entry>
    <title>话说软件工程</title>
    <link href="https://2020.iosdevlog.com/2020/04/22/software-engineering/"/>
    <id>https://2020.iosdevlog.com/2020/04/22/software-engineering/</id>
    <published>2020-04-22T01:55:04.000Z</published>
    <updated>2020-04-23T11:18:22.008Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103325.png" /></p><a id="more"></a><h2 id="维基百科自由的百科全书-1">维基百科，自由的百科全书 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>软件工程（英语：software engineering），是软件开发领域里对工程方法的系统应用。</p><p>1968 年秋季，NATO（北约）的科技委员会召集了近50名一流的编程人员、计算机科学家和工业界巨头，讨论和制定摆脱“软件危机”的对策。在那次会议上第一次提出了软件工程（software engineering）这个概念，研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。它涉及到程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。其后的几十年里，各种有关软件工程的技术、思想、方法和概念不断被提出，软件工程逐步发展为一门独立的科学。</p><p>1993年，电气电子工程师学会（IEEE）给出了一个更加综合的定义："将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中"。此后，IEEE多次给出软件工程的定义。</p><p>在现代社会中，软件应用于多个方面。典型的软件比如有电子邮件、嵌入式系统、人机界面、办公包、操作系统、网页、编译器、数据库、游戏等。同时，各个行业几乎都有计算机软件的应用，比如工业、农业、银行、航空、政府部门等。这些应用促进了经济和社会的发展，提高人们的工作效率，同时提升了生活质量。</p><p>软件工程师是对应用软件创造软件的人们的统称，软件工程师按照所处的领域不同可以分为系统分析师、系统架构师、前端和后端工程师、程序员、测试工程师、用户界面设计师等等。各种软件工程师人们俗称程序员。</p><h3 id="定义">定义</h3><p>关于软件工程的定义，在GB/T11457-2006《信息技术 软件工程术语》中将其定义为</p><blockquote><p>"应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科"。</p></blockquote><p>包括：<br />1. 创立与使用健全的工程原则，以便经济地获得可靠且高效率的软件。<br />1. 应用系统化，遵从原则，可被计量的方法来发展、操作及维护软件；也就是把工程应用到软件上。<br />1. 与开发、管理及更新软件产品有关的理论、方法及工具。<br />1. 一种知识或学科，目标是生产质量良好、准时交货、符合预算，并满足用户所需的软件。<br />1. 实际应用科学知识在设计、建构计算机程序，与相伴而来所产生的文件，以及后续的操作和维护上。<br />1. 使用与系统化生产和维护软件产品有关之技术与管理的知识，使软件开发与修改可在有限的时间与费用下进行。<br />1. 建造由工程师团队所开发之大型软件系统有关的知识学科。<br />1. 对软件分析、设计、实施及维护的一种系统化方法。<br />1. 系统化地应用工具和技术于开发以计算机为主的应用。<br />1. 软件工程是关于设计和开发优质软件。</p><h3 id="没有银弹与人月神话">没有银弹与人月神话</h3><p>在1986年，IBM大型机之父佛瑞德·布鲁克斯发表了他的著名论文《没有银弹》，在这篇著名的论文中他断言：“在10年内无法找到解决软件危机的灵丹妙药”。从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等。佛瑞德·布鲁克斯著名作品还有《人月神话》。</p><p>布鲁克斯在《人月神话：软件项目管理之道（The Mythical Man-Month）》提到，将没有灵丹妙药（silver bullet）可以一蹴而就，开发软件的困难是内生的，只能渐进式的改善。整体环境没有改变以前，唯一可能的解，是依靠人的素质，培养优秀的工程师。</p><h3 id="软件工程的发展方向">软件工程的发展方向</h3><p>“敏捷开发”（Agile Development）被认为是软件工程的一个重要的发展。它强调软件开发应当是能够对未来可能出现的变化和不确定性作出全面反应的。<br />敏捷开发被认为是一种“轻量级”的方法。在轻量级方法中最负盛名的应该是“极限编程”（Extreme Programming，简称为XP）。而与轻量级方法相对应的是“重量级方法”的存在。重量级方法强调以开发过程为中心，而不是以人为中心。重量级方法的例子比如CMM/PSP/TSP。</p><p>面向方面的程序设计（Aspect Oriented Programming，简称AOP）被认为是近年来软件工程的另外一个重要发展。这里的方面指的是完成一个功能的对象和函数的集合。在这一方面相关的内容有泛型编程（Generic Programming）和模板。</p><h2 id="软件工程之美2">软件工程之美<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p>软件工程学让我知道，软件项目的开发其实是一个工程，整个开发过程是可以有效组织起来的；对于开发过程的各个阶段，已经有很多解决问题的最佳实践，有很多方法来帮助我们高效完成任务；我们还可以借助工具来协助管理，提升开发效率。</p><ol type="1"><li>“器”就是软件工程中的各种工具。</li><li>“术”就是软件工程中的各种方法。<ul><li>例如如何做需求分析？</li><li>如何对需求变更做变更管理？</li></ul></li><li>“道”就是软件工程知识的核心思想、本质规律。<ul><li>例如为什么要有需求分析？</li><li>需求变更产生的深层次原因是什么？</li><li>项目中决策的依据是什么？</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104028.png" /></p><p>——《软件工程——实践者的研究方法》Roger S.Pressman</p><p>聚焦于质量，构建和维护高质量的软件</p><p>软件工程 = 工具 + 方法 + 过程</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104406.png" /></p><p>学习软件工程的四重境界</p><ol type="1"><li>用器：工具<ul><li>原型设计工具</li><li>持续集成工具</li></ul></li><li>学术：方法<ul><li>需求分析方法</li></ul></li><li>悟道：本源<ul><li>核心思想</li><li>本质规律</li></ul></li><li>传道<ul><li>教学</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422104750.png" /></p><h3 id="基础理论">基础理论</h3><p>从宏观的角度建立起软件工程的知识结构，展现软件工程学的全景图，让你掌握从软件工程的基础概念到主流的软件过程方法论。</p><p>去尝试用工程化的思维模式，去分析和解决工作和生活中的问题。</p><p>工程</p><blockquote><p>有人参与、有计划、有步骤地造一件产品，我们通常称为“工程”。</p></blockquote><p>软件危机</p><blockquote><p>软件产品质量低劣、软件维护工作量大、成本不断上升、进度不可控、程序人员无限度地增加。</p></blockquote><p>软件工程，它是为研究和克服软件危机而生。</p><p>要用工程化方法去规范软件开发，让项目可以按时完成、成本可控、质量有保证。</p><p>工程方法</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422165654.png" /></p><p>Engineering Method<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><p>工程方法通常会分成六个阶段：想法、概念、计划、设计、开发和发布。</p><ol type="1"><li><strong>想法</strong>：想法阶段通常是想要解决问题。最开始问题通常是模糊的，所以需要清晰地定义好问题，研究其可行性，检查是否有可行的解决方案。</li><li><strong>概念</strong>：概念阶段就是用图纸、草图、模型等方式，提出一些概念性的解决方案。这些方案可能有多个，最终会确定一个解决方案。</li><li><strong>计划</strong>：计划阶段是关于如何实施的计划，通常会包含人员、任务、任务持续时间、任务的依赖关系，以及完成项目所需要的预算。</li><li><strong>设计</strong>：设计阶段就是要针对产品需求，将解决方案进一步细化，设计整体架构和划分功能模块，作为分工合作和开发实施的一个依据和参考。</li><li><strong>开发</strong>：开发阶段就是根据设计方案，将解决方案构建实施。开发阶段通常是一个迭代的过程，这个阶段通常会有构建、测试、调试和重新设计的迭代。</li><li><strong>发布</strong>：将最终结果包括文档发布。</li></ol><p>瀑布模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422105710.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422171515.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422171838.png" /></p><p>V 模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174616.png" /></p><p>螺旋模型</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174710.png" /></p><p>统一软件开发过程（Rational Unified Process，RUP）-《构建之法》</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422174829.png" /></p><p>框架或指南：敏捷开发</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422105759.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422175150.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422180442.png" /></p><p>Jira<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422180930.png" /></p><p>每日站立会议</p><p>重点是要高效沟通反馈</p><h3 id="项目过程">项目过程</h3><p>软件生命周期，把知识点拆成：规划、需求分析、设计、编码、测试、运行维护这六个阶段，了解每个阶段要侧重做哪些事；分析每个阶段常见的问题，找到解决方法；了解各个阶段有哪些工具可以对项目有帮助，从而学会应用它们。</p><h3 id="案例分析">案例分析</h3><p>大公司是怎么应用软件工程的。</p><h2 id="参考书目">参考书目</h2><ul><li>《构建之法》</li></ul><p>作者邹欣是微软的研发总监，同时在多所高校进行了软件工程的教学实践，在此基础上对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。也是本专栏很多很好的补充。<br />* 《人月神话》</p><p>这是软件工程历史上的经典著作，内容发人深省，40 年来一直畅销不衰，里面的观点即使到现在也不过时。这本书即使你以前看过，隔一段时间再翻看一遍，可能都会有新的感悟。</p><ul><li>《人件》</li></ul><p>如果说《人月神话》关注“软件开发”本身，《人件》则关注软件开发中的“人”。作者指出知识型企业的核心是人，而不是技术。</p><ul><li>《知行合一： 实现价值驱动的敏捷和精益开发》</li></ul><p>作者丛斌有二十多年从事软件工程教学、咨询和研究的经验，所以书写的特别接地气，文章有很多真实案例，对敏捷开发和 CMMI 都有很深入描述。</p><ul><li>《软件工程——实践者的研究方法》</li></ul><p>这是大部分高校采用的软件工程标准教材，可以作为一个参考。《持续交付》讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。</p><ul><li>《走出软件作坊》</li></ul><p>这本书生动的描述了国内小型 IT 企业在发展过程中遇到的一系列项目管理问题，以及作者是如何去解决这些问题的。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/软件工程" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/软件工程</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/158" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/158</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="http://sites.tufts.edu/eeseniordesignhandbook/2013/engineering-method/" target="_blank" rel="noopener" class="uri">http://sites.tufts.edu/eeseniordesignhandbook/2013/engineering-method/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p><a href="https://www.atlassian.com/zh/software/jira/features" target="_blank" rel="noopener" class="uri">https://www.atlassian.com/zh/software/jira/features</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103325.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="software" scheme="https://2020.iosdevlog.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>i-Book.in：一个索引IPFS链接的搜索引擎</title>
    <link href="https://2020.iosdevlog.com/2020/04/21/IPFS/"/>
    <id>https://2020.iosdevlog.com/2020/04/21/IPFS/</id>
    <published>2020-04-20T16:00:05.000Z</published>
    <updated>2020-04-23T11:18:40.873Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103547.png" /></p><a id="more"></a><p>i-Book.in 是一个索引IPFS链接的搜索引擎 (beta_0.5)。</p><p>i-Book.in旨在为IPFS网络内储存的零散文件做一个索引，除描述外仅包含指向IPFS网络内的链接。本站索引的全部信息均从可公开获取的Internet资料中收集，仅用于提供信息的目的，它不储存任何文件。</p><p>i-Book.in尊重版权持有者的权利，并尊重DMCA，如您觉得本站包含的索引侵犯了您的权利，您可参照 该页面 提交版权声明，我们会在48小时内审核，核实后会做移除处理。</p><p>域名第一个字符 i 是有特殊含义的，代表着IPFS的 i 。本站索引指向的文件全部储存在IPFS网络上，这些链接由无数热心网友自主上传分享而来，我们只是做了一些微小的工作，将其整合到一个索引之中而已。</p><p>本搜索引擎不会采取强制收费制，以前、现在、未来都不会。但为了维持服务的正常运转，我们限制了游客跳转的次数(试图抵抗爬虫)。</p><p>并且为了支付服务器、CDN等必要开销，我们在内页设置了广告。请将本站加入【广告过滤插件】白名单以支持我们，当然，你也可以直接 捐赠 我们，让本站能够持续稳定的发展。</p><p>如果你觉得这个搜索引擎还不错，不妨分享给其他爱读书的朋友们。</p><p>i-Book.in 已经在 GitHub 开源了索引数据，有兴趣的可以 <a href="https://github.com/SaltyLeo/i-book.in" target="_blank" rel="noopener">点此</a> 访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/20200422103547.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="book" scheme="https://2020.iosdevlog.com/categories/book/"/>
    
    
      <category term="search" scheme="https://2020.iosdevlog.com/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>iData for iOS</title>
    <link href="https://2020.iosdevlog.com/2020/04/20/iData/"/>
    <id>https://2020.iosdevlog.com/2020/04/20/iData/</id>
    <published>2020-04-20T15:50:26.000Z</published>
    <updated>2020-04-20T16:04:12.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Detail.png" /></p><p>iData: <a href="https://www.cn-ki.net" target="_blank" rel="noopener" class="uri">https://www.cn-ki.net</a><br />iData for iOS: <a href="https://github.com/iOSDevLog/iData" target="_blank" rel="noopener" class="uri">https://github.com/iOSDevLog/iData</a></p><a id="more"></a><h2 id="screenshots">## Screenshots</h2><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/About.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/List.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Empty.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Search.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Downloaded.png" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Open.png" /></p><h2 id="licence">## Licence</h2><p><code>iData</code> is released under the MIT license. See <a href="LICENSE">LICENSE</a> for details.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/Detail.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;iData: &lt;a href=&quot;https://www.cn-ki.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; class=&quot;uri&quot;&gt;https://www.cn-ki.net&lt;/a&gt;&lt;br /&gt;
iData for iOS: &lt;a href=&quot;https://github.com/iOSDevLog/iData&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; class=&quot;uri&quot;&gt;https://github.com/iOSDevLog/iData&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="data" scheme="https://2020.iosdevlog.com/categories/data/"/>
    
    
      <category term="paper" scheme="https://2020.iosdevlog.com/tags/paper/"/>
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>编译时修改 iOS icon</title>
    <link href="https://2020.iosdevlog.com/2020/04/20/icon/"/>
    <id>https://2020.iosdevlog.com/2020/04/20/icon/</id>
    <published>2020-04-20T06:49:14.000Z</published>
    <updated>2020-04-20T16:05:21.971Z</updated>
    
    <content type="html"><![CDATA[<p>Build informations on top of your app icon. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>How To Change Your App Icon at Build Time <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><a id="more"></a><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/krzysztofzablocki/IconOverlaying" target="_blank" rel="noopener" class="uri">https://github.com/krzysztofzablocki/IconOverlaying</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://www.raywenderlich.com/1716-how-to-change-your-app-icon-at-build-time" target="_blank" rel="noopener" class="uri">https://www.raywenderlich.com/1716-how-to-change-your-app-icon-at-build-time</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Build informations on top of your app icon. &lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;How To Change Your App Icon at Build Time &lt;a href=&quot;#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/categories/iOS/"/>
    
    
      <category term="icon" scheme="https://2020.iosdevlog.com/tags/icon/"/>
    
  </entry>
  
  <entry>
    <title>OSI 七层模型</title>
    <link href="https://2020.iosdevlog.com/2020/04/19/osi/"/>
    <id>https://2020.iosdevlog.com/2020/04/19/osi/</id>
    <published>2020-04-19T15:59:42.000Z</published>
    <updated>2020-04-20T16:08:06.871Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/OSI.jpg" /></p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/TCP_IP.jpg" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/OSI.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>适用于 iOS 的虚拟机</title>
    <link href="https://2020.iosdevlog.com/2020/04/18/utm/"/>
    <id>https://2020.iosdevlog.com/2020/04/18/utm/</id>
    <published>2020-04-18T15:49:23.000Z</published>
    <updated>2020-04-18T15:56:04.033Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/utmapp/UTM/master/screen.png" /></p><blockquote><p>It is possible to invent a single machine which can be used to compute any computable sequence.</p></blockquote><p>-- Alan Turing, 1936</p><blockquote><p>有可能发明一台可以用来计算任何可计算序列的机器。</p></blockquote><p>-艾伦·图灵（Alan Turing），1936年</p><p>UTM 是 <code>iOS</code> 的功能齐全的虚拟机主机。简而言之，它使您可以在 <code>iPhone</code> 和 <code>iPad</code> 上运行 <code>Windows</code>，<code>Android</code> 等。有关更多信息，请访问https://getutm.app/</p><a id="more"></a><h2 id="特征">特征</h2><ul><li>借助 <code>qemu</code> 作为后端，支持 30 多种处理器，包括 <code>x86_64</code>，<code>ARM64</code> 和 <code>RISC-V</code></li><li>借助 <code>SPICE</code>，可通过半虚拟化实现快速本地图形处理</li><li>使用 <code>Qemu TCG</code> 的基于JIT的加速</li><li>使用最新和最出色的 <code>API</code> 从头开始为 <code>iOS11+</code> 设计的前端</li><li>直接从设备创建，管理，运行 <code>VM</code></li><li>无需越狱！</li></ul><h2 id="安装">安装</h2><p><a href="https://getutm.app/install/" target="_blank" rel="noopener" class="uri">https://getutm.app/install/</a></p><h2 id="github">GitHub</h2><p><a href="https://github.com/utmapp/UTM" target="_blank" rel="noopener" class="uri">https://github.com/utmapp/UTM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/utmapp/UTM/master/screen.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is possible to invent a single machine which can be used to compute any computable sequence.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-- Alan Turing, 1936&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有可能发明一台可以用来计算任何可计算序列的机器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;-艾伦·图灵（Alan Turing），1936年&lt;/p&gt;
&lt;p&gt;UTM 是 &lt;code&gt;iOS&lt;/code&gt; 的功能齐全的虚拟机主机。简而言之，它使您可以在 &lt;code&gt;iPhone&lt;/code&gt; 和 &lt;code&gt;iPad&lt;/code&gt; 上运行 &lt;code&gt;Windows&lt;/code&gt;，&lt;code&gt;Android&lt;/code&gt; 等。有关更多信息，请访问https://getutm.app/&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/categories/iOS/"/>
    
    
      <category term="github" scheme="https://2020.iosdevlog.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>首届 微软在线技术峰会 的云原生、开源与 DevOps 专场</title>
    <link href="https://2020.iosdevlog.com/2020/04/16/Microsoft/"/>
    <id>https://2020.iosdevlog.com/2020/04/16/Microsoft/</id>
    <published>2020-04-16T14:26:37.000Z</published>
    <updated>2020-04-16T15:10:16.724Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/Microsoft.png" /></p><a id="more"></a><p>最敏捷的业务创新协作，最低成本的业务迭代落地，这才是云原生、开源与 DevOps。</p><p>Microsoft Azure 为您推荐首届 微软在线技术峰会 的云原生、开源与DevOps专场。</p><p>本专场将以微软的开源代码协作为基础，深入讲解如何利用云原生、开源以及DevOps来实现最敏捷的业务创新协作流程，帮助企业实现最低成本的业务需求。</p><p>4月18日 专场详情 ：</p><p>10：20-10：50 开源在企业中的应用与发展趋势<br />Chris Aniszczyk CNCF - CTO</p><p>10：50-11：40 Azure 无服务器与微服务治理模式<br />Alan Liu</p><p>11：40-12：30 简化K8s开发！OAM与DAPR云原生应用的全流程研发实战</p><p>13：00-13：50 Azure Spring Cloud: 在Kubernetes上运行spring boot微服务的新方式<br />梁莉 微软Cloud + AI Group首席产品经理Lead</p><p>13：50-14：40 DevOps与GitHub在企业中的最佳实践<br />庄俊乾 微软云计算开发领域专家</p><p>14：40-15：30 生产应用程序的 Debugging 和Interacting<br />Thomas Huang TW</p><p>15：30-16：20 为什么 VS Code 如此流行？<br />韩骏 微软开发工具事业部资深开发工程师</p><p>16：20-17：10 Azure Synapse在游戏数据分析中的最佳实践<br />杨永波 微软资深云计算架构师</p><p>同时，在最值得期待的峰会 Keynote 部分，Microsoft Azure 邀请到了微软CEO Satya Nadella 以及来自微软 Azure， Power Platform，Microsoft 365 及 GitHub 的全球CTO及 CVP 为大家带来6场深度 Keynote 演讲，共同展望前沿技术的当下与未来。</p><p>Microsoft Azure 诚挚的邀请您与来自两岸三地的 5W+ 技术达人、众多行业顶级媒体平台共同参与，实时解锁最新技术动态！让我们一同弯道超车，开启这趟数字化转型之旅 ！</p><p>PS: 开发者 免费使用 Office 365</p><p><a href="https://developer.microsoft.com/zh-cn/microsoft-365/dev-program" target="_blank" rel="noopener" class="uri">https://developer.microsoft.com/zh-cn/microsoft-365/dev-program</a></p><p>Get a free Microsoft 365 E5 developer subscription​</p><p>Be your own administrator and prototype apps and solutions on your sandbox subscription.</p><ul><li>Includes 25 user licenses for development purposes</li><li>Access core Microsoft 365 workloads and capabilities (Windows not included), including:<ul><li>All Office 365 apps including SharePoint, OneDrive, Outlook/Exchange, Teams, Planner, Word, Excel, PowerPoint, and more</li><li>Office 365 Advanced Threat Protection</li><li>Advanced analytics with Power BI</li><li>Enterprise Mobility + Security (EMS) for compliance and information protection</li><li>Azure Active Directory for building advanced identity and access management solutions</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/welcom_365.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/join.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/subscribe.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/onmicrosoft.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/Microsoft.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="open source" scheme="https://2020.iosdevlog.com/categories/open-source/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="microsoft" scheme="https://2020.iosdevlog.com/tags/microsoft/"/>
    
      <category term="tech" scheme="https://2020.iosdevlog.com/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/15/Data-structure/"/>
    <id>https://2020.iosdevlog.com/2020/04/15/Data-structure/</id>
    <published>2020-04-15T15:40:21.000Z</published>
    <updated>2020-04-15T18:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/1-7-2.jpg" /></p><h2 id="数据结构">数据结构</h2><blockquote><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><ol type="1"><li>逻辑结构<ol type="1"><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ol></li><li>物理结构<ol type="1"><li>顺序存储结构（数组）</li><li>链接存储结构（指针/引用）</li></ol></li></ol><a id="more"></a><h2 id="算法">算法</h2><blockquote><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p></blockquote><h3 id="算法的特性">算法的特性</h3><ol type="1"><li>输入</li><li>输出</li><li>有穷性</li><li>确定性</li><li>可行性</li></ol><h3 id="算法设计的要求">算法设计的要求</h3><ol type="1"><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高 &amp; 存储量低</li></ol><h3 id="算法效率的度量方法">算法效率的度量方法</h3><ol type="1"><li>事后统计方法<ul><li>通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</li><li>不科学、不准确</li></ul></li><li>事前分析估算方法<ul><li>在计算机程序编制前，依据统计方法对算法进行估算</li></ul></li></ol><p>因素：</p><ol type="1"><li>算法采用的策略、方法<ul><li>算法好坏的根本</li></ul></li><li>编译产生的代码质量<ul><li>软件支持</li></ul></li><li>问题的输入规模</li><li>机器执行指令的速度<ul><li>硬件性能</li></ul></li></ol><p>通过算法时间复杂度来估算算法时间效率。</p><h4 id="算法时间复杂度">算法时间复杂度</h4><blockquote><p>在进行算法分析时，语句总的执行次数 <span class="math inline">\(T(n)\)</span> 是关于问题规模 <span class="math inline">\(n\)</span> 的函数，进而分析 <span class="math inline">\(T(n)\)</span> 随 <span class="math inline">\(n\)</span> 的变化情况并确定 <span class="math inline">\(T(n)\)</span> 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：<span class="math inline">\(T(n)=O(f(n))\)</span>。</p></blockquote><p>这样用大写 <span class="math inline">\(O()\)</span> 来体现算法时间复杂度的记法，我们称之为 <strong>大O记法</strong>。</p><p>推导大O阶方法</p><ol type="1"><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li></ol><ul><li>常数阶：<span class="math inline">\(O(1)\)</span></li><li>线性阶：<span class="math inline">\(O(n)\)</span></li><li>对数阶：<span class="math inline">\(O(\log n)\)</span></li><li>平方阶：<span class="math inline">\(O(n^2)\)</span>，<span class="math inline">\(O(m×n)\)</span></li></ul><h4 id="算法空间复杂度">算法空间复杂度</h4><p>若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为 <strong>原地工作</strong>，空间复杂度为 <span class="math inline">\(O(1)\)</span>。</p><h2 id="线性表list">线性表（List）</h2><blockquote><p>零个或多个数据元素的有限序列。</p></blockquote><h3 id="线性表的顺序存储结构">线性表的顺序存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line">    <span class="keyword">int</span> length;             <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><ul><li>存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度 MaxSize。</li><li>线性表的当前长度：length。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets//3-5-3.jpg" /></p><h3 id="线性表的链式存储结构">线性表的链式存储结构</h3><p>除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。</p><p>我们把存储数据元素信息的域称为 <code>数据域</code>，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素 ai 的存储映像，称为 <code>结点（Node）</code>。</p><p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-4.jpg" /></p><p>链表中第一个结点的存储位置叫做 <code>头指针</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-5.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span> <span class="comment">/* 定义LinkList */</span></span><br></pre></td></tr></table></figure><p>若线性表为空表，则头结点的指针域为“空”。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-6.jpg" /></p><p>带有头结点的单链表</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-6-8.jpg" /></p><h3 id="单链表结构与顺序存储结构优缺点">单链表结构与顺序存储结构优缺点</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-11-1.jpg" /></p><p>经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。</li><li>若需要频繁插入和删除时，宜采用单链表结构。</li><li>比如说游戏开发中，对于用户注册的个人信息，除了注册时插入数据外，绝大多数情况都是读取，所以应该考虑用顺序存储结构。而游戏中的玩家的武器或者装备列表，随着玩家的游戏过程中，可能会随时增加或删除，此时再用顺序存储就不太合适了，单链表结构就可以大展拳脚。</li><li>当然，这只是简单的类比，现实中的软件开发，要考虑的问题会复杂得多。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。</li><li>而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。</li></ul><h3 id="静态链表">静态链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-12-5.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性表的静态链表存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur; <span class="comment">/* 游标(Cursor) ，为0时表示无指向 */</span></span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><p>静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。</p><h3 id="循环链表">循环链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-13-3.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-13-4.jpg" /></p><h3 id="双向链表">双向链表</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-14-3.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-14-4.jpg" /></p><h3 id="线性表总结">线性表总结</h3><p>先谈了它的定义，线性表是零个或多个具有相同类型的数据元素的有限序列。然后谈了线性表的抽象数据类型，如它的一些基本操作。</p><p>之后我们就线性表的两大结构做了讲述，先讲的是比较容易的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。通常我们都是用数组来实现这一结构。</p><p>后来是我们的重点，由顺序存储结构的插入和删除操作不方便，引出了链式存储结构。它具有不受固定的存储空间限制，可以比较快捷的插入和删除操作的特点。然后我们分别就链式存储结构的不同形式，如单链表、循环链表和双向链表做了讲解，另外我们还讲了若不使用指针如何处理链表结构的静态链表方法。</p><p>总的来说，线性表的这两种结构，其实是后面其他数据结构的基础，把它们学明白了，对后面的学习有着至关重要的作用。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/3-15-1.jpg" /></p><h2 id="栈stack">栈（stack）</h2><blockquote><p>限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><ul><li>允许插入和删除的一端称为栈顶（top）</li><li>另一端称为栈底（bottom）</li><li>不含任何数据元素的栈称为空栈</li><li>栈又称为后进先出（LastIn First Out）的线性表，简称LIFO结构。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-2-2.jpg" /></p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-2-3.jpg" /></p><h3 id="栈的顺序存储结构及实现">栈的顺序存储结构及实现</h3><h4 id="栈的顺序存储结构">栈的顺序存储结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 顺序栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        SElemType data[MAXSIZE];</span><br><span class="line">        <span class="keyword">int</span> top; <span class="comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-4-2.jpg" /></p><p>进栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-4-3.jpg" /></p><h4 id="两栈共享空间">两栈共享空间</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-5-1.jpg" /></p><h4 id="栈的链式存储结构及实现链栈">栈的链式存储结构及实现（链栈）</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链栈结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        SElemType data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        LinkStackPtr top;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">&#125; LinkStack;</span><br></pre></td></tr></table></figure><p>进栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-2.jpg" /></p><p>出栈操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-6-3.jpg" /></p><h3 id="栈的作用">栈的作用</h3><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</p><p>所以现在的许多高级语言，比如 <code>Java</code>、<code>C#</code> 等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用Stack的 <code>push</code> 和 <code>pop</code> 方法，非常方便。</p><h3 id="栈的应用">栈的应用</h3><h4 id="递归">递归</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-8-3.jpg" /></p><p>把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做 <strong>递归函数</strong>。</p><p>迭代和递归的区别是：</p><ul><li>迭代使用的是循环结构</li><li>递归使用的是选择结构</li></ul><p>递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。</p><h4 id="四则运算表达式求值">四则运算表达式求值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + (<span class="number">3</span> - <span class="number">1</span>) × <span class="number">3</span> + <span class="number">10</span> ÷ <span class="number">2</span></span><br></pre></td></tr></table></figure><p>后缀（逆波兰）表示法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">1</span> - <span class="number">3</span> * + <span class="number">10</span> <span class="number">2</span> / +</span><br></pre></td></tr></table></figure><ul><li>所有的符号都是在要运算数字的后面出现</li><li>没有括号</li></ul><p>中缀表达式转后缀表达式</p><ul><li>从左到右遍历中缀表达式的每个数字和符号<ul><li>若是数字就输出，即成为后缀表达式的一部分</li><li>若是符号，则判断其与栈顶符号的优先级<ul><li>是右括号或优先级不高于栈顶符号（乘除优先加减）<ul><li>则栈顶元素依次出栈并输出，并将当前符号进栈</li></ul></li></ul></li></ul></li><li>一直到最终输出后缀表达式为止。</li></ul><h2 id="队列queue">队列（queue）</h2><blockquote><p>只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p></blockquote><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。</p><p>允许插入的一端称为队尾，允许删除的一端称为队头。</p><p>假设队列是 <span class="math inline">\(q=(a_1,a_2,......,a_n)\)</span>，那么 <span class="math inline">\(a_1\)</span> 就是队头元素，而 <span class="math inline">\(a_n\)</span> 是队尾元素。</p><p>这样我们就可以删除时，总是从 <span class="math inline">\(a_1\)</span> 开始，而插入时，列在最后。</p><p>这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-10-1.jpg" /></p><h3 id="队列的抽象数据类型">队列的抽象数据类型</h3><p>入队列操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-1.jpg" /></p><p>出队列</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-2.jpg" /></p><h4 id="循环队列的顺序存储结构">循环队列的顺序存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-12-8.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 循环队列的顺序存储结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front; <span class="comment">/* 头指针 */</span></span><br><span class="line"><span class="keyword">int</span> rear;  <span class="comment">/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><h4 id="队列的链式存储结构及实现链队列">队列的链式存储结构及实现（链队列）</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-1.jpg" /></p><p>空队列时，front和rear都指向头结点</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-2.jpg" /></p><p>入队操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-3.jpg" /></p><p>出队操作</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-13-4.jpg" /></p><h3 id="总结">总结</h3><p>栈和队列，它们都是特殊的线性表，只不过对插入和删除操作做了限制。</p><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。因此它们各自有各自的技巧来解决这个问题。</p><p>对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。</p><p>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。</p><p>它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/4-14-1.jpg" /></p><h3 id="串字符串string">串/字符串（string）</h3><blockquote><p>由零个或多个字符组成的有限序列</p></blockquote><p>回文诗</p><blockquote><p>儿忆父兮妻忆夫，寂寥长守夜灯孤。迟回寄雁无音讯，久别离人阻路途。诗韵和成难下笔，酒杯一酌怕空壶。知心几见曾来往，水隔山遥望眼枯。</p></blockquote><p>一般记为 <span class="math inline">\(s=&quot;a_1a_2......a_n&quot; (n≥0)\)</span>，其中，s 是字符串的名称.</p><p>零个字符的串称为空串（nullstring），它的长度为零，可以直接用两双引号 "" 表示。</p><p><code>子串</code> 与 <code>主串</code>，串中任意个数的连续字符组成的子序列称为该串的 <code>子串</code>，相应地，包含子串的串称为 <code>主串</code>。</p><p>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><h3 id="串的比较">串的比较</h3><p>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</p><h3 id="串的抽象数据类型">串的抽象数据类型</h3><h4 id="串的顺序存储结构">串的顺序存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-5-1.jpg" /></p><h4 id="串的链式存储结构">串的链式存储结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-5-3.jpg" /></p><h3 id="朴素的模式匹配算法">朴素的模式匹配算法</h3><p>简单的说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 朴素的模式匹配法 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;<span class="comment">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j]) <span class="comment">/* 两字母相等则继续 */</span></span><br><span class="line">      &#123;</span><br><span class="line">++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">      &#123;  </span><br><span class="line">         i = i-j+<span class="number">2</span>;<span class="comment">/* i退回到上次匹配首位的下一位 */</span></span><br><span class="line">         j = <span class="number">1</span>; <span class="comment">/* j退回到子串T的首位 */</span></span><br><span class="line">      &#125;      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp-模式匹配算法">KMP 模式匹配算法</h3><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-2.jpg" /><br /><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-3.jpg" /></p><p>子串有与首字符相等的字符</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-7-5.jpg" /></p><p>关键就取决于子串的结构中是否有重复的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Game2020/Assets/5-0-1.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过计算返回子串T的next数组。 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(<span class="keyword">String</span> T, <span class="keyword">int</span> *next)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">  i=<span class="number">1</span>;</span><br><span class="line">  j=<span class="number">0</span>;</span><br><span class="line">  next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i&lt;T[<span class="number">0</span>])  <span class="comment">/* 此处T[0]表示串T的长度 */</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span> || T[i]== T[j]) <span class="comment">/* T[i]表示后缀的单个字符，T[j]表示前缀的单个字符 */</span></span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++j;  </span><br><span class="line">next[i] = j;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">j= next[j];<span class="comment">/* 若字符不相同，则j值回溯 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span></span><br><span class="line"><span class="comment">/*  T非空，1≤pos≤StrLength(S)。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(<span class="keyword">String</span> S, <span class="keyword">String</span> T, <span class="keyword">int</span> pos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = pos;<span class="comment">/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">/* j用于子串T中当前位置下标值 */</span></span><br><span class="line"><span class="keyword">int</span> next[<span class="number">255</span>];<span class="comment">/* 定义一next数组 */</span></span><br><span class="line">get_next(T, next);<span class="comment">/* 对串T作分析，得到next数组 */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>]) <span class="comment">/* 若i小于S的长度并且j小于T的长度时，循环继续 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j==<span class="number">0</span> || S[i] == T[j]) <span class="comment">/* 两字母相等则继续，与朴素算法增加了j=0判断 */</span></span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> <span class="comment">/* 指针后退重新开始匹配 */</span></span><br><span class="line">       j = next[j];<span class="comment">/* j退回合适的位置，i值不变 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T[<span class="number">0</span>]) </span><br><span class="line"><span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP 算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显。</p><h3 id="总结-1">总结</h3><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p><p>本质上，它是一种线性表的扩展，但相对于线性表关注一个个元素来说，我们对串这种结构更多的是关注它子串的应用问题，如查找、替换等操作。</p><p>现在的高级语言都有针对串的函数可以调用。我们在使用这些函数的时候，同时也应该要理解它当中的原理，以便于在碰到复杂的问题时，可以更加灵活的使用，比如 KMP 模式匹配算法的学习，就是更有效地去理解 index 函数当中的实现细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Game2020/Assets/1-7-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;数据结构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构是相互之间存在一种或多种特定关系的数据元素的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;逻辑结构
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;集合结构&lt;/li&gt;
&lt;li&gt;线性结构&lt;/li&gt;
&lt;li&gt;树形结构&lt;/li&gt;
&lt;li&gt;图形结构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;物理结构
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;顺序存储结构（数组）&lt;/li&gt;
&lt;li&gt;链接存储结构（指针/引用）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
      <category term="cs" scheme="https://2020.iosdevlog.com/tags/cs/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 组织也可以免费创建私有仓库</title>
    <link href="https://2020.iosdevlog.com/2020/04/15/github/"/>
    <id>https://2020.iosdevlog.com/2020/04/15/github/</id>
    <published>2020-04-15T13:49:49.000Z</published>
    <updated>2020-04-15T14:08:43.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/15/github/github.png" /></p><p>2019 年 GitHub 用户可以免费创建私有仓库，组织不行。</p><p>从今天开始，组织也可以免费创建私有仓库。</p><a id="more"></a><p>订阅 GitHub 邮件的都应该收到以 2 封邮件。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/email_2.png" /></p><p>GitHub 将永久性对用户和团队免费开放私有仓库的使用，并且不限制项目协作人数。</p><p>同时 GitHub 上当前拥有的一些核心功能，也将对所有人免费开放，以便开发者可以更好的使用 GitHub 来进行日常团队协作，无需再受价格阻碍。</p><p>每个项目的团队人员，现在可以在 GitHub 上自由使用 CI/CD，项目管理，代码审查，软件包管理等日常项目开发工作。</p><p>打开 GitHub，从主页也可以看到提示。</p><p>点击查看 <a href="https://github.blog/2020-04-14-github-is-now-free-for-teams/" target="_blank" rel="noopener" class="uri">https://github.blog/2020-04-14-github-is-now-free-for-teams/</a>。</p><p>拿组织 <a href="https://github.com/iOSDevLog" target="_blank" rel="noopener">iOSDevLog</a> 测试一下。</p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/new.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/15/github/assets.png" /></p><p>确定可以创建私有仓库了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/15/github/github.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2019 年 GitHub 用户可以免费创建私有仓库，组织不行。&lt;/p&gt;
&lt;p&gt;从今天开始，组织也可以免费创建私有仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://2020.iosdevlog.com/categories/github/"/>
    
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
      <category term="git" scheme="https://2020.iosdevlog.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://2020.iosdevlog.com/2020/04/13/network/"/>
    <id>https://2020.iosdevlog.com/2020/04/13/network/</id>
    <published>2020-04-12T16:27:21.000Z</published>
    <updated>2020-04-14T17:04:41.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png" /></p><p>维基百科<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener" title="TCP/IP协议族">网际网路协议套组</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener" title="应用层">应用层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Border_Gateway_Protocol" target="_blank" rel="noopener" title="Border Gateway Protocol">BGP</a></li><li><a href="https://zh.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener" title="Dynamic Host Configuration Protocol">DHCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener" title="Domain Name System">DNS</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88%E5%82%B3%E8%BC%B8%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="档案传输协定">FTP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="超文本传输协议">HTTP</a></li><li><a href="https://zh.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener" title="HTTPS">HTTPS</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Message_Access_Protocol" target="_blank" rel="noopener" title="Internet Message Access Protocol">IMAP</a></li><li><a href="https://zh.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" target="_blank" rel="noopener" title="Lightweight Directory Access Protocol">LDAP</a></li><li><a href="https://zh.wikipedia.org/w/index.php?title=%E5%AA%92%E9%AB%94%E9%96%98%E9%81%93%E6%8E%A7%E5%88%B6%E5%8D%94%E5%AE%9A&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">MGCP</a></li><li><a href="https://zh.wikipedia.org/wiki/MQTT" target="_blank" rel="noopener" title="MQTT">MQTT</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_News_Transfer_Protocol" target="_blank" rel="noopener" title="Network News Transfer Protocol">NNTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="noopener" title="Network Time Protocol">NTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Post_Office_Protocol" target="_blank" rel="noopener" title="Post Office Protocol">POP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call" target="_blank" rel="noopener" title="Open Network Computing Remote Procedure Call">ONC/RPC</a></li><li><a href="https://zh.wikipedia.org/wiki/Real-time_Transport_Protocol" target="_blank" rel="noopener" title="Real-time Transport Protocol">RTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Real_Time_Streaming_Protocol" target="_blank" rel="noopener" title="Real Time Streaming Protocol">RTSP</a></li><li><a href="https://zh.wikipedia.org/wiki/Routing_Information_Protocol" target="_blank" rel="noopener" title="Routing Information Protocol">RIP</a></li><li><a href="https://zh.wikipedia.org/wiki/Session_Initiation_Protocol" target="_blank" rel="noopener" title="Session Initiation Protocol">SIP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="简单邮件传输协议">SMTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Simple_Network_Management_Protocol" target="_blank" rel="noopener" title="Simple Network Management Protocol">SNMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener" title="Secure Shell">SSH</a></li><li><a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener" title="Telnet">Telnet</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%B6%88%E6%81%AF%E4%B8%8E%E5%AD%98%E5%9C%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="可扩展消息与存在协议">XMPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:应用层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener" title="传输层">传输层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener" title="Transmission Control Protocol">TCP</a></li><li><a href="https://zh.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener" title="User Datagram Protocol">UDP</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener" title="传输层安全性协定">TLS／SSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Datagram_Congestion_Control_Protocol" target="_blank" rel="noopener" title="Datagram Congestion Control Protocol">DCCP</a></li><li><a href="https://zh.wikipedia.org/wiki/Stream_Control_Transmission_Protocol" target="_blank" rel="noopener" title="Stream Control Transmission Protocol">SCTP</a></li><li><a href="https://zh.wikipedia.org/wiki/Resource_Reservation_Protocol" target="_blank" rel="noopener" title="Resource Reservation Protocol">RSVP</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:传输层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%B1%A4" target="_blank" rel="noopener" title="网络层">网路层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener" title="Internet Protocol">IP</a> <ul><li><a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener" title="IPv4">IPv4</a></li><li><a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener" title="IPv6">IPv6</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Control_Message_Protocol" target="_blank" rel="noopener" title="Internet Control Message Protocol">ICMP</a></li><li><a href="https://zh.wikipedia.org/wiki/ICMPv6" target="_blank" rel="noopener" title="ICMPv6">ICMPv6</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E7%A2%BA%E6%93%81%E5%A1%9E%E9%80%9A%E7%9F%A5" target="_blank" rel="noopener" title="明确拥塞通知">ECN</a></li><li><a href="https://zh.wikipedia.org/wiki/Internet_Group_Management_Protocol" target="_blank" rel="noopener" title="Internet Group Management Protocol">IGMP</a></li><li><a href="https://zh.wikipedia.org/wiki/Open_Shortest_Path_First" target="_blank" rel="noopener" title="Open Shortest Path First">OSPF</a></li><li><a href="https://zh.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener" title="IPsec">IPsec</a></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:网络层协议"><em>更多...</em></a></li></ul><p><a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%A3%E7%B5%90%E5%B1%A4&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">连结层</a></p><ul><li><a href="https://zh.wikipedia.org/wiki/Address_Resolution_Protocol" target="_blank" rel="noopener" title="Address Resolution Protocol">ARP</a></li><li><a href="https://zh.wikipedia.org/wiki/Neighbor_Discovery_Protocol" target="_blank" rel="noopener" title="Neighbor Discovery Protocol">NDP</a></li><li><a href="https://zh.wikipedia.org/wiki/Tunneling_protocol" target="_blank" rel="noopener" title="Tunneling protocol">Tunnels</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Layer_2_Tunneling_Protocol" target="_blank" rel="noopener" title="Layer 2 Tunneling Protocol">L2TP</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Point-to-Point_Protocol" target="_blank" rel="noopener" title="Point-to-Point Protocol">PPP</a></li><li><a href="https://zh.wikipedia.org/wiki/Media_access_control" target="_blank" rel="noopener" title="Media access control">MAC</a> <ul><li><a href="https://zh.wikipedia.org/wiki/Ethernet" target="_blank" rel="noopener" title="Ethernet">Ethernet</a></li><li><a href="https://zh.wikipedia.org/wiki/Digital_subscriber_line" target="_blank" rel="noopener" title="Digital subscriber line">DSL</a></li><li><a href="https://zh.wikipedia.org/wiki/Integrated_Services_Digital_Network" target="_blank" rel="noopener" title="Integrated Services Digital Network">ISDN</a></li><li><a href="https://zh.wikipedia.org/wiki/Fiber_Distributed_Data_Interface" target="_blank" rel="noopener" title="Fiber Distributed Data Interface">FDDI</a></li></ul></li><li><a href="https://zh.wikipedia.org/wiki/Category:%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener" title="Category:链路协议"><em>更多...</em></a></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/0.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/1.png" /></p><h2 id="网络分层的真实含义是什么2">网络分层的真实含义是什么?<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><p><img src="https://2020.iosdevlog.com/2020/04/13/network/2.jpg" /></p><ol type="1"><li>始终想象自己是一个处理网络包的程序:<ul><li>如何拿到网络包，如何根据规则进行处理，如何发出去;</li></ul></li><li>始终牢记一个原则:<ul><li>只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。</li></ul></li></ol><p>对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然 是发不出去的。</p><h2 id="ifconfig">ifconfig</h2><ul><li>Windows<ul><li>ifconfig</li></ul></li><li>Linux<ul><li>net-tools<ul><li>ifconfig</li></ul></li><li>iproute2<ul><li>ip addr</li></ul></li></ul></li></ul><blockquote><p><code>IP 地址</code> 是一个网卡在网络世界的 <strong>通讯地址</strong>，相当于我们现实世界的门牌号码。</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/04/13/network/3.jpg" /></p><h3 id="无类型域间选路cidr">无类型域间选路(CIDR)</h3><p>于是有了一个折中的方式叫作无类型域间选路，简称 CIDR。</p><p>这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是网络号，后面是主机号。</p><p><code>10.100.122.2/24</code>，这个 IP 地址中有一个 <em>斜杠</em>，斜杠后面有个数字 <code>24</code>。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><blockquote><p>MAC 地址更像是 <strong>身份证</strong>，是一个唯一的标识。</p></blockquote><h3 id="公有-ip-地址和私有-ip-地址">公有 IP 地址和私有 IP 地址</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/4.jpg" /></p><h3 id="排队规则qdisc-queueing-discipline">排队规则（qdisc， queueing discipline）</h3><ul><li>pfifo<ul><li>不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列</li></ul></li><li>pfifo_fast<ul><li>三个波段(band)</li><li>每个波段里面，使用先进先出规则</li><li>band 0 的优先级最高</li></ul></li></ul><p>数据包是按照服务类型(Type of Service，TOS)被分配多三个波段(band)里面的。<code>TOS</code> 是 IP 头里 面的一个字段，代表了当前的包是高优先级的，还是低优先级的。</p><ul><li>IP 是地址，有定位功能</li><li>MAC 是身份证，无定位功能</li><li>CIDR 可以用来判断是不是本地人</li><li>IP 分公有的 IP 和私有的 IP</li></ul><h3 id="网络设备的状态标识net_device-flags">网络设备的状态标识（net_device flags）</h3><ul><li>UP：网卡处于启动的状态</li><li>BROADCAST：网卡有广播地址，可以发送广播包</li><li>MULTICAST：发送多播包</li><li>LOWER_UP： 网线插着，L1 是启动的</li><li>MTU （二层 MAC 层）1500：最大传输单元 MTU 为 1500，这是以太网的默认值</li></ul><h2 id="dhcp与pxe">DHCP与PXE</h2><p>如何配置 IP 地址</p><p><code>net-tools</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth1 10.0.0.1/24 </span><br><span class="line">sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure><p><code>iproute2</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line">sudo ip link <span class="built_in">set</span> up eth1</span><br></pre></td></tr></table></figure><p>Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发 送到网关。</p><p>配置文件</p><ol type="1"><li>CIDR（IP地址）</li><li>子网掩码</li><li>广播地址</li><li>网关地址</li></ol><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）</p><ol type="1"><li>DHCP <strong>D</strong>iscover</li><li>DHCP <strong>O</strong>ffer</li><li>DHCP <strong>R</strong>equest</li><li>DHCP <strong>A</strong>ck</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/5.png" /></p><p>dhcp_protocol<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><h3 id="预启动执行环境preboot-execution-environment-pxe">预启动执行环境（Preboot Execution Environment / <strong>PXE</strong>)</h3><p>操作系统启动</p><ol type="1"><li>BIOS（Basic Input output System)</li><li>读取 MBR(Master Boot Record， 主引导记录)</li><li>启动 GRUB（GRand Unified Bootloader，多重操作系统启动管理器)</li><li>GRUB 加载内核，根文件系统 initramfs</li><li>启动内核</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/6.jpg" /></p><h2 id="从二层到三层">从二层到三层</h2><h3 id="第一层物理层">第一层：物理层</h3><h4 id="最小的局域网lan">最小的局域网（LAN）</h4><p>2 台电脑相连</p><ul><li>网线<ul><li>水晶头</li><li>1,2 收</li><li>3,6 发</li><li>需要 1和3，2和6 交换位置</li></ul></li></ul><h4 id="集线器-hub-广播模式">集线器 / Hub （广播模式）</h4><ul><li>多台电脑相连</li><li>完全复制</li></ul><h3 id="第二层数据链路层mac层-medium-access-control媒体访问控制">第二层：数据链路层（MAC）层 (Medium Access Control，媒体访问控制)</h3><ol type="1"><li>信道化分</li><li>轮流协议</li><li>随机接入协议<ul><li>以太网</li></ul></li></ol><p>第二层的网络包格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/7.jpg" /></p><h5 id="arp">ARP</h5><p>已知 IP 地址，求 MAC 地址的协议</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/8.jpg" /></p><p>报文</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/9.jpg" /></p><h4 id="交换机">交换机</h4><ul><li>转发表</li></ul><ol type="1"><li>MAC 层是用来解决多路访问的堵车问题的;</li><li>ARP 是通过吼的方式来寻找目标 MAC 地址的，吼完之后记住一段时间，这个叫作缓存;</li><li>交换机是有MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。</li></ol><h3 id="交换机与vlan">交换机与VLAN</h3><p>拓扑结构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/10.jpg" /></p><p>环路问题</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/11.jpg" /></p><p>STP 协议</p><p>在数据结构中，有一个方法叫做 <strong>最小生成树</strong>。有环的我们常称为 <strong>图</strong>。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作 <code>STP</code>，全称 <em>Spanning Tree Protocol</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/12.jpg" /></p><ul><li>Root Bridge，也就是根交换机。这个比较容易理解，可以比喻为“掌门”交换机，是某棵树的老大，是掌门，最大的大哥。</li><li>Designated Bridges，有的翻译为指定交换机。这个比较难理解，可以想像成一个“小弟”，对于树来说，就是一棵树的树枝。所谓“指定”的意思是，我拜谁做大哥，其他交换机通过这个交换机到达根交换机，也就相当于拜他做了大哥。这里注意是树枝，不是叶子，因为叶子往往是主机。</li><li>Bridge Protocol Data Units （BPDU） ，网桥协议数据单元。可以比喻为“相互比较实力”的协议。行走江湖，比的就是武功，拼的就是实力。当两个交换机碰见的时候，也就是相连的时候，就需要互相比一比内力了。BPDU 只有掌门能发，已经隶属于某个掌门的交换机只能传达掌门的指示。</li><li>Priority Vector，优先级向量。可以比喻为实力 （值越小越牛）。实力是啥？就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, and Port ID]。为什么这样设计呢？这是因为要看怎么来比实力。先看 Root Bridge ID。拿出老大的 ID 看看，发现掌门一样，那就是师兄弟；再比 Root Path Cost，也即我距离我的老大的距离，也就是拿和掌门关系比，看同一个门派内谁和老大关系铁；最后比 Bridge ID，比我自己的 ID，拿自己的本事比。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/13.jpg" /></p><h3 id="虚拟局域网-vlan">虚拟局域网 (VLAN)</h3><p><img src="https://2020.iosdevlog.com/2020/04/13/network/14.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/15.jpg" /></p><p>当交换机的数目越来越多的时候，会遭遇环路问题，让网络包迷路，这就需要使用 STP 协议，通过华山论剑比武的方式，将有环路的图变成没有环路的树，从而解决环路问题。</p><p>交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。</p><h3 id="icmp-与-ping">ICMP 与 ping</h3><p>ping 是基于 ICMP 协议工作的（查询报文）。</p><p>ICMP 全称 <strong>Internet Control Message Protocol</strong>，就是互联网控制报文协议。</p><p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/16.jpg" /></p><p><code>查询报文</code></p><p>常用的 ping 就是 <strong>查询报文</strong>，是一种主动请求，并且获得主动应答的 ICMP 协议。</p><ul><li>对 ping 的主动请求，进行网络抓包，称为 ICMP ECHO REQUEST。</li><li>主动请求的回复，称为 ICMP ECHO REPLY。</li></ul><p>比起原生的 ICMP，这里面多了两个字段：</p><ul><li>一个是标识符</li><li>另一个是序号</li></ul><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><p><code>差错报文</code></p><ol type="1"><li>终点不可达<ul><li>网络不可达</li><li>主机不可达</li><li>协议不可达</li><li>端口不可达</li><li>需要进行分片但设置了不分片位</li></ul></li><li>源站抑制<ul><li>让源站放慢发送速度</li></ul></li><li>时间超时<ul><li>超过网络包的生存时间还是没到</li></ul></li><li>路由重定向<ul><li>让下次发给另一个路由器</li></ul></li></ol><p>差错报文的结构相对复杂一些。除了前面还是 IP，ICMP 的前 8 字节不变，后面则跟上出错的那个 IP 包的 IP 头和 IP 正文的前 8 个字节。</p><p>而且这类侦查兵特别恪尽职守，不但自己返回来报信，还把一部分遗物也带回来。</p><p><code>ping</code>：查询报文类型的使用</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/17.jpg" /></p><p><code>Traceroute</code>：差错报文类型的使用</p><p>traceroute，现代 Linux系统 称为 tracepath，Windows系统称为 tracert，是一种电脑网络工具。它可显示封包在 IP 网络经过的路由器的 IP 地址。</p><p>它会使用 ICMP 的规则，故意制造一些能够产生错误的场景。</p><p>Traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。</p><p>Traceroute 的参数指向某个目的 IP 地址，它会发送一个 UDP 的数据包。将 TTL 设置成 1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。</p><p>Traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。</p><p>ICMP 相当于网络世界的侦察兵。</p><p>两种类型的 ICMP 报文，一种是主动探查的查询报文，一种异常报告的差错报文</p><ol type="1"><li>ping 使用查询报文</li><li>Traceroute 使用差错报文</li></ol><h3 id="网关">网关</h3><p>出入门</p><p>路由器会有内网网口和外网网口。</p><p>配置网卡</p><p>当然 DHCP 是可以默认配置的。在进行网卡配置的时候，除了 IP 地址，还需要配置一个 <code>Gateway</code> 的东西，这个就是 <code>网关</code>。</p><figure><img src="https://2020.iosdevlog.com/2020/04/13/network/18.jpg" alt="" /><figcaption>MAC 头和 IP 头</figcaption></figure><p>MAC 头</p><ol type="1"><li>目标 MAC 地址</li><li>源 MAC 地址</li><li>协议类型<ol type="1"><li>IP 协议<br />IP 头</li></ol></li><li>版本号： IPv4</li><li>服务类型 TOS (Type of Service)</li><li>TTL</li><li>协议<ol type="1"><li>TCP</li><li>UDP</li></ol></li><li>源 IP</li><li>目标 IP<ol type="1"><li>CIDR 和子网掩码</li><li>判断是否在同一网段<ol type="1"><li>同一个网段<ol type="1"><li>通过 ARP 获得 MAC 地址</li></ol></li><li>不是同一网段<ol start="2" type="1"><li>需要发往默认网关 Gateway</li></ol></li></ol></li></ol></li></ol><p>网关往往是一个 <code>路由器</code>，是一个 <code>三层</code> 转发的设备。</p><p>一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源 IP 同网段的。</p><p>很多情况下，人们把网关就叫作路由器。</p><p>其实不完全准确。</p><p>路由器是一台设备。</p><h4 id="静态路由">静态路由</h4><p>MAC 地址是一个局域网内才有效的地址。</p><p>因而，MAC 地址只要过网关，就必定会改变，因为已经换了局域网。</p><p>两者主要的区别在于 IP 地址是否改变。</p><ul><li>不改变 IP 地址的网关，称为 <code>转发网关</code>；</li></ul><p>“欧洲十国游”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/19.jpg" /></p><ul><li>改变 IP 地址的网关，称为 <code>NAT 网关</code>。</li></ul><p>Network Address Translation 地址转换，简称 NAT。<br />网络地址端口转换NAPT（Network Address Port Translation）有端口号。</p><p>“玄奘西行”型</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/20.jpg" /></p><p>Source Network Address Translation 源地址转换，简称 SNAT。<br />Destination Network Address Translation 目标地址转换，简称 SNAT。</p><p>路由表</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/21.jpg" /></p><ol type="1"><li>如果离开本局域网，就需要经过网关，网关是路由器的一个网口；</li><li>路由器是一个三层设备，里面有如何寻找下一跳的规则；</li><li>经过路由器之后 MAC 头要变，如果 IP 不变，相当于不换护照的欧洲旅游，如果 IP 变，相当于换护照的玄奘西行。</li></ol><h4 id="动态路由">动态路由</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/22.jpg" /></p><ul><li>距离矢量路由算法</li></ul><p>第一大类的算法称为距离矢量路由（distance vector routing）。它是基于 Bellman-Ford 算法的。</p><p>这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每</p><p>一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/23.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/24.jpg" /></p><ul><li>链路状态路由算法</li></ul><p>第二大类算法是链路状态路由（link state routing），基于 Dijkstra 算法。</p><p>这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。</p><p>然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链</p><p>路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。</p><p>每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到</p><p>两点之间的最短路径。</p><p>动态路由协议</p><ul><li>基于链路状态路由算法的 OSPF<br />OSPF（Open Shortest Path First，开放式最短路径优先）就是这样一个基于链路状态路由协议，广泛</li></ul><p>应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为内部网关协议</p><p>（Interior Gateway Protocol，简称IGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><ul><li>基于距离矢量路由算法的 BGP</li></ul><p>但是外网的路由协议，也即国家之间的，又有所不同。我们称为外网路由协议（Border Gateway Protocol，简称BGP）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/25.jpg" /></p><p>在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。</p><p>路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；</p><p>动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP 协议和 OSPF 协议。</p><h2 id="最重要的传输层">最重要的传输层</h2><p>MAC 层定义本地局域网传输。<br />IP 层定义了整个网络端到端的传输行为</p><p>这两层基本定义了这样的基因</p><blockquote><p>网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段。 我们笼统地称为包。</p></blockquote><p>包单独传输，自行选路，在不同的设备封装解封装，不保证到达。基于这个基因， 生下来的孩子 UDP 完全继承了这些特性，几乎没有自己的思想。</p><h3 id="udp">UDP</h3><p>UDP 包头</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/27.jpg" /></p><p>UDP 的三大特点：</p><ol type="1"><li>沟通简单</li><li>轻信他人</li><li>愣头青，做事不懂权变</li></ol><p>UDP 的三大使用场景</p><ol type="1"><li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用。</li><li>不需要一对一沟通，建立连接，而是可以广播的应用。</li><li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候。</li></ol><p>基于 UDP 定制化的五个例子</p><ol type="1"><li>网页或者 APP 的访问<ol type="1"><li>QUIC（全称Quick UDP Internet Connections，快速 UDP 互联网连接）是 Google 提出的一种基于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。</li></ol></li><li>流媒体的协议</li><li>实时游戏</li><li>IoT 物联网</li><li>移动通信领域</li></ol><p>如果将 TCP 比作成熟的社会人，UDP 则是头脑简单的小朋友。TCP 复杂，UDP 简单；<br />TCP 维护连接，UDP 谁都相信；<br />TCP 会坚持知进退；UDP 愣头青一个，勇往直前；<br />UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。例如 DHCP、VXLAN、QUIC 等。</p><h3 id="tcp">TCP</h3><p>TCP 包头格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/28.jpg" /></p><ul><li>顺序问题，稳重不乱；</li><li>丢包问题，承诺靠谱；</li><li>连接维护，有始有终；</li><li>流量控制，把握分寸；</li><li>拥塞控制，知进知退。</li></ul><p>TCP 的三次握手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/29.jpg" /></p><p>SYN （Synchronize Sequence Number，同步序列编号）<br />ACK （Acknokedgement）用于回复<br />RST （Reset）</p><p>TCP 四次挥手</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/30.jpg" /></p><p>FIN （finish）</p><p>TCP 状态机</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/31.jpg" /></p><p>TCP 包头很复杂，但是主要关注五个问题，顺序问题，丢包问题，连接维护，流量控制，拥塞控制；</p><p>连接的建立是经过三次握手，断开的时候四次挥手。</p><p>顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘 录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少;</p><p>拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着 石头过河，找到最优值。</p><h3 id="socket">Socket</h3><p>Socket 这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根</p><p>网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个 Socket。</p><p>Socket 函数需要指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6。</p><p>另外，还要指定到底是 TCP 还是 UDP。还记得咱们前面讲过的，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM。</p><h4 id="基于-tcp-协议的-socket-程序函数调用过程">基于 TCP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/32.jpg" /></p><p>TCP 的 Socket 就是一个文件流，是非常准确的。因为，Socket 在 Linux 中就是以文件的形式存在的。</p><p>除此之外，还存在文件描述符。写入和读出，也是通过文件描述符。</p><p>文件描述符是一个整数，是这个数组的下标。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/33.jpg" /></p><h4 id="基于-udp-协议的-socket-程序函数调用过程">基于 UDP 协议的 Socket 程序函数调用过程</h4><p><img src="https://2020.iosdevlog.com/2020/04/13/network/34.jpg" /></p><h4 id="服务器如何接更多的项目">服务器如何接更多的项目？</h4><p>系统会用一个四元组来标识一个 TCP 连接。</p><p>{本机 IP, 本机端口, 对端 IP, 对端端口}</p><ul><li>多进程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/35.jpg" /></p><ul><li>多线程</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/36.jpg" /></p><ul><li>IO 多路复用，一个线程维护多个 Socket</li><li>IO 多路复用，从“派人盯着”到“有事通知” epoll</li></ul><p>epoll 被称为解决C10K 问题的利器。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/37.jpg" /></p><p>记住 TCP 和 UDP 的 Socket 的编程中，客户端和服务端都需要调用哪些函数；</p><p>写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而 epoll 机制能解决。</p><h2 id="最常用的应用层">最常用的应用层</h2><h3 id="http-协议">HTTP 协议</h3><p>HTTP 的报文大概分为三大部分。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/38.jpg" /></p><ol type="1"><li>请求行<ol type="1"><li>GET 获取 R</li><li>POST 创建 C</li><li>PUT 修改 U</li><li>DELETE 删除 D</li></ol></li><li>请求的首部<ol type="1"><li>Accept-Charset：客户端可以接受的字符集</li><li>Content-Type：正文的格式</li></ol></li><li>请求的正文实体</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/39.jpg" /></p><p>HTTP 2.0</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/40.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/41.jpg" /></p><p>QUIC 协议</p><p>机制一：自定义连接机制<br />机制二：自定义重传机制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/42.jpg" /></p><p>机制三：无阻塞的多路复用<br />机制四：自定义流量控制</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/43.jpg" /></p><p>HTTP 协议虽然很常用，也很复杂，重点记住 GET、POST、 PUT、DELETE 这几个方法，以及重要的首部字段；</p><p>HTTP 2.0 通过头压缩、分帧、二进制编码、多路复用等技术提升性能；</p><p>QUIC 协议通过基于 UDP 自定义的类似 TCP 的连接、重试、多路复用、流量控制技术，进一步提升性能。</p><h3 id="https协议">HTTPS协议</h3><p>加密</p><ol type="1"><li>对称加密</li><li>非对称加密</li></ol><p>这个证书是怎么生成的呢？会不会有人假冒权威机构颁发证书呢？就像有假身份证、假户口本一样。</p><p>生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构去认证，这个权威机构我们称为 CA（ Certifcate Authority）。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/44.jpg" /></p><h3 id="流媒体协议">流媒体协议</h3><p>压缩</p><ol type="1"><li>空间冗余</li><li>时间冗余</li><li>视觉冗余</li><li>编码冗余</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/45.jpg" /></p><p>视频编码的两大流派</p><ol type="1"><li>ITU（International Telecommunications Union）的 VECG（Video Coding Experts Group），这个称为国际电联下的 VECG。<ul><li>H.261、 H.262、H.263、H.264、H.265</li></ul></li><li>ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），这个是ISO 旗下的 MPEG，本来是做视频存储的。例如，编码后保存在 VCD 和 DVD 中。当然后来也慢慢侧重视频传输了。<ul><li>MPEG-1、MPEG-2、MPEG-4、MPEG-7</li></ul></li></ol><p>ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/46.jpg" /></p><p>编码：如何将丰富多彩的图片变成二进制流？</p><p><code>I 帧</code>，也称关键帧。里面是完整的图片，只需要本帧数据，就可以完成解码。</p><p><code>P 帧</code>，前向预测编码帧。P 帧表示的是这一帧跟之前的一个关键帧（或 P 帧）的差别，解码时需要用之前缓存的画面，叠加上和本帧定义的差别，生成最终画面。</p><p><code>B 帧</code>，双向预测内插编码帧。B 帧记录的是本帧与前后帧的差别。要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的数据与本帧数据的叠加，取得最终的画面。</p><p>可以看出，I 帧最完整，B 帧压缩率最高，而压缩后帧的序列，应该是在 <code>IBBP</code> 的间隔出现的。这就是通过时序进行编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/47.jpg" /></p><p>在一帧中，分成多个片，每个片中分成多个宏块，每个宏块分成多个子块，这样将一张大的图分解成一个个小块，可以方便进行空间上的编码。</p><p>尽管时空非常立体的组成了一个序列，但是总归还是要压缩成一个二进制流。这个流是有结构的，是一个个的网络提取层单元（NALU，Network Abstraction Layer Unit）。变成这种格式就是为了传输，因为网络上的传输，默认的是一个个的包，因而这里也就分成了一个个的单元。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/48.jpg" /></p><p>每一个 NALU 首先是一个起始标识符，用于标识 NALU 之间的间隔；然后是 NALU 的头，里面主要配置了 NALU 的类型；最终 Payload 里面是 NALU 承载的数据。</p><p>在 NALU 头里面，主要的内容是类型 NAL Type。</p><p><code>0x07</code> 表示 SPS，是序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。</p><p><code>0x08</code> 表示 PPS，是图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/49.jpg" /></p><p>推流：如何把数据流打包传输到对端？</p><p>RTMP 是基于 TCP 的，因而肯定需要双方建立一个 TCP 的连接。</p><p>在有 TCP 的连接的基础上，还需要建立一个 RTMP 的连接，也即在程序里面，你需要调用 RTMP 类库的 Connect 函数，显示创建一个连接。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/50.jpg" /></p><p>一开始双方就要知道对方的时间戳。</p><p>未来沟通这些事情，需要发送六条消息：客户端发送 C0、C1、 C2，服务器发送 S0、 S1、 S2。</p><p>RTMP Packet 包 Message 的格式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/51.jpg" /></p><p>流媒体服务器，整个过程就</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/52.jpg" /></p><p>分发网络</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/53.jpg" /></p><p>客户端通过 RTMP 拉流的过程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/54.jpg" /></p><p>视频名词比较多，编码两大流派达成了一致，都是通过时间、空间的各种算法来压缩数据；</p><p>压缩好的数据，为了传输组成一系列 NALU，按照帧和片依次排列；</p><p>排列好的 NALU，在网络传输的时候，要按照 RTMP 包的格式进行包装，RTMP 的包会拆分成</p><p>Chunk 进行传输；</p><p>推送到流媒体集群的视频流经过转码和分发，可以被客户端通过 RTMP 协议拉取，然后组合为</p><p>NALU，解码成视频格式进行播放。</p><h3 id="p2p协议">P2P协议</h3><p>下载</p><ol type="1"><li>HTTP</li><li>FTP 文件传输协议<ol type="1"><li>主动模式（PORT）</li><li>被动模式（PASV</li></ol></li><li>P2P (peer-to-peer)</li></ol><p>种子（.torrent）文件</p><ol type="1"><li>announce（tracker URL）</li><li>文件信息<ol type="1"><li>info 区</li><li>Name 字段</li><li>每个段的大小</li><li>段哈希值</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/55.jpg" /></p><p>去中心化网络（DHT）</p><p>DHT 网络是如何查找朋友的？</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/56.jpg" /></p><p>下载一个文件可以使用 HTTP 或 FTP，这两种都是集中下载的方式，而 P2P 则换了一种思路，采取非中心化下载的方式；</p><p>P2P 也是有两种，一种是依赖于 tracker 的，也即元数据集中，文件数据分散；另一种是基于分布式的哈希算法，元数据和文件数据全部分散。</p><h2 id="陌生的数据中心">陌生的数据中心</h2><h3 id="dns协议">DNS协议</h3><p>DNS(Domain Name System,域名系统)_协议（DNS）是一种分布式网络目录服务，主要用于域名与 IP 地址的相互转换，以及控制因特网的电子邮件的发送。</p><ol type="1"><li>根 DNS 服务器 ：返回顶级域 DNS 服务器的 IP 地址</li><li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址</li><li>权威 DNS 服务器 ：返回相应主机的 IP 地址</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/57.jpg" /></p><p>DNS 解析流程</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/58.jpg" /></p><p>负载均衡</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/59.jpg" /></p><p>DNS 是网络世界的地址簿，可以通过域名查地址，因为域名服务器是按照树状结构组织的，因而域名查找是使用递归的方法，并通过缓存的方式增强性能；</p><p>在域名和 IP 的映射过程中，给了应用基于域名做负载均衡的机会，可以是简单的负载均衡，也可以根据地址和运营商做全局的负载均衡。</p><h3 id="httpdns">HTTPDNS</h3><p>HTTPDNS 服务器的工作模式</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/60.jpg" /></p><p>HTTPDNS 服务器的调度设计</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/61.jpg" /></p><h3 id="cdn">CDN</h3><p>Content Delivery Network，即内容分发网络。</p><p>分布在各个地方的各个数据中心的节点，就称为 <code>边缘节点</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/62.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/63.jpg" /></p><ol type="1"><li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li><li>用户所处的运营商；</li><li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li><li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li></ol><p>接入层缓存的架构</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/64.jpg" /></p><p>防盗链</p><ol type="1"><li>refer 机制</li><li>时间戳防盗链</li></ol><p>CDN 和电商系统的分布式仓储系统一样，分为中心节点、区域节点、边缘节点，而数据缓存在离用户最近的位置。</p><p>CDN 最擅长的是缓存静态数据，除此之外还可以缓存流媒体数据，这时候要注意使用防盗链。它也支持动态数据的缓存，一种是边缘计算的生鲜超市模式，另一种是链路优化的冷链运输模式。</p><h3 id="数据中心">数据中心</h3><p>数据中心分为三层。</p><p>服务器连接到接入层，然后是汇聚层，再然后是核心层，最外面是边界路由器和安全设备。</p><p>数据中心的所有链路都需要高可用性。服务器需要绑定网卡，交换机需要堆叠，三层设备可以通过等价路由，二层设备可以通过TRILL协议。</p><p>随着云和大数据的发展，东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。</p><h3 id="vpn">VPN</h3><p>VPN，全名 Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/65.jpg" /></p><p>VPN是如何工作的？</p><p>VPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术，这里面涉及三种协议：乘客协议、隧道协议和承载协议。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/66.jpg" /></p><p>我们以 IPsec 协议为例来说明。</p><p>一种十分安全的VPN，IPsec VPN。这是基于IP协议的安全隧道协议，为了保证在公网上面信息的安全，因而采取了一定的机制保证安全性。</p><ul><li>机制一：私密性</li><li>机制二：完整性</li><li>机制三：真实性</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/13/network/67.jpg" /></p><p>协议簇</p><ul><li>两种协议的区别在于封装网络包的格式不一样<ul><li>AH（Authentication Header），只能进行数据摘要 ，不能实现数据加密。</li><li>ESP（Encapsulating Security Payload），能够进行数据加密和数据摘要</li></ul></li><li>两类算法<ul><li>加密算法</li><li>摘要算法</li></ul></li><li>两大组件<ul><li>用于VPN的双方要进行对称密钥的交换的IKE组件</li><li>VPN的双方要对连接进行维护的SA（Security Association）组件</li></ul></li></ul><p>IPsec VPN的建立过程</p><ol type="1"><li>第一个阶段，建立IKE自己的SA</li><li>建立IPsec SA</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/13/network/68.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/69.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/70.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/71.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/72.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/73.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/74.jpg" /></p><h4 id="比较">比较</h4><ul><li>IP 协议：<ul><li>不是面向连接的，是尽力而为的协议，每个 IP 包自由选择路径，依赖于上一层 TCP 的重发来保证可靠性</li><li>优点：一条道路崩溃时，可以自动换其他路</li><li>缺点：不断的路由查找，效率低下</li></ul></li><li>IPSec VPN 的缺点：<ul><li>由于 IPSec VPN 是基于 IP 协议的，所以速度慢</li></ul></li><li>ATM 协议：<ul><li>这种协议是面向连接的，并且和 IP 是同一个层次，ATM 是在传输之前先建立一个连接，形成一个虚拟的通路</li><li>优点：速度快，因为按照指定路径传输</li><li>缺点：当某个节点故障，连接就会中断，无法传输数据</li></ul></li><li>多协议标签交换「MPLS，Multi-Protocol Label Switching」<ul><li>结合了 IP 和 ATM 协议的优点</li><li>需要标签交换路由器「LSR，Label Switching Router」的支持</li><li>如何动态生成标签 LDP「Label Distribution Protocol」</li></ul></li><li>将 MPLS 和 VPN 结合起来可以提高 VPN 的效率<ul><li>需要解决的问题有：<ul><li>BGP 协议如何处理地址空间重叠的 VPN 的路由</li><li>路由表怎么区分重复的网段</li></ul></li></ul></li></ul><p>IPsec VPN的协议簇</p><p>VPN可以将一个机构的多个数据中心通过隧道的方式连接起来，让机构感觉在一个数据中心里面，就像自驾游通过琼州海峡一样；</p><p>完全基于软件的 IPsec VPN 可以保证私密性、完整性、真实性、简单便宜，但是性能稍微差一些；</p><p>MPLS-VPN 综合和IP转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买。</p><h3 id="移动网络">移动网络</h3><ul><li>2G：txt</li><li>3G：jpg</li><li>4G：avi</li></ul><h4 id="g-网络">2G 网络</h4><p>手机是通过收发无线信号来通信的，专业名称是 <code>Mobile Station</code>，简称 <code>MS</code>，需要嵌入 <code>SIM</code>。</p><p>手机是客户端，而无线信号的服务端，就是基站子系统（BSS，Base Station SubsystemBSS）。</p><p>基站子系统分两部分</p><ul><li>一部分对外提供无线通信，叫作基站收发信台（BTS，Base Transceiver Station）</li><li>另一部分对内连接有线网络，叫作基站控制器（BSC，Base Station Controller）</li></ul><p>基站收发信台通过无线收到数据后，转发给基站控制器。</p><p>这部分属于无线的部分，统称为无线接入网（RAN，Radio Access Network）。</p><p>基站控制器通过有线网络，连接到提供手机业务的运营商的数据中心，这部分称为核心网（CN，Core Network）。</p><p>核心网还没有真的进入互联网，这部分还是主要提供手机业务，是手机业务的有线部分。</p><p>首先接待基站来的数据的是移动业务交换中心（MSC，Mobile Service Switching Center），它是进入核心网的入口，但是它不会让你直接连接到互联网上。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/75.jpg" /></p><p>因而2G时代的上网如图所示，我们总结一下，有这几个核心点:</p><ul><li>手机通过无线信号连接基站;</li><li>基站一面朝前接无线，一面朝后接核心网;</li><li>核心网一面朝前接到基站请求，一是判断你是否合法，二是判断你是不是本地号，还有没有钱，一面通过网关连接电话网络。</li></ul><h4 id="g-网络-1">2.5G 网络</h4><p>后来从2G到了2.5G，也即在原来电路交换的基础上，加入了分组交换业务，支持Packet的转发，从而支持IP网络。 在上述网络的基础上，基站一面朝前接无线，一面朝后接核心网。在朝后的组件中，多了一个分组控制单元(PCU，Packet Control Unit)，用以提供分组交换通道。 在核心网里面，有个朝前的接待员(SGSN，Service GPRS Supported Node)和朝后连接IP网络的网关型GPRS支持节点(GGSN，Gateway GPRS Supported Node)。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/76.jpg" /></p><h4 id="g-网络-2">3G 网络</h4><p>到了3G时代，主要是无线通信技术有了改进，大大增加了无线的带宽。</p><p>以W-CDMA为例，理论最高2M的下行速度，因而基站改变了，一面朝外的是Node B，一面朝内连接核心网的是无线网络控制器(RNC，Radio Network Controller)。核心网以及连接的IP网 络没有什么变化。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/77.jpg" /></p><h4 id="g-网络-3">4G 网络</h4><p>然后就到了今天的 4G网络，基站为 eNodeB，包含了原来Node B 和 RNC 的功能，下行速度向百兆级别迈进。另外，核心网实现了控制面和数据面的分离，这个怎么理解呢?</p><p>在前面的核心网里面，有接待员 MSC 或者 SGSN，你会发现检查是否合法是它负责，转发数据也是它负责，也即控制面和数据面是合二为一的，这样灵活性比较差，因为控制面主要是指令，多是 小包，往往需要高的及时性;数据面主要是流量，多是大包，往往需要吞吐量。</p><p>于是有了下面这个架构。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/78.jpg" /></p><p>HSS 用于存储用户签约信息的数据库，其实就是你这个号码归属地是哪里的，以及一些认证信息。</p><p>MME 是核心控制网元，是控制面的核心，当手机通过 eNodeB 连上的时候，MME 会根据 HSS 的信息，判断你是否合法。如果允许连上来，MME 不负责具体的数据的流量，而是MME会选择数据 面的 SGW 和 PGW ，然后告诉 eNodeB，我允许你连上来了，你连接它们吧。</p><p>于是手机直接通过 eNodeB 连接 SGW ，连上核心网， SGW 相当于数据面的接待员，并通过 PGW 连到 IP网络。 PGW 就是出口网关。在出口网关，有一个组件 PCRF，称为策略和计费控制单元，用 来控制上网策略和流量的计费。</p><h4 id="g-网络协议解析">4G 网络协议解析</h4><p>我们来仔细看一下4G网络的协议，真的非常复杂。我们将几个关键组件放大来看。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/79.jpg" /></p><h4 id="控制面协议">控制面协议</h4><p>其中虚线部分是控制面的协议。当一个手机想上网的时候，先要连接 eNodeB，并通过 S1-MME 接口，请求 MME 对这个手机进行认证和鉴权。</p><p>S1-MME 协议栈如下图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/80.jpg" /></p><p>UE就是你的手机，eNodeB还是两面派，朝前对接无线网络，朝后对接核心网络，在控制面对接的是MME。</p><p>eNodeB和MME之间的连接就是很正常的IP网络，但是这里面在IP层之上，却既不是TCP，也不是UDP，而是SCTP。这也是传输层的协议，也是面向连接的，但是更加适合移动网络。 它继承了 TCP 较为完善的拥塞控制并改进TCP的一些不足之处。</p><ul><li>SCTP 的第一个特点是 <code>多宿主</code>。</li></ul><p>一台机器可以有多个网卡，而对于TCP连接来讲，虽然服务端可以监听0.0.0.0，也就是从哪个网卡来的连接都能接受，但是一旦建立了连接，就建立了四元组，也就选定了某个网卡。</p><p>SCTP 引入了联合（association）的概念，将多个接口、多条路径放到一个联合中来。当检测到一条路径失效时，协议就会通过另外一条路径来发送通信数据。应用程序甚至都不必知道发生了故障、恢复，从而提供更高的可用性和可靠性。</p><ul><li>SCTP 的第二个特点是将一个联合分成多个流。</li></ul><p>一个联合中的所有流都是独立的，但均与该联合相关。每个流都给定了一个流编号，它被编码到 SCTP 报文中，通过联合在网络上传送。在 TCP 的机制中，由于强制顺序，导致前一个不到达，后一个就得等待，SCTP 的多个流不会相互阻塞。</p><ul><li>SCTP 的第三个特点是四次握手，防止 SYN 攻击。</li></ul><p>在TCP中是三次握手，当服务端收到客户的 SYN 之后，返回一个SYN-ACK 之前，就建立数据结构，并记录下状态，等待客户端发送 ACK 的 ACK。当恶意客户端使用虚假的源地址来伪造大量SYN报文时，服务端需要分配大量的资源，最终耗尽资源，无法处理新的请求。</p><p>SCTP 可以通过四次握手引入 Cookie 的概念，来有效地防止这种攻击的产生。在 SCTP 中，客户机使用一个INIT报文发起一个连接。服务器使用一个 INIT-ACK 报文进行响应，其中就包括了 Cookie。</p><p>然后客户端就使用一个 COOKIE-ECHO 报文进行响应，其中包含了服务器所发送的 Cookie。这个时候，服务器为这个连接分配资源，并通过向客户机发送一个COOKIE-ACK报文对其进行响应。</p><ul><li>SCTP 的第四个特点是将消息分帧。</li></ul><p>TCP 是面向流的，也即发送的数据没头没尾，没有明显的界限。这对于发送数据没有问题，但是对于发送一个个消息类型的数据，就不太方便。有可能客户端写入10个字节，然后再写入20个字节。服务端不是读出10个字节的一个消息，再读出20个字节的一个消息，而有可能读入25个字节，再读入5个字节，需要业务层去组合成消息。</p><p>SCTP 借鉴了 UDP 的机制，在数据传输中提供了消息分帧功能。当一端对一个套接字执行写操作时，可确保对等端读出的数据大小与此相同。</p><ul><li>SCTP 的第五个特点是断开连接是三次挥手。</li></ul><p>在 TCP 里面，断开连接是四次挥手，允许另一端处于半关闭的状态。SCTP 选择放弃这种状态，当一端关闭自己的套接字时，对等的两端全部需要关闭，将来任何一端都不允许再进行数据的移动了。</p><p>当MME通过认证鉴权，同意这个手机上网的时候，需要建立一个数据面的数据通路。建立通路的过程还是控制面的事情，因而使用的是控制面的协议 GTP-C。</p><p>建设的数据通路分两段路，其实是两个隧道。一段是从 eNodeB 到 SGW ，这个数据通路由 MME 通过 S1-MME 协议告诉 eNodeB，它是隧道的一端，通过 S11 告诉 SGW ，它是隧道的另一端。第二端是从 SGW 到 PGW ， SGW 通过 S11 协议知道自己是其中一端，并主动通过S5协议，告诉 PGW 它是隧道的另一端。</p><p>GTP-C 协议是基于 UDP 的，这是 UDP 中的一个例子。如果看GTP头，我们可以看到，这里面有隧道的ID，还有序列号。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/81.jpg" /></p><p>通过序列号，不用TCP，GTP-C自己就可以实现可靠性，为每个输出信令消息分配一个依次递增的序列号，以确保信令消息的按序传递，并便于检测重复包。对于每个输出信令消息启动定时器， 在定时器超时前未接收到响应消息则进行重发。</p><h4 id="数据面协议">数据面协议</h4><p>当两个隧道都打通，接在一起的时候， PGW 会给手机分配一个 IP地址，这个 IP地址是隧道内部的 IP地址，可以类比为IPsec协议里面的 IP地址。这个IP地址是归手机运营商管理的。然后，手机可 以使用这个 IP地址，连接 eNodeB，从 eNodeB 经过 S1-U协议，通过第一段隧道到达 SGW ，再从 SGW 经过 S8协议，通过第二段隧道到达 PGW ，然后通过 PGW 连接到互联网。</p><p>数据面的协议都是通过 GTP-U，如图所示。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/82.jpg" /></p><p>手机每发出的一个包，都由 GTP-U 隧道协议封装起来，格式如下。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/83.jpg" /></p><p>和 IPsec 协议很类似，分为乘客协议、隧道协议、承载协议。其中乘客协议是手机发出来的包，IP 是手机的 IP，隧道协议里面有隧道 ID，不同的手机上线会建立不同的隧道，因而需要隧道ID来标 识。承载协议的 IP 地址是 SGW 和 PGW 的IP地址。</p><h4 id="手机上网流程">手机上网流程</h4><p>接下来，我们来看一个手机开机之后上网的流程，这个过程称为 Attach。可以看出来，移动网络还是很复杂的。因为这个过程要建立很多的隧道，分配很多的隧道ID，所以我画了一个图来详细 说明这个过程。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/84.jpg" /></p><ol type="1"><li>手机开机以后，在附近寻找基站eNodeB，找到后给eNodeB发送 Attach Request，说“我来啦，我要上网”。</li><li>eNodeB 将请求发给MME，说“有个手机要上网”。</li><li>MME 去请求手机，一是认证，二是鉴权，还会请求HSS看看有没有钱，看看是在哪里上网。</li><li>当 MME 通过了手机的认证之后，开始分配隧道，先告诉 SGW ，说要创建一个会话(Create Session)。在这里面，会给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道ID。</li><li>SGW 转头向 PGW 请求建立一个会话，为 PGW 的控制面分配一个隧道ID t2，也给 PGW 的数据面分配一个隧道ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道ID。</li><li>PGW 回复 SGW 说“创建会话成功”，使用自己的控制面隧道ID t2，回复里面携带着给 SGW 控制面分配的隧道ID t4和控制面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成。双方请求 对方，都要带着对方给自己分配的隧道ID，从而标志是这个手机的请求。</li><li>接下来 SGW 回复MME说“创建会话成功”，使用自己的隧道ID t1 访问 MME，回复里面有给MME分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7。</li><li>当MME发现后面的隧道都建设成功之后，就告诉eNodeB，“后面的隧道已经建设完毕， SGW 给你分配的隧道ID是t7，你可以开始连上来了，但是你也要给 SGW 分配一个隧道ID”。</li><li>eNodeB 告诉MME自己给 SGW 分配一个隧道，ID为t8。</li><li>MME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW ，从而前面的隧道也建设完毕。</li></ol><p>这样，手机就可以通过建立的隧道成功上网了。</p><h4 id="异地上网问题">异地上网问题</h4><p>接下来我们考虑异地上网的事情。 为什么要分 SGW 和 PGW 呢，一个GW不可以吗? SGW 是你本地的运营商的设备，而 PGW 是你所属的运营商的设备。</p><p>如果你在巴塞罗那，一下飞机，手机开机，周围搜寻到的肯定是巴塞罗那的eNodeB。通过MME去查寻国内运营商的HSS，看你是否合法，是否还有钱。</p><p>如果允许上网，你的手机和巴塞罗那的 SGW 会建立一个隧道，然后巴塞罗那的 SGW 和国内运营商的 PGW 建立一个隧道，然后通过国内运营商的 PGW 上网。</p><p><img src="https://2020.iosdevlog.com/2020/04/13/network/85.jpg" /></p><p>这样判断你是否能上网的在国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的IP地址也是国内运营商里统计的。</p><p>运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算。</p><p>由于你的上网策略是由国内运营商在PCRF中控制的，因而你还是上不了脸书。</p><ul><li>移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变;</li><li>记住 4G网络的结构，有 eNodeB、MME、 SGW 、 PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程;</li><li>即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书。</li></ul><h2 id="云计算中的网络">云计算中的网络</h2><h3 id="云中网络">云中网络</h3><h3 id="软件定义网络">软件定义网络</h3><h3 id="云中的网络安全">云中的网络安全</h3><h3 id="云中的网络qos">云中的网络QoS</h3><h3 id="云中网络的隔离grevxlan">云中网络的隔离GRE、VXLAN</h3><h2 id="容器技术中的网络">容器技术中的网络</h2><h3 id="容器网络">容器网络</h3><h3 id="flannel">Flannel</h3><h3 id="calico">Calico</h3><h2 id="微服务相关协议">微服务相关协议</h2><h3 id="rpc协议">RPC协议</h3><h3 id="基于-xml-的-soap-协议">基于 XML 的 SOAP 协议</h3><h3 id="基于-json-的-restful-接口协议">基于 JSON 的 RESTful 接口协议</h3><h3 id="二进制类rpc协议">二进制类RPC协议</h3><h3 id="跨语言类rpc协议">跨语言类RPC协议</h3><h2 id="搭建一个网络实验环境">搭建一个网络实验环境</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/网络传输协议" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/网络传输协议</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/85" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/85</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/" target="_blank" rel="noopener" class="uri">http://cabeggar.github.io/2016/02/21/DHCP-starvation-with-ScaPy/</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/13/network/Communication_protocol.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;维基百科&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="protocal" scheme="https://2020.iosdevlog.com/tags/protocal/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 思维导图</title>
    <link href="https://2020.iosdevlog.com/2020/04/12/nginx/"/>
    <id>https://2020.iosdevlog.com/2020/04/12/nginx/</id>
    <published>2020-04-12T15:06:15.000Z</published>
    <updated>2020-04-12T16:31:27.805Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。</p><p>2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。</p><p>Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/12/nginx/nginx.svg" /></p><p>Nginx 思维导图 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h2 id="编译">编译</h2><h3 id="选择官方模块">选择官方模块</h3><ul><li><p>with</p></li><li><p>without</p></li></ul><h3 id="指定运行时路径参数">指定运行时路径、参数</h3><h3 id="添加第三方模块">添加第三方模块</h3><ul><li><p>下载第三方模块</p><ul><li><p>config指定模块位置</p></li><li><p>C源码定义模块</p></li></ul></li></ul><h3 id="添加动态模块">添加动态模块</h3><h3 id="指定编译连接参数">指定编译连接参数</h3><h2 id="命令行">命令行</h2><h3 id="参数">参数</h3><ul><li><p>-s发送信号</p><ul><li><p>stop</p></li><li><p>quit</p></li><li><p>reload</p></li><li><p>reopen</p></li></ul></li><li><p>测试配置</p><ul><li>-t,-T,-q</li></ul></li><li><p>帮助信息</p><ul><li>-h,-?</li></ul></li><li><p>版本信息</p><ul><li>-v,-V</li></ul></li><li><p>指定运行参数</p><ul><li><p>-g</p></li><li><p>-c</p></li><li><p>-p</p></li></ul></li></ul><h2 id="运维监控">运维监控</h2><h3 id="日志">日志</h3><ul><li><p>类型</p><ul><li><p>error日志</p><ul><li>debug_connection对指定连接记日志</li></ul></li><li><p>access日志</p><ul><li><p>压缩</p></li><li><p>缓存</p></li></ul></li></ul></li><li><p>记录日志方式</p><ul><li><p>直写文件</p></li><li><p>syslog</p></li><li><p>循环写内存</p></li></ul></li></ul><h3 id="stub_status">stub_status</h3><ul><li><p>accepted</p></li><li><p>handled</p></li><li><p>requests</p></li><li><p>active</p></li><li><p>reading</p></li><li><p>writing</p></li><li><p>waiting</p></li></ul><h2 id="进程模型">进程模型</h2><h3 id="通讯方式">通讯方式</h3><ul><li><p>信号</p><ul><li><p>TERM, INT</p></li><li><p>QUIT</p></li><li><p>HUP</p></li><li><p>USR1</p></li><li><p>USR2</p></li><li><p>WINCH</p></li></ul></li><li><p>共享内存</p><ul><li><p>slab内存管理</p></li><li><p>互斥锁</p></li></ul></li></ul><h3 id="进程">进程</h3><ul><li><p>master</p></li><li><p>worker</p></li><li><p>cache manager</p></li><li><p>cache loader</p></li></ul><h2 id="对象容器">对象容器</h2><h3 id="数组">数组</h3><h3 id="链表">链表</h3><h3 id="队列">队列</h3><h3 id="红黑树">红黑树</h3><h3 id="基数树">基数树</h3><h3 id="哈希表">哈希表</h3><ul><li>桶大小向上对齐cpu cache line</li></ul><h2 id="内存池">内存池</h2><h3 id="request">request</h3><ul><li>随请求结束释放</li></ul><h3 id="connection">connection</h3><ul><li>随连接断开释放</li></ul><h2 id="连接池">连接池</h2><h3 id="事件池">事件池</h3><h3 id="上下游共享">上下游共享</h3><h3 id="keepalive长连接池">keepalive长连接池</h3><h2 id="模块设计">模块设计</h2><h3 id="模块类型">模块类型</h3><ul><li><p>core模块</p></li><li><p>event模块</p></li><li><p>http模块</p></li><li><p>conf模块</p></li><li><p>stream模块</p></li><li><p>mail模块</p></li></ul><h3 id="模块通用接口">模块通用接口</h3><ul><li><p>init_master</p></li><li><p>init_module</p></li><li><p>init_process</p></li><li><p>init_thread</p></li><li><p>exit_thread</p></li><li><p>exit_process</p></li><li><p>exit_master</p></li></ul><h2 id="请求的处理阶段">请求的处理阶段</h2><h3 id="http">http</h3><ul><li><p>POST_READ阶段</p></li><li><p>SERVER_REWRITE阶段</p></li><li><p>FIND_CONFIG阶段</p></li><li><p>REWRITE阶段</p></li><li><p>POST_REWRITE阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>POST_ACCESS阶段</p></li><li><p>PRECONTENT阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h3 id="stream">stream</h3><ul><li><p>POST_ACCEPT阶段</p></li><li><p>PREACCESS阶段</p></li><li><p>ACCESS阶段</p></li><li><p>SSL阶段</p></li><li><p>PREREAD阶段</p></li><li><p>CONTENT阶段</p></li><li><p>LOG阶段</p></li></ul><h2 id="变量">变量</h2><h3 id="按应用场景">按应用场景</h3><ul><li><p>http模块</p></li><li><p>stream模块</p></li></ul><h3 id="按功能">按功能</h3><ul><li><p>框架变量</p><ul><li>upstream变量</li></ul></li><li><p>模块变量</p></li></ul><h3 id="按使用方式">按使用方式</h3><ul><li><p>提供方</p></li><li><p>使用方</p></li></ul><h2 id="反向代理">反向代理</h2><h3 id="http-1">http</h3><ul><li><p>上游</p><ul><li><p>协议</p><ul><li><p>http/https</p></li><li><p>fastcgi</p></li><li><p>scgi</p></li><li><p>uwsgi</p></li><li><p>websocket</p></li><li><p>spdy</p></li><li><p>grpc</p></li><li><p>memcached</p></li><li><p>redis</p></li></ul></li><li><p>限速</p></li></ul></li><li><p>缓存</p><ul><li><p>缓存类型</p><ul><li><p>响应内容缓存</p><ul><li>分片</li></ul></li><li><p>openfile缓存</p></li><li><p>浏览器缓存</p></li></ul></li><li><p>缓存大小</p></li><li><p>更新淘汰方式</p></li></ul></li><li><p>下游</p><ul><li><p>http/https</p></li><li><p>限速</p></li></ul></li><li><p>平衡上下游网速</p><ul><li><p>接收请求包体</p></li><li><p>接收响应包体</p></li></ul></li></ul><h3 id="stream-1">stream</h3><ul><li><p>tcp</p></li><li><p>udp</p></li><li><p>透传客户端地址</p><ul><li><p>proxy_protocol</p></li><li><p>IP地址透传</p></li><li><p>上游服务直接返回报文</p></li></ul></li></ul><h3 id="mail">mail</h3><h3 id="负载均衡">负载均衡</h3><ul><li><p>策略</p><ul><li><p>轮询</p></li><li><p>哈希</p><ul><li>一致性哈希</li></ul></li><li><p>基于第三方服务</p></li></ul></li><li><p>健康检查</p></li><li><p>连接池</p></li><li><p>配置DNS服务</p></li></ul><h2 id="nginx.conf指令">nginx.conf指令</h2><h3 id="类型">类型</h3><ul><li><p>块指令</p><ul><li><p>main</p></li><li><p>http</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>location</p></li><li><p>if</p></li><li><p>limit_except</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li><li><p>event</p></li><li><p>stream</p><ul><li><p>server</p></li><li><p>upstream</p></li><li><p>map</p></li><li><p>geo</p></li></ul></li></ul></li><li><p>普通指令</p><ul><li><p>脚本类</p></li><li><p>设置动作</p></li><li><p>存储值</p></li></ul></li></ul><h3 id="父子指令块配置合并规则">父子指令块配置合并规则</h3><h3 id="server匹配规则">server匹配规则</h3><ul><li><p>精确匹配</p></li><li><p>泛域名</p></li><li><p>正则表达式</p></li><li><p>默认server</p></li></ul><h3 id="location匹配规则">location匹配规则</h3><ul><li><p>前缀字符串匹配</p></li><li><p>正则表达式匹配</p></li></ul><h3 id="参数单位">参数单位</h3><ul><li><p>时间</p></li><li><p>空间</p></li></ul><h2 id="性能优化">性能优化</h2><h3 id="内存效率">内存效率</h3><ul><li><p>tcp</p><ul><li>linux pressure模式</li></ul></li><li><p>http</p></li></ul><h3 id="cpu效率">CPU效率</h3><ul><li><p>绑定CPU</p></li><li><p>静态优先级</p></li><li><p>谨慎使用消耗CPU过大的模块</p></li><li><p>线程池</p></li><li><p>worker间负载均衡</p><ul><li><p>建连接</p></li><li><p>多网卡队列</p></li></ul></li></ul><h3 id="网络效率">网络效率</h3><ul><li><p>tcp</p><ul><li><p>建立连接</p><ul><li><p>FastOpen</p></li><li><p>backlog</p></li><li><p>超时时间</p></li></ul></li><li><p>传输</p><ul><li><p>缓冲区大小</p><ul><li>BGP</li></ul></li><li><p>拥塞控制</p><ul><li>初始拥塞窗口</li></ul></li><li><p>延迟批量发送</p><ul><li><p>tcp_nodelay</p></li><li><p>tcp_nopush</p></li></ul></li></ul></li><li><p>关闭连接</p><ul><li><p>keepalive释放资源</p></li><li><p>减少time_wait</p></li><li><p>超时时间</p></li></ul></li></ul></li><li><p>http</p><ul><li><p>keepalive长连接</p></li><li><p>应用层缓冲区大小</p><ul><li><p>header</p></li><li><p>body</p></li></ul></li><li><p>lingering_close</p></li><li><p>超时时间</p></li></ul></li><li><p>TLS/SSL</p><ul><li><p>session缓存</p></li><li><p>OCSP</p></li><li><p>会话票据</p></li><li><p>算法选择</p><ul><li><p>对称加密算法</p><ul><li>分组模式</li></ul></li><li><p>非对称加密算法</p></li></ul></li></ul></li><li><p>网卡</p></li></ul><h3 id="磁盘io">磁盘IO</h3><ul><li><p>AIO</p></li><li><p>directio</p></li><li><p>零拷贝</p><ul><li>sendfile</li></ul></li><li><p>日志文件</p><ul><li><p>写入缓存</p></li><li><p>压缩后写入</p></li><li><p>syslog</p></li></ul></li><li><p>减少读取次数</p><ul><li>empty_gif模块</li></ul></li><li><p>磁盘</p></li></ul><h2 id="openresty">openresty</h2><h3 id="指令">指令</h3><ul><li><p>http</p><ul><li><p>处理阶段</p></li><li><p>响应过滤</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>ssl</p></li><li><p>共享内存</p></li></ul></li><li><p>stream</p><ul><li><p>处理阶段</p></li><li><p>进程启动</p></li><li><p>upstream连接上游</p></li><li><p>共享内存</p></li><li><p>ssl</p></li></ul></li></ul><h3 id="lua模块">lua模块</h3><h3 id="sdk">SDK</h3><ul><li><p>正则表达式</p></li><li><p>流程控制类</p></li><li><p>版本与配置</p></li><li><p>进程信息</p></li><li><p>定时器</p></li><li><p>子请求</p></li><li><p>用户请求</p></li><li><p>时间类API</p></li><li><p>多线程</p><ul><li><p>coroutine</p></li><li><p>thread</p></li></ul></li><li><p>shared_dict</p></li><li><p>socket</p><ul><li><p>tcp</p></li><li><p>udp</p></li></ul></li><li><p>response header</p></li><li><p>内容输出</p></li><li><p>常量</p></li><li><p>其他</p><ul><li><p>var变量</p></li><li><p>arg参数</p></li><li><p>日志</p><ul><li>log</li></ul></li><li><p>get_phase</p></li><li><p>sleep</p></li></ul></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/Nginx" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/Nginx</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://github.com/russelltao/geektime-nginx" target="_blank" rel="noopener" class="uri">https://github.com/russelltao/geektime-nginx</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx（发音同“engine X”）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和 HTTP 缓存。该软件由伊戈尔·赛索耶夫创建并于 2004年 首次公开发布。2011年 成立同名公司以提供支持。&lt;/p&gt;
&lt;p&gt;2019年3月11日，Nginx 公司被 F5 Networks（英语：F5 Networks）以6.7亿美元收购。&lt;/p&gt;
&lt;p&gt;Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。一大部分 Web 服务器使用 Nginx，通常作为负载均衡器。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
      <category term="nginx" scheme="https://2020.iosdevlog.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains Academy Knowledge Map</title>
    <link href="https://2020.iosdevlog.com/2020/04/11/jetbrains/"/>
    <id>https://2020.iosdevlog.com/2020/04/11/jetbrains/</id>
    <published>2020-04-11T15:26:38.000Z</published>
    <updated>2020-04-13T05:12:00.211Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png" /></p><p>基础/算法/开发工具/Java/Python/Kotlin/前端​<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><h2 id="java">Java</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Java.png" /></p><h3 id="hello-world">Hello World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello AIDevLog!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/compiling_java.svg" /></p><h3 id="standard-input">Standard Input</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name = scanner.next();</span><br><span class="line"><span class="keyword">int</span> num = scanner.nextInt();</span><br><span class="line">String line = scanner.nextLine();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"Hello, "</span> + name +<span class="string">"!"</span>);</span><br><span class="line">System.out.println(line);</span><br></pre></td></tr></table></figure><h3 id="templete">Templete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String name = scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kotlin">Kotlin</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Kotlin.png" /></p><h2 id="essentials">Essentials</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Essentials.png" /></p><h2 id="fronted">Fronted</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Fronted.png" /></p><h2 id="python">Python</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Python.png" /></p><h2 id="algorithm">Algorithm</h2><p><img src="https://2020.iosdevlog.com/2020/04/11/jetbrains/Algorithm.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://hyperskill.org/knowledge-map" target="_blank" rel="noopener" class="uri">https://hyperskill.org/knowledge-map</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/11/jetbrains/DevTools.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;基础/算法/开发工具/Java/Python/Kotlin/前端​&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="academy" scheme="https://2020.iosdevlog.com/categories/academy/"/>
    
    
      <category term="python" scheme="https://2020.iosdevlog.com/tags/python/"/>
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="jetbrain" scheme="https://2020.iosdevlog.com/tags/jetbrain/"/>
    
      <category term="java" scheme="https://2020.iosdevlog.com/tags/java/"/>
    
      <category term="kotlin" scheme="https://2020.iosdevlog.com/tags/kotlin/"/>
    
      <category term="tool" scheme="https://2020.iosdevlog.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>人人都是产口经理 3.0</title>
    <link href="https://2020.iosdevlog.com/2020/04/10/pm/"/>
    <id>https://2020.iosdevlog.com/2020/04/10/pm/</id>
    <published>2020-04-10T15:51:20.000Z</published>
    <updated>2020-04-21T02:28:17.868Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/10/pm/pm.png" /></p><p><a href="https://time.geekbang.org/column/article/215594" target="_blank" rel="noopener">苏杰的产品创新课</a></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/10/pm/network.png" /></p><p><a href="https://time.geekbang.org/column/article/92378" target="_blank" rel="noopener">深入浅出计算机组成原理</a></p><p><img src="https://2020.iosdevlog.com/2020/04/10/pm/computer.png" /></p><p><a href="https://time.geekbang.org/column/article/14905" target="_blank" rel="noopener">趣谈网络协议</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/10/pm/pm.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/215594&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苏杰的产品创新课&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="manager" scheme="https://2020.iosdevlog.com/tags/manager/"/>
    
      <category term="pm" scheme="https://2020.iosdevlog.com/tags/pm/"/>
    
      <category term="cs" scheme="https://2020.iosdevlog.com/tags/cs/"/>
    
      <category term="network" scheme="https://2020.iosdevlog.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://2020.iosdevlog.com/2020/04/09/Design-pattern/"/>
    <id>https://2020.iosdevlog.com/2020/04/09/Design-pattern/</id>
    <published>2020-04-09T12:55:32.000Z</published>
    <updated>2020-04-09T14:33:18.081Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/Design-pattern.svg" /></p><a id="more"></a><h2 id="种经典的设计模式">23 种经典的设计模式</h2><ul><li>创建型<ul><li><ol type="1"><li>单例模式</li></ol></li><li><ol start="2" type="1"><li>工厂模式-工厂方法</li></ol></li><li><ol start="3" type="1"><li>工厂模式-抽象工厂</li></ol></li><li><ol start="4" type="1"><li>建造者模式</li></ol></li><li><ol start="5" type="1"><li>原型模式</li></ol></li></ul></li><li>结构型<ul><li><ol start="6" type="1"><li>代理模式</li></ol></li><li><ol start="7" type="1"><li>桥接模式</li></ol></li><li><ol start="8" type="1"><li>装饰者模式</li></ol></li><li><ol start="9" type="1"><li>适配器模式</li></ol></li><li><ol start="10" type="1"><li>门面模式</li></ol></li><li><ol start="11" type="1"><li>组合模式</li></ol></li><li><ol start="12" type="1"><li>享元模式</li></ol></li></ul></li><li>行为型<ul><li><ol start="13" type="1"><li>观察者模式</li></ol></li><li><ol start="14" type="1"><li>模板模式</li></ol></li><li><ol start="15" type="1"><li>策略模式</li></ol></li><li><ol start="16" type="1"><li>职责链模式</li></ol></li><li><ol start="17" type="1"><li>迭代器模式</li></ol></li><li><ol start="18" type="1"><li>状态模式</li></ol></li><li><ol start="19" type="1"><li>访问者模式</li></ol></li><li><ol start="20" type="1"><li>备忘录模式</li></ol></li><li><ol start="21" type="1"><li>命令模式</li></ol></li><li><ol start="22" type="1"><li>解释器模式</li></ol></li><li><ol start="23" type="1"><li>中介模式</li></ol></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/gof-23-design-patterns.png" /></p><p>设计模式中设计的可变方面<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p><img src="https://2020.iosdevlog.com/2020/04/09/Design-pattern/1.png" /></p><h2 id="设计原则">设计原则</h2><ul><li>SOLID 设计模式的六大原则<ul><li>SRP 单一职责原则<ul><li>Single Responsibility Principle</li></ul></li><li>OCP 开闭原则<ul><li>Open Closed Principle</li></ul></li><li>LSP 里式替换原则<ul><li>Liskov Substitution Principle</li></ul></li><li>LOD 法则<ul><li>Law of Demeter</li></ul></li><li>ISP 接口隔离原则<ul><li>Interface Segregation Principle</li></ul></li><li>DIP 依赖倒置原则<ul><li>Dependence Inversion Principle</li></ul></li></ul></li><li>DRY 原则<ul><li>Don't Repeat Yourself</li></ul></li><li>KISS 原则<ul><li>Keep it Simple and Stupid</li></ul></li><li>YAGNI 适可而止原则<ul><li>You Ain’t Gonna Need It</li></ul></li></ul><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="http://yuweijun.github.io/blog/" target="_blank" rel="noopener" class="uri">http://yuweijun.github.io/blog/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/09/Design-pattern/Design-pattern.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="cs" scheme="https://2020.iosdevlog.com/categories/cs/"/>
    
    
      <category term="code" scheme="https://2020.iosdevlog.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>算法思想</title>
    <link href="https://2020.iosdevlog.com/2020/04/09/algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/09/algorithm/</id>
    <published>2020-04-09T06:09:13.000Z</published>
    <updated>2020-04-09T12:06:54.824Z</updated>
    
    <content type="html"><![CDATA[<p>不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p><ul><li>贪心算法<ul><li>霍夫曼编码（Huffman Coding）</li><li>Prim 和 Kruskal 最小生成树算法</li><li>Dijkstra 单源最短路径算法</li></ul></li><li>分治算法<ul><li>MapRedue</li></ul></li><li>回溯算法</li><li>动态规划</li></ul><a id="more"></a><h2 id="贪心算法">贪心算法</h2><ol type="1"><li>定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</li><li>是否可以用贪心算法解决<ul><li>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</li></ul></li><li>贪心算法产生的结果是否是最优的</li></ol><p>贪心算法实战分析</p><ol type="1"><li>分糖果</li><li>付钱<ul><li>99 = 50 + 2 * 20 + 10 + 5 + 4 * 1</li></ul></li><li>区间覆盖</li></ol><h3 id="霍夫曼编码">霍夫曼编码</h3><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在20%～90%之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。</p><p>霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？</p><p>根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.1.jpg" /></p><p>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A、B的父节点。最后再把C节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.2.jpg" /></p><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为0，指向右子节点的边，我们统统标记为1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.3.jpg" /></p><p>贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，我们只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="分治算法">分治算法</h2><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong></p><p>分治算法一般都比较适合用递归来实现。</p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ol type="1"><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ol type="1"><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><p>分治算法应用举例分析</p><ul><li>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</li><li>有两个 <span class="math inline">\(n\*n\)</span> 的矩阵 A，B，如何快速求解两个矩阵的乘积 <span class="math inline">\(C=A\*B\)</span>？</li><li>求出一组数据的有序对个数或者逆序对个数？</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.1.jpg" /></p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。</p><p>我们用分治算法来试试。我们套用分治的思想来求数组A的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.2.jpg" /></p><p>实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分治算法用四个字概括就是“分而治之”，将原问题划分成n个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><h2 id="回溯算法">回溯算法</h2><ul><li>软件开发<ul><li>正则表达式匹配</li><li>编译原理中的语法分析</li></ul></li><li>数学问题<ul><li>数独</li><li>八皇后</li><li>0-1背包</li><li>图的着色</li><li>旅行商问题</li><li>全排列</li></ul></li></ul><h3 id="八皇后问题">八皇后问题</h3><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/39.1.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">"* "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包">0-1背包</h3><p>有一个背包，背包总的承载重量是Wkg。现在我们有n个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><ol type="1"><li>“*”匹配任意多个（大于等于0个）任意字符</li><li>“?”匹配零个或者一个任意字符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。</p><h2 id="动态规划dynamic-programming">动态规划（Dynamic Programming）</h2><h3 id="初识动态规划">初识动态规划</h3><p>大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。</p><p>动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p><h3 id="动态规划理论">动态规划理论</h3><h4 id="最优子结构">最优子结构</h4><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h4 id="无后效性">无后效性</h4><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><h4 id="重复子问题">重复子问题</h4><p>这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h3 id="动态规划实战">动态规划实战</h3><p>如何量化两个字符串的相似度？</p><p>有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。</p><p>编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。</p><ul><li>莱文斯坦距离允许增加、删除、替换字符这三个编辑操作</li><li>最长公共子串长度只允许增加、删除字符这两个编辑操作。</li></ul><p>两个字符串 <em>mitcmu</em> 和 <em>mtacnu</em> 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/42.1.jpg" /></p><h2 id="比较">比较</h2><p>贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类。</p><p>前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心算法
&lt;ul&gt;
&lt;li&gt;霍夫曼编码（Huffman Coding）&lt;/li&gt;
&lt;li&gt;Prim 和 Kruskal 最小生成树算法&lt;/li&gt;
&lt;li&gt;Dijkstra 单源最短路径算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分治算法
&lt;ul&gt;
&lt;li&gt;MapRedue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;回溯算法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-5-字符串匹配</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/</id>
    <published>2020-04-08T09:36:23.000Z</published>
    <updated>2020-04-08T10:55:30.824Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th>算法</th><th>预处理时间</th><th>匹配时间</th></tr></thead><tbody><tr class="odd"><td>BF算法 / 朴素算法</td><td>0 (无需预处理)</td><td>Θ(nm)</td></tr><tr class="even"><td>Rabin-Karp算法</td><td>Θ(m)</td><td>平均 Θ(n + m),最差 Θ((n-m)m)</td></tr><tr class="odd"><td>基于有限状态机的搜索</td><td>Θ(mk)</td><td>Θ(n)</td></tr><tr class="even"><td>克努斯-莫里斯-普拉特算法</td><td>Θ(m)</td><td>Θ(n)</td></tr><tr class="odd"><td>Boyer-Moore字符串搜索算法</td><td>Θ(m + k)</td><td>最好Ω(n/m),最坏 O(n)</td></tr><tr class="even"><td>Bitap算法</td><td>Θ(m + k)</td><td>O(mn)</td></tr></tbody></table><a id="more"></a><h2 id="bf算法">BF算法</h2><p>BF算法 中的 <code>BF</code> 是 <em>Brute Force</em> 的缩写，中文叫作 <strong>暴力匹配算</strong>法，也叫 <strong>朴素匹配算法</strong>。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.1.jpg" /></p><ul><li>主串</li><li>模式串</li></ul><p>把主串的长度记作 <code>n</code>，模式串的长度记作 <code>m</code>。</p><p>在主串中查找模式串，所以 <code>n&gt;m</code>。</p><p>BF算法的思想：</p><blockquote><p>在主串中，检查起始位置分别是 <code>0、1、2…n-m</code> 且长度为 <code>m</code> 的 <code>n-m+1</code> 个子串，看有没有跟模式串匹配的。</p></blockquote><p>尽管理论上，BF算法的时间复杂度很高，是O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的 <code>KISS（Keep it Simple and Stupid）</code> 设计原则。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2 id="rk算法">RK算法</h2><p>RK算法的全称叫 <em>Rabin-Karp算法</em>，是由它的两位发明者 <em>Rabin</em> 和 <em>Karp</em> 的名字来命名的。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.4.jpg" /></p><blockquote><p>通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p></blockquote><p>通过查表的方法来提高效率。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.5.jpg" /></p><h2 id="bm算法1">BM算法<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF算法和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.1.jpg" /></p><p>一次性把模式串往后多滑动几位，把模式串移动到c的后面。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.2.jpg" /></p><h3 id="bm算法原理分析">BM算法原理分析</h3><p>坏字符规则（bad character rule）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.3.jpg" /></p><p>没有匹配的字符叫作坏字符（主串中的字符）。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.7.jpg" /></p><p>好后缀规则（good suffix shift）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.10.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.12.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.13.jpg" /></p><p>BM算法代码实现</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.14.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把 <em>BM算法</em> 代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑si-xi计算得到的移动位数可能会出现负数的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.15.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.16.jpg" /></p><p>引入最关键的变量 <code>suffix数组</code></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.17.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.18.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.19.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.20.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.21.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.22.jpg" /></p><p>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp算法基本原理">KMP算法基本原理</h3><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的，算法的全称是Knuth Morris Pratt算法，简称为KMP算法。</p><p>KMP算法的核心思想，跟上一节讲的BM算法非常相近。我们假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>这里我们可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作 <em>坏字符</em>，把已经匹配的那段字符串叫作 <em>好前缀</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.3.jpg" /></p><p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.5.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失效函数计算方法</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.9.jpg" /></p><h2 id="小结">小结</h2><p><em>BF算法</em> 是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是O(n*m)，n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p><em>RK算法</em> 是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，<em>RK算法</em> 的时间复杂度是 <span class="math inline">\(O(n\)</span>)，跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 <span class="math inline">\(O(n*m\)</span>)。</p><p><em>BM算法</em> 尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。如果一遍看不懂的话，你就多看几遍。</p><p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法。</p><p>BM算法有两个规则，坏字符和好后缀。KMP算法借鉴BM算法的思想，可以总结成好前缀规则。这里面最难懂的就是next数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。</p><p>一种类似动态规划的方法，按照下标i从小到大，依次计算 <code>next[i]</code>，并且 <code>next[i]</code> 的计算通过前面已经计算出来的 <code>next[0]，next[1]，……，next[i-1]</code> 来推导。</p><p>KMP算法的时间复杂度是 <span class="math inline">\(O(n+m)\)</span>，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf" target="_blank" rel="noopener" class="uri">http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;预处理时间&lt;/th&gt;
&lt;th&gt;匹配时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;BF算法 / 朴素算法&lt;/td&gt;
&lt;td&gt;0 (无需预处理)&lt;/td&gt;
&lt;td&gt;Θ(nm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Rabin-Karp算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;平均 Θ(n + m),最差 Θ((n-m)m)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;基于有限状态机的搜索&lt;/td&gt;
&lt;td&gt;Θ(mk)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;克努斯-莫里斯-普拉特算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Boyer-Moore字符串搜索算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;最好Ω(n/m),最坏 O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Bitap算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;O(mn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-4-图（Graph）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/graph/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/graph/</id>
    <published>2020-04-08T08:08:48.000Z</published>
    <updated>2020-04-08T11:15:29.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>顶点（vertex）：图中的元素</li><li>边（edge）：一个顶点与任意其他顶点建立连接关系</li><li>度（degree）：跟顶点相连接的边的条数<ul><li>入度（In-degree）</li><li>出度（Out-degree）</li></ul></li><li>有向图：边有方向的图</li><li>无向图：边没有方向的图</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg" /></p><a id="more"></a><h2 id="邻接矩阵存储方法">邻接矩阵存储方法</h2><p>图最直观的一种存储方法就是，邻接矩阵（Adjacency Matrix）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点i与顶点j之间有边，我们就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 <code>1</code>；对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，那我们就将 <code>A[i][j]</code> 标记为 <code>1</code>。同理，如果有一条箭头从顶点 <code>j</code> 指向顶点i的边，我们就将 <code>A[j][i]</code> 标记为 <code>1</code>。对于带权图，数组中就存储相应的权重。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.3.jpg" /></p><p>稀疏图（Sparse Matrix）浪费存储空间。</p><h2 id="邻接表存储方法">邻接表存储方法</h2><h3 id="邻接表adjacency-list">邻接表（Adjacency List）</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.4.jpg" /></p><h3 id="逆邻接表">逆邻接表</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.5.jpg" /></p><h3 id="哈希算法等数据分片方">哈希算法等数据分片方</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.6.jpg" /></p><h3 id="数据库存储">数据库存储</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.7.jpg" /></p><h2 id="无向图代码">无向图代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q被访问，那相应的 <code>visited[q]</code> 会被设置为 <code>true</code>。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第 <code>k+1</code> 层的顶点。当我们访问到第k层的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第 <code>k+1</code> 层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。<code>prev[w]</code> 存储的是，顶点 <code>w</code> 是从哪个前驱顶点遍历过来的。比如，我们通过顶点2的邻接表访问到顶点3，那 <code>prev[3]</code> 就等于 <code>2</code>。为了正向打印出路径，我们需要递归地来打印，你可以看下 <code>print()</code> 函数的实现方式。</p><p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。</p><h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称DFS。最直观的例子就是“走迷宫”。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 <code>O(E)</code>，E表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 <code>visited</code>、<code>prev</code> 数组和递归调用栈。</p><p><code>visited</code>、<code>prev</code> 数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 <code>O(V)</code>。</p><h2 id="小结">小结</h2><p>无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。</p><p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><ul><li>深度：栈</li><li>广度：队列</li></ul><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如A<em>、IDA</em>等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点（vertex）：图中的元素&lt;/li&gt;
&lt;li&gt;边（edge）：一个顶点与任意其他顶点建立连接关系&lt;/li&gt;
&lt;li&gt;度（degree）：跟顶点相连接的边的条数
&lt;ul&gt;
&lt;li&gt;入度（In-degree）&lt;/li&gt;
&lt;li&gt;出度（Out-degree）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有向图：边有方向的图&lt;/li&gt;
&lt;li&gt;无向图：边没有方向的图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-3-堆（heap）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/heap/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/heap/</id>
    <published>2020-04-08T05:31:30.000Z</published>
    <updated>2020-04-08T11:14:59.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><a id="more"></a><h2 id="堆完全二叉树">堆（完全二叉树）</h2><p>比较适合用数组来存储</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.2.jpg" /></p><p>插入一个元素</p><p>堆化（heapify）</p><ul><li>从下往上</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.3.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) &#123; <span class="keyword">return</span>; &#125; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>删除堆顶元素</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.5.jpg" /></p><ul><li>从上往下</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含 <span class="math inline">\(n\)</span> 个节点的完全二叉树，树的高度不会超过 <span class="math inline">\(\log_{2}n\)</span>。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <span class="math inline">\(O(\log n)\)</span>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><h2 id="堆排序">堆排序</h2><h3 id="建堆">建堆</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.7.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.8.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下标从 <span class="math inline">\(\frac{n}{2}\)</span> 开始到 <span class="math inline">\(1\)</span> 的数据进行堆化，下标是 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点是叶子节点，不需要堆化。</p><p>对于完全二叉树来说，下标从 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.9.jpg" /></p><h3 id="排序">排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。它跟最后一个元素交换，那最大元素就放到了下标为 <span class="math inline">\(n\)</span> 的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，下标为 <span class="math inline">\(n\)</span> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <span class="math inline">\(n-1\)</span> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <span class="math inline">\(n-1\)</span> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <span class="math inline">\(1\)</span> 的一个元素，排序工作就完成了。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.10.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序要比堆排序性能好">快速排序要比堆排序性能好？</h2><ul><li>堆排序数据访问的方式没有快速排序友好</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.11.jpg" /></p><ul><li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</li></ul><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.12.jpg" /></p><h2 id="堆的应用">堆的应用</h2><ul><li>优先级队列<ul><li>依赖<ul><li>赫夫曼编码</li><li>图的最短路径</li><li>最小生成树算法</li></ul></li><li>具体<ul><li>合并有序小文件</li><li>高性能定时器</li></ul></li></ul></li><li>利用堆求 <code>Top K</code><ul><li><span class="math inline">\(n\)</span> 个数据的数组中，查找前 <span class="math inline">\(K\)</span> 大数据<ul><li>维护一个大小为 K 的小顶堆，顺序遍历数组</li></ul></li></ul></li><li>利用堆求中位数<ul><li>1 个大顶堆，1 个小顶堆</li><li>百分位数</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.13.jpg" /></p><p>删除堆顶数据和往堆中插入数据的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>，<span class="math inline">\(n\)</span> 表示堆中的数据个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.14.jpg" /></p><p>=======<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8<br />## 小结</p><p>堆是一种完全二叉树。</p><p>它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br />除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><p>堆的几个重要的应用，它们分别是：优先级队列、求Top K问题和求中位数问题。</p><h1 id="优先级队列是一种特殊的队列优先级高的数据先出队而不再像普通的队列那样先进先出实际上堆就可以看作优先级队列只是称谓不一样罢了求top-k问题又可以分为针对静态数据和针对动态数据只需要利用一个堆就可以做到非常高效率的查询top-k的数据求中位数实际上还有很多变形比如求99百分位数据90百分位数据等处理的思路都是一样的即利用两个堆一个大顶堆一个小顶堆随着数据的动态添加动态调整两个堆中的数据最后大顶堆的堆顶元素就是要求的数据">优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求Top K问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询Top K的数据。求中位数实际上还有很多变形，比如求99百分位数据、90百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</h1><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一个完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-2-树（Tree）</title>
    <link href="https://2020.iosdevlog.com/2020/04/06/tree/"/>
    <id>https://2020.iosdevlog.com/2020/04/06/tree/</id>
    <published>2020-04-06T04:10:33.000Z</published>
    <updated>2020-04-09T04:19:12.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><p>学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p>每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.2.jpg" /></p><p>A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.3.jpg" /></p><ol type="1"><li>高度（Height）</li><li>深度（Depth）</li><li>层（Level）</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.4.jpg" /></p><h2 id="二叉树binary-tree">二叉树（Binary Tree）</h2><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.5.jpg" /></p><p>两个子节点，分别是 <code>左子节点</code> 和 <code>右子节点</code>。</p><p>概念解释</p><ul><li><strong>节点</strong>：树中的每个元素称为节点</li><li><strong>父子关系</strong>：相邻两节点的连线，称为父子关系</li><li><strong>根节点</strong>：没有父节点的节点</li><li><strong>叶子节点</strong>：没有子节点的节点</li><li><strong>父节点</strong>：指向子节点的节点</li><li><strong>子节点</strong>：被父节点指向的节点</li><li><strong>兄弟节点</strong>：具有相同父节点的多个节点称为兄弟节点关系</li><li><strong>节点的高度</strong>：节点到叶子节点的最长路径所包含的边数</li><li><strong>节点的深度</strong>：根节点到节点的路径所包含的边数</li><li><strong>节点的层数</strong>：节点的深度+1（根节点的层数是1）</li><li><strong>树的高度</strong>：等于根节点的高度</li></ul><p>编号2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作 <strong>满二叉树</strong>。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.6.jpg" /></p><p>编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作 <strong>完全二叉树</strong>。</p><p>如何表示（或者存储）一棵二叉树？</p><ul><li>基于指针或者引用的 <code>链式存储法</code></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.7.jpg" /></p><ul><li>基于数组的 <code>顺序存储法</code><ul><li>根节点存储在下标 <code>i = 1</code> 的位置</li><li>那左子节点存储在下标 <code>2 * i</code> 的位置</li><li>右子节点存储在 <code>2 * i + 1</code> 的位置。</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.8.jpg" /></p><p><strong>堆其实就是一种完全二叉树，最常用的存储方式就是数组</strong></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.9.jpg" /></p><p>二叉树的遍历</p><ul><li>深度优先<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.10.jpg" /></p><p>递推公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>。</p><p>树是非线性表数据结构。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>，你需要理解并能用递归代码来实现。</p><h2 id="二叉查找树-二叉搜索树binary-search-tree">二叉查找树 / 二叉搜索树（Binary Search Tree）</h2><p>快速</p><ul><li>查找</li><li>插入</li><li>删除</li></ul><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.1.jpg" /></p><p>查找操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.2.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”。</p><p>快速地查找 <code>最大节点</code> 和 <code>最小节点</code>、<code>前驱节点</code> 和 <code>后继节点</code>。</p><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 <span class="math inline">\(O(n)\)</span>，非常高效。因此，二叉查找树也叫作 <strong>二叉排序树</strong>。</p><p>支持重复数据的二叉查找树</p><ol type="1"><li>对象中的其他字段叫作卫星数据。</li><li>对象的某个字段作为键值（key）来构建二叉查找树。<ol type="1"><li>链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</li><li>插入的数据放到这个节点的右子树。</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.7.jpg" /></p><p>时间复杂度分析</p><p>完全二叉树的高度小于等于 <span class="math inline">\(\log_{2} n\)</span></p><h3 id="散列表-vs-二叉查找树">散列表 vs 二叉查找树</h3><ol type="1"><li>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 <span class="math inline">\(O(1)\)</span>，非常高效。</li><li>叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)。</li></ol><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 <span class="math inline">\(O(n)\)</span> 的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 <span class="math inline">\(O(\log n)\)</span>。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 <span class="math inline">\(O(\log n)\)</span> 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><h3 id="二叉查找树小结">二叉查找树小结</h3><p>它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。</p><p>对于存在重复数据的二叉查找树，两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是O(n)和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，<code>平衡二叉查找树</code>，时间复杂度可以做到稳定的 <span class="math inline">\(O(logn)\)</span>。</p><h2 id="红黑树red-black-tree">红黑树（Red-Black Tree）</h2><p>平衡二叉查找树</p><ul><li>Splay Tree（伸展树）</li><li>Treap（树堆）</li><li>红黑树（简称 R-B Tree）</li></ul><blockquote><p>二叉树中任意一个节点的左右子树的高度相差不能大于1。</p></blockquote><p>从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.1.jpg" /></p><p>最先被发明的平衡二叉查找树是 <a href="https://zh.wikipedia.org/wiki/AVL树" target="_blank" rel="noopener">AVL树</a>。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。</p><ol type="1"><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.2.jpg" /></p><p>画图将黑色的、空的叶子节点都省略</p><blockquote><p>为什么说红黑树是“近似平衡”的？</p></blockquote><ul><li>“平衡”的意思可以等价为性能不退化。</li><li>“近似平衡”就等价为性能不会退化的太严重。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.3.jpg" /></p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。</p><p>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 <span class="math inline">\(\log_{2} n\)</span>，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。</p><h3 id="实现红黑树的基本思想">实现红黑树的基本思想</h3><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的 3、4 点恢复过来。</p><p>左旋（rotate left）：围绕某个节点的左旋<br />右旋（rotate right）：围绕某个节点的右旋</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.1.jpg" /></p><h4 id="插入操作的平衡调整">插入操作的平衡调整</h4><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</p><ul><li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li></ul><p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作 <strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的叔叔节点 d 是红色，我们就依次执行下面的操作：</p><ul><li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑ß色；</li><li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 <code>CASE 2</code> 或者 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.2.jpg" /></p><p><code>CASE 2</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：</p><ul><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点 b 左旋；</li><li>跳到 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.3.jpg" /></p><p><code>CASE 3</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：</p><p>围绕关注节点 a 的祖父节点 c 右旋；<br />将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。<br />调整结束。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.4.jpg" /></p><h4 id="删除操作的平衡调整">删除操作的平衡调整</h4><p>第一步：针对删除节点初步调整</p><p>初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</p><p><code>CASE 1</code>：如果要删除的节点是 a，它只有一个子节点 b</p><ul><li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li><li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li><li>调整结束，不需要进行二次调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.5.jpg" /></p><p><code>CASE 2</code>：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c 。我们就依次进行下面的操作：</p><ul><li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li><li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.6.jpg" /></p><p><code>CASE 3</code>：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点，我们就依次进行下面的操作：</p><ul><li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 <code>CASE 1</code>；</li><li>将节点 a 替换成后继节点 d ；</li><li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.7.jpg" /></p><p>第二步：针对关注节点进行二次调整</p><p>让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><p>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的兄弟节点 c 是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.8.jpg" /></p><p><code>CASE 2</code>：如果关注节点是a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d 、e都是黑色的，我们就依次进行下面的操作：</p><ul><li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红-黑”或者“黑-黑”；</li><li>关注节点从a变成其父节点 b ；</li><li>继续从四种情况中选择符合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.9.jpg" /></p><p><code>CASE 3</code>：如果关注节点是a，它的兄弟节点 c 是黑色，c的左子节点 d 是红色，c的右子节点e是黑色，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变；</li><li>跳转到 <code>CASE 4</code>，继续调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.10.jpg" /></p><p><code>CASE 4</code>：如果关注节点 a 的兄弟节点 c 是黑色的，并且c的右子节点是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li><li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li><li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>将关注节点 a 的叔叔节点e设置为黑色；</li><li>调整结束。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.11.jpg" /></p><blockquote><p>为什么要求叶子节点是黑色的空节点？</p></blockquote><p>为了实现起来方便。</p><p>假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.12.jpg" /></p><p>加上 “叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.13.jpg" /></p><p>会不会比较浪费存储空间呢？答案是不会的。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.14.jpg" /></p><h3 id="trie树-字典树">Trie树 / 字典树</h3><p>它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p><em>Trie树</em> 的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><p><code>how，hi，her，hello，so，see</code></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.1.jpg" /></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.2.jpg" /></p><p>构造过程的每一步，都相当于往Trie树中插入一个字符串。当所有字符串都插入完成之后，Trie树就构造好了。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.3.jpg" /></p><p>“her”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.4.jpg" /></p><p>“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.5.jpg" /></p><p>如何实现一棵 <em>Trie树</em>？</p><ol type="1"><li>将字符串集合构造成 <em>Trie树</em></li><li>在 <em>Trie树</em> 中查询一个字符串</li></ol><p><em>Trie树</em> 是一个多叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  BinaryTreeNode left;</span><br><span class="line">  BinaryTreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串中只有从 a 到 z 这26个小写字母</li><li>组中下标为 0 的位置，存储指向子节点 a 的指针</li><li>下标为 1 的位置存储指向子节点 b 的指针</li><li>某个字符的子节点不存在，对应的下标的位置存储 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在pattern</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 找到pattern</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建Trie树的过程，需要扫描所有的字符串，时间复杂度是O(n)（n表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是k，那我们只需要比对大约k个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好Trie树后，在其中查找字符串的时间复杂度是O(k)，k表示要查找的字符串的长度。</p><p>缩点优化</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.7.jpg" /></p><p>Trie树 与 散列表、红黑树 的比较</p><p>Trie树 比较适合的是查找前缀匹配的字符串</p><p>应用</p><ul><li>自动输入补全<ul><li>输入法自动补全功能</li><li>IDE代码编辑器自动补全功能</li><li>浏览器网址输入的自动补全功能</li></ul></li></ul><h3 id="内容小结">内容小结</h3><p>“红黑树一向都很难学”，有这种想法的人很多。其实主要原因是，很多人试图去记忆它的平衡调整策略。</p><ol type="1"><li><p>第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p></li><li><p>第二点，找准关注节点，不要搞丢、搞错关注节点。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p></li><li><p>第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p></li></ol><p>Trie树是一种解决字符串快速匹配问题的数据结构。如果用来构建Trie树的这一组字符串中，前缀重复的情况不是很多，那Trie树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p><p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 Trie树 中做字符串匹配还是非常高效的，时间复杂度是 <span class="math inline">\(O(k)\)</span>，k表示要匹配的字符串的长度。</p><p>但是，Trie树 的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie树 最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie树 比较经典的应用场景。</p><h2 id="高级">高级</h2><h2 id="实战">实战</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/126</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
</feed>
