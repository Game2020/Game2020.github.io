<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-04-03T16:24:14.306Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InfoQ 写作平台</title>
    <link href="https://2020.iosdevlog.com/2020/04/03/infoq/"/>
    <id>https://2020.iosdevlog.com/2020/04/03/infoq/</id>
    <published>2020-04-03T15:47:28.000Z</published>
    <updated>2020-04-03T16:24:14.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/1.png" /></p><a id="more"></a><p>前几天收到 InfoQ 的邮件。</p><p>您已通过审核。</p><p>感谢您的内测申请，很高兴邀请您加入 InfoQ 写作平台。<br />以下是关于入驻平台的相关信息，还请仔细阅读：<br />...<br />（具体操作路径及注意事项将在群中通知，请您务必添加小助手微信）</p><h2 id="infoq-是什么">InfoQ 是什么？</h2><p>去 Google 一下。</p><p><a href="www.infoq.com">www.infoq.com</a><br />InfoQ: Software Development News, Videos &amp; Books<br />Curated and peer-reviewed content covering innovation in professional software development, read by over 1 million developers worldwide.</p><p><a href="www.infoq.cn">www.infoq.cn</a><br />InfoQ - 促进软件开发领域知识与创新的传播-极客邦<br />InfoQ是一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。提供架构，云计算，AI，前端，大数据，Java，软件开发，编程等技术资讯及技术 ...</p><p>baike.baidu.com › item › InfoQ<br />InfoQ_百度百科<br />软件正在改变世界！InfoQ（Information Queue）是一个在线新闻/社区网站，旨在通过促进软件开发领域知识与创新的传播，为软件开发者提供帮助。...</p><h2 id="程序员评价">程序员评价</h2><p>知乎上有一个关于 InfoQ 的提问：<a href="https://www.zhihu.com/question/353239355/answer/883885600" target="_blank" rel="noopener">为什么InfoQ新加的话题模块没什么人讨论？</a></p><p>有且仅有一条回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">infoq 难道不是一个给</span><br><span class="line"></span><br><span class="line">产品经理</span><br><span class="line">不写代码的CTO</span><br><span class="line">大小会议上不断强调自己是“技术出身”的CEO</span><br><span class="line">...</span><br><span class="line">看的，并且在看完网站内容，回头就使用它来指导程序员做设计甚至开发的地方吗？</span><br><span class="line"></span><br><span class="line">那些人和程序员不同，他们不爱和同行讨论。</span><br></pre></td></tr></table></figure><p>——庄严《白话C++》作者</p><h2 id="群公告">群公告</h2><p>今天下午 3 点多终于开始加群了。</p><p>以下群公告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">哈喽，1号创作者们。</span><br><span class="line"></span><br><span class="line">为了方便平台内测信息的同步&amp;交流，请大家把群中备注改为【姓名 &#x2F; 笔名 - 行业领域】，谢谢配合！</span><br><span class="line"></span><br><span class="line">写作平台预计将于【清明假期后】正式向本群的创作者们开放，请大家提前备好【3 篇以上】文章作品，届时大家将首批体验 InfoQ 写作平台编辑器，并自行发布文章。如有任何疑问，可查看 InfoQ 写作平台为大家准备的：《给内容创作者的一封信》：&lt;https:&#x2F;&#x2F;shimo.im&#x2F;docs&#x2F;T9vxKx8qXd688RRX&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">当然，也可以随时艾特或私戳文字君哟~</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/infoq.png" /></p><h2 id="写作经历">写作经历</h2><p>之前在 <a href="https://www.csdn.net" target="_blank" rel="noopener">csdn</a>, <a href="http://www.chinaunix.net" target="_blank" rel="noopener">unixchina</a> 的技术论坛活动。</p><p>2014 年开始自己的博客：<a href="https://www.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://www.iosdevlog.com</a> jekyll。</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/iosdevlog.png" /></p><p>后来开通了 <strong>简书</strong>： <a href="https://www.jianshu.com/u/1577b98c62f4" target="_blank" rel="noopener">iOSDevLog</a>，掘金，知乎，微信公众号：iOSDevLog 和 AIDevLog。</p><p><span class="math inline">\(云^{+}\)</span> 社区是转 <strong>简书</strong> 的。</p><p>小武小久记录: <a href="https://1519.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://1519.iosdevlog.com</a> jekyll<br />游戏开发博客：<a href="https://game.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://game.iosdevlog.com</a> hexo+next<br />2019 年博客：<a href="https://2019.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://2019.iosdevlog.com</a> hexo+next<br />2020 年博客：<a href="https://2020.iosdevlog.com" class="uri">https://2020.iosdevlog.com</a> hexo</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/gamedevlog.png" /></p><p>其中简书参加过几个日更的活动，最近也不怎么在上面更新了。</p><p>最近只在 2020 年博客 和 微信公众号：<em>AI开发日志</em> 上更新。</p><p>现在要准备 InfoQ 上的文章，先写着，再去之前的文章里面找点能用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/03/infoq/1.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://2020.iosdevlog.com/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="infoq" scheme="https://2020.iosdevlog.com/tags/infoq/"/>
    
      <category term="geek" scheme="https://2020.iosdevlog.com/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>《程序员的数学基础课》</title>
    <link href="https://2020.iosdevlog.com/2020/04/02/math/"/>
    <id>https://2020.iosdevlog.com/2020/04/02/math/</id>
    <published>2020-04-02T09:19:25.000Z</published>
    <updated>2020-04-03T14:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg" /></p><blockquote><p>数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力</p></blockquote><p>——《程序员的数学基础课》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>如何学习新技术</p><ol type="1"><li>第一阶段：怎么使用</li><li>第二阶段：如何实现，原理是什么</li><li>第三阶段：为什么这样实现</li></ol><ul><li>明确需求</li><li>用多少学多少</li><li>理解数学的本质</li><li>数学思想与数学逻辑</li></ul><a id="more"></a><h2 id="基础思想">基础思想</h2><h3 id="二进制">二进制</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/1.jpg" /></p><h3 id="余数">余数</h3><p>余数总是在一个固定的范围内。</p><p>同余定理用来 <code>分类/均分</code> 的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/2.jpg" /></p><h3 id="迭代法">迭代法</h3><p>不断地用旧的变量值，递推计算新的变量值。</p><ul><li>求数值的精确或者近似解<ul><li>二分法(Bisection method)</li><li>牛顿迭代法 (Newton’s method)</li></ul></li><li>在一定范围内查找目标值<ul><li>二分查找</li></ul></li><li>机器学习算法中的迭代<ul><li>K- 均值算法(K-means clustering)</li><li>PageRank 的马尔科夫链(Markov chain)</li><li>梯度下降法(Gradient descent)</li></ul></li></ul><p>很多时候机器学习 的过程，就是根据已知的数据和一定的假设，求一个局部最优解</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/3.jpg" /></p><h3 id="数学归纳法">数学归纳法</h3><p>数学归纳法的一般步骤是这样的:</p><ol type="1"><li>证明基本情况(通常是 <span class="math inline">\(n = 1\)</span> 的时候)是否成立;</li><li>假设 <span class="math inline">\(n = k-1\)</span> 成立，再证明 <span class="math inline">\(n=k\)</span> 也是成立的( <span class="math inline">\(k\)</span> 为任意大于 <span class="math inline">\(1\)</span> 的自然数)。</li></ol><p>和使用迭代法的计算相比，数学归纳法 最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正 确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</p><p>递归调用的代码和数学归纳法的逻辑是一致的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/4.jpg" /></p><h3 id="递归">递归</h3><ol type="1"><li>初始状态，也就是 <span class="math inline">\(n=1\)</span> 的时候，命题是否成立;</li><li>如果 <span class="math inline">\(n=k-1\)</span> 的时候，命题成立。那么只要证明 <span class="math inline">\(n=k\)</span> 的时候，命题也成立。其中 <span class="math inline">\(k\)</span> 为大于 <span class="math inline">\(1\)</span> 的自然数。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.jpg" /></p><h3 id="排列">排列</h3><p>排列，一般地，从 <span class="math inline">\(n\)</span> 个不同元素中取出 <span class="math inline">\(m（m≤n）\)</span> 个元素，按照一定的顺序排成一列，叫做从 <span class="math inline">\(n\)</span> 个元素中取出 <span class="math inline">\(m\)</span> 个元素的一个排列(permutation)。特别地，当 <span class="math inline">\(m=n\)</span> 时，这个排列被称作全排列(all permutation)。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/7.jpg" /></p><h3 id="组合">组合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/8.jpg" /></p><h3 id="动态规划">动态规划</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/10.jpg" /></p><h3 id="树的深度优先搜索">树的深度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/12.jpg" /></p><h3 id="树的广度优先搜索">树的广度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/14.jpg" /></p><h3 id="从树到图">从树到图</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.jpg" /></p><h3 id="时间和空间复杂度">时间和空间复杂度</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/16.jpg" /></p><h2 id="概率统计">概率统计</h2><h3 id="概率和统计">概率和统计</h3><p>概率(Probability)</p><ul><li>随机变量(Random Variable)：事件所有可能出现的状态</li><li>概率分布 (Probability Distribution)：每个状态出现的可能性<ul><li>离散 型随机变量(Discrete Random Variable)</li><li>连续型随机变量(Continuous Random Variable)</li></ul></li></ul><p>对于离散型随机变量，通过联合概率 <span class="math inline">\(P(x, y)\)</span> 在 <span class="math inline">\(y\)</span> 上求和，就可以得到 <span class="math inline">\(P(x)\)</span>，这个 <span class="math inline">\(P(x)\)</span> 就 是边缘概率(Marginal Probability)</p><p>概率论研究的就是这些概率之间相互转化的关系，比如联合概率、条件概率和边缘概率。</p><ul><li>决策树(Decision Tree)<ul><li>信息熵(Entropy)/ 香农熵(Shannon Entropy)</li><li>信息增益(Information Gain)</li><li>基尼指数(Gini)</li></ul></li></ul><p>概率和统计 <code>互逆</code></p><ul><li>概率论是对数据产生的过程进行建模，然后研究某种模型所产生的数据有什么特性。</li><li>通过已知的数据，来推导产生这些数据的模型是怎样的。</li></ul><h3 id="概率基础">概率基础</h3><p>概率分布描述的其实就是随机变量的概率规律</p><p>参考：看见统计<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.1.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.3.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.4.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.6.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.png" /></p><h3 id="文本分类">文本分类</h3><p>文本分类系统的基本框架</p><ol type="1"><li>采集训练样本</li><li>预处理自然语言</li><li>训练模型</li><li>实时分类预测</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/23.png" /></p><p>基于自然语言的预处理</p><ol type="1"><li>分词<ol type="1"><li>基于字符串匹配</li><li>基于统计和机器学习<ol type="1"><li>隐马尔科夫模 型(HMM，Hidden Markov Model)</li><li>条件随机场(CRF，Conditional Random Field)</li></ol></li></ol></li><li>取词干和归一化</li><li>停用词</li><li>同义词和扩展词</li></ol><h3 id="语言模型">语言模型</h3><p>语言模型是什么?</p><ul><li>链式法则</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.2.png" /></p><ul><li>马尔科夫假设</li></ul><p>理解了链式法则，我们再来看看马尔可夫假设。</p><p>这个假设的内容是:</p><p>任何一个词 <span class="math inline">\(w_{i}\)</span> 出现的概率只和它前面的 <span class="math inline">\(1\)</span> 个或若干个词有关。</p><p>基于这个假设，我们可以提出 <code>多元文法 (Ngram)模型</code>。Ngram 中的“N”很重要，它表示任何一个词出现的概率，只和它前 面的 <span class="math inline">\(N-1\)</span> 个词有关。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.6.png" /></p><p>语言模型的应用</p><ol type="1"><li>信息检索</li><li>中文分词</li></ol><p>第一，使用联合概率，条件概率和边缘概率的“三角”关系，进行相互推导。链式法则就 是很好的体现。</p><p>第二，使用马尔科夫假设，把受较多随机变量影响的条件概率，简化为受较少随机变量影 响的条件概率，甚至是边缘概率。</p><p>第三，使用贝叶斯定理，通过先验概率推导后验概率。在信息检索中，给定查询的情况下 推导文档的概率，就需要用到这个定理。</p><h3 id="马尔科夫模型">马尔科夫模型</h3><p>假设：每个词出现的概率和 之前的一个或若干个词有关。</p><p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状 态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假 设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是 <code>马尔科夫模型(Markov Model)</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.5.jpg" /></p><p>PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.6.png" /></p><p>隐马尔科夫模型</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.10.jpg" /></p><h3 id="信息熵">信息熵</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.1.jpg" /></p><ul><li>信息量：信息论中的一个度量<ul><li>信息量应该为正数;</li><li>一个事件的信息量和它发生的概率成反比;</li></ul></li><li>信息熵(Entropy)：集合的 纯净度的一个指标<ol type="1"><li>一个集合里的元素全部是属于同一个分组，这个时候就表示最纯净，我们就说熵为 0;</li><li>如果这个集合里的元素是来自不同的分组，那么熵是大于 0 的值。其具体的计算公式 如下:</li></ol></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.2.png" /></p><p>一个集合中所包含的分组越多、元素在这些分组里分布 得越均匀，熵值也越大。</p><p>而熵值表示了纯净的程度，或者从相反的角度来说，是混乱的程 度。</p><p>信息量期望</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.3.png" /></p><p>对于多个小集合而言，其整体的熵等于各个小集合之熵的加权平均。</p><ul><li>信息增益(Information Gain)：划分后整体熵的下降</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.5.png" /></p><h3 id="决策树">决策树</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.1.png" /></p><ol type="1"><li>第一步，根据集合中的样本分类，为每个集合计算信息熵，并通过全部集合的熵之加权平 均，获得整个数据集的熵。注意，一开始集合只有一个，并且包含了所有的样本。</li><li>第二步，根据信息增益，计算每个特征的区分能力。挑选区分能力最强的特征，并对每个 集合进行更细的划分。</li><li>第三步，有了新的划分之后，回到第一步，重复第一步和第二步，直到没有更多的特征， 或者所有的样本都已经被分好类。</li></ol><ul><li>ID3(Iterative Dichotomiser 3，迭代二叉树 3 代)<ul><li>信息增益</li><li>优先考虑具有较多取值的特征</li></ul></li><li>C4.5 算法<ul><li>信息增益率(Information Gain Ratio)</li><li>分裂信息(Split Information)</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.4.png" /></p><ul><li>CART 算法(Classification and Regression Trees，分类与回归 树)<ul><li>基尼指数(Gini)</li><li>二叉树</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/27.6.png" /></p><ul><li>优化<ul><li>剪枝<ul><li>预剪枝</li><li>后剪枝</li></ul></li><li>随机森林</li></ul></li></ul><h3 id="熵信息增益和卡方">熵、信息增益和卡方</h3><p>利用卡方检验进行特征选择</p><p>如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。</p><h3 id="归一化和标准化">归一化和标准化</h3><p>为什么需要特征变换?</p><ul><li>线性回归模型：因变量和自变量为线性关系</li><li>非线性回归分析模型：因变量和自变量为非线性关系</li></ul><p>多元线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.1.png" /></p><p>两种常见的特征变换方法</p><ul><li>归一化(Normalization)。</li></ul><p>它其实就是获取原始数据的最大值和最小值，然后把原始值线性变换到 [0,1] 之间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.2.png" /></p><ul><li>标准化</li></ul><p>基于正态分布的 z 分数(z-score)标准化(Standardization)。</p><p>该方法假设数据呈现标准正态分布。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.3.png" /></p><p><span class="math display">\[x^{\prime}=\frac{(x-\mu)}{\sigma}\]</span></p><p>其中 <span class="math inline">\(x\)</span> 为原始值，<span class="math inline">\(\mu\)</span> 为均值，<span class="math inline">\(\sigma\)</span> 为标准差，<span class="math inline">\(x^{\prime}\)</span> 是变换后的值。</p><h3 id="统计意义">统计意义</h3><p>A/B 测试</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/30.png" /></p><p>显著性差异(Significant Difference)</p><ol type="1"><li>第一，两个分布之间的差异。<ul><li>“有显著性差异”</li></ul></li><li>第二，采样引起的差异。<ul><li>“无显著性差异”</li></ul></li></ol><p>“具有显著性差异”，称为“差异具有统计意义”或者“差异具有显著性”</p><p>统计假设检验和显著性检验</p><p>统计假设检验是指事先对随机变量的参数或总体分布做出一个假设，然后利用样本信息来 判断这个假设是否合理。</p><p>在统计学上，我们称这种假设为虚无假设(Null Hypothesis)，也叫原假设或零假设，通常记作 <code>H0</code>。</p><p>而和虚无假设对立的假设，我们称为对立假设(Alternative Hypothesis)，通常记作 <code>H1</code>。也就是说，如果证明虚无假设不成立，那么就可以推出对立假设成立。</p><p>通常我们把概率不超 过 0.05 的事件称为“小概率事件”</p><p>P 值(P-value)</p><p>P 值中的 P 代表 Probability，就是当 H0 假 设为真时，样本出现的概率，或者换句话说，其实就是我们所观测到的样本数据符合原假 设 H0 的可能性有多大。</p><p>方差分析</p><p>方差分析(Analysis of Variance, ANOVA)，也叫 <strong>F检验</strong>。</p><ul><li>随机性：样本是随机采样的;</li><li>独立性：来自不同组的样本是相互独立的;</li><li>正态分布性：组内样本都来自一个正态分布;</li><li>方差齐性：不同组的方差相等或相近。</li></ul><p>自由度(degree of freedom)，英文缩写是 df，它是指采样中能够自由变化的数据个 数。</p><h3 id="拟合">拟合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/32.png" /></p><ul><li><strong>欠拟合问题</strong> 产生的主要原因 是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大。</li><li><strong>过拟合问题</strong> 产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符 合训练样本，但是无法适应测试样本或者说新的数据。</li></ul><p>交叉验证(Cross Validation)的划分方式来保持训练数 据和测试数据的一致性。</p><h2 id="线性代数">线性代数</h2><h3 id="线性代数-1">线性代数</h3><p>向量和向量空间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.1.png" /></p><p>向量的每个元素就代表 一维特征，而元素的值代表了相应特征的值，我们称这类向量为 <strong>特征向量(Feature Vector)</strong>。</p><p><strong>矩阵的特征向量(Eigenvector)</strong></p><p>向量的运算</p><ul><li>加法</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/33.3.png" /></p><ul><li>乘法(或点乘)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.4.png" /></p><ul><li>距离</li><li>夹角</li></ul><p>矩阵的运算</p><p>矩阵由多个长度相等的向量组成，其中的每列或者每行就是一个向量。</p><p>因此，我们把向量延伸一下就能得到矩阵(Matrix)。</p><p>矩阵乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.6.png" /></p><p>两个矩阵中对应元素进行相乘，称它为 <strong>元素对应乘积</strong>，或者 <strong>Hadamard 乘积</strong></p><p>转置(Transposition)是指矩阵内的元素行索引和纵索引互换</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.7.png" /></p><p>单位矩阵(Identity Matrix)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.8.png" /></p><p>矩阵逆(Matrix Inversion)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.9.png" /></p><h3 id="向量空间模型">向量空间模型</h3><p>向量之间的距离</p><ul><li>曼哈顿距离(Manhattan Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.3.png" /></p><ul><li>欧氏距离(Euclidean Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.5.png" /></p><ul><li>切比雪夫距离(Chebyshev Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.6.png" /></p><p>向量的长度</p><ul><li><span class="math inline">\(L_{1}\)</span> 范数 <span class="math inline">\(\|x\|\)</span> ，它是为 <span class="math inline">\(x\)</span> 向量各个元素绝对值之和，对应于向量和原点之间的曼哈顿距离。<br /><span class="math inline">\(L_{2}\)</span> 范数 <span class="math inline">\(\|x\|_2\)</span> ，它是向量 <span class="math inline">\(x\)</span> 各个元素平方和的 <span class="math inline">\(\frac{1}{2}\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的欧氏距离。<br /><span class="math inline">\(L_{p}\)</span> 范数 <span class="math inline">\(\|x\|_p\)</span> ，为向量各个元素绝对值 <span class="math inline">\(p\)</span> 次方和的 <span class="math inline">\(1/p\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的闵氏距离。<br /><span class="math inline">\(L_{\infty}\)</span> 范数 <span class="math inline">\(\|x\|_{\infty}\)</span>，为 <span class="math inline">\(x\)</span> 向量各个元素绝对值最大那个元素的绝对值，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的切比雪夫距离。</li></ul><p>所以，在讨论向量的长度时，我们需要弄清楚是 <code>L几范数</code>。</p><p>向量之间的夹角</p><p><span class="math display">\[\operatorname{cosine}(X, Y)=\frac{\sum_{i=1}^{n}\left(x_{i} \times y_{i}\right)}{\sqrt{\sum_{i=1}^{n} x_{i}^{2} \times \sum_{i=1}^{n} y_{i}^{2}}}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.7.png" /></p><p>向量空间模型(Vector Space Model)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.8.png" /></p><h3 id="文本检索">文本检索</h3><p>信息检索就是让计算机根据用户信息需求，从大规模、非结构化的数据中，找 出相关的资料。</p><p>信息检索中的向量空间模型</p><ol type="1"><li>第一步，把文档集合都转换成向量的形式。</li><li>第二步，把用户输入的查询转换成向量的形式，然后把这个查询的向量和所有文档的向 量，进行比对，计算出基于距离或者夹角余弦的相似度。</li><li>第三步，根据查询和每个文档的相似度，找出相似度最高的文档，认为它们是和指定查询 最相关的。</li><li>第四步，评估查询结果的相关性。</li></ol><h3 id="文本聚类">文本聚类</h3><p>聚类算法</p><p>K 均值(K-Means)聚类算法</p><p>尽量最大化总的 群组内相似度，同时尽量最小化群组之间的相似度。</p><ol type="1"><li>从 N 个数据对象中随机选取 k 个对象作为质心，这里每个群组的质心定义是，群组内 所有成员对象的平均值。因为是第一轮，所以第 i 个群组的质心就是第 i 个对象，而且 这时候我们只有这一个组员。</li><li>对剩余的对象，测量它和每个质心的相似度，并把它归到最近的质心所属的群组。这里 我们可以说距离，也可以说相似度，只是两者呈现反比关系。</li><li>重新计算已经得到的各个群组的质心。这里质心的计算是关键，如果使用特征向量来表 示的数据对象，那么最基本的方法是取群组内成员的特征向量，将它们的平均值作为质心的向量表示。</li><li>迭代上面的第 2 步和第 3 步，直至新的质心与原质心相等或相差之值小于指定阈值，算法结束。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/36.png" /></p><h3 id="矩阵">矩阵</h3><p>PageRank 链接分析算法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.1.png" /></p><p>简化 PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.2.png" /></p><p>矩阵点乘</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.3.png" /></p><p>拓扑图</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.4.png" /></p><p>原始矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.5.png" /></p><p>归一化</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.6.png" /></p><p>初始值都设为 1</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.7.png" /></p><p>考虑随机跳转</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.9.png" /></p><p>用矩阵实现推荐系统的核心思想</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.1.png" /></p><p>基于用户的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.2.png" /></p><p>基于物品的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.3.png" /></p><h3 id="线性回归">线性回归</h3><p><span class="math display">\[\begin{aligned}&amp;2 x_{1}+x_{2}+x_{3}=0\\&amp;4 x_{1}+2 x_{2}+x_{3}=56\\&amp;2 x_{1}-x_{2}+4 x_{3}=4\end{aligned}\]</span></p><h4 id="高斯消元法">高斯消元法</h4><p>使用矩阵实现高斯消元法</p><p>系数矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.1.png" /></p><p>消元</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.2.png" /></p><p>系数</p><p><span class="math display">\[\begin{array}{l}1 \cdot x_{1}+0 \cdot x_{2}+0 \cdot x_{3}=71 \\0 \cdot x_{1}+1 \cdot x_{2}+0 \cdot x_{3}=-86 \\0 \cdot x_{1}+0 \cdot x_{2}+1 \cdot x_{3}=-56\end{array}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.3.png" /></p><p>增广矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.4.png" /></p><p>线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.1.png" /></p><p>最小二乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.2.png" /></p><h3 id="pca主成分分析principal-component-analysis">PCA主成分分析(Principal Component Analysis)</h3><ol type="1"><li><p>标准化样本矩阵中的原始数据;</p></li><li><p>获取标准化数据的协方差矩阵;</p></li><li><p>计算协方差矩阵的特征值和特征向量;</p></li><li><p>依照特征值的大小，挑选主要的特征向量; 5. 生成新的特征。</p></li><li><p>标准化原始数据</p></li></ol><p><span class="math display">\[x^{\prime}=\frac{x-\mu}{\sigma}\]</span></p><ol start="2" type="1"><li>获取协方差矩阵</li></ol><ul><li>协方差(Covariance)：衡量两个变 量的总体误差</li></ul><p><span class="math display">\[\operatorname{cov}(x, y)=\frac{\sum_{k=1}^{m}\left(x_{k}-\bar{x}\right)\left(y_{k}-\bar{y}\right)}{m-1}\]</span></p><ul><li>协方差矩阵</li></ul><p><span class="math display">\[\operatorname{cov}\left(X_{, i}, X_{, j}\right)=\frac{\sum_{k=1}^{m}\left(x_{k, i}-\bar{X}_{, i}\right)\left(x_{k, j}-\bar{X}_{, j}\right)}{m-1}\]</span></p><p><span class="math display">\[C O V=\left[\begin{array}{ccccc}\operatorname{cov}\left(X_{1}, X_{1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{1}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{n}\right) \\\operatorname{cov}\left(X_{2}, X_{1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{2}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{n}\right) \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\\operatorname{cov}\left(X_{n}, X_{1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{n}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{n}\right)\end{array}\right]\]</span></p><ol start="3" type="1"><li>计算协方差矩阵的特征值和特征向量</li></ol><p><span class="math display">\[X v=\lambda v\]</span></p><p>特征 值的推导过程</p><p><span class="math display">\[\begin{aligned}&amp;X v=\lambda v\\&amp;X v-\lambda v=0\\&amp;X v-\lambda I v=0\\&amp;(X-\lambda I) v=0\end{aligned}\]</span></p><p>矩阵的行列式</p><p><span class="math display">\[|(X-\lambda I)|=\left| \left[ \begin{array}{cccccc}x_{1,1}-\lambda &amp; x_{1,2} &amp; x_{1,3} &amp; \cdots &amp; x_{1, n-1} &amp; x_{1, n} \\x_{2,1} &amp; x_{2,2}-\lambda &amp; x_{2,3} &amp; \cdots &amp; x_{2, n-1} &amp; x_{2, n} \\x_{3,1} &amp; x_{3,2} &amp; x_{3,3}-\lambda &amp; \cdots &amp; x_{3, n-1} &amp; x_{3, n} \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\x_{n-1,1} &amp; x_{n-1,2} &amp; x_{n-1,3} &amp; \cdots &amp; x_{n-1, n-1}-\lambda &amp; x_{n-1, n} \\x_{n, 1} &amp; x_{n, 2} &amp; x_{n, 3} &amp; \cdots &amp; x_{n, n-1} &amp; x_{n, n}-\lambda\end{array}\right] \right| =0\]</span></p><p><span class="math display">\[(\lambda I-X)\left[\begin{array}{l}x_{1} \\x_{2} \\\dots \\x_{n}\end{array}\right]\]</span></p><ol start="4" type="1"><li>挑选主要的特征向量，转换原始数据</li></ol><h3 id="svd-奇异值分解singular-value-decomposition">SVD 奇异值分解(Singular Value Decomposition)</h3><p>方阵的特征分解</p><p><code>方阵(Square Matrix)</code> 是一种特殊的矩阵，它的行数和列数相等。如果一个矩阵的行数和列数 都是 n，那么我们把它称作 n 阶方阵。</p><p>如果一个矩阵和其转置矩阵相乘得到的是单位矩阵，那么它就是一个 <code>酉矩阵(Unitary Matrix)</code>。</p><p><span class="math display">\[X^{\prime} X=I\]</span></p><p>其中 X’表示 X 的转置，I 表示单位矩阵。</p><p>换句话说，矩阵 X 为酉矩阵的充分必要条件是 X 的转 置矩阵和 X 的逆矩阵相等。</p><p><span class="math display">\[X^{\prime}=X^{-1}\]</span></p><p>特征分解(Eigendecomposition)</p><p><span class="math display">\[\begin{aligned}&amp;X V V^{-1}=V \Sigma V^{-1}\\&amp;X I=V \Sigma V^{-1}\\&amp;X=V \Sigma V^{-1}\end{aligned}\]</span></p><p>主要考量因素</p><ol type="1"><li>硬件的性能</li><li>命中率</li><li>更新周期</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.2.png" /></p><h3 id="搜索引擎">搜索引擎</h3><p>搜索引擎的设计框架</p><ul><li>离线的预处理</li><li>在线的查询</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.1.png" /></p><p>倒排索引的设计</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.3.png" /></p><p>向量空间和倒排索引的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.4.png" /></p><p>查询分类和搜索引擎的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/48.png" /></p><h3 id="推荐系统">推荐系统</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/51.jpg" /></p><h2 id="程序员需要读哪些数学书">程序员需要读哪些数学书？</h2><p>基础思想篇推荐书籍:《离散数学及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_1.jpg" /></p><p>概率统计篇推荐书籍:《概率统计》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_2.png" /></p><p>线性代数篇推荐书籍:《线性代数及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_3.png" /></p><p>入门、通识类书籍推荐：《程序员的数学》</p><p>《程序员的数学》<br />《程序员的数 学:概率统计》<br />《程序员的数学:线性代数》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_4.png" /></p><p>计算机领域:《数学之美》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_5.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/235" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/235</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://2020.iosdevlog.com/2020/03/11/seeing-theory/" class="uri">https://2020.iosdevlog.com/2020/03/11/seeing-theory/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——《程序员的数学基础课》&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何学习新技术&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;第一阶段：怎么使用&lt;/li&gt;
&lt;li&gt;第二阶段：如何实现，原理是什么&lt;/li&gt;
&lt;li&gt;第三阶段：为什么这样实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;明确需求&lt;/li&gt;
&lt;li&gt;用多少学多少&lt;/li&gt;
&lt;li&gt;理解数学的本质&lt;/li&gt;
&lt;li&gt;数学思想与数学逻辑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="basic" scheme="https://2020.iosdevlog.com/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>理解机器学习的24本书（免费）</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/ml/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/ml/</id>
    <published>2020-04-01T14:53:31.000Z</published>
    <updated>2020-04-01T15:22:09.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/ml/1.jpg" /></p><a id="more"></a><blockquote><p><em>我们想要的是一台能从经验中学习的机器</em></p></blockquote><p>——艾伦·图灵</p><p>毫无疑问，机器学习已成为当今最受欢迎的主题之一。根据一项<a href="http://blog.indeed.com/2019/03/14/best-jobs-2019/" target="_blank" rel="noopener">研究</a>，机器学习工程师被评为 2019年 美国最佳工作之一。</p><p>展望这一趋势，我们整理了一些最佳（免费）机器学习书籍的清单，这些书籍将证明对有志于在该领域发展职业的每个人都有帮助。</p><h2 id="islr">1. <a href="http://faculty.marshall.usc.edu/gareth-james/ISL/" target="_blank" rel="noopener">ISLR</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/2.jpg" /></p><p>机器学习理论的最佳入门书。甚至付费书籍也不比它好。很好地介绍了数学知识，并在 <code>R</code> 中有练习材料。</p><h2 id="神经网络与深度学习">2. <strong><a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">神经网络与深度学习</a></strong></h2><p>这本免费的在线书是其中最好的和最快的关于深度学习的介绍。阅读只需几天，即可为您提供有关深度学习的所有基础知识。</p><h2 id="模式识别与机器学习">3. <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">模式识别与机器学习</a></h2><p>它是最著名的理论性机器学习书籍之一，因此无需撰写过多的介绍。</p><h2 id="深度学习花书">4. <strong><a href="https://www.deeplearningbook.org/" target="_blank" rel="noopener">深度学习/花书</a></strong></h2><p>这本书是《深度学习》的圣经，是对深度学习算法和方法的介绍，对初学者和从业者都非常有用。</p><h2 id="了解机器学习从理论到算法">5. <a href="https://www.cse.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf" target="_blank" rel="noopener">了解机器学习：从理论<strong>到算法</strong></a></h2><p>关于机器学习理论的文章确实很棒。</p><h2 id="成功的七个步骤实践中的机器学习">6. <strong><a href="https://daoudclarke.github.io/guide.pdf" target="_blank" rel="noopener">成功的七个步骤：实践中的机器学习</a></strong></h2><p>进入该领域的非技术产品经理和非机器学习软件工程师都不应错过本教程。写得很好（略旧，不涉及深度学习，但可以用于所有实际目的）。</p><h2 id="机器学习规则机器学习工程的最佳实践">7. <strong><a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf" target="_blank" rel="noopener">机器学习规则：机器学习工程的最佳实践</a></strong></h2><p>想知道 <code>Google</code> 如何看待其机器学习产品吗？这是一个非常好的机器学习产品管理教程。</p><h2 id="面向工程师的机器学习简介">8. <strong><a href="https://arxiv.org/abs/1709.02840" target="_blank" rel="noopener">面向工程师的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="无需深度学习的机器学习简介">9. <strong><a href="https://docs.google.com/document/d/1Rp6sf129T0j1isIQByyUeby4fwKgwTyiVleNwX7JGmg/edit" target="_blank" rel="noopener">无需深度学习的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="机器学习入门笔记">10. <strong><a href="http://lcsl.mit.edu/courses/ml/1718/MLNotes.pdf" target="_blank" rel="noopener">机器学习入门笔记</a></strong></h2><p>面向绝对初学者的机器学习指南。</p><h2 id="机器学习基础">11. <strong><a href="https://cs.nyu.edu/~mohri/mlbook/" target="_blank" rel="noopener">机器学习基础</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/3.jpg" /></p><p>关于机器学习数学概念的详细论述。</p><h2 id="变量和特征选择简介">12. <strong><a href="https://dl.acm.org/doi/10.5555/944919.944968" target="_blank" rel="noopener">变量和特征选择简介</a></strong></h2><p>特征工程和变量选择可能是传统机器学习算法中最重要的人工输入。（在深度学习方法中不那么重要，但是深度学习并不能解决所有问题）。本教程介绍了不同的要素工程方法。</p><h2 id="automl-frank-hutterlars-kotthoffjoaquin-vanschoren">13. <strong><a href="https://www.automl.org/book/" target="_blank" rel="noopener">AutoML– Frank Hutter，Lars Kotthoff，Joaquin Vanschoren</a></strong></h2><p>在完成功能工程后，近来的传统机器学习实际上已经减少到运行 <code>AutoML</code> 模型（h2o，auto sklearn或tpot，这是ParallelDots的最爱）。（实际上，也有几种方法可以进行自动化的非特定于域的自动要素工程）。本书介绍了AutoML中使用的方法。</p><h2 id="用pytorch进行深度学习">14. <strong><a href="https://pytorch.org/deep-learning-with-pytorch" target="_blank" rel="noopener">用Pytorch进行深度学习</a></strong></h2><p>一本免费的书，可帮助您使用 <code>PyTorch</code> 学习深度学习。<code>PyTorch</code> 是ParallelDots 上我们最喜欢的深度学习库，我们建议所有人进行深度学习的应用研究/开发。</p><h2 id="深度学习">15. <strong><a href="http://d2l.ai/" target="_blank" rel="noopener">深度学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/4.png" /></p><p>另一本有关深度学习的详细书，该书使用亚马逊的 <code>MXN​​et</code> 库教授深度学习。</p><h2 id="kerasbook-github-笔记本">16. <strong><a href="https://github.com/fchollet/deep-learning-with-python-notebooks" target="_blank" rel="noopener">Kerasbook Github 笔记本</a></strong></h2><p>Francois Chollet 是 <code>Keras</code> 库的负责人。他撰写的《用Python进行深度学习》一书在Keras教授《深度学习》，获得了很好的评价。这本书 <strong>不是</strong> 免费提供的，但是它的所有代码都可以在 <code>Github</code> 上以笔记本的形式获得（用深度学习示例构成一本书），并且是很好的资源。几年前我在学习 <code>Keras</code> 时就读了它，这是非常好的资源。</p><h2 id="基于模型的机器学习">17. <strong><a href="http://mbmlbook.com/" target="_blank" rel="noopener">基于模型的机器学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/5.png" /></p><p>贝叶斯机器学习的绝佳资源。使用 <code>Microsoft</code> 的 <code>Infer.Net</code> 库进行教学，因此您可能必须安装 <code>IronPython</code> 才能阅读/实现本书的示例。</p><h2 id="机器学习的贝叶斯模型">18. <strong><a href="http://www.columbia.edu/~jwp2128/Teaching/E6720/BayesianModelsMachineLearning2016.pdf" target="_blank" rel="noopener">机器学习的贝叶斯模型</a></strong></h2><p>另一本书详细介绍了机器学习中的各种贝叶斯方法。</p><h2 id="爱森斯坦自然语言处理笔记">19. <strong><a href="https://github.com/jacobeisenstein/gt-nlp-class/blob/master/notes/eisenstein-nlp-notes.pdf" target="_blank" rel="noopener">爱森斯坦自然语言处理笔记</a></strong></h2><p>自然语言处理是机器学习中最流行的用途。GATech课程中的这些注释很好地概述了如何使用机器学习来解释人类语言。</p><h2 id="强化学习-sutton和barto">20. <strong><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">强化学习– Sutton和Barto</a></strong></h2><p>强化学习的圣经。这是进入强化学习领域的任何人都必须阅读的。</p><h2 id="机器学习的高斯过程">21. <a href="http://www.gaussianprocess.org/gpml/" target="_blank" rel="noopener">机器学习的高斯过程</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/6.gif" /></p><p>使用贝叶斯优化和高斯过程进行机器学习。借助基于变分推理的库（例如Edward / GpyTorch / BOTorch等），此方法正在卷土重来。</p><h2 id="机器学习访谈机器学习系统设计chip-huyen">22. <strong><a href="https://github.com/chiphuyen/machine-learning-systems-design" target="_blank" rel="noopener">机器学习访谈机器学习系统设计Chip Huyen</a></strong></h2><p>要参加机器学习工作的面试吗？这些问题可能有助于在回答机器学习系统问题时找出策略。</p><h2 id="机器学习的算法方面">23. <strong><a href="https://people.csail.mit.edu/moitra/docs/bookex.pdf" target="_blank" rel="noopener">机器学习的算法方面</a></strong></h2><p>本书涉及机器学习的各个部分，其中涉及计算算法和数值方法，以解决诸如分解模型，字典学习和高斯模型之类的问题。</p><h2 id="机器学习的因果关系">24. <strong><a href="https://arxiv.org/abs/1911.10500" target="_blank" rel="noopener">机器学习的因果关系</a></strong></h2><p>随着因果关系进入数据科学领域，机器学习也摆脱了讨论。尽管没有详细的资料可解决，但是这里是一个简短的教程，试图解释机器学习因果关系的关键概念。</p><p>原文：<a href="https://blog.paralleldots.com/data-science/24-best-and-free-books-to-understand-machine-learning/" target="_blank" rel="noopener">24 Best (and Free) Books To Understand Machine Learning</a></p><p>作者：<a href="https://blog.paralleldots.com/author/reashikaa/" target="_blank" rel="noopener">Reashikaa Verma</a></p><p>时间：2020/03/12</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/ml/1.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ml" scheme="https://2020.iosdevlog.com/tags/ml/"/>
    
      <category term="book" scheme="https://2020.iosdevlog.com/tags/book/"/>
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>《艰难的制造》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/9787550298637/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/9787550298637/</id>
    <published>2020-04-01T08:28:03.000Z</published>
    <updated>2020-04-01T08:43:01.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg" /></p><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />副标题: 讲述制造业在政策和市场夹缝中的生存故事<br />出版年: 2017-6<br />页数: 672<br />定价: 69.90<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550298637</p><a id="more"></a><h2 id="内容简介">内容简介</h2><p>宁炒一座楼，不办一家厂，开厂为啥干不过炒房，做实业的为啥干不过搞金融的？作为立国之本、创造财富的制造业发生了什么？市场的大手，政策的大手，究竟在其中起到什么样的作用？</p><p>小说以一家中小型机械制造厂切入，以手术解剖的方式娓娓道来秉持实业理想的柳钧和从事金融的好友钱宏明的典型遭遇。无论是山寨模仿、技术剽窃、恶意抢单、黑社会威胁、税务查账、环保穿小鞋还是信用证诈骗、房地产投机、民间高利贷、非法集资，从起步到发展过程中大到政策，小到员工管理的九九八十一难一一为你呈现。</p><p>本书作者阿耐曾为浙江某著名民营制造业高管，几十年经营管理经验，写出来的都是“实打实的真材实料”。自连载以来，引发珠三角、长三角众多制造业老板及金融从业者的广泛共鸣。</p><h2 id="结局对比">结局对比</h2><p>最后一章里面，这一（2008）年，<strong>柳钧</strong> 失去最好的朋友，却还晦气得在年底前出国洽商的时候撞见宿仇 <strong>杨巡</strong>。</p><p><strong>柳钧</strong> 以为 <strong>杨巡</strong> 要逃，杨巡说：</p><blockquote><p>"人在青山在，只要公司不倒，所有债务都只是账面数字，哪家公司不是负债运行的。"</p></blockquote><p><strong>杨巡</strong> 的世界只有利益相关，<strong>柳钧</strong> 和 <strong>宋运辉</strong> 观点：</p><blockquote><p>“创造力无价。”</p></blockquote><blockquote><p>“你该不会还以为我送了宋总和梁姐很多好处？”两人对视，柳钧从杨巡眼里看出一丝恍惚。“或许，你的世界只有利益相关，但我们的世界里有一些傻傻的东西，比如你近来才意识到知识无价，因为这个社会发展到现阶段，人力成本上升趋势已不可逆转，无论国内外的市场竞争都将越来越靠科研技术。只是眼下的大环境并不支持这种脚踏实地的竞争方式，有很多傻傻的人内心很焦虑，很着急，很想尽一己之力稍微改变一下这样的结构问题。我们都在努力，我非常感谢宋总支持我的努力。他是个很有精神感召力的人。</p></blockquote><p>——第106章 2008年新劳动合同法和新政策带来的负担(14) / 最后一章</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;作者: 阿耐&lt;br /&gt;
出版社: 北京联合出版公司&lt;br /&gt;
副标题: 讲述制造业在政策和市场夹缝中的生存故事&lt;br /&gt;
出版年: 2017-6&lt;br /&gt;
页数: 672&lt;br /&gt;
定价: 69.90&lt;br /&gt;
装帧: 平装&lt;br /&gt;
丛书: 读客·知识小说文库&lt;br /&gt;
ISBN: 9787550298637&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="改革" scheme="https://2020.iosdevlog.com/tags/%E6%94%B9%E9%9D%A9/"/>
    
      <category term="大江大河" scheme="https://2020.iosdevlog.com/tags/%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
  </entry>
  
  <entry>
    <title>《大江东去》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/03/31/9787550230552/"/>
    <id>https://2020.iosdevlog.com/2020/03/31/9787550230552/</id>
    <published>2020-03-31T05:50:41.000Z</published>
    <updated>2020-04-01T09:14:51.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg" /></p><a id="more"></a><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />出品方: 读客文化<br />副标题: 经典收藏版全三册<br />出版年: 2014-7-15<br />页数: 1992<br />定价: 168.00<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550230552</p><h2 id="内容简介">内容简介</h2><p>《大江东去》是著名财经作家阿耐创作的一部全景表现改革开放30年来中国经济和社会生活变迁历史的长篇小说。</p><p>小说以经济改革为主线，全面、细致、深入地表现了1978年以来中国改革开放30年的伟大历史进程。展现了中国改革开放30年来经济领域的改革、社会生活的变化、政治领域的变革 以及人们精神面貌的变化等方方面面；生动而真实地刻画了活跃在改革开放前沿的代表人物，如国营企业的领导、农民企业家、个体户、政府官员、海归派、知识分子等等。人物典型深刻，故事跌宕磅礴。</p><p>从表现历史的深度和广度上来说，在表现中国改革开放历史进程这一题材里，这部作品具有很重的分量和特殊意义，被誉为“描写改革开放30年的第一小说”，荣获中宣部“五个一工程奖”。</p><h2 id="宋运辉">宋运辉</h2><blockquote><p>出国考察和谈判，出差的地方与美国隔个太平洋。开颜一直担心 去见你（宋运辉）那个女学生（梁思申）。</p></blockquote><blockquote><p>宋运辉厌恶地再看一眼他的内裤，调头离开。从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p><p>从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p></blockquote><p>——第143章 1992年(7)</p><blockquote><p>宋运辉愣愣地看着好友，却道：“冰冻三尺非一日之寒，原来我一直看不起她。”</p><p>宋运辉摇头愤怒地道：“没办法，知道这婚姻是程家设计的，我……你让我傻瓜一直当到底？”</p></blockquote><p>——第144章 1992年(8)</p><blockquote><p>那么用与程开颜婚姻和美来洗刷告发。他若想离婚，那就坐实告发。谁让他确实与梁思申认识呢。程父是料定他与梁思申没关联，又更料定他爱事业胜过一切，推定他肯定会不惜代价坚持项目，才会出此下策。程父大概也很清楚，他若真因此与程开颜重修旧好，以后就没脸再提离婚。宋运辉无法不感叹，姜是老的辣，程父打蛇打七寸，落点一分不差。</p></blockquote><p>——第161章 1992年(25)</p><blockquote><p>这一刻，宋运辉意识到，他再找多少理由，都无法掩盖一条事实，结婚至今，他变心了。他犹豫良久，才勉强挤出一句：“没有。”</p><p>可心中也清楚，他心虚，他无法再为自己找任何理由。</p></blockquote><p>——第170章 1993年(9)</p><h2 id="梁思申">梁思申</h2><blockquote><p>“那是你傻。”外公都不要听梁思申的申诉，“我走遍全世界，哪儿都一样，什么事只要跟钱搭一起，都没个干净的。你们那行当算计的都是大钱，即使规则也是黑的，你还什么讲规则，你是给洗脑了才不觉得黑。你跟我说秃鹫，秃鹫是干什么的？你做秃鹫玩得高兴，你想过被秃鹫吃的人是什么想法？股票又是什么？衍生品又是什么？都是内行人空对空玩外行人的游戏。只有你才以为是数字是科学，笨蛋！难怪你一会儿控诉你爸一会儿又控诉小辉，敢情你学校出来还没长大过啊，会不会太弱智，难道以前是我高看你了？”</p></blockquote><p>——第294章 1998年(3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书 - 改革 - 大江大河" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6-%E6%94%B9%E9%9D%A9-%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP 路线图</title>
    <link href="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/"/>
    <id>https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/</id>
    <published>2020-03-30T14:28:50.000Z</published>
    <updated>2020-03-30T15:29:06.909Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png" /></p><p>nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。</p><a id="more"></a><ul><li>关键字之间的关系可以用模棱两可的方式解释，因为它们以语义思维导图的格式表示。请只关注方框中的关键字，并将其视为学习的必要部分。</li><li>仅在图像中包含大量关键字和知识的工作就具有挑战性。因此，请注意，此路线图是建议或想法之一。</li><li>您有资格自由使用材料（包括商业目的），但强烈希望提供参考。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li></ul><h2 id="概率统计">概率统计</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/prob.png" /></p><h2 id="机器学习">机器学习</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/ml.png" /></p><h2 id="文字挖掘">文字挖掘</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/textmining.png" /></p><h2 id="自然语言处理">自然语言处理</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/nlp.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/graykode/nlp-roadmap" target="_blank" rel="noopener" class="uri">https://github.com/graykode/nlp-roadmap</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="nlp" scheme="https://2020.iosdevlog.com/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>Docker Cheat Sheet</title>
    <link href="https://2020.iosdevlog.com/2020/03/29/docker/"/>
    <id>https://2020.iosdevlog.com/2020/03/29/docker/</id>
    <published>2020-03-29T14:41:44.000Z</published>
    <updated>2020-03-29T14:49:22.932Z</updated>
    
    <content type="html"><![CDATA[<p>想要一起来完善这份速查表吗？<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 参见<a href="#贡献手册contributing">贡献手册</a>部分吧！</p><blockquote><p>译者注：以下部分链接需科学上网后使用。</p><p>Due to GFW, varies links below could not be accessed in China Mainland.</p></blockquote><h2 id="目录">目录</h2><ul><li><a href="#为何使用-docker">为何使用 Docker</a></li><li><a href="#系统环境">系统环境(Prerequisites)</a></li><li><a href="#安装">安装(Installation)</a></li><li><a href="#容器container">容器(Containers)</a></li><li><a href="#镜像images">镜像(Images)</a></li><li><a href="#网络networks">网络(Networks)</a></li><li><a href="#仓管中心和仓库registry--repository">仓管中心和仓库(Registry &amp; Repository)</a></li><li><a href="#dockerfile">Dockerfile</a></li><li><a href="#层layers">层(Layers)</a></li><li><a href="#链接links">链接(Links)</a></li><li><a href="#卷标volumes">卷标(Volumes)</a></li><li><a href="#暴露端口exposing-ports">暴露端口(Exposing Ports)</a></li><li><a href="#最佳实践">最佳实践(Best Practices)</a></li><li><a href="#安全security">安全(security)</a></li><li><a href="#小贴士">小贴士(Tips)</a></li><li><a href="#贡献手册contributing">贡献手册(Contributing)</a></li></ul><a id="more"></a><h2 id="为何使用-docker">为何使用 Docker</h2><p>「通过 Docker，开发者可以使用任何语言任何工具创建任何应用。“Dockerized” 的应用是完全可移植的，能在任何地方运行 - 不管是同事的 OS X 和 Windows 笔记本，或是在云端运行的 Ubuntu QA 服务，还是在虚拟机运行的 Red Hat 产品数据中心。</p><p>Docker Hub 上有 13000+ 的应用，开发者可以从中选取一个进行快速扩展开发。Docker 跟踪管理变更和依赖关系，让系统管理员能更容易理解开发人员是如何让应用运转起来的。而开发者可以通过 Docker Hub 的共有/私有仓库，构建他们的自动化编译，与其他合作者共享成果。</p><p>Docker 帮助开发者更快地构建和发布高质量的应用。」—— <a href="https://www.docker.com/what-docker/#copy1" target="_blank" rel="noopener">什么是 Docker</a></p><h2 id="系统环境">系统环境</h2><p>我用的是 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh My Zsh</a> 和 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#docker" target="_blank" rel="noopener">Docker 插件</a>，它可以自动补全 Docker 命令。你的环境可能有所不同。</p><h3 id="linux">Linux</h3><p>Docker 对于 Linux 内核版本的 <a href="https://docs.docker.com/engine/installation/binaries/#check-kernel-dependencies" target="_blank" rel="noopener">最低要求</a> 为 <code>3.10.x</code>。</p><h3 id="macos">MacOS</h3><p>10.8「Mountain Lion」或更新版本。</p><h3 id="检查版本">检查版本</h3><p>时刻关注你当前正在使用的 Docker 版本是十分重要的，这能够帮助你了解可用的特性。同时，可以让你在查找镜像时选择使用的版本。接下来让我们看看如何操作。</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/version/" target="_blank" rel="noopener"><code>docker version</code></a> 查看你正在运行的 Docker 版本。</li></ul><p>获取 Docker 服务版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version --format &#39;&#123;&#123;.Server.Version&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">1.8.0</span><br></pre></td></tr></table></figure><p>你也可以输出原始的 JSON 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version --format &#39;&#123;&#123;json .&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#123;&quot;Client&quot;:&#123;&quot;Version&quot;:&quot;1.8.0&quot;,&quot;ApiVersion&quot;:&quot;1.20&quot;,&quot;GitCommit&quot;:&quot;f5bae0a&quot;,&quot;GoVersion&quot;:&quot;go1.4.2&quot;,&quot;Os&quot;:&quot;linux&quot;,&quot;Arch&quot;:&quot;am&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><h3 id="linux-1">Linux</h3><p>Docker 官方提供了快速、易用的安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br></pre></td></tr></table></figure><p>如果你不想执行一个不明不白的 Shell 脚本，那么请看 <a href="https://docs.docker.com/engine/installation/linux/" target="_blank" rel="noopener">安装说明</a>，选择你在用的发行版本。</p><p>如果你是一个 Docker 超新手，那么你应当先去看看 <a href="https://docs.docker.com/engine/getstarted/" target="_blank" rel="noopener">系列教程</a>。</p><h3 id="macos-1">macOS</h3><p>下载并安装 <a href="https://www.docker.com/community-edition" target="_blank" rel="noopener">Docker Community Edition</a>。如果你在使用 Homebrew-Cask，只需在命令行输入 <code>brew cask install docker</code> 即可。下载安装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a> 亦可。<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker For Mac</a> 很赞，但是它的安装过程与 VirtualBox 不太一样。详情请查阅 <a href="https://docs.docker.com/docker-for-mac/docker-toolbox/" target="_blank" rel="noopener">比较</a>。</p><blockquote><p><strong>注意</strong>：Docker Toolbox 已经过时。你应当使用 Docker Community Edition，详见 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a></p></blockquote><p>安装好 Docker Community Edition 后，点击 Launchpad 内的 Docker 图标。接着即可启动容器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>好了，现在你有了一个运行中的 Docker 容器了。</p><h2 id="容器container">容器(Container)</h2><p><a href="http://etherealmind.com/basics-docker-containers-hypervisors-coreos/" target="_blank" rel="noopener">关于 Docker 进程隔离的基础</a>。容器 (Container) 之于虚拟机 (Virtual Machine) 就好比线程之于进程。或者你可以把他们想成是「吃了类固醇的 chroots」。</p><h3 id="生命周期">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/create" target="_blank" rel="noopener"><code>docker create</code></a> 创建容器但不启动它。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rename/" target="_blank" rel="noopener"><code>docker rename</code></a> 用于重命名容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/run" target="_blank" rel="noopener"><code>docker run</code></a> 一键创建并同时启动该容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rm" target="_blank" rel="noopener"><code>docker rm</code></a> 删除容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/update/" target="_blank" rel="noopener"><code>docker update</code></a> 调整容器的资源限制。</li></ul><p>通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 <code>docker run -td container_id</code> 命令。选项 <code>-t</code> 表示分配一个 pseudo-TTY 会话，<code>-d</code> 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</p><p>如果你需要一个临时容器，可使用 <code>docker run --rm</code> 会在容器停止之后删除它。</p><p>如果你需要映射宿主机 (host) 的目录到 Docker 容器内，可使用 <code>docker run -v $HOSTDIR:$DOCKERDIR</code>。详见 <a href="#卷标volumes">卷标(Volumes)</a> 一节。</p><p>如果你想同时删除与容器相关联的卷标，那么在删除容器的时候必须包含 <code>-v</code> 选项，像这样 <code>docker rm -v</code>。</p><p>从 Docker 1.10 起，其内置一套各容器独立的 <a href="https://docs.docker.com/engine/admin/logging/overview/" target="_blank" rel="noopener">日志引擎</a>，每个容器可以独立使用。你可以使用 <code>docker run --log-driver=syslog</code> 来自定义日志引擎（例如以上的 <code>syslog</code>）。</p><h3 id="启动和停止">启动和停止</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/start" target="_blank" rel="noopener"><code>docker start</code></a> 启动已存在的容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/stop" target="_blank" rel="noopener"><code>docker stop</code></a> 停止运行中的容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/restart" target="_blank" rel="noopener"><code>docker restart</code></a> 重启容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/pause/" target="_blank" rel="noopener"><code>docker pause</code></a> 暂停运行中的容器，将其「冻结」在当前状态。</li><li><a href="https://docs.docker.com/engine/reference/commandline/unpause/" target="_blank" rel="noopener"><code>docker unpause</code></a> 结束容器暂停状态。</li><li><a href="https://docs.docker.com/engine/reference/commandline/wait" target="_blank" rel="noopener"><code>docker wait</code></a> 阻塞地等待某个运行中的容器直到停止。</li><li><a href="https://docs.docker.com/engine/reference/commandline/kill" target="_blank" rel="noopener"><code>docker kill</code></a> 向运行中的容器发送 SIGKILL 指令。</li><li><a href="https://docs.docker.com/engine/reference/commandline/attach" target="_blank" rel="noopener"><code>docker attach</code></a> 连接到运行中的容器。</li></ul><p>如果你想将容器的端口 (ports) 暴露至宿主机，请见 <a href="#暴露端口exposing-ports">暴露端口</a> 一节。</p><p>关于 Docker 实例崩溃后的重启策略，详见 <a href="http://container42.com/2014/09/30/docker-restart-policies/" target="_blank" rel="noopener">本文</a>。</p><h4 id="cpu-限制">CPU 限制</h4><p>你可以限制 CPU 资源占用，无论是指定百分比，或是特定核心数。</p><p>例如，你可以设置 <a href="https://docs.docker.com/engine/reference/run/#/cpu-share-constraint" target="_blank" rel="noopener"><code>cpu-shares</code></a>。该配置看起来有点奇怪 -- 1024 表示 100% CPU，因此如果你希望容器使用所有 CPU 内核的 50%，应将其设置为 512：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --c 512 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure><p>更多信息请参阅 <a href="https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu" target="_blank" rel="noopener" class="uri">https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu</a>。</p><p>通过 <a href="https://docs.docker.com/engine/reference/run/#/cpuset-constraint" target="_blank" rel="noopener"><code>cpuset-cpus</code></a> 可使用特定 CPU 内核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --cpuset-cpus&#x3D;0,4,6 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure><p>请参阅 <a href="https://agileek.github.io/docker/2014/08/06/docker-cpuset/" target="_blank" rel="noopener" class="uri">https://agileek.github.io/docker/2014/08/06/docker-cpuset/</a> 获取更多细节以及一些不错的视频。</p><p>注意，Docker 在容器内仍然能够 <strong>看到</strong> 全部 CPU -- 它仅仅是不使用全部而已。请参阅 <a href="https://github.com/docker/docker/issues/20770" target="_blank" rel="noopener" class="uri">https://github.com/docker/docker/issues/20770</a> 获取更多细节。</p><h4 id="内存限制">内存限制</h4><p>同样，亦可给 Docker 设置 <a href="https://docs.docker.com/engine/reference/run/#/user-memory-constraints" target="_blank" rel="noopener">内存限制</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 300M ubuntu:14.04 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="能力capabilities">能力(Capabilities)</h4><p>Linux 的 Capability 可以通过使用 <code>cap-add</code> 和 <code>cap-drop</code> 设置。请参阅 <a href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener" class="uri">https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities</a> 获取更多细节。这有助于提高安全性。</p><p>如需要挂载基于 FUSE 的文件系统，你需要结合 <code>--cap-add</code> 和 <code>--device</code> 使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it --cap-add SYS_ADMIN --device &#x2F;dev&#x2F;fuse sshfs</span><br></pre></td></tr></table></figure><p>授予对某个设备的访问权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device&#x3D;&#x2F;dev&#x2F;ttyUSB0 debian bash</span><br></pre></td></tr></table></figure><p>授予对所有设备的访问权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged -v &#x2F;dev&#x2F;bus&#x2F;usb:&#x2F;dev&#x2F;bus&#x2F;usb debian bash</span><br></pre></td></tr></table></figure><p>有关容器特权的更多信息请参阅 <a href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener">本文</a>。</p><h3 id="信息">信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/ps" target="_blank" rel="noopener"><code>docker ps</code></a> 查看运行中的所有容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/logs" target="_blank" rel="noopener"><code>docker logs</code></a> 从容器中读取日志。（你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 <code>json-file</code> 和 <code>journald</code>）。</li><li><a href="https://docs.docker.com/engine/reference/commandline/inspect" target="_blank" rel="noopener"><code>docker inspect</code></a> 查看某个容器的所有信息（包括 IP 地址）。</li><li><a href="https://docs.docker.com/engine/reference/commandline/events" target="_blank" rel="noopener"><code>docker events</code></a> 从容器中获取事件 (events)。</li><li><a href="https://docs.docker.com/engine/reference/commandline/port" target="_blank" rel="noopener"><code>docker port</code></a> 查看容器的公开端口。</li><li><a href="https://docs.docker.com/engine/reference/commandline/top" target="_blank" rel="noopener"><code>docker top</code></a> 查看容器中活动进程。</li><li><a href="https://docs.docker.com/engine/reference/commandline/stats" target="_blank" rel="noopener"><code>docker stats</code></a> 查看容器的资源使用量统计信息。</li><li><a href="https://docs.docker.com/engine/reference/commandline/diff" target="_blank" rel="noopener"><code>docker diff</code></a> 查看容器文件系统中存在改动的文件。</li></ul><p><code>docker ps -a</code> 将显示所有容器，包括运行中和已停止的。</p><p><code>docker stats --all</code> 同样将显示所有容器，默认仅显示运行中的容器。</p><h3 id="导入-导出">导入 / 导出</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/cp" target="_blank" rel="noopener"><code>docker cp</code></a> 在容器和本地文件系统之间复制文件或目录。</li><li><a href="https://docs.docker.com/engine/reference/commandline/export" target="_blank" rel="noopener"><code>docker export</code></a> 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。</li></ul><h3 id="执行命令">执行命令</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/exec" target="_blank" rel="noopener"><code>docker exec</code></a> 在容器内执行命令。</li></ul><p>例如，进入正在运行的 <code>foo</code> 容器，并连接 (attach) 到一个新的 Shell 进程：<code>docker exec -it foo /bin/bash</code>。</p><h2 id="镜像images">镜像(Images)</h2><p>镜像是 <a href="https://docs.docker.com/engine/understanding-docker/#how-does-a-docker-image-work" target="_blank" rel="noopener">Docker 容器的模板</a>。</p><h3 id="生命周期-1">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/images" target="_blank" rel="noopener"><code>docker images</code></a> 查看所有镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/import" target="_blank" rel="noopener"><code>docker import</code></a> 从归档文件创建镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/build" target="_blank" rel="noopener"><code>docker build</code></a> 从 Dockerfile 创建镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/commit" target="_blank" rel="noopener"><code>docker commit</code></a> 为容器创建镜像，如果容器正在运行则会临时暂停。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rmi" target="_blank" rel="noopener"><code>docker rmi</code></a> 删除镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/load" target="_blank" rel="noopener"><code>docker load</code></a> 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。</li><li><a href="https://docs.docker.com/engine/reference/commandline/save" target="_blank" rel="noopener"><code>docker save</code></a> 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。</li></ul><h3 id="其它信息">其它信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/history" target="_blank" rel="noopener"><code>docker history</code></a> 查看镜像的历史记录。</li><li><a href="https://docs.docker.com/engine/reference/commandline/tag" target="_blank" rel="noopener"><code>docker tag</code></a> 给镜像打标签命名（本地或者仓库均可）。</li></ul><h3 id="清理">清理</h3><p>虽然你可以用 <code>docker rmi</code> 命令来删除指定的镜像，不过有个名为 <a href="https://github.com/spotify/docker-gc" target="_blank" rel="noopener">docker-gc</a> 的工具，它可以以一种安全的方式，清理掉那些不再被任何容器使用的镜像。Docker 1.13 起，使用 <code>docker image prune</code> 亦可删除未使用的镜像。参见 <a href="#清理">清理</a>。</p><h3 id="加载-保存镜像">加载 / 保存镜像</h3><p>从文件中加载镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; my_image.tar.gz</span><br></pre></td></tr></table></figure></p><p>保存既有镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my_image:my_tag | gzip &gt; my_image.tar.gz</span><br></pre></td></tr></table></figure></p><h3 id="导入-导出容器">导入 / 导出容器</h3><p>从文件中导入容器镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar.gz | docker import - my_image:my_tag</span><br></pre></td></tr></table></figure></p><p>导出既有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export my_container | gzip &gt; my_container.tar.gz</span><br></pre></td></tr></table></figure></p><h3 id="加载已保存的镜像-与-导入已导出为镜像的容器-的不同">加载已保存的镜像 与 导入已导出为镜像的容器 的不同</h3><p>通过 <code>load</code> 命令来加载镜像，会创建一个新的镜像，并继承原镜像的所有历史。<br />通过 <code>import</code> 将容器作为镜像导入，也会创建一个新的镜像，但并不包含原镜像的历史，因此会比使用 <code>load</code> 方式生成的镜像更小。</p><h2 id="网络networks">网络(Networks)</h2><p>Docker 具备 <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">网络</a> 功能。我并不是很了解它，所以这是一个扩展本文的好地方。文档 <a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/" target="_blank" rel="noopener">使用网络</a> 指出，这是一种无需暴露端口即可实现 Docker 容器间通信的好方法。</p><h3 id="生命周期-2">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank" rel="noopener"><code>docker network create</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_rm/" target="_blank" rel="noopener"><code>docker network rm</code></a></li></ul><h3 id="其它信息-1">其它信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_ls/" target="_blank" rel="noopener"><code>docker network ls</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/" target="_blank" rel="noopener"><code>docker network inspect</code></a></li></ul><h3 id="建立连接">建立连接</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_connect/" target="_blank" rel="noopener"><code>docker network connect</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/" target="_blank" rel="noopener"><code>docker network disconnect</code></a></li></ul><p>你可以 <a href="https://blog.jessfraz.com/post/ips-for-all-the-things/" target="_blank" rel="noopener">为容器指定 IP 地址</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用你自己的子网和网关创建一个桥接网络</span><br><span class="line">docker network create --subnet 203.0.113.0&#x2F;24 --gateway 203.0.113.254 iptastic</span><br><span class="line"></span><br><span class="line"># 基于以上创建的网络，运行一个 Nginx 容器并指定 IP</span><br><span class="line">$ docker run --rm -it --net iptastic --ip 203.0.113.2 nginx</span><br><span class="line"></span><br><span class="line"># 在其他地方使用 CURL 访问这个 IP（假设该 IP 为公网）</span><br><span class="line">$ curl 203.0.113.2</span><br></pre></td></tr></table></figure><h2 id="仓管中心和仓库registry-repository">仓管中心和仓库(Registry &amp; Repository)</h2><p>仓库 (repository) 是 <em>被托管(hosted)</em> 的已命名镜像 (tagged images) 的集合，这组镜像用于构建容器文件系统。</p><p>仓管中心 (registry) 则是 <em>托管服务(host)</em> -- 用于存储仓库并提供 HTTP API，以便 <a href="https://docs.docker.com/engine/tutorials/dockerrepos/" target="_blank" rel="noopener">管理仓库的上传和下载</a>。</p><p>Docker 官方托管着自己的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">仓管中心</a>，包含着数量众多的仓库。不过话虽如此，这个仓管中心 <a href="https://titanous.com/posts/docker-insecurity" target="_blank" rel="noopener">并没有很好地验证镜像</a>，所以如果你担心安全问题的话，请尽量避免使用它。</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/login" target="_blank" rel="noopener"><code>docker login</code></a> 登入仓管中心。</li><li><a href="https://docs.docker.com/engine/reference/commandline/logout" target="_blank" rel="noopener"><code>docker logout</code></a> 登出仓管中心。</li><li><a href="https://docs.docker.com/engine/reference/commandline/search" target="_blank" rel="noopener"><code>docker search</code></a> 从仓管中心检索镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/pull" target="_blank" rel="noopener"><code>docker pull</code></a> 从仓管中心拉取镜像到本地。</li><li><a href="https://docs.docker.com/engine/reference/commandline/push" target="_blank" rel="noopener"><code>docker push</code></a> 从本地推送镜像到仓管中心。</li></ul><h3 id="本地仓管中心">本地仓管中心</h3><p>你可以使用 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener">docker distribution</a> 项目搭建本地的仓管中心，详情参阅 <a href="https://github.com/docker/docker.github.io/blob/master/registry/deploying.md" target="_blank" rel="noopener">本地发布 (local deploy)</a> 的介绍。</p><p>科学上网后，也可以看看 <a href="https://groups.google.com/a/dockerproject.org/forum/#!forum/distribution" target="_blank" rel="noopener">Google+ Group</a>。</p><h2 id="dockerfile">Dockerfile</h2><p>当你执行 <code>docker build</code> 时，Docker 将会根据 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">配置文件</a> 启动 Docker 容器。远优于使用 <code>docker commit</code>。</p><p>以下是一些编写 Dockerfile 的常用编辑器，并链接到适配的语法高亮模块︰</p><ul><li>如果你在使用 <a href="http://jedit.org" target="_blank" rel="noopener">jEdit</a>，你可以使用我开发的 Dockerfile <a href="https://github.com/wsargent/jedit-docker-mode" target="_blank" rel="noopener">语法高亮模块</a>。</li><li><a href="https://packagecontrol.io/packages/Dockerfile%20Syntax%20Highlighting" target="_blank" rel="noopener">Sublime Text 2</a></li><li><a href="https://atom.io/packages/language-docker" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/ekalinin/Dockerfile.vim" target="_blank" rel="noopener">Vim</a></li><li><a href="https://github.com/spotify/dockerfile-mode" target="_blank" rel="noopener">Emacs</a></li><li><a href="https://github.com/docker/docker/tree/master/contrib/syntax/textmate" target="_blank" rel="noopener">TextMate</a></li><li>更多信息请参阅 <a href="https://domeide.github.io/" target="_blank" rel="noopener">Docker 遇上 IDE</a></li></ul><h3 id="指令">指令</h3><ul><li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="noopener">.dockerignore</a></li><li><a href="https://docs.docker.com/engine/reference/builder/#from" target="_blank" rel="noopener">FROM</a> 为其他指令设置基础镜像 (Base Image)。</li><li><a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated" target="_blank" rel="noopener">MAINTAINER (deprecated - use LABEL instead)</a> 为生成的镜像设置作者字段。</li><li><a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank" rel="noopener">RUN</a> 在当前镜像的基础上生成一个新层并执行命令。</li><li><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">CMD</a> 设置容器默认执行命令。</li><li><a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank" rel="noopener">EXPOSE</a> 告知 Docker 容器在运行时所要监听的网络端口。注意：并没有实际上将端口设置为可访问。</li><li><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">ENV</a> 设置环境变量。</li><li><a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener">ADD</a> 将文件、目录或远程文件复制到容器中。缓存无效。请尽量用 <code>COPY</code> 代替 <code>ADD</code>。</li><li><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener">COPY</a> 将文件或文件夹复制到容器中。注意：将使用 ROOT 用户复制文件，故无论 USER / WORKDIR 指令如何配置，你都需要手动修改其所有者（<code>chown</code>），<code>ADD</code> 也是一样。</li><li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">ENTRYPOINT</a> 将容器设为可执行的。</li><li><a href="https://docs.docker.com/engine/reference/builder/#volume" target="_blank" rel="noopener">VOLUME</a> 在容器内部创建挂载点 (mount point) 指向外部挂载的卷标或其他容器。</li><li><a href="https://docs.docker.com/engine/reference/builder/#user" target="_blank" rel="noopener">USER</a> 设置随后执行 RUN / CMD / ENTRYPOINT 命令的用户名。</li><li><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="noopener">WORKDIR</a> 设置工作目录 (working directory)。</li><li><a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARG</a> 定义编译时 (build-time) 变量。</li><li><a href="https://docs.docker.com/engine/reference/builder/#onbuild" target="_blank" rel="noopener">ONBUILD</a> 添加触发指令，当该镜像被作为其他镜像的基础镜像时该指令会被触发。</li><li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank" rel="noopener">STOPSIGNAL</a> 设置停止容器时，向容器内发送的系统调用信号 (system call signal)。</li><li><a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">LABEL</a> 将键值对元数据 (key/value metadata) 应用到镜像、容器或是守护进程。</li></ul><h3 id="教程">教程</h3><ul><li><a href="http://flux7.com/blogs/docker/docker-tutorial-series-part-3-automation-is-the-word-using-dockerfile/" target="_blank" rel="noopener">Flux7's Dockerfile Tutorial</a></li></ul><h3 id="例子">例子</h3><ul><li><a href="https://docs.docker.com/engine/reference/builder/#dockerfile-examples" target="_blank" rel="noopener">Examples</a></li><li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li><li><a href="http://crosbymichael.com/" target="_blank" rel="noopener">Michael Crosby</a> 还有更多的 <a href="http://crosbymichael.com/dockerfile-best-practices.html" target="_blank" rel="noopener">Dockerfiles best practices</a> / <a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html" target="_blank" rel="noopener">take 2</a></li><li><a href="http://jonathan.bergknoff.com/journal/building-good-docker-images" target="_blank" rel="noopener">Building Good Docker Images</a> / <a href="http://jonathan.bergknoff.com/journal/building-better-docker-images" target="_blank" rel="noopener">Building Better Docker Images</a></li><li><a href="https://speakerdeck.com/garethr/managing-container-configuration-with-metadata" target="_blank" rel="noopener">Managing Container Configuration with Metadata</a></li></ul><h2 id="层layers">层(Layers)</h2><p>Docker 的版本化文件系统是基于层的。就像 <a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/" target="_blank" rel="noopener">Git 的提交或文件变更系统</a> 一样。</p><h2 id="链接links">链接(Links)</h2><p>链接 (links) <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank" rel="noopener">通过 TCP/IP 端口</a> 实现 Docker 容器之间的通讯。<a href="https://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/" target="_blank" rel="noopener">Atlassian</a> 展示了可用的例子。你还可以 <a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/#/updating-the-etchosts-file" target="_blank" rel="noopener">通过主机名 (hostname) 链接</a>。</p><p>在某种意义上来说，该特性已经被 <a href="https://docs.docker.com/network/" target="_blank" rel="noopener">自定义网络</a> 所替代。</p><p>注意: 如果你希望容器之间<strong>只</strong>通过链接进行通讯，在启动 Docker 守护进程时，请使用 <code>-icc=false</code> 来禁用内部进程通讯。</p><p>假设你有一个名为 CONTAINER 的容器（通过 <code>docker run --name CONTAINER</code> 指定）并且在 Dockerfile 中，暴露了一个端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 1337</span><br></pre></td></tr></table></figure><p>然后，我们创建另外一个名为 LINKED 的容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --link CONTAINER:ALIAS --name LINKED user&#x2F;wordpress</span><br></pre></td></tr></table></figure><p>然后 CONTAINER 暴露的端口和别名将会以如下的环境变量出现在 LINKED 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ALIAS_PORT_1337_TCP_PORT</span><br><span class="line">$ALIAS_PORT_1337_TCP_ADDR</span><br></pre></td></tr></table></figure><p>那么你便可以通过这种方式来连接它了。</p><p>使用 <code>docker rm --link</code> 即可删除链接。</p><p>通常，Docker 容器（亦可理解为「服务」）之间的链接，是「服务发现」的一个子集。如果你打算在生产中大规模使用 Docker，这将是一个很大的问题。请参阅<a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-service-discovery-and-distributed-configuration-stores" target="_blank" rel="noopener">The Docker Ecosystem: Service Discovery and Distributed Configuration Stores</a> 获取更多信息。</p><h2 id="卷标volumes">卷标(Volumes)</h2><p>Docker 的卷标 (volumes) 是 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/" target="_blank" rel="noopener">独立的文件系统</a>。它们并非必须连接到特定的容器上。</p><h3 id="生命周期-3">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener"><code>docker volume create</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/" target="_blank" rel="noopener"><code>docker volume rm</code></a></li></ul><h3 id="信息-1">信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/" target="_blank" rel="noopener"><code>docker volume ls</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" target="_blank" rel="noopener"><code>docker volume inspect</code></a></li></ul><p>卷标在不能使用链接（只有 TCP/IP）的情况下非常有用。例如，如果你有两个 Docker 实例需要通讯并在文件系统上留下记录。</p><p>你可以一次性将其挂载到多个 docker 容器上，通过 <code>docker run --volumes-from</code>。</p><p>因为卷标是独立的文件系统，它们通常被用于存储各容器之间的瞬时状态。也就是说，你可以配置一个无状态临时容器，关掉之后，当你有第二个这种临时容器实例的时候，你可以从上一次保存的状态继续执行。</p><p>查看 <a href="http://crosbymichael.com/advanced-docker-volumes.html" target="_blank" rel="noopener">卷标进阶</a> 来获取更多细节。<a href="http://container42.com/2014/11/03/docker-indepth-volumes/" target="_blank" rel="noopener">Container42</a> 非常有用。</p><p>你可以 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume" target="_blank" rel="noopener">将宿主 MacOS 的文件夹映射为 Docker 卷标</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;Users&#x2F;wsargent&#x2F;myapp&#x2F;src:&#x2F;src</span><br></pre></td></tr></table></figure><p>你也可以用远程 NFS 卷标，如果你觉得你 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume" target="_blank" rel="noopener">有足够勇气</a>。</p><p>还可以考虑运行一个纯数据容器，像 <a href="http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/" target="_blank" rel="noopener">这里</a> 所说的那样，提供可移植数据。</p><p>记得，<a href="#将文件挂载为卷标">文件也可以被挂载为卷标</a>。</p><h2 id="暴露端口exposing-ports">暴露端口(Exposing ports)</h2><p>通过宿主容器暴露输入端口相当 <a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports" target="_blank" rel="noopener">繁琐但有效的</a>。</p><p>例如使用 <code>-p</code> 将容器端口映射到宿主端口上（只使用本地主机 (localhost) 接口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage</span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank" rel="noopener">EXPOSE</a> 告知 Docker，该容器在运行时监听指定的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;CONTAINERPORT&gt;</span><br></pre></td></tr></table></figure><p>但是注意 EXPOSE 并不会直接暴露端口，你需要用参数 <code>-p</code> 。比如说你要在 localhost 上暴露容器的端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A DOCKER -p tcp --dport &lt;LOCALHOSTPORT&gt; -j DNAT --to-destination &lt;CONTAINERIP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>如果你是在 Virtualbox 中运行 Docker，那么你需要配置端口转发 (forward the port)。使用 <a href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html" target="_blank" rel="noopener">forwarded_port</a> 在 Vagrantfile 上配置暴露的端口范围，这样你就可以动态地映射了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  (49000..49900).each do |port|</span><br><span class="line">    config.vm.network :forwarded_port, :host &#x3D;&gt; port, :guest &#x3D;&gt; port</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果你忘记了将什么端口映射到宿主机上的话，可使用 <code>docker port</code> 查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER $CONTAINERPORT</span><br></pre></td></tr></table></figure><h2 id="最佳实践">最佳实践</h2><p>这里有一些最佳实践，以及争论焦点：</p><ul><li><a href="http://gregoryszorc.com/blog/2014/10/16/the-rabbit-hole-of-using-docker-in-automated-tests/" target="_blank" rel="noopener">The Rabbit Hole of Using Docker in Automated Tests</a></li><li><a href="https://twitter.com/bridgetkromhout" target="_blank" rel="noopener">Bridget Kromhout</a> has a useful blog post on <a href="http://sysadvent.blogspot.co.uk/2014/12/day-1-docker-in-production-reality-not.html" target="_blank" rel="noopener">running Docker in production</a> at Dramafever.<br /></li><li>There's also a best practices <a href="http://developers.lyst.com/devops/2014/12/08/docker/" target="_blank" rel="noopener">blog post</a> from Lyst.</li><li><a href="https://engineering.salesforceiq.com/2013/11/05/a-docker-dev-environment-in-24-hours-part-2-of-2.html" target="_blank" rel="noopener">A Docker Dev Environment in 24 Hours!</a></li><li><a href="https://tersesystems.com/2013/11/20/building-a-development-environment-with-docker/" target="_blank" rel="noopener">Building a Development Environment With Docker</a></li><li><a href="https://samsaffron.com/archive/2013/11/07/discourse-in-a-docker-container" target="_blank" rel="noopener">Discourse in a Docker Container</a></li></ul><h2 id="安全security">安全(Security)</h2><p>这节准备讨论一些关于 Docker 安全性的问题。Docker 官方文档 <a href="https://docs.docker.com/articles/security/" target="_blank" rel="noopener">安全</a> 页面讲述了更多细节。</p><p>首先第一件事：Docker 是有 root 权限的。如果你在 <code>docker</code> 组，那么你就有 <a href="https://web.archive.org/web/20161226211755/http://reventlov.com/advisories/using-the-docker-command-to-root-the-host" target="_blank" rel="noopener">root 权限</a>。如果你将 Docker 的 Unix Socket 暴露给容器，意味着你赋予了容器 <a href="https://www.lvh.io/posts/dont-expose-the-docker-socket-not-even-to-a-container/" target="_blank" rel="noopener">宿主机 root 权限</a>。</p><p>Docker 不应当作为唯一的防御措施。你应当使其更加安全可靠。</p><p>为了更好地理解容器暴露了什么，可参阅由 <a href="https://twitter.com/dyn___" target="_blank" rel="noopener">Aaron Grattafiori</a> 编写的 <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf" target="_blank" rel="noopener">Understanding and Hardening Linux Containers</a>。这是一个完整全面且包含大量链接和脚注的容器问题指南，介绍了许多有用的内容。即使你已经加固过容器，以下的安全提示依然十分有帮助，但并不能代替理解的过程。</p><h3 id="安全提示">安全提示</h3><p>为了最大的安全性，你应当考虑在虚拟机上运行 Docker。这是直接从 Docker 安全团队拿来的资料 -- <a href="http://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security" target="_blank" rel="noopener">slides</a> / <a href="http://www.projectatomic.io/blog/2014/08/is-it-safe-a-look-at-docker-and-security-from-linuxcon/" target="_blank" rel="noopener">notes</a>。之后，可使用 AppArmor、seccomp、SELinux、grsec 等来 <a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/" target="_blank" rel="noopener">限制容器的权限</a>。更多细节，请查阅 <a href="https://blog.docker.com/2016/02/docker-engine-1-10-security/" target="_blank" rel="noopener">Docker 1.10 security features</a>。</p><p>Docker 镜像 ID 属于 <a href="https://medium.com/@quayio/your-docker-image-ids-are-secrets-and-its-time-you-treated-them-that-way-f55e9f14c1a4" target="_blank" rel="noopener">敏感信息</a> 所以它不应该向外界公开。请将它们当作密码来对待。</p><p>阅读由 <a href="https://github.com/konstruktoid" target="_blank" rel="noopener">Thomas Sjögren</a> 编写的 <a href="https://github.com/konstruktoid/Docker/blob/master/Security/CheatSheet.adoc" target="_blank" rel="noopener">Docker Security Cheat Sheet</a>：关于加固容器的不错的建议。</p><p>查看 <a href="https://github.com/docker/docker-bench-security" target="_blank" rel="noopener">Docker 安全测试脚本</a>，下载 <a href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices/" target="_blank" rel="noopener">最佳实践白皮书</a>。</p><p>你应当远离使用非稳定版本 grsecurity / pax 的内核，比如 <a href="https://en.wikipedia.org/wiki/Alpine_Linux" target="_blank" rel="noopener">Alpine Linux</a>。如果在产品中用了 grsecurity，那么你应该考虑使用有 <a href="https://grsecurity.net/business_support.php" target="_blank" rel="noopener">商业支持</a> 的 <a href="https://grsecurity.net/announce.php" target="_blank" rel="noopener">稳定版本</a>，就像你对待 RedHat 那样。虽然要 $200 每月，但对于你的运维预算来说不值一提。</p><p>从 Docker 1.11 开始，你可以轻松的限制在容器中可用的进程数，以防止 fork 炸弹。 这要求 Linux 内核 &gt;= 4.3，并且要在内核配置中打开 CGROUP_PIDS=y。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --pids-limit&#x3D;64</span><br></pre></td></tr></table></figure><p>同时，你也可以限制进程再获取新权限。该功能是 Linux 内核从 3.5 版本开始就拥有的。你可以从 <a href="http://www.projectatomic.io/blog/2016/03/no-new-privs-docker/" target="_blank" rel="noopener">这篇博客</a> 中阅读到更多关于这方面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --security-opt&#x3D;no-new-privileges</span><br></pre></td></tr></table></figure><p>以下内容摘选自 <a href="http://container-solutions.com/is-docker-safe-for-production/" target="_blank" rel="noopener">Container Solutions</a> 的 <a href="http://container-solutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf" target="_blank" rel="noopener">Docker Security Cheat Sheet</a>（PDF 版本，难以使用，故复制至此）：</p><p>关闭内部进程通讯：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d --icc&#x3D;false --iptables</span><br></pre></td></tr></table></figure><p>设置容器为只读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --read-only</span><br></pre></td></tr></table></figure><p>通过 hashsum 来验证卷标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull debian@sha256:a25306f3850e1bd44541976aa7b5fd0a29be</span><br></pre></td></tr></table></figure><p>设置卷标为只读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd)&#x2F;secrets:&#x2F;secrets:ro debian</span><br></pre></td></tr></table></figure><p>在 Dockerfile 中定义用户并以该用户运行，避免在容器中以 ROOT 身份操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r user &amp;&amp; useradd -r -g user user</span><br><span class="line">USER user</span><br></pre></td></tr></table></figure><h3 id="用户命名空间user-namespaces">用户命名空间(User Namespaces)</h3><p>还可以通过使用 <a href="https://s3hh.wordpress.com/2013/07/19/creating-and-using-containers-without-privilege/" target="_blank" rel="noopener">用户命名空间</a> -- 自 1.10 版本起已内置，但默认并未启用。</p><p>要在 Ubuntu 15.10 中启用用户命名空间 (remap the userns)，请 <a href="https://raesene.github.io/blog/2016/02/04/Docker-User-Namespaces/" target="_blank" rel="noopener">跟着这篇博客的例子</a> 来做。</p><h3 id="安全相关视频">安全相关视频</h3><ul><li><a href="https://youtu.be/04LOuMgNj9U" target="_blank" rel="noopener">Using Docker Safely</a></li><li><a href="https://youtu.be/KmxOXmPhZbk" target="_blank" rel="noopener">Securing your applications using Docker</a></li><li><a href="https://youtu.be/a9lE9Urr6AQ" target="_blank" rel="noopener">Container security: Do containers actually contain?</a></li><li><a href="https://www.youtube.com/watch?v=iN6QbszB1R8" target="_blank" rel="noopener">Linux Containers: Future or Fantasy?</a></li></ul><h3 id="安全路线图">安全路线图</h3><p>Docker 的路线图提到关于 <a href="https://github.com/docker/docker/blob/master/ROADMAP.md#11-security" target="_blank" rel="noopener">seccomp 的支持</a>。<br />一个名为 <a href="https://github.com/jfrazelle/bane" target="_blank" rel="noopener">bane</a> 的 AppArmor 策略生成器正在实现 <a href="https://github.com/docker/docker/issues/17142" target="_blank" rel="noopener">安全配置文件</a>。</p><h2 id="小贴士">小贴士</h2><p>链接：</p><ul><li><a href="http://sssslide.com/speakerdeck.com/bmorearty/15-docker-tips-in-5-minutes" target="_blank" rel="noopener">15 Docker Tips in 5 minutes</a></li><li><a href="https://codefresh.io/blog/everyday-hacks-docker/" target="_blank" rel="noopener">CodeFresh Everyday Hacks Docker</a></li></ul><h3 id="清理-1">清理</h3><p>最新的 <a href="https://github.com/docker/docker/pull/26108" target="_blank" rel="noopener">数据管理命令</a> 已在 Docker 1.13 实现：</p><ul><li><code>docker system prune</code></li><li><code>docker volume prune</code></li><li><code>docker network prune</code></li><li><code>docker container prune</code></li><li><code>docker image prune</code></li></ul><h3 id="df-命令">df 命令</h3><p><code>docker system df</code> 将显示当前 Docker 各部分占用的磁盘空间。</p><h3 id="heredoc-声明-docker-容器">Heredoc 声明 Docker 容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t htop - &lt;&lt; EOF</span><br><span class="line">FROM alpine</span><br><span class="line">RUN apk --no-cache add htop</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="最近一次的容器-id">最近一次的容器 ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias dl&#x3D;&#39;docker ps -l -q&#39;</span><br><span class="line">docker run ubuntu echo hello world</span><br><span class="line">docker commit $(dl) helloworld</span><br></pre></td></tr></table></figure><h3 id="带命令的提交需要-dockerfile">带命令的提交（需要 Dockerfile）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -run&#x3D;&#39;&#123;&quot;Cmd&quot;:[&quot;postgres&quot;, &quot;-too -many -opts&quot;]&#125;&#39; $(dl) postgres</span><br></pre></td></tr></table></figure><h3 id="获取-ip-地址">获取 IP 地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | grep -wm1 IPAddress | cut -d &#39;&quot;&#39; -f 4</span><br></pre></td></tr></table></figure><p>或使用 <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | jq -r &#39;.[0].NetworkSettings.IPAddress&#39;</span><br></pre></td></tr></table></figure><p>或使用 <a href="https://docs.docker.com/engine/reference/commandline/inspect" target="_blank" rel="noopener">go 模板</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p>或在通过 Dockerfile 构建镜像时，通过构建参数 (build argument) 传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_HOST_IP&#x3D;&#96;ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &#39;&#123; print $2 &#125;&#39; | cut -f2 -d: | head -n1&#96;</span><br><span class="line">echo DOCKER_HOST_IP &#x3D; $DOCKER_HOST_IP</span><br><span class="line">docker build \</span><br><span class="line">  --build-arg ARTIFACTORY_ADDRESS&#x3D;$DOCKER_HOST_IP </span><br><span class="line">  -t sometag \</span><br><span class="line">  some-directory&#x2F;</span><br></pre></td></tr></table></figure><h3 id="获取端口映射">获取端口映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123;range $p, $conf :&#x3D; .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;&#39; &lt;containername&gt;</span><br></pre></td></tr></table></figure><h3 id="通过正则匹配容器">通过正则匹配容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(docker ps -a | grep &quot;REGEXP_PATTERN&quot; | cut -f1 -d&quot; &quot;); do echo $i; done&#96;</span><br></pre></td></tr></table></figure><h3 id="获取环境变量配置">获取环境变量配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm ubuntu env</span><br></pre></td></tr></table></figure><h3 id="强行终止运行中的容器">强行终止运行中的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="删除所有容器强行删除无论容器运行或停止">删除所有容器（强行删除！无论容器运行或停止）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure><h3 id="删除旧容器">删除旧容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep &#39;weeks ago&#39; | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm</span><br></pre></td></tr></table></figure><h3 id="删除已停止的容器">删除已停止的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &#96;docker ps -a -q -f status&#x3D;exited&#96;</span><br></pre></td></tr></table></figure><h3 id="停止并删除容器">停止并删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm -v $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="删除无用-dangling-的镜像">删除无用 (dangling) 的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><h3 id="删除所有镜像">删除所有镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id="删除无用-dangling-的卷标">删除无用 (dangling) 的卷标</h3><p>Docker 1.9 版本起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>1.9.0 中，参数 <code>dangling=false</code> 居然 <em>没</em> 用 - 它会被忽略然后列出所有的卷标。</p><h3 id="查看镜像依赖">查看镜像依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -viz | dot -Tpng -o docker.png</span><br></pre></td></tr></table></figure><h3 id="docker-容器瘦身">Docker 容器瘦身</h3><ul><li>在某层 (RUN layer) 清理 APT</li></ul><p>这应当和其他 apt 命令在同一层中完成。<br />否则，前面的层将会保持原有信息，而你的镜像则依旧臃肿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &#123;apt commands&#125; \</span><br><span class="line">  &amp;&amp; apt-get clean \  </span><br><span class="line">  &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* &#x2F;tmp&#x2F;* &#x2F;var&#x2F;tmp&#x2F;*</span><br></pre></td></tr></table></figure><ul><li><p>压缩镜像<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">docker export $ID | docker import – flat-image-name</span><br></pre></td></tr></table></figure></p></li><li><p>备份<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">(docker export $ID | gzip -c &gt; image.tgz)</span><br><span class="line">gzip -dc image.tgz | docker import - flat-image-name</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="监视运行中容器的系统资源利用率">监视运行中容器的系统资源利用率</h3><p>检查某个容器的 CPU、内存以及网络 I/O 使用情况，你可以：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container&gt;</span><br></pre></td></tr></table></figure></p><p>按 ID 列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps -q)</span><br></pre></td></tr></table></figure></p><p>按名称列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format &#39;&#123;&#123;.Names&#125;&#125;&#39;)</span><br></pre></td></tr></table></figure></p><p>按指定镜像名称列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -f ancestor&#x3D;ubuntu</span><br></pre></td></tr></table></figure></p><p>删除所有未标签命名 (untagged) 的容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep “^” | awk &#39;&#123;split($0,a,&quot; &quot;); print a[3]&#125;&#39;)</span><br></pre></td></tr></table></figure></p><p>通过正则匹配删除指定容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep wildfly | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm -f</span><br></pre></td></tr></table></figure></p><p>删除所有已退出 (exited) 的容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a | grep Exit | awk &#39;&#123; print $1 &#125;&#39;)</span><br></pre></td></tr></table></figure></p><h3 id="将文件挂载为卷标">将文件挂载为卷标</h3><p>文件也可以被挂载为卷标。例如你可以仅仅注入单个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从容器复制文件</span></span><br><span class="line">docker run --rm httpd cat /usr/<span class="built_in">local</span>/apache2/conf/httpd.conf &gt; httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载修改后的配置启动容器</span></span><br><span class="line">docker run --rm -ti -v <span class="string">"<span class="variable">$PWD</span>/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro"</span> -p <span class="string">"80:80"</span> httpd</span><br></pre></td></tr></table></figure><h2 id="贡献手册contributing">贡献手册(Contributing)</h2><p>以下是如何贡献本速查表的说明。</p><h3 id="打开-readme.md">打开 README.md</h3><p>点击 <a href="https://github.com/wsargent/docker-cheat-sheet/blob/master/README.md" target="_blank" rel="noopener">README.md</a></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn" target="_blank" rel="noopener">GitHub docker-cheat-sheet</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要一起来完善这份速查表吗？&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 参见&lt;a href=&quot;#贡献手册contributing&quot;&gt;贡献手册&lt;/a&gt;部分吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：以下部分链接需科学上网后使用。&lt;/p&gt;
&lt;p&gt;Due to GFW, varies links below could not be accessed in China Mainland.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#为何使用-docker&quot;&gt;为何使用 Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#系统环境&quot;&gt;系统环境(Prerequisites)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装(Installation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#容器container&quot;&gt;容器(Containers)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#镜像images&quot;&gt;镜像(Images)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#网络networks&quot;&gt;网络(Networks)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#仓管中心和仓库registry--repository&quot;&gt;仓管中心和仓库(Registry &amp;amp; Repository)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dockerfile&quot;&gt;Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#层layers&quot;&gt;层(Layers)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#链接links&quot;&gt;链接(Links)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#卷标volumes&quot;&gt;卷标(Volumes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#暴露端口exposing-ports&quot;&gt;暴露端口(Exposing Ports)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#最佳实践&quot;&gt;最佳实践(Best Practices)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安全security&quot;&gt;安全(security)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#小贴士&quot;&gt;小贴士(Tips)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#贡献手册contributing&quot;&gt;贡献手册(Contributing)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://2020.iosdevlog.com/categories/docker/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>《DevOps 实战笔记》</title>
    <link href="https://2020.iosdevlog.com/2020/03/28/DevOps/"/>
    <id>https://2020.iosdevlog.com/2020/03/28/DevOps/</id>
    <published>2020-03-28T01:49:24.000Z</published>
    <updated>2020-04-03T14:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/0.png" /></p><blockquote><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>——维基百科<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>DevOps经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。</p><a id="more"></a><p>团队间沟通和协作的重要性一点也不亚于写代码、写文档、做测试之类的常规工作。</p><p>如何快速地持续交付高质量的软件，满足用户的多样化需求，并借此提升企业的利润和市场占有率，已经成为企业必须要面对的现实问题。</p><p>软件开发过程的改进，除了依赖于技术进步，还依赖于流程、理念、文化等全方位的改进，而这正是 DevOps 带给软件开发方式的一场革命。</p><p>DevOps 已经成为了所有 IT 从业人员应知应会的必备技能。</p><h2 id="devops-实践指南2">《DevOps 实践指南》<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><ul><li>如何梳理出一套清晰的 DevOps 理念和完整的知识体系？</li><li>如何获得一线大厂的实践经验，让 DevOps 真正落地？</li><li>如何获得一条渐进式的 DevOps 学习曲线，让自己在正确的方向上不断增值？</li></ul><h2 id="基础知识篇">基础知识篇</h2><p>DevOps 的定义、价值、实施与衡量，在最开始帮你建立起正确的 DevOps 体系认知。</p><p>软件工程诞生以来所历经的三个重要发展阶</p><ol type="1"><li>瀑布式开发模式</li><li>敏捷式开发模式</li><li>DevOps 模式</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/1.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/2.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/3.png" /></p><p>整个软件交付过程中，不仅只有开发和运维，业务也是重要的一环。</p><blockquote><p>DevOps 是通过平台（Platform）、流程（Process）和人（People）的有机整合，以 C（协作）A（自动化）L（精益）M（度量）S（共享）文化为指引，旨在建立一种可以快速交付价值并且具有持续改进能力的现代化 IT 组织。</p></blockquote><p>软件慢慢从企业内部的支撑系统和成本中心，变成了企业服务的直接载体和利润中心。</p><p>VUCA 时代</p><ol type="1"><li>易变性（Volatility）</li><li>不确定性（Uncertainty）</li><li>复杂性（Complexity）</li><li>模糊性（Ambiguity）</li></ol><p>软件交付的效率和质量成了当今企业的核心价值和核心竞争力。</p><p>“工业革命消灭了绝大多数的手工业群体，却催生了程序员这个现存最大的手工业群体”。</p><p>DevOps 的 4 个结果指标</p><ol type="1"><li><strong>部署频率</strong>：指应用和服务向生产环境部署代码的频率。</li><li><strong>变更前置时间</strong>：指代码从提交到成功运行在生产环境的时长。</li><li><strong>服务恢复时间</strong>：指线上应用和服务出现故障到恢复运行的时长。</li><li><strong>变更失败率</strong>：指应用和服务在生产环境部署失败或者部署后导致服务降级的比例。</li></ol><p>软件交付</p><ol type="1"><li>交付效率</li><li>交付质量</li></ol><p>高效能的组织不仅做到了高效率，还实现了高质量。</p><p><code>工具和文化</code></p><ul><li>DevOps 工具</li></ul><p>一切软件交付过程中的手动环节，都是未来可以尝试进行优化的方向。</p><ul><li>DevOps 文化</li></ul><p>在不同的文化制度下，相同的人发挥出来的生产力也会有天壤之别。</p><p>DevOps 的 3 个支柱</p><ol type="1"><li>人（People）</li><li>流程（Process）</li><li>平台（Platform）</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/4.png" /></p><p>技术采纳生命周期定律</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/5.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/6.png" /></p><p>步骤与原则</p><p><code>道法术器</code> DevOps：<code>法</code></p><ol type="1"><li>识别差距</li><li>锚定目标</li><li>关注能力</li><li>持续改进</li></ol><p>DevOps 实施的过程</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/7.png" alt="" /><figcaption>部署引力图</figcaption></figure><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/8.png" /></p><h2 id="落地实践篇">落地实践篇</h2><h3 id="转型路径">转型路径</h3><p>最核心的部分。我将带你通盘梳理 DevOps 的转型路径。</p><p><code>VSM</code> 是 Value Stream Mapping 的缩写，也就是我们常说的价值流图。</p><p>VSM 是企业 DevOps 转型的第一步。</p><p>《DevOps 实践指南》三步工作法</p><ul><li><strong>第一步：流动。</strong> 通过工作可视化，限制在制品数量，并注入一系列的工程实践，从而加速从开发到运营的流动过程，实现低风险的发布。</li><li><strong>第二步：反馈。</strong> 通过注入流动各个过程的反馈能力，使缺陷在第一时间被发现，用户和运营数据第一时间展示，从而提升组织的响应能力。</li><li><strong>第三步：持续学习和试验。</strong> 没有任何文化和流程是天生完美的，通过团队激励学习分享，将持续改进注入日常工作，使组织不断进步。</li></ul><p>通过流程和平台的结合，来驱动流程的自动化流转，这才是 DevOps 的正确姿势。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/9.png" alt="" /><figcaption>价值流交付图</figcaption></figure><p>价值</p><ol type="1"><li>看见全貌</li><li>识别问题</li><li>促进沟通</li><li>驱动度量</li><li>价值展现</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/10.jpeg" alt="" /><figcaption>VSM</figcaption></figure><h4 id="实施-devops-的常见路径">实施 DevOps 的常见路径</h4><ul><li>自底向上</li><li>自顶向下</li></ul><p>通用路径</p><ol type="1"><li>寻找合适的试点项目<ol type="1"><li>贴近核心业务</li><li>倾向敏捷业务</li><li>改进意愿优先</li></ol></li><li>寻找团队痛点</li><li>快速建立初期成功</li><li>快速展示和持续改进</li></ol><p>DevOps 转型的 J 型曲线</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/11.png" alt="" /><figcaption>J</figcaption></figure><p>转型小组</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/12.jpg" /></p><h3 id="敏捷实践">敏捷实践</h3><h4 id="如果业务不够敏捷it-再怎么努力也没用">如果业务不够敏捷，IT 再怎么努力也没用</h4><p>业务敏捷和交付能力二者缺一不可</p><p>关于需求分析： 影响地图</p><p>"Why-Who-How-What” 分析方法</p><ul><li>Why 代表目标，它可以是一个核心的业务目标，也可以是一个实际的用户需求。</li><li>Who 代表影响对象，也就是通过影响谁来实现这个目标。</li><li>How 代表影响，也就是怎样影响用户以实现我们的目标。</li><li>What 代表需要交付什么样的功能，可以带来期望的影响。</li></ul><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/13.png" alt="" /><figcaption>影响地图</figcaption></figure><p>卡诺模型（Kano Model）</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/14.png" alt="" /><figcaption>卡诺模型（Kano Model）</figcaption></figure><ol type="1"><li><strong>兴奋型</strong>：指超乎用户想象的需求，是可遇不可求的功能。比如用户想要一个更好的功能手机，乔布斯带来了 iPhone，这会给用户带来极大的满足感。</li><li><strong>期望型</strong>：用户的满意度会随着这类需求数量的增多而线性增长，做得越多，效果越好，但难以有质的突破。比如，一个电商平台最开始是卖书，后面逐步扩展到卖电脑、家居用品等多个类别。用户更多的线性需求被满足，满意度自然也会提升。</li><li><strong>必备型</strong>：这些是产品必须要有的功能，如果没有的话，会带来非常大的影响。不过有这些功能的话，也没人会夸你做得有多好，比如安全机制和风控机制等。</li><li><strong>无差别型</strong>：做了跟没做一样，这就是典型的无用功。比如你花了好大力气做了一个需求，但是几乎没有用户使用，这个需求就属于无差别型。</li><li><strong>反向型</strong>：无中生有类需求，实际上根本不具备使用条件，或者用户压根不这么想。这类需求做出来以后，通常会给用户带来很大的困扰，成为被吐槽的对象。</li></ol><p>核心要做到 3 点</p><ol type="1"><li>优先规划期望型和必备型需求，将其纳入日常的交付迭代中，保持一定的交付节奏；</li><li>识别无差别型和反向型需求，这些对于用户来说并没有产生价值。如果团队对需求的分类有争议，可以进一步开展用户调研和分析。</li><li>追求兴奋型需求，因为它会带来产品的竞争壁垒和差异化。</li></ol><p>用户故事拆分粒度，遵循 INVEST 原则</p><ul><li><strong>Independent（独立的）</strong>：减少用户故事之间的依赖，可以让用户故事更加灵活地验证和交付，而避免大批量交付对于业务敏捷性而言至关重要。</li><li><strong>Negotiable（可协商的）</strong>：用户故事不应该是滴水不漏、行政命令式的，而是要抛出一个场景描述，并在需求沟通阶段不断细化完成。</li><li><strong>Valuable（有价值的）</strong>：用户故事是以用户价值为核心的，所以每个故事都是在对用户交付价值，所以要站在用户的视角思考问题，避免像最近特别火的那句话一样：“我不要你觉得，我要我觉得。”</li><li><strong>Estimatable（可评估的）</strong>：用户故事应该可以粗略评估工作量，无论是故事点数还是时间，都可以。如果是一个预研性质的故事，则需要进一步深挖可行性，避免不知道为什么做而做。</li><li><strong>Small（小的）</strong>：用户故事应该是最小的交付颗粒度，所以按照敏捷开发方式，无论迭代还是看板，都需要在一个交付周期内完成。</li><li><strong>Testable（可测试的）</strong>：也就是验收条件，如果没有办法证明需求已经完成，也就没有办法进行验收和交付。</li></ul><p>MVP 原则</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/15.png" alt="" /><figcaption>MVP 原则</figcaption></figure><p>BizDevOps</p><p>引入业务的 DevOps，就成了 BizDevOps，这也是 DevOps 发展的一种潮流。</p><p>核心理念：</p><ul><li>对齐业务和开发目标、指标；</li><li>把握安全、合规指标；</li><li>及时对齐需求，减少无用开发；</li><li>体现 DevOps 的价值；</li><li>让开发团队开始接触业务，不单单是执行，调动积极性。</li></ul><h4 id="精益看板">精益看板</h4><p>《改变世界的机器》</p><p>加快价值流动是精益看板的核心</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/16.png" /></p><p>精益看板的实践方法</p><ol type="1"><li><p>可视化流程</p></li><li><p>定义清晰的规则</p><ol type="1"><li>可视化规则<ol type="1"><li>卡片的颜色<ol type="1"><li>需求（绿色）</li><li>缺陷（红色）</li><li>改进事项（蓝色）</li></ol></li><li>卡片的内容</li><li>卡片的依赖和阻塞状态</li></ol></li><li>显式化规则</li></ol></li><li><p>限制在制品数量</p><ol type="1"><li>需求流入节点</li><li>需求流出节点</li></ol></li><li><p>管理工作流程</p><ol type="1"><li>每日站会</li><li>队列填充会议</li><li>发布规划会议</li></ol></li><li><p>建立反馈和持续改进</p></li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/17.png" alt="" /><figcaption>看板</figcaption></figure><p>看板创始人 David J Anderson 总结了看板方法的成熟度模型，用于指导中大型团队实践看板方法</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/18.png" alt="" /><figcaption>kmm</figcaption></figure><h3 id="工程实践">工程实践</h3><h4 id="配置管理工程实践基础">配置管理：工程实践基础</h4><ol type="1"><li>版本变更标准化 Git<ol type="1"><li>提交概要信息</li><li>提交详细信息</li><li>提交关联需求</li></ol></li><li>将一切纳入版本控制<ol type="1"><li>制品管理</li><li>生成物不需要版本控制</li></ol></li><li>全流程可追溯</li><li>单一可信数据源</li></ol><h4 id="分支策略让研发高效协作的关键要素">分支策略：让研发高效协作的关键要素</h4><p><code>git flow</code></p><ol type="1"><li>主干开发，分支发布</li><li>分支开发，主干发布</li><li>主干开发，主干发布</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/19.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/20.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/21.png" /></p><p><code>git checkout feature1 &amp;&amp; git fetch origin &amp;&amp; git rebase -i origin/master</code></p><p>最常见的操作包括：</p><ol type="1"><li>p：选择提交；</li><li>r：更新提交的注释信息；</li><li>e：编辑提交，可以将一个提交拆分成多个；</li><li>s：压合提交，将多个提交合并成一个；</li><li>f：类似压合提交，但是放弃这个提交的注释信息，直接使用合并提交的注释信息；</li></ol><p>当然，在 git rebase 的交互界面中，你也可以调整提交的顺序，比如将特性功能和关联的 Bugfix 整合在一起。</p><h4 id="持续集成-ci">持续集成 CI</h4><p>CI 是 Continuous Integration 的缩写，也就是我们熟悉的持续集成</p><blockquote><p>CI 是一种软件开发实践，团队成员频繁地将他们的工作成果集成到一起（通常每人每天至少提交一次，这样每天就会有多次集成），并且在每次提交后，自动触发运行一次包含自动化验证集的构建任务，以便尽早地发现集成问题。</p></blockquote><p>——马丁·福勒（Martin Fowler）</p><p>越是痛苦的事情，就要越频繁地做。</p><p>实施 CI 三个阶段</p><ol type="1"><li>第一阶段：每次提交触发完整的流水线<ol type="1"><li>统一的分支策略</li><li>清晰的集成规则</li><li>标准化的资源池</li><li>足够快的反馈周期</li></ol></li><li>第二阶段：每次流水线触发自动化测试<ol type="1"><li>匹配合适的测试活动</li><li>树立测试结果的公信度</li><li>提升测试活动的有效性</li></ol></li><li>第三阶段：出了问题可以在第一时间修复</li></ol><h4 id="自动化测试devops的阿克琉斯之踵">自动化测试：DevOps的阿克琉斯之踵</h4><p>自动化测试建设也面临着一些问题</p><ol type="1"><li>投入产出比</li><li>上手门槛</li><li>维护成本高</li><li>测试设备投入高</li></ol><p>自动化测试的设计</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/22.png" /></p><p>DevOps Handbook</p><p>Web 应用</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/23.png" /></p><p>自动化测试的开发</p><ul><li>cURL</li><li>Postman</li><li>JMeter</li></ul><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/24.png" /></p><p>如果自动化测试覆盖率足够高，那么软件质量一定不会差到哪儿去。</p><p>自动化测试结果分析</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/25.png" /></p><h4 id="内建质量丰田和亚马逊给我们的启示">内建质量：丰田和亚马逊给我们的启示</h4><ol type="1"><li>问题发现得越早，修复成本就越低；</li><li>质量是每个人的责任，而不是质量团队的责任。</li></ol><p>在开发阶段，代码评审和持续集成就是一个非常好的内建质量的实践。</p><p>内建质量的实施步骤</p><ol type="1"><li>第一步：选择适合的检查类型</li><li>第二步：定义指标并达成一致<ol type="1"><li>参考值的定义是一门艺术</li><li>静态指标就是固定值</li></ol></li><li>第三步：建立自动化执行和检查能力</li><li>第四步：定义问题处理方式</li><li>第五步：持续优化和改进</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/26.png" /></p><p>核心目标不是为了通过质量门禁，而是为了质量提升，这才是最重要的。</p><p>内建质量的常见问题</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/27.jpg" /></p><h4 id="技术债务那些不可忽视的潜在问题">技术债务：那些不可忽视的潜在问题</h4><p>什么是技术债务？</p><blockquote><p>老板拍下来一个紧急需求，要求你在 3 天内开发完成上线。</p></blockquote><ul><li>方案 1：采用分层架构，引入消息队列。这样做的好处是结构清晰，功能解耦，但是需要 1 周的时间；</li><li>方案 2：直接在原有代码的基础上修修补补，硬塞进去一块逻辑和页面，这样做需要 2 天时间，还有 1 天时间来测试。</li></ul><p>代码维护的时间越长，引入的技术债务就会越多，从而使团队背上沉重的负担。</p><p>技术债务长什么样？</p><ul><li>一份代码里面定义了一堆全局变量，各个角落都在引用；</li><li>一个脚本仓库里面，一大堆名字看起来差不多的脚本，内容也都差不多；</li><li>一个函数里面修修补补写了上千行；数据表查询各种神奇的关联；</li><li>参数传递纯靠肉眼计算顺序；</li><li>因为修改一段代码引发了一系列莫名其妙的问题；</li><li>……</li></ul><p>七宗罪</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/28.jpg" /></p><p>为什么要重视技术债务？</p><ol type="1"><li>额外的研发成本</li><li>不稳定的产品质量</li><li>难以维护的产品</li></ol><p>如何量化技术债务？</p><p>目前业界比较常用的开源软件，就是 SonarQube。</p><p>解决方法和原则</p><p>解决技术债务步骤</p><ol type="1"><li>共识</li><li>可见</li><li>止损</li><li>改善</li></ol><p>4 条原则</p><ol type="1"><li>让技术债务呈良性下降趋势。</li><li>优先解决高频修改的问题。</li><li>在新项目中启动试点。</li><li>技术债务无法被消灭，也不要等到太晚。</li></ol><p>优先处理</p><ul><li>大量重复代码；</li><li>类之间的耦合严重；</li><li>方法过于复杂；</li><li>条件判断嵌套太多；</li><li>缺少必要的异常处理；</li><li>多表关联和缺少索引；</li><li>代码风险和缺陷；</li><li>安全漏洞。</li></ul><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/29.jpeg" /></p><h3 id="部署实践">部署实践</h3><h4 id="环境管理一切皆代码">环境管理：一切皆代码</h4><p>环境就成了软件行业的“头号背锅侠”。</p><p>环境管理的挑战</p><ol type="1"><li>环境种类繁多</li><li>环境复杂性上升</li><li>环境一致性难以保证</li><li>环境交付速度慢</li><li>环境变更难以追溯</li></ol><p>基础设施即代码就是用一种描述性的语言，通过文本管理环境配置，并且自动化完成环境配置的方式。</p><p>典型的就是以 <code>CAPS</code> 为代表的自动化环境配置管理工具，也就是 <code>Chef、Ansible、Puppet 和 Saltstacks</code> 四个开源工具的首字母缩写。</p><p>开发运维打通的 GitOps 实践</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/30.png" /></p><p>开发环境的治理实践</p><p>采用基础设施即代码的方法，生成一个包含全部工具依赖的 <code>Docker</code> 镜像，并分发给开发团队。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  harbor.devops.com:<span class="number">5000</span>/test:ansible </span><br><span class="line"><span class="keyword">MAINTAINER</span> XX &lt;xx@devops.com&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./docker  /docker</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /docker</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">export</span> TMPDIR=/var/tmp &amp;&amp; ansible-playbook -v -i playbooks/inventories/docker playbooks/docker_container.yml</span></span><br></pre></td></tr></table></figure><h4 id="部署管理低风险的部署发布策略">部署管理：低风险的部署发布策略</h4><p>部署和发布这两个概念，经常会被混用，但严格来说，部署和发布代表两种不同的实践。</p><p><code>部署</code> 是一组技术实践，表示通过技术手段，将本次开发测试完成的功能实体（比如代码、二进制包、配置文件、数据库等）应用到指定环境的过程，包括开发环境、预发布环境、生产环境等。部署的结果是对服务器进行变更，但是这个变更结果不一定对外可见。</p><p><code>发布，也就是 Release</code>，更偏向一种业务实践，也就是将部署完成的功能正式生效，对用户可见和提供服务的过程。</p><p>要在保障一定的质量水平的前提下，尽量加快发布节奏，并通过低风险发布手段，以及线上测试和监控能力，尽早地发现问题，并以一种最简单的手段来快速恢复。</p><ul><li>一定的质量水平</li><li>低风险发布手段</li><li>线上测试和监控</li><li>快速恢复</li></ul><p>低风险的发布手段</p><ol type="1"><li>蓝绿部署</li><li>灰度发布</li><li>暗部署</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/31.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/32.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/33.png" /></p><p><a href="https://www.gocd.org/2017/07/25/blue-green-deployments.html" target="_blank" rel="noopener" class="uri">https://www.gocd.org/2017/07/25/blue-green-deployments.html</a></p><p>线上测试和监控</p><p>开源的 GoReplay 工具</p><ol type="1"><li>采用灰度发布、用户众测等方式，逐步观察用户行为并收集用户数据，以验证新版本的可用性是否符合预期。</li><li>用户反馈</li><li>使用线上流量测试</li></ol><p>快速恢复</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/34.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/35.png" /></p><h4 id="混沌工程软件领域的反脆弱">混沌工程：软件领域的反脆弱</h4><blockquote><p>Chaos Engineering is the discipline of experimenting on a distributed system in order to build confidence in the system’s capability to withstand turbulent conditions in production.</p><p>混沌工程是一门在分布式系统上进行实验的学科，目的是建立人们对于复杂系统在生产环境中抵御突发事件的信心。</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/36.jpeg" /></p><p>故障演练就是针对以往发生过的问题进行有针对性地模拟演练。</p><p>混沌工程不是为了制造问题，而是为了揭示问题。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/37.png" /></p><p>混沌工程的原则</p><ul><li>建立稳定状态的假设</li><li>真实世界的事件</li><li>在生产中试验</li><li>持续的自动化实验</li><li>最小影响范围</li></ul><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/38.jpg" alt="" /><figcaption>参考指标</figcaption></figure><h3 id="度量改进">度量改进</h3><h4 id="正向度量如何建立完整的devops度量体系">正向度量：如何建立完整的DevOps度量体系？</h4><p>DevOps 希望做到的就是持续、快速和高质量的价值交付。</p><p>指标典型特征</p><ol type="1"><li>明确受众</li><li>直指问题</li><li>量化趋势</li><li>充满张力</li></ol><p>定义指标原则</p><ol type="1"><li><strong>全局指标优于局部指标</strong>：过度的局部优化可能对整体产出并无意义，从而偏离了度量的核心，也就是提升交付速度和交付质量。</li><li><strong>综合指标优于单一指标</strong>：从单一维度入手会陷入只见树木不见森林的困境，综合指标更加客观。所以，要解决一个问题，就需要一组指标来客观指引。</li><li><strong>结果指标优于过程指标</strong>：首先要有结果指标，以结果为导向，以过程为途径，一切过程指标都应该归结到结果指标。</li><li><strong>团队指标优于个人指标</strong>：优先考核团队指标而非个人指标，团队共享指标有助于形成内部合力，减少内部的割裂。</li><li><strong>灵活指标优于固化指标</strong>：指标的设立是为了有针对性地实施改进，需要考虑业务自身的差异性和改进方向，而非简单粗暴的“一刀切”，并且随着团队能力的上升，指标也需要适当的调整，从而不断挑战团队的能力。</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/39.jpeg" /></p><p>如何开启度量工作？</p><ol type="1"><li>第 1 步：细化指标</li><li>第 2 步：收集度量数据</li><li>第 3 步：建立可视化平台</li><li>第 4 步：识别瓶颈并持续改进</li></ol><p>指标宜少不宜多，宜精不宜烂</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/40.jpg" /></p><h4 id="持续改进pdca体系和持续改进的意义">持续改进：PDCA体系和持续改进的意义</h4><p>核心就是团队已经具备了持续改进的能力，而不只是简简单单地引入了几个工具，建立了几个度量指标而已。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/41.png" /></p><p>鼓励正向回溯和总结</p><p>故障回溯并不一定以确定责任为第一要务，更重要的是，要识别系统流程中的潜在问题和漏洞，并通过后续机制来进行保障，比如增加测试用例、增加产品走查事项等等。</p><p>其实，大到线上故障，小到日常错误，都值得回溯和总结。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/42.png" /></p><p>预留固定时间进行改进</p><p>在团队的 Backlog 中新增一类任务，专门用于记录和跟踪这类持续改进的内容。</p><h2 id="平台工具篇">平台工具篇</h2><p>涵盖平台建设的 3 个阶段、产品研发和设计、不可忽视的开源工具等，帮你找到快速搭建平台的钥匙。</p><h3 id="开源还是自研企业devops平台建设的三个阶段">开源还是自研：企业DevOps平台建设的三个阶段</h3><p>企业 DevOps 平台建设的三个阶段</p><p>阶段一：从无到有</p><p>核心原则就是选择主流工具</p><ul><li>需求管理工具 Jira；</li><li>知识管理工具 Confluence；</li><li>版本控制系统 GitLab；</li><li>持续集成工具 Jenkins；</li><li>代码质量工具 SonarQube；</li><li>构建工具 Maven/Gradle；</li><li>制品管理 Artifactory/Harbor；</li><li>配置管理工具 Ansible；</li><li>配置中心 Apollo；</li><li>测试工具 RF/Selenium/Appium/Jmeter/TestNG；安</li><li>全合规工具 BlackDuck/Fortify；</li><li>……</li></ul><p>阶段二：从小到大</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/43.png" /></p><p>阶段三：从繁到简</p><p>你要提供的不再是一个工具，而是一整套的解决方案；不是解决一个问题，而是解决交付过程中方方面面的问题。</p><p>DevOps 核心理念</p><ol type="1"><li>标准化：一切皆有规则，一切皆有标准；</li><li>自动化：干掉一切不必要的手工操作环节，能一键完成的，绝不操作两次；</li><li>服务化：面向用户设计，而不是面向专家设计，让每个人都能在没有外界依赖的前提下，完成自己的工作；</li><li>数据化：对数据进行收集、汇总、分析和展示，让客观数据呈现出来，让数据指导持续改进。</li></ol><h3 id="产品设计之道devops产品设计的五个层次">产品设计之道：DevOps产品设计的五个层次</h3><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/44.png" /></p><h3 id="持续交付平台现代流水线必备的十大特征">持续交付平台：现代流水线必备的十大特征</h3><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/45.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/46.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/47.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/48.png" /></p><h3 id="让数据说话如何建设企业级数据度量平台">让数据说话：如何建设企业级数据度量平台？</h3><p>事前：指标共识</p><p><strong>数据本身不会说话，是人们赋予了数据意义</strong>，而“这个意义“就是度量指标。</p><p>事中：平台建设</p><p>挑战一：大量数据源平台对接</p><p>插件化：数据采集器</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/49.png" alt="" /><figcaption>数据采集器</figcaption></figure><p>挑战二：海量数据存储分析</p><ol type="1"><li>数据量大</li><li>数据结构不统一</li><li>数据访问频</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/50.png" alt="" /><figcaption>数据度量的架构图</figcaption></figure><p>事后：规则落地</p><h3 id="平台产品研发">平台产品研发</h3><p>开发策略</p><p><strong>研发环境容器化</strong></p><p>开发协作流程</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/51.png" alt="" /><figcaption>图片版</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/52.png" alt="" /><figcaption>文字版</figcaption></figure><p>产品运营策略</p><p>团队不仅要做得好，还要善于运营和宣传，而这又是技术团队的一大软肋。</p><p>很多事情其实没有没有多难，关键就看有没有想，有没有坚持做。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/53.png" alt="" /><figcaption>文字版</figcaption></figure><p>团队文化建设</p><ol type="1"><li>让专业的人做专业的事情</li><li>抓大放小，适当地忽略细节</li></ol><h3 id="开源工具">开源工具</h3><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/54.png" alt="" /><figcaption>系统的架构图</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/55.png" alt="" /><figcaption>系统关系示意图</figcaption></figure><h3 id="迈向云端云原生应用时代的平台思考">迈向云端：云原生应用时代的平台思考</h3><blockquote><p>Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization.</p><p>云原生使用一种开源软件技术栈来部署微服务应用，将每个组件打包到它自己的容器中，并且通过动态编排来优化资源的利用率。</p></blockquote><p>开源软件、微服务应用、容器化部署和动态编排</p><ol type="1"><li>自动化生成依赖的配置文件<ol type="1"><li>Dockerfile：用于生成 Docker 镜像</li><li>Jenkinsfile：应用关联的流水线配置</li><li>Helm Chart：把应用打包并部署运行在 Kubernetes 上的资源文件</li><li>Skaffold：用于在 Kubernetes 中生成 Docker image 的工具</li></ol></li><li>自动化流水线过程<ol type="1"><li>流水线即代码</li><li>流水线的抽象和复用</li><li>流水线的条件判断</li></ol></li><li>自动化多环境部署</li><li>使用云原生流水线</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/56.jpeg" alt="" /><figcaption>Serverless Jenkins 和 Tekton 的关系示意图</figcaption></figure><h2 id="转型案例篇">转型案例篇</h2><p>提到的理论、落地实践和工具融入其中，融会贯通。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/57.png" alt="" /><figcaption>微软的 Azure DevOps 平台</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/58.jpeg" alt="" /><figcaption>爆炸半径</figcaption></figure><h2 id="成为devops工程师的必备技能">成为DevOps工程师的必备技能</h2><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/59.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/60.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/61.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/62.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/63.jpeg" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/64.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/65.jpg" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/DevOps" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/DevOps</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/235" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/235</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/28/DevOps/0.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——维基百科&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DevOps经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="action" scheme="https://2020.iosdevlog.com/tags/action/"/>
    
  </entry>
  
  <entry>
    <title>设计图生成 App，Supernova 限时免费</title>
    <link href="https://2020.iosdevlog.com/2020/03/27/supernova/"/>
    <id>https://2020.iosdevlog.com/2020/03/27/supernova/</id>
    <published>2020-03-27T14:05:53.000Z</published>
    <updated>2020-03-27T14:23:28.036Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://2020.iosdevlog.com/2020/03/27/supernova/supernano.jpg" alt="" /><figcaption>Supernano</figcaption></figure><ul><li>Sketch 和 Adobe XD 原型</li><li>----&gt;</li><li>Flutter，iOS，Android，React Native App</li></ul><p>Supernano 可以帮助设计师直接创建出可运行的原生 App，或是帮助工程师们大大减少花费在拼 UI 上的时间消耗。</p><a id="more"></a><p>由于 <strong>COVID-19 新型冠状病毒</strong> 引起的近期事件，<em>Supernova 公司</em>将免费开放 Supernova 的所有功能，直到 2020年6月1日。</p><p>他们希望消除创建应用程序的所有限制，可能会增加构建工具以协助和应对这种前所未有的情况以及未来发展的可能性。 <em>Supernova 公司</em> 还希望它减轻当前经济不确定性所造成的任何财务负担。</p><h2 id="如何加入-supernova">如何加入 Supernova</h2><p>如果您是 Supernova 的新手，请在 <a href="https://supernova.io/" target="_blank" rel="noopener">supernova.io</a>（mac only！）上下载它，打开该应用程序，然后完成注册过程。</p><p>如果您已经是用户，请登录并更新到8.5版。</p><p>您应该会收到以下公告：</p><p><img src="https://2020.iosdevlog.com/2020/03/27/supernova/unlock.png" /></p><p>单击“解锁所有功能”以消除对该产品的所有限制。</p><p>请享用。</p><h2 id="问答环节">问答环节</h2><p>Windows可用吗？</p><blockquote><p>很不幸的是，不行。 <em>Supernova 公司</em> 已按原样解锁了当前产品的所有功能。它仍然是仅Mac应用程序。 <em>Supernova 公司</em> 正在努力尽快发布基于云的版本。</p></blockquote><p>我对 Supernova 的使用有什么限制吗？</p><blockquote><p>不，所有功能均已解锁，因此您可以充分利用 Supernova 的潜力。您可以导入Sketch 和 Adobe XD 文件，原型并转换为 Flutter，iOS，Android 和React Native，而没有任何产品限制。有关使用 Supernova 的更多信息，请访问 <em>Supernova 公司</em> 的文档。</p></blockquote><p>我已经支付了每月或每年的 Supernova 许可证，这对我来说意味着什么？</p><blockquote><p><em>Supernova 公司</em> 已经为您的帐户免费提供了三个月的信用额。</p></blockquote><p>当这结束时会发生什么？</p><blockquote><p><em>Supernova 公司</em> 会在6月1日前一周提醒所有用户更改其帐户，以避免不必要的费用。您可以在帐户设置中选择退订或继续使用 Supernova 的付费版本。查看 <em>Supernova 公司</em> 的定价页面以获取有关计划的更多详细信息。</p></blockquote><p>详情：<a href="https://medium.com/@appsupernova/full-supernova-functionality-free-408bf912237f" target="_blank" rel="noopener">Full Supernova Functionality, Free</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/27/supernova/supernano.jpg&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;Supernano&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Sketch 和 Adobe XD 原型&lt;/li&gt;
&lt;li&gt;----&amp;gt;&lt;/li&gt;
&lt;li&gt;Flutter，iOS，Android，React Native App&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Supernano 可以帮助设计师直接创建出可运行的原生 App，或是帮助工程师们大大减少花费在拼 UI 上的时间消耗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="https://2020.iosdevlog.com/categories/software/"/>
    
    
      <category term="Android" scheme="https://2020.iosdevlog.com/tags/Android/"/>
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/tags/iOS/"/>
    
      <category term="UI" scheme="https://2020.iosdevlog.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Docker 实践</title>
    <link href="https://2020.iosdevlog.com/2020/03/27/docker/"/>
    <id>https://2020.iosdevlog.com/2020/03/27/docker/</id>
    <published>2020-03-27T10:55:24.000Z</published>
    <updated>2020-03-28T16:34:59.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/27/docker/docker-cheat-sheet.png" /></p><ul><li>Image/镜像: 系统镜像 CentOS.iso</li><li>Container/容器: 虚拟机 VM</li><li>Docker Hub: 镜像中心 GitHub</li></ul><a id="more"></a><p>查看 container ID / Get the ID of the container by using the docker ps command.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>停止 container / Use the docker stop command to stop the container.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Swap out &lt;the-container-id&gt; with the ID from docker ps</span></span><br><span class="line">docker stop &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><p>删除 container，<code>-f</code> 强删 / Once the container has stopped, you can remove it by using the docker rm command.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><h2 id="centos-8-新用户">CentOS 8 新用户</h2><p><code>root</code> 帐号添加新用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser iosdevlog</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure><p>添加 <code>iosdevlog</code> 那一行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">iosdevlog       ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>切换到 iosdevlog</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - iosdevlog</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h2 id="安装-docker">安装 Docker</h2><p><a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Get Started with Docker</a></p><p>设置仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装 Docker Engine-Community</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io --nobest</span><br></pre></td></tr></table></figure><p>启动 Docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="非-root-用户运行">非 root 用户运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br><span class="line"><span class="comment"># sudo groupadd -g 999 docker </span></span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker <span class="comment"># 将当前用户加入到 docker 用户组中</span></span><br><span class="line">newgrp docker  <span class="comment"># 更新用户组</span></span><br><span class="line">sudo systemctl restart docker <span class="comment"># 重启 docker-daemon</span></span><br><span class="line">docker version <span class="comment"># 运行 docker</span></span><br></pre></td></tr></table></figure><h2 id="docker-101-tutorial"><a href="https://www.docker.com/101-tutorial" target="_blank" rel="noopener">Docker 101 Tutorial</a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></table></figure><p>You'll notice a few flags being used. Here's some more info on them:</p><ul><li><code>-d</code> - run the container in detached mode (in the background)</li><li><code>-p 80:80</code> - map port 80 of the host to port 80 in the container</li><li><code>docker/getting-started</code> - the image to use</li></ul><p>查看 <code>container</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>remove container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><h2 id="dev-开发">dev 开发</h2><p><code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install --production</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>创建 <code>image</code> -t tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><p>运行刚才创建的 <code>getting-started</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 getting-started</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-                &lt;p className="text-center"&gt;No items yet! Add one above!&lt;/p&gt;</span></span><br><span class="line"><span class="addition">+                &lt;p className="text-center"&gt;You have no todo items yet! Add one above!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/diff.png" /></p><h2 id="docker-hub"><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></h2><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/docker_hub.png" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login -u iosdevlog</span><br><span class="line">docker tag getting-started iosdevlog/getting-started</span><br><span class="line">docker push iosdevlog/getting-started</span><br></pre></td></tr></table></figure><h2 id="play-with-docker"><a href="http://play-with-docker.com/" target="_blank" rel="noopener">Play with Docker</a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 iosdevlog/getting-started</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/Play_with_Docker.png" /></p><p>打开 3000 按钮</p><h3 id="持久化-persisting-our-todo-data">持久化 Persisting our Todo Data¶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create todo-db</span><br><span class="line">docker run -dp 3000:3000 -v todo-db:&#x2F;etc&#x2F;todos iosdevlog&#x2F;getting-started</span><br></pre></td></tr></table></figure><p>数据保存位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect todo-db</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2020-03-27T12:28:25Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/todo-db/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"todo-db"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/data.png" /></p><h3 id="绑定挂载-using-bind-mounts">绑定挂载 Using Bind Mounts</h3><ul><li><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Named Volumes</th><th>Bind Mounts</th><th></th></tr></thead><tbody><tr class="odd"><td>Host Location</td><td>Docker chooses</td><td>You control</td></tr><tr class="even"><td>Mount Example (using -v)</td><td>my-volume:/usr/local/data</td><td>/path/to/data:/usr/local/data</td></tr><tr class="odd"><td>Populates new volume with container contents</td><td>Yes</td><td>No</td></tr><tr class="even"><td>Supports Volume Drivers</td><td>Yes</td><td>No</td></tr></tbody></table></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">    -w /app -v <span class="variable">$PWD</span>:/app \</span><br><span class="line">    node:12-alpine \</span><br><span class="line">    sh -c <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br></pre></td></tr></table></figure><p>查看 logs</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f &lt;container-id&gt;</span><br><span class="line">$ nodemon src/index.js</span><br><span class="line">[nodemon] 1.19.2</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Using sqlite database at /etc/todos/todo.db</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p><code>src/static/js/app.js</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-                         &#123;submitting ? 'Adding...' : 'Add Item'&#125;</span></span><br><span class="line"><span class="addition">+                         &#123;submitting ? 'Adding...' : 'Add'&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/add.png" /></p><p>Using bind mounts is very common for local development setups.</p><p>在本地开发设置中，使用绑定挂载很常见。</p><p>开发完成后就可以创建自己的 <code>image</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><h2 id="多个容器-multi-container-apps">多个容器 Multi-Container Apps</h2><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/multi-app-architecture.png" /></p><h3 id="create-the-network.">Create the network.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create todo-app</span><br></pre></td></tr></table></figure><p>Start a MySQL container and attach it the network.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --network todo-app --network-alias mysql \</span><br><span class="line">    -v todo-mysql-data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">    -e MYSQL_DATABASE=todos \</span><br><span class="line">    mysql:5.7</span><br></pre></td></tr></table></figure><p>connect to the database</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;mysql-container-id&gt; mysql -p</span><br><span class="line">Enter password: secret</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| todos              |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.05 sec)</span><br></pre></td></tr></table></figure><h3 id="connecting-to-mysql">Connecting to MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network todo-app nicolaka/netshoot</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nicolaka/netshoot:latest</span><br><span class="line">                    dP            dP                           dP   </span><br><span class="line">                    88            88                           88   </span><br><span class="line">88d888b. .d8888b. d8888P .d8888b. 88d888b. .d8888b. .d8888b. d8888P </span><br><span class="line">88<span class="string">'  `88 88ooood8   88   Y8ooooo. 88'</span>  `88 88<span class="string">'  `88 88'</span>  `88   88   </span><br><span class="line">88    88 88.  ...   88         88 88    88 88.  .88 88.  .88   88   </span><br><span class="line">dP    dP `88888P<span class="string">'   dP   `88888P'</span> dP    dP `88888P<span class="string">' `88888P'</span>   dP   </span><br><span class="line">                                                                    </span><br><span class="line">Welcome to Netshoot! (github.com/nicolaka/netshoot)</span><br></pre></td></tr></table></figure><p><code>dig</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig mysql</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.14</span><span class="number">.8</span> &lt;&lt;&gt;&gt; mysql</span><br><span class="line">;; <span class="keyword">global</span> options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">61687</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">1</span>, AUTHORITY: <span class="number">0</span>, ADDITIONAL: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;mysql.<span class="keyword">IN</span>A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">mysql.<span class="number">600</span><span class="keyword">IN</span>A<span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">7</span> msec</span><br><span class="line">;; SERVER: <span class="number">127.0</span><span class="number">.0</span><span class="number">.11</span><span class="meta">#53(127.0.0.11)</span></span><br><span class="line">;; <span class="keyword">WHEN</span>: Fri Mar <span class="number">27</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">31</span> UTC <span class="number">2020</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">44</span></span><br></pre></td></tr></table></figure><ul><li>MYSQL_HOST - the hostname for the running MySQL server</li><li>MYSQL_USER - the username to use for the connection</li><li>MYSQL_PASSWORD - the password to use for the connection</li><li>MYSQL_DB - the database to use once connected</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">  -w /app -v <span class="variable">$PWD</span>:/app \</span><br><span class="line">  --network todo-app \</span><br><span class="line">  -e MYSQL_HOST=mysql \</span><br><span class="line">  -e MYSQL_USER=root \</span><br><span class="line">  -e MYSQL_PASSWORD=secret \</span><br><span class="line">  -e MYSQL_DB=todos \</span><br><span class="line">  node:12-alpine \</span><br><span class="line">  sh -c <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br></pre></td></tr></table></figure><p><code>docker logs &lt;container-id&gt;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn install v1.22.0</span><br><span class="line">[1/4] Resolving packages...</span><br><span class="line">success Already up-to-date.</span><br><span class="line">Done <span class="keyword">in</span> 0.54s.</span><br><span class="line">yarn run v1.22.0</span><br><span class="line">$ nodemon src/index.js</span><br><span class="line">[nodemon] 1.19.2</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Waiting <span class="keyword">for</span> mysql:3306.</span><br><span class="line">Connected!</span><br><span class="line">Connected to mysql db at host mysql</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p><code>docker exec -ti &lt;mysql-container-id&gt; mysql -p todos</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from todo_items;</span><br><span class="line">+--------------------------------------+---------------------------------------+-----------+</span><br><span class="line">| id                                   | name                                  | completed |</span><br><span class="line">+--------------------------------------+---------------------------------------+-----------+</span><br><span class="line">| 9b3dc86c-2ec9-4413-8a71-28b3c3515358 | DevOps                                |         0 |</span><br><span class="line">| 9428c285-e5e1-4f50-bf11-ee854cc8554f | Hello, I<span class="string">'m AIDevLog. Welcome to 2020! |         0 |</span></span><br><span class="line"><span class="string">+--------------------------------------+---------------------------------------+-----------+</span></span><br><span class="line"><span class="string">2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/MySQL.png" /></p><h2 id="docker-compose">docker-compose</h2><p><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener" class="uri">https://docs.docker.com/compose/install/</a></p><p>Compose 使用的三个步骤：</p><ol type="1"><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.4/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>output</p><blockquote><p>docker-compose version 1.25.4, build 8d51620a</p></blockquote><p>Creating our Compose File</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pwd: app</span><br><span class="line">cat docker-compose.yml</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.7"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:12-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">secret</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">todos</span></span><br></pre></td></tr></table></figure><p>Running our Application Stack</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p>docker-compose up</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>output</p><blockquote><p>Creating network "app_default" with the default driver<br /><br />Creating volume "app_todo-mysql-data" with default driver<br /><br />Creating app_mysql_1 ... done<br /><br />Creating app_app_1 ... done</p></blockquote><p><code>log</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Attaching to app_mysql_1, app_app_1</span><br><span class="line">app_1    | yarn install v1.22.0</span><br><span class="line">app_1    | [1&#x2F;4] Resolving packages...</span><br><span class="line">...</span><br><span class="line">app_1    | Waiting for mysql:3306...............</span><br><span class="line">app_1    | Connected!</span><br><span class="line">app_1    | Connected to mysql db at host mysql</span><br><span class="line">app_1    | Listening on port 3000</span><br><span class="line">mysql_1  | 2020-03-27 16:37:47+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.29-1debian10 started.</span><br><span class="line">...</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.309134Z 0 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.309309Z 0 [Note] mysqld: ready for connections.</span><br><span class="line">mysql_1  | Version: &#39;5.7.29&#39;  socket: &#39;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock&#39;  port: 3306  MySQL Community Server (GPL)</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.365195Z 2 [Note] Got an error reading communication packets</span><br></pre></td></tr></table></figure><p>Tearing it All Down</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="image-building-best-practices">Image Building Best Practices</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">history</span> getting-started</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">7e58c32dc1b5        5 hours ago         /bin/sh -c <span class="comment">#(nop)  CMD ["node" "/app/src/ind…   0B                  </span></span><br><span class="line">ebe4a0dcca7e        5 hours ago         /bin/sh -c yarn install --production            83.2MB              </span><br><span class="line">3fd0eef12d70        5 hours ago         /bin/sh -c <span class="comment">#(nop) COPY dir:2f31be1c05e031e42…   6.65MB              </span></span><br><span class="line">c164b9c205a1        5 hours ago         /bin/sh -c <span class="comment">#(nop) WORKDIR /app                  0B                  </span></span><br><span class="line">f77abbe89ac1        3 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["node"]                 0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENTRYPOINT ["docker-entry…   0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop) COPY file:238737301d473041…   116B                </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c apk add --no-cache --virtual .bui…   7.62MB              </span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENV YARN_VERSION=1.22.0      0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.9MB              </span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENV NODE_VERSION=12.16.1     0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/sh"]              0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop) ADD file:0c4555f363c2672e3…   5.6MB</span></span><br></pre></td></tr></table></figure><h3 id="layer-caching">Layer Caching¶</h3><p>Update the Dockerfile to copy in the <code>package.json</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json yarn.lock ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install --production</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>Build a new image using docker build</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><p>更改 <code>src/static/index.html</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/static/index.html b/src/static/index.html</span><br><span class="line">index a606bf1..19cfb57 100644</span><br><span class="line"><span class="comment">--- a/src/static/index.html</span></span><br><span class="line"><span class="comment">+++ b/src/static/index.html</span></span><br><span class="line"><span class="meta">@@ -8,7 +8,7 @@</span></span><br><span class="line">     &lt;link rel="stylesheet" href="css/font-awesome/all.min.css" crossorigin="anonymous" /&gt;</span><br><span class="line">     &lt;link href="https://fonts.googleapis.com/css?family=Lato&amp;display=swap" rel="stylesheet" /&gt;</span><br><span class="line">     &lt;link rel="stylesheet" href="css/styles.css" /&gt;</span><br><span class="line"><span class="deletion">-    &lt;title&gt;Todo App&lt;/title&gt;</span></span><br><span class="line"><span class="addition">+    &lt;title&gt;AIDevLog Todo App&lt;/title&gt;</span></span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">     &lt;div id="root"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>docker build</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br><span class="line">Sending build context to Docker daemon  65.73MB</span><br><span class="line">Step 1/6 : FROM node:12-alpine</span><br><span class="line"> ---&gt; f77abbe89ac1</span><br><span class="line">Step 2/6 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; c164b9c205a1</span><br><span class="line">Step 3/6 : COPY package.json yarn.lock ./</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 77446d8145bc</span><br><span class="line">Step 4/6 : RUN yarn install --production</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f0323073e6ce</span><br><span class="line">Step 5/6 : COPY . .</span><br><span class="line"> ---&gt; 0e1288f88991</span><br><span class="line">Step 6/6 : CMD [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> f3a0bd941311</span><br><span class="line">Removing intermediate container f3a0bd941311</span><br><span class="line"> ---&gt; 2abff2421550</span><br><span class="line">Successfully built 2abff2421550</span><br><span class="line">Successfully tagged getting-started:latest</span><br></pre></td></tr></table></figure><h2 id="docker-cheatsheets.md"><a href="https://gist.github.com/JustinTW/10236453" target="_blank" rel="noopener">Docker-Cheatsheets.md</a></h2><h3 id="clean-all">Clean all</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop `docker ps -a -q` </span><br><span class="line">docker rm `docker ps -a -q` </span><br><span class="line">docker rmi -f `sudo docker images -q`</span><br><span class="line">docker volume rm $(docker volume ls -f dangling=<span class="literal">true</span> -q)</span><br></pre></td></tr></table></figure><h3 id="clean-image">Clean <none> image</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images --no-trunc | grep none | awk <span class="string">'&#123;print $3&#125;'</span> | xargs docker rmi -f</span><br></pre></td></tr></table></figure><h3 id="change-docker-image-location">Change docker image location</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btrfs subvolume create /mnt/disk/@docker</span><br><span class="line">rsync -aqxP /var/lib/docker/* /mnt/disk/@docker</span><br></pre></td></tr></table></figure><ul><li>method 1: <code>變更 docker 儲存路徑</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>:[<span class="string">"https://cache-docker.hopebaytech.com"</span>],</span><br><span class="line">  <span class="string">"insecure-registries"</span>:[<span class="string">"docker:5000"</span>],</span><br><span class="line">  <span class="string">"dns"</span>:[<span class="string">"172.16.1.254"</span>, <span class="string">"8.8.8.8"</span>],</span><br><span class="line">  <span class="string">"graph"</span>: <span class="string">"/mnt/disk/docker"</span>,</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"btrfs"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新啟動服務</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="啟動設定檔位置">啟動設定檔位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;docker.conf</span><br></pre></td></tr></table></figure><h3 id="attach-a-running-container">Attach a running container</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list containers</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach a running containers</span></span><br><span class="line">docker attach [CONTAINER ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach a running containers into bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t arkease-pro-web bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/27/docker/docker-cheat-sheet.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Image/镜像: 系统镜像 CentOS.iso&lt;/li&gt;
&lt;li&gt;Container/容器: 虚拟机 VM&lt;/li&gt;
&lt;li&gt;Docker Hub: 镜像中心 GitHub&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://2020.iosdevlog.com/categories/docker/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>AI Cheatsheets</title>
    <link href="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/"/>
    <id>https://2020.iosdevlog.com/2020/03/26/aicheatsheets/</id>
    <published>2020-03-26T15:45:13.000Z</published>
    <updated>2020-03-26T16:41:00.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scipy.png" /></p><p>我什么时候能总结得这么好呢？</p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Numpy.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-3.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/matplotlib-cheatsheet.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Matplotlib.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scikit_learn.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_network_cells.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_network_graphs.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_networks_zoo.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-3.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Keras.jpg" /></p><p><a href="https://aicheatsheets.com" target="_blank" rel="noopener" class="uri">https://aicheatsheets.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scipy.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我什么时候能总结得这么好呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="cheatsheets" scheme="https://2020.iosdevlog.com/tags/cheatsheets/"/>
    
      <category term="numpy" scheme="https://2020.iosdevlog.com/tags/numpy/"/>
    
      <category term="scipy" scheme="https://2020.iosdevlog.com/tags/scipy/"/>
    
      <category term="matplotlib" scheme="https://2020.iosdevlog.com/tags/matplotlib/"/>
    
      <category term="pandas" scheme="https://2020.iosdevlog.com/tags/pandas/"/>
    
      <category term="tf" scheme="https://2020.iosdevlog.com/tags/tf/"/>
    
      <category term="keras" scheme="https://2020.iosdevlog.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>表格化数据挖掘</title>
    <link href="https://2020.iosdevlog.com/2020/03/25/table/"/>
    <id>https://2020.iosdevlog.com/2020/03/25/table/</id>
    <published>2020-03-25T10:06:00.000Z</published>
    <updated>2020-03-25T13:52:39.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/25/table/0.png" /></p><a id="more"></a><h2 id="经典的结构化数据挖掘方法">经典的结构化数据挖掘方法</h2><h3 id="什么是结构化数据">什么是结构化数据</h3><ul><li><p>结构化数据指的主要是表格数据(Tabular Data)</p></li><li><p>最简单的想象:可以记载在 Excel 表格中的均是表格数据</p><ul><li><p>每列数据一般称之为一个变量(字段)</p></li><li><p>变量可以分为离散型变量和连续型变量</p></li></ul></li><li><p>绝大多数的数据都是表格数据(或可以转化为表格数据)</p></li></ul><h3 id="结构化数据的传统建模流程">结构化数据的传统建模流程</h3><ul><li><p>传统来说(在某种意义上仍是如此)，结构化数据常常要求大量的业务理解</p></li><li><p>探索性数据分析往往占很大成分</p></li><li><p>90% 时间花在清洗数据和探索性分析上</p></li></ul><h3 id="传统建模流程的问题">传统建模流程的问题</h3><ul><li><p>最核心的悖论:业务理解从哪里来?</p></li><li><p>一些实际的问题</p><ul><li><p>高维稀疏变量</p></li><li><p>较差的变量质量</p></li><li><p>类似的业务理解能力</p></li><li><p>业务的多变性</p></li></ul></li></ul><h2 id="表格化数据挖掘基本流程">表格化数据挖掘基本流程</h2><h3 id="数据挖掘竞赛和新的建模流程">数据挖掘竞赛和新的建模流程</h3><ul><li><p>竞赛基本流程</p></li><li><p>挑战</p><ul><li><p>无业务理解</p></li><li><p>少数提交机会</p></li><li><p>测试集和训练集可能不一样-&gt; 建模结果必须稳定</p></li><li><p>时间短暂，必须充分利用时间</p></li></ul></li><li><p>数据挖掘竞赛和实际业务中的建模有类似挑战，但有一点重要不同</p><ul><li>实际业务建模必须要逐步引入更多变量，而竞赛中变量已经给定</li></ul></li></ul><h3 id="新的流程">新的流程</h3><ul><li><p>数据清理和EDA</p></li><li><p>半自动的变量构建+手动构建</p></li><li><p>一类模型主要提高准确率，另一些模型做集成备选</p><ul><li><p>传统来说主要用于提高准确率的是靠集成树的方法</p></li><li><p>近年来神经网络为基础的建模越来越多</p></li></ul></li><li><p>集成学习</p><ul><li><p>被集成的模型必须有一定准确性</p></li><li><p>被集成的模型必须有一定的多样性</p></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/03/25/table/1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/25/table/2.png" /></p><h3 id="关于新的流程的一些说明">关于新的流程的一些说明</h3><ul><li><p>前三个环节经常需要反复进行</p></li><li><p>基本原则:尽可能利用算力和时间</p></li><li><p>不同人对于 EDA 重要性说法不同，个人建议初学者以实验为主</p></li><li><p>非常重要的原则:结合全局和局部信息</p></li></ul><h2 id="半自动特征构建">半自动特征构建</h2><h3 id="target-mean-encoding">Target Mean Encoding</h3><ul><li><p>Target Mean Encoding 简介</p><ul><li><p>对于离散变量最有效编码方法之一</p></li><li><p>对于维度较高的离散性变量效果很好</p></li><li><p>重点在于防止过拟合</p></li></ul></li><li><p>其他的 Groupby 函数应用</p><ul><li><p>实现 Target Mean Encoding 可以使用 df.groupby([A,B])[C].agg(func)</p></li><li><p>Groupby 函数可以应用于任何其他变量，在某种程度上捕捉了多变量之间的交叉效应</p></li><li><p>Func 可以是多种函数，如 mean，std，kurtosis，min，max 等等</p></li><li><p>可以对残差进行以上操作</p></li></ul></li></ul><h3 id="categorical-encoders">Categorical Encoders</h3><ul><li><p>One-hot Encoder</p></li><li><p>Ordinal Encoder</p></li><li><p>其他 Encoder</p><ul><li><p>Count Encoder</p></li><li><p>HashMap</p></li></ul></li></ul><h3 id="连续变量的离散化方法">连续变量的离散化方法</h3><ul><li><p>为什么要对连续变量进行离散化</p><ul><li><p>捕捉非线性效应</p></li><li><p>捕捉交叉效应</p></li></ul></li><li><p>常见的离散化方法</p><ul><li><p>Uniform</p></li><li><p>基于 Quantile</p></li><li><p>基于聚类</p></li><li><p>基于树</p></li></ul></li><li><p>树模型</p></li></ul><h3 id="entity-embedding">Entity Embedding</h3><ul><li><p>Entity Embedding 基础</p></li><li><p>如何加入 Vincinal Information</p></li></ul><h3 id="连续变量的转换">连续变量的转换</h3><ul><li><p>常见的数据转换方法</p></li><li><p>基于 ECDF 的方法</p></li><li><p>Box-Cox 变换和 Yeo-Johnson Transform</p></li></ul><h3 id="缺失值和异常值的处理">缺失值和异常值的处理</h3><ul><li><p>概述</p><ul><li><p>异常值和缺失值的定义常常是难以确定的</p></li><li><p>异常值的检验最可靠的方法</p><ul><li><p>EDA 加上业务逻辑</p></li><li><p>可以根据分位数或其他方法(其他方法未必靠谱)</p></li><li><p>如果异常值是由于输入失误造成的，则可以将之作为缺失值处理</p></li></ul></li><li><p>缺失值的填充往往可以根据业务决定</p><ul><li><p>其他可以采用平均值、中位数或众数进行填充</p></li><li><p>也可以单独构建模型进行预测</p></li></ul></li></ul></li><li><p>常见处理方法</p><ul><li><p>缺失值的填充往往可以根据业务决定</p></li><li><p>缺失和异常本身可能是有信息量的，可以构造哑变量进行处理</p><ul><li>成租的缺失值和异常值本身可能是有信息的</li></ul></li><li><p>对于部分异常值，还需要进行截断处理</p></li><li><p>对于重要的缺失变量，很有可能需要进行预测</p></li><li><p>R 中的一些包，如 MICE，可以帮助进行缺失值和异常值的处理</p></li></ul></li></ul><h2 id="自动特征构建方法">自动特征构建方法</h2><h3 id="自动特征挖掘">自动特征挖掘</h3><ul><li><p>应用</p></li><li><p>难点:组合优化问题</p></li></ul><h3 id="遗传算法简介">遗传算法简介</h3><h3 id="symbolic-learning-简介">Symbolic Learning 简介</h3><ul><li><p>采用遗传算法找寻如何构造衍生变量</p></li><li><p>在 gplearn 库当中已经实现</p></li></ul><h3 id="autocross-简介">AutoCross 简介</h3><ul><li><p>第四范式开发(未开源)</p></li><li><p>主要目的:寻找交叉效应</p></li><li><p>创新</p><ul><li><p>Beam Search</p></li><li><p>简化的逻辑回归求解方式</p></li></ul></li><li><p>可以进行提升</p><ul><li><p>Meta Feature</p></li><li><p>更好的优化方法</p></li></ul></li></ul><h2 id="降维方法">降维方法</h2><h3 id="pcanmf-和-tsne">PCA，NMF 和 tSNE</h3><ul><li><p>为什么要降维</p><ul><li><p>找到宏观信息</p></li><li><p>找到交叉效应</p></li><li><p>不建议先降维再拟合模型</p></li></ul></li><li><p>PCA和NMF简介</p></li><li><p>tSNE 简介</p></li><li><p>实现</p><ul><li><p>在 sklearn 当中均有实现</p><ul><li><p>PCA</p></li><li><p>NMF</p></li><li><p>tSNE</p></li></ul></li></ul></li><li><p>应用</p><ul><li><p>隐藏维度的选择取决于数据</p></li><li><p>数据需要进行预处理</p></li><li><p>标准化</p></li><li><p>选取重要变量</p></li><li><p>去掉过于稀疏的个别变量</p></li><li><p>可构建2折和3折交叉效应</p></li><li><p>降维方法的参数并不十分重要，一般来说如果有时间，选取所有参数并拟合模型进行测试</p></li></ul></li></ul><h3 id="denoising-autoencoder">Denoising AutoEncoder</h3><ul><li><p>Denoising AutoEncoder 简介</p></li><li><p>实践中的注意事项</p><ul><li><p>DAE 一般对多模态有很好效果</p></li><li><p>一般的噪声范畴:5%-20%</p></li><li><p>其他降维方法的 trick 也适用于 DAE</p></li><li><p>注意将中间层均拿出来进行预测</p></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/03/25/table/3.png" /></p><h3 id="variational-autoencoder">Variational AutoEncoder</h3><ul><li><p>Variational AutoEncoder 的数学形式</p></li><li><p>实践中的注意事项</p><ul><li><p>VAE 的实现可见</p></li><li><p>VAE 是很火的研究领域</p></li><li><p>训练常常难以收敛</p></li><li><p>在实际应用中较罕见</p></li></ul></li></ul><h2 id="变量选择方法">变量选择方法</h2><h3 id="概述">概述</h3><ul><li><p>变量重要 = 哲学问题</p></li><li><p>优化角度 = 组合优化问题</p></li><li><p>初步选择可根据数据特点</p><ul><li>最重要的指标为缺失值和变化率</li></ul></li><li><p>其他的一些选择方法</p><ul><li><p>“去一”的选择方法(主要方法)</p></li><li><p>模型相关的方法-&gt;和模型高度相关，不可靠</p></li><li><p>其他优化方法-&gt;不成熟</p></li></ul></li></ul><h3 id="去一选择法">“去一”选择法</h3><ul><li><p>整体流程</p></li><li><p>问题</p></li></ul><h2 id="集成树模型">集成树模型</h2><h3 id="概述-1">概述</h3><ul><li><p>树模型的缺点和优点</p><ul><li><p>优点</p><ul><li><p>非线性效应</p></li><li><p>交叉效应</p></li><li><p>稀疏</p></li></ul></li><li><p>缺点</p><ul><li><p>不稳定</p></li><li><p>表现力差</p></li><li><p>精度差</p></li></ul></li></ul></li><li><p>集成树模型分类</p><ul><li><p>基本思路</p><ul><li>将多个树模型构成进行平均</li></ul></li><li><p>方法</p><ul><li><p>随机森林类</p></li><li><p>随机森林</p></li><li><p>ExtraTrees</p></li><li><p>梯度提升树</p><ul><li><p>GBDT</p></li><li><p>XGBoost</p></li><li><p>LightGBM</p></li><li><p>CatBoost</p></li></ul></li></ul></li></ul></li></ul><h3 id="gbdt-和-xgboost">GBDT 和 XgBoost</h3><ul><li><p>GBDT 的数学</p></li><li><p>XgBoost 的数学</p></li><li><p>XgBoost 的实现</p></li><li><p>XgBoost 的重要参数</p><ul><li><p>最重要的参数</p><ul><li>树的深度</li></ul></li><li><p>其他参数</p><ul><li><p>Eta:一般选取为 0.01-0.2</p></li><li><p>min_child_weight:建议进行 CV finetune</p></li><li><p>Gamma:建议进行 CV finetune</p></li></ul></li></ul></li></ul><p>整理自：<a href="https://github.com/geektime-geekbang/NLP" target="_blank" rel="noopener">《NLP实战高手课》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/25/table/0.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="DataMining" scheme="https://2020.iosdevlog.com/tags/DataMining/"/>
    
  </entry>
  
  <entry>
    <title>《10x程序员工作法》思维导图</title>
    <link href="https://2020.iosdevlog.com/2020/03/24/10x/"/>
    <id>https://2020.iosdevlog.com/2020/03/24/10x/</id>
    <published>2020-03-24T13:44:30.000Z</published>
    <updated>2020-03-24T14:42:03.645Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/24/10x/10x.svg" /></p><a id="more"></a><h2 id="以终为始">以终为始</h2><h3 id="重点">重点</h3><ul><li><p>DoD，确定好完成的定义，减少团队内部的理解不一致。</p></li><li><p>用户故事，细化出有价值的需求。</p></li><li><p>持续集成，通过尽早集成，减少改动量，降低集成的难度。</p></li><li><p>精益创业，减少过度开发不确定性产品带来的浪费。</p></li><li><p>迭代 0，在项目开始之前，做好一些基础准备。</p></li></ul><h3 id="思维转变">思维转变</h3><ul><li><p>任何事物都要经过两次创造：</p><ul><li><p>头脑中的创造，也就是智力上的或者第一次创造（Mental/First Creation）</p></li><li><p>付诸实践，也就是实际的构建或第二次创造（Physical/Second Creation）</p></li></ul></li><li><p>在更大的上下文内发现自己的“终”</p></li><li><p>通过推演，找到通往“终”的路径</p></li><li><p>用可度量的“数字”定义自己的“终”</p></li></ul><h3 id="实战指南">实战指南</h3><ul><li><p>遇到事情，倒着想</p></li><li><p>在做任何事之前，先定义完成的标准</p></li><li><p>在做任何需求或任务之前，先定好验收标准</p></li><li><p>尽早提交代码去集成</p></li><li><p>默认所有需求都不做，直到弄清楚为什么要做这件事</p></li><li><p>扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上</p></li><li><p>在动手做一件事之前，先推演一番</p></li><li><p>问一下自己，我的工作是不是可以用数字衡量</p></li><li><p>设计你的迭代 0 清单，给自己的项目做体检</p></li></ul><h2 id="任务分解">任务分解</h2><h3 id="重点-1">重点</h3><ul><li><p>测试金字塔</p><ul><li><p>行业中测试组合的最佳实践</p></li><li><p>多写单元测试是关键</p></li></ul></li><li><p>测试驱动开发</p><ul><li><p>测试驱动开发的节奏</p><ul><li><p>红——绿——重构</p></li><li><p>重构是测试驱动开发区别于测试先行的关键</p></li></ul></li><li><p>测试驱动设计</p></li><li><p>编写可测的代码</p></li></ul></li><li><p>艾森豪威尔矩阵（Eisenhower Matrix）</p><ul><li><p>将事情按照重要和紧急进行划分</p></li><li><p>重要且紧急的事情要立即做</p></li><li><p>重要但不紧急的事情应该是我们重点投入精力的地方</p></li><li><p>紧急但不重要的事情，可以委托别人做</p></li><li><p>不重要不紧急的事情，尽量少做</p></li></ul></li><li><p>最小可行产品</p><ul><li><p>“刚刚好”满足客户需求的产品</p></li><li><p>在实践中，要用最小的代价找到一条可行的路径</p></li></ul></li></ul><h3 id="实战指南-1">实战指南</h3><ul><li><p>动手做一个工作之前，请先对它进行任务分解</p></li><li><p>多写单元测试</p></li><li><p>我们应该编写可测的代码</p></li><li><p>将任务拆小，越小越好</p></li><li><p>按照完整实现一个需求的顺序去安排分解出来的任务</p></li><li><p>要想写好测试，就要写简单的测试</p></li><li><p>想要管理好需求，先把需求拆小</p></li><li><p>尽量做最重要的事</p></li><li><p>做好产品开发，最可行的方式是采用 MVP</p></li></ul><h3 id="评判标准">评判标准</h3><ul><li><p>尽量不写 static 方法</p></li><li><p>主分支开发模型是一种更好的开发分支模型</p></li><li><p>好的用户故事应该符合 INVEST 原则</p></li><li><p>估算是一个加深对需求理解的过程，好的估算是以任务分解为基础的</p></li><li><p>好的测试应该符合 A-TRIP</p></li></ul><h3 id="改善">改善</h3><ul><li><p>分而治之，是人类解决问题的基本手段</p></li><li><p>软件变更成本，它会随着时间和开发阶段逐步增加</p></li><li><p>测试框架把自动化测试作为一种最佳实践引入到开发过程中<br />使得测试动作可以通过标准化的手段固定下来</p></li><li><p>极限编程之所以叫“极限”，它背后的理念就是把好的实践推向极限</p></li><li><p>大师级程序员的工作秘笈是任务分解，分解到可以进行的微操作</p></li><li><p>按照完整实现一个需求的顺序安排开发任务</p></li></ul><h3 id="额外">额外</h3><ul><li><p>对不了解技术的任务，先要去了解技术，然后再做任务分解</p></li><li><p>通过一次技术 Spike ，学习新技术</p></li><li><p>丢弃掉在 Spike 过程中开发的原型代码</p></li><li><p>分清目标与现状，用目标作为方向，指导现状的改变</p></li><li><p>多个功能并行开发可以考虑使用 Feature Toggle</p></li><li><p>在遗留系统上做改造可以考虑使用 Branch by Abstraction</p></li></ul><h2 id="任务分解-1">任务分解</h2><h3 id="重点-2">重点</h3><ul><li><p>看板</p><ul><li><p>一种来自精益生产的可视化实践</p></li><li><p>按阶段将任务放置其中</p></li><li><p>可以帮助我们发现问题</p></li></ul></li><li><p>持续集成</p><ul><li><p>做好持续集成的关键是，快速反馈</p></li><li><p>本地检查通过之后再提交</p></li><li><p>找到有效的反馈方式，比如：CI 监视器</p></li><li><p>持续集成的纪律</p></li><li><p>只有 CI 服务器处于绿色的状态才能提交代码</p></li><li><p>CI 服务器一旦检查出错，要立即修复</p></li></ul></li><li><p>回顾会议</p><ul><li><p>软件团队复盘的一种实践</p></li><li><p>枚举关注点，选出重点，深入讨论，列出行动项，找到负责人</p></li></ul></li><li><p>5 个为什么</p><ul><li><p>又一个来自丰田的实践</p></li><li><p>沿着一条主线追问多个问题</p></li></ul></li></ul><h3 id="实战指南-2">实战指南</h3><ul><li><p>通过沟通反馈，不断升级自己的编解码能力</p></li><li><p>用业务的语言写代码</p></li><li><p>多面对面沟通，少开会</p></li><li><p>多尝试用可视化的方式进行沟通</p></li><li><p>做好持续集成的关键在于，快速反馈</p></li><li><p>定期复盘，找准问题根因，不断改善</p></li><li><p>多走近用户</p></li><li><p>事情往前做，有问题尽早暴露</p></li><li><p>多输出，让知识更有结构</p></li></ul><h3 id="思路">思路</h3><ul><li><p>用信息论理解沟通反馈</p></li><li><p>写代码的进阶路径编写可以运行的代码</p><ul><li><p>编写符合代码规范的代码</p></li><li><p>编写人可以理解的代码</p></li><li><p>用业务语言写代码</p></li></ul></li><li><p>会议是一种重量级的沟通方式</p><ul><li><p>减少参会人数</p></li><li><p>找人面对面沟通</p></li></ul></li><li><p>聆听用户声音</p><ul><li><p>能做自己用户，做自己的用户</p></li><li><p>能接近用户，接近用户</p></li><li><p>没有用户，创造用户</p></li></ul></li><li><p>Fail Fast</p><ul><li><p>一种编写代码的原则</p></li><li><p>出现问题尽早报错</p></li></ul></li><li><p>金字塔原理</p><ul><li>从中心论点，到分论点，再到论据</li></ul></li></ul><h3 id="额外-1">额外</h3><ul><li><p>持续集成是一条主线，可以将诸多实践贯穿起来</p><ul><li><p>从持续集成到稳定的开发分支，到频繁提交，足够小的任务，到任务分解</p></li><li><p>从持续集成到可检查</p></li><li><p>到测试防护网</p></li><li><p>到测试覆盖率</p></li><li><p>到单元测试</p></li><li><p>到可测试代码</p></li><li><p>到软件设计</p></li></ul></li><li><p>安全性检查，是回顾会议的前提条件</p></li><li><p>在信息获取上，国内外程序员差别不大，开拓视野，改善工作习惯，是国内程序员亟需提高的</p></li></ul><h2 id="自动化">自动化</h2><h3 id="重点-3">重点</h3><ul><li><p>持续交付</p><ul><li><p>将生产部署纳入了开发的考量</p></li><li><p>持续交付的基础设施通常包含持续集成环境、测试环境、预生产环境和生产环境</p></li><li><p>构建流水线保证到了下游的交付物一定是通过上游验证的</p></li><li><p>随着 Docker 的诞生，交付由发布包变成了 Docker 镜像</p></li></ul></li><li><p>DevOps</p><ul><li><p>将开发和运维结合到一起</p></li><li><p>环境配置工具上的进步，让基础设施即代码成了行业共识</p></li></ul></li><li><p>验收测试</p><ul><li><p>站在业务的角度编写</p></li><li><p>BDD 是一种编写验收测试的方式</p></li><li><p>Given…When…Then… 的描述给了一个描述业务的统一方式</p></li><li><p>写好验收测试，需要构建测试模型</p></li></ul></li><li><p>SOLID 原则</p><ul><li><p>设计模式背后的道理</p></li><li><p>单一职责原则（Single responsibility principle，SRP）</p></li><li><p>开放封闭原则（Open–closed principle，OCP）</p></li><li><p>Liskov 替换原则（Liskov substitution principle，LSP）</p></li><li><p>接口隔离原则（Interface segregation principle，ISP）</p></li><li><p>依赖倒置原则（Dependency inversion principle，DIP）</p></li><li><p>用好单一职责原则，前提条件是看待问题颗粒度要小</p></li></ul></li><li><p>DDD</p><ul><li><p>它将思考的起点拉到了业务上</p></li><li><p>DDD 分为战略设计和战术设计</p></li></ul></li><li><p>微服务</p><ul><li><p>做好微服务的前提是划分好限界上下文</p></li><li><p>微服务的第一步，不要划分微服务</p></li></ul></li></ul><h3 id="实战指南-3">实战指南</h3><ul><li><p>请谨慎地将工作自动化</p></li><li><p>将你的工作过程自动化</p></li><li><p>有体系地学习运维知识</p></li><li><p>将部署纳入开发的考量</p></li><li><p>将验收测试自动化</p></li><li><p>把函数写短</p></li><li><p>构建好你的领域模型</p></li><li><p>用简单技术解决问题，直到问题变复杂</p></li><li><p>学习领域驱动设计</p></li></ul><h3 id="改善-1">改善</h3><ul><li><p>程序员的三大美德</p><ul><li><p>懒惰（Laziness）</p></li><li><p>急躁（Impatience）</p></li><li><p>懒惰（hubris）</p></li></ul></li><li><p>小心 NIH 综合症（Not Invented Here Syndrome）</p></li><li><p>写好构建脚本，做好项目自动化</p></li><li><p>参照 Java 知识体系，学习运维知识</p></li><li><p>软件设计最基础的原则是“高内聚、低耦合”</p></li><li><p>分层架构是一种设计上的分解</p></li><li><p>不同业务量的系统本质上不是一个系统</p></li><li><p>采用简单技术解决问题，直到问题变复杂</p></li></ul><h3 id="额外-2">额外</h3><ul><li><p>持续集成的延伸</p><ul><li><p>持续集成完成系统集成</p></li><li><p>持续交付完成可部署上线</p></li><li><p>“持续验证”完成产品想法验证</p></li></ul></li><li><p>AB 测试，用一个软件的多个版本验证想法</p></li><li><p>Selenium 用以完成浏览器的自动化</p></li><li><p>熟练使用快捷键</p></li></ul><p><a href="https://www.douban.com/doulist/113366760/" target="_blank" rel="noopener">推荐书</a></p><p>总结自：<a href="https://time.geekbang.org/column/intro/148" target="_blank" rel="noopener">《10x程序员工作法》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/24/10x/10x.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="效率" scheme="https://2020.iosdevlog.com/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="mindmap" scheme="https://2020.iosdevlog.com/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>[译] Python 测试入门</title>
    <link href="https://2020.iosdevlog.com/2020/03/23/test/"/>
    <id>https://2020.iosdevlog.com/2020/03/23/test/</id>
    <published>2020-03-23T02:57:42.000Z</published>
    <updated>2020-03-23T04:14:30.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/23/test/Getting-Started-with-Testing-in-Python_Watermarked.png" /></p><a id="more"></a><p>本教程适用于使用Python编写了出色的应用程序但尚未编写任何测试的任何人。</p><p>使用Python进行测试是一个巨大的话题，并且可能会带来很多复杂性，但是并不需要很困难。您可以通过几个简单的步骤开始为您的应用程序创建简单的测试，然后从那里开始进行构建。</p><p>在本教程中，您将学习如何创建基本测试，执行测试以及在用户之前查找错误！您将了解可用于编写和执行测试，检查应用程序性能甚至查找安全问题的工具。</p><h2 id="测试您的代码">测试您的代码</h2><p>有很多方法可以测试您的代码。在本教程中，您将从最基本的步骤中学习技术，并朝着高级方法学习。</p><h3 id="自动化与手动测试">自动化与手动测试</h3><p>好消息是，您可能已经创建了一个未意识到的测试。还记得您第一次运行应用程序并使用它吗？您是否检查了功能并尝试使用它们？这称为<strong>探索性测试</strong>，是手动测试的一种形式。</p><p>探索性测试是无计划的测试形式。在探索性测试中，您只是在探索应用程序。</p><p>要拥有一套完整的手动测试，您要做的就是列出应用程序具有的所有功能，可以接受的不同输入类型以及预期结果。现在，每次更改代码时，都需要遍历该列表中的每个项目并进行检查。</p><p>听起来不那么有趣，不是吗？</p><p>这就是自动测试的用处。自动测试是通过脚本而不是人工执行测试计划（您要测试的应用程序部分，要测试它们的顺序以及预期的响应）的执行。Python已经提供了一组工具和库来帮助您为应用程序创建自动化测试。在本教程中，我们将探索那些工具和库。</p><h3 id="单元测试与集成测试">单元测试与集成测试</h3><p>测试领​​域不乏术语，现在您已经知道自动测试和手动测试之间的区别，现在该更深入了。</p><p>想想如何测试汽车的灯光。您将打开灯（称为<strong>测试步骤</strong>）并离开车外，或请朋友检查灯是否点亮（称为<strong>测试断言</strong>）。测试多个组件称为<strong>集成测试</strong>。</p><p>考虑所有需要正确工作的事物，以使一个简单的任务获得正确的结果。这些组件就像您的应用程序的部分，您编写的所有类，函数和模块一样。</p><p>集成测试的主要挑战是，集成测试无法给出正确的结果。如果无法找出系统的哪一部分发生故障，很难诊断问题。如果灯不亮，则可能是灯泡坏了。电池没电了吗？交流发电机呢？汽车的计算机出故障了吗？</p><p>如果您有一辆豪华的现代汽车，它将在灯泡熄灭时告诉您。它使用<strong>单元测试</strong>的形式进行此操作。</p><p>单元测试是一种较小的测试，它检查单个组件是否以正确的方式运行。单元测试可帮助您隔离应用程序中损坏的内容并更快地对其进行修复。</p><p>您刚刚看过两种测试：</p><ol type="1"><li>集成测试将检查应用程序中的组件是否相互配合。</li><li>单元测试检查应用程序中的一小部分。</li></ol><p>您可以使用Python编写集成测试和单元测试。要为内置功能编写单元测试<code>sum()</code>，您需要<code>sum()</code>对照已知输出检查输出。</p><p>例如，下面是检查<code>sum()</code>数字<code>(1, 2, 3)</code>等于的方法<code>6</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br></pre></td></tr></table></figure><p>由于值正确，因此不会在REPL上输出任何内容。</p><p>如果来自的结果<code>sum()</code>不正确，则会失败并显示<code>AssertionError</code>和消息<code>"Should be 6"</code>。再次尝试使用错误值的断言语句以查看<code>AssertionError</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> sum([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AssertionError: Should be <span class="number">6</span></span><br></pre></td></tr></table></figure><p>在REPL中，您看到一个 <code>AssertionError</code> 抛出，因为的结果<code>sum()</code>不匹配<code>6</code>。</p><p>与其在REPL上进行测试，不如将其放入一个名为的新Python文件中<code>test_sum.py</code>并再次执行：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test_sum()</span><br><span class="line">    print(<span class="string">"Everything passed"</span>)</span><br></pre></td></tr></table></figure></p><p>现在，您已经编写了一个<strong>测试用例</strong>，一个断言和一个入口点（命令行）。您现在可以在命令行中执行此操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test_sum.py</span><br><span class="line">Everything passed</span><br></pre></td></tr></table></figure><p>您可以看到成功的结果<code>Everything passed</code>。</p><p>在Python中，将<code>sum()</code>任何iterable作为其第一个参数。您使用列表进行了测试。现在也用元组测试。<code>test_sum_2.py</code>使用以下代码创建一个名为的新文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_tuple</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sum((<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    test_sum()</span><br><span class="line">    test_sum_tuple()</span><br><span class="line">    print(<span class="string">"Everything passed"</span>)</span><br></pre></td></tr></table></figure><p>当执行时<code>test_sum_2.py</code>，脚本将给出错误，因为<code>sum()</code>of <code>(1, 2, 2)</code>是<code>5</code>，不是<code>6</code>。脚本的结果为您提供错误消息，代码行和回溯：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python test_sum_2.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"test_sum_2.py"</span>, line 9, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"> test_sum_tuple()</span><br><span class="line"> File <span class="string">"test_sum_2.py"</span>, line 5, <span class="keyword">in</span> test_sum_tuple</span><br><span class="line"> assert sum((1, 2, 2)) == 6, <span class="string">"Should be 6"</span></span><br><span class="line">AssertionError: Should be 6</span><br></pre></td></tr></table></figure><p>在这里，您可以看到代码中的错误如何在控制台上产生错误，并提供有关错误的位置和预期的结果的一些信息。</p><p>以这种方式编写测试对于一个简单的检查是可以的，但是如果多个测试失败了怎么办？这是测试运行程序的用处。测试运行程序是一个特殊的应用程序，用于运行测试，检查输出并为您提供调试和诊断测试及应用程序的工具。</p><h3 id="选择测试运行工具">选择测试运行工具</h3><p>有许多可用于Python的测试运行器。Python标准库中内置的一个称为<code>unittest</code>。在本教程中，您将使用<code>unittest</code>测试用例和<code>unittest</code>测试运行器。的原理<code>unittest</code>很容易移植到其他框架。三种最受欢迎​​的测试运行工具是：</p><ul><li><code>unittest</code></li><li><code>nose</code> / <code>nose2</code></li><li><code>pytest</code></li></ul><p>为您的需求和经验水平选择最佳的测试运行工具很重要。</p><h4 id="unittest"><code>unittest</code></h4><p><code>unittest</code>从2.1版开始已内置到Python标准库中。您可能会在商业Python应用程序和开源项目中看到它。</p><p><code>unittest</code>包含测试框架和测试运行器。<code>unittest</code>对编写和执行测试有一些重要要求。</p><p><code>unittest</code> 要求：</p><ul><li>您将测试作为方法放入类中</li><li>您在<code>unittest.TestCase</code>类中使用了一系列特殊的断言方法，而不是内置<code>assert</code>语句</li></ul><p>要将先前的示例转换为<code>unittest</code>测试用例，您必须：</p><ol type="1"><li><code>unittest</code>从标准库导入</li><li>创建一个<code>TestSum</code>从<code>TestCase</code>该类继承的类</li><li>通过添加<code>self</code>第一个参数将测试函数转换为方法</li><li>更改断言以<code>self.assertEqual()</code>在<code>TestCase</code>类上使用方法</li><li>将命令行入口点更改为call <code>unittest.main()</code></li></ol><p>按照以下步骤操作<code>test_sum_unittest.py</code>，使用以下代码创建一个新文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), <span class="number">6</span>, <span class="string">"Should be 6"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_tuple</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(sum((<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)), <span class="number">6</span>, <span class="string">"Should be 6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>如果在命令行上执行此操作，则会看到一个成功（以<code>.</code>表示）和一个失败（以<code>F</code>表示）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python test_sum_unittest.py</span><br><span class="line">.F</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_sum_tuple (__main__.TestSum)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"test_sum_unittest.py"</span>, line 9, <span class="keyword">in</span> test_sum_tuple</span><br><span class="line"> self.assertEqual(sum((1, 2, 2)), 6, <span class="string">"Should be 6"</span>)</span><br><span class="line">AssertionError: Should be 6</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure><p>您刚刚使用<code>unittest</code>测试运行器执行了两个测试。</p><p><strong>注意：</strong>如果要编写需要同时在Python 2和3中执行的测试用例，请务必小心。在python 2.7及以下版本中，<code>unittest</code>称为<code>unittest2</code>。如果仅从中导入<code>unittest</code>，则将在Python 2和3之间获得具有不同功能的不同版本。</p><p>有关更多信息<code>unittest</code>，您可以浏览单元测试<a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">文档</a>。</p><h4 id="nose"><code>nose</code></h4><p>随着时间的流逝，您可能会发现，随着为应用程序编写数百甚至数千个测试，变得越来越难以理解和使用的输出<code>unittest</code>。</p><p><code>nose</code>与使用该<code>unittest</code>框架编写的任何测试兼容，并且可以用作<code>unittest</code>测试运行程序的直接替代品。<code>nose</code>作为开源应用程序的开发落后了，<code>nose2</code>因此创建了一个名为fork的分支。如果您是从头开始的，建议您使用<code>nose2</code>而不是<code>nose</code>。</p><p>要开始使用<code>nose2</code>，请<code>nose2</code>从PyPI 安装并在命令行上执行。<code>nose2</code>将尝试在当前目录中发现所有命名的测试脚本<code>test*.py</code>和继承的测试用例<code>unittest.TestCase</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pip install nose2</span><br><span class="line">$ python -m nose2</span><br><span class="line">.F</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_sum_tuple (__main__.TestSum)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"test_sum_unittest.py"</span>, line 9, <span class="keyword">in</span> test_sum_tuple</span><br><span class="line"> self.assertEqual(sum((1, 2, 2)), 6, <span class="string">"Should be 6"</span>)</span><br><span class="line">AssertionError: Should be 6</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure><p>您刚刚执行了<code>test_sum_unittest.py</code>从<code>nose2</code>测试运行程序创建的测试。<code>nose2</code>提供了许多命令行标志来过滤您执行的测试。有关更多信息，您可以浏览<a href="https://nose2.readthedocs.io/" target="_blank" rel="noopener">Nose 2文档</a>。</p><h4 id="pytest"><code>pytest</code></h4><p><code>pytest</code>支持<code>unittest</code>测试用例的执行。<code>pytest</code>编写<code>pytest</code>测试用例是其真正的优势。<code>pytest</code>测试用例是Python文件中名称开头的一系列函数<code>test_</code>。</p><p><code>pytest</code> 还有其他一些很棒的功能：</p><ul><li>支持内置<code>assert</code>语句，而不是使用特殊<code>self.assert*()</code>方法</li><li>支持筛选测试用例</li><li>能够从上次失败的测试中重新运行</li><li>包含数百个插件的生态系统，以扩展功能</li></ul><p>编写<code>TestSum</code>测试用例示例<code>pytest</code>将如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_tuple</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> sum((<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)) == <span class="number">6</span>, <span class="string">"Should be 6"</span></span><br></pre></td></tr></table></figure><p>您已经删除了<code>TestCase</code>，对类的任何使用以及命令行入口点。</p><p>可以在<a href="https://docs.pytest.org/en/latest/" target="_blank" rel="noopener">Pytest文档网站上</a>找到更多信息。</p><h2 id="编写您的第一个测试">编写您的第一个测试</h2><p>让我们将到目前为止所学的知识汇总起来，而不是测试内置<code>sum()</code>功能，而是测试相同需求的简单实现。</p><p>创建一个新的项目文件夹，并在其中创建一个名为的新文件夹<code>my_sum</code>。在内部<code>my_sum</code>，创建一个名为的空文件<code>__init__.py</code>。创建<code>__init__.py</code>文件意味着<code>my_sum</code>可以从父目录将文件夹作为模块导入。</p><p>您的项目文件夹应如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│</span><br><span class="line">└── my_sum&#x2F;</span><br><span class="line">    └── __init__.py</span><br></pre></td></tr></table></figure><p>打开<code>my_sum/__init__.py</code>并创建一个名为的新函数<code>sum()</code>，该函数接受一个可迭代的（列表，元组或集合）并将这些值加在一起：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(arg)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> arg:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure></p><p>此代码示例创建一个名为的变量<code>total</code>，遍历其中的所有值<code>arg</code>，并将它们添加到中<code>total</code>。一旦迭代结束，它将返回结果。</p><h3 id="在哪里编写测试">在哪里编写测试</h3><p>要开始编写测试，您只需创建一个名为的文件<code>test.py</code>，其中将包含您的第一个测试用例。由于该文件将需要能够导入您的应用程序以进行测试，因此您希望将其放置<code>test.py</code>在package文件夹上方，因此目录树将如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_sum/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">|</span><br><span class="line">└── test.py</span><br></pre></td></tr></table></figure><p>您会发现，随着添加越来越多的测试，单个文件将变得混乱并且难以维护，因此您可以创建一个名为的文件夹<code>tests/</code>并将测试拆分为多个文件。按照惯例，请确保每个文件均以<code>test_</code> 开头，因此所有测试运行程序都将假定Python文件包含要执行的测试。一些非常大的项目根据测试的目的或用途将测试划分为更多的子目录。</p><p><strong>注意：</strong>如果您的应用程序是单个脚本怎么办？</p><p>您可以使用内置函数 <code>__import__()</code> 导入脚本的任何属性，例如类，函数和变量。替换 <code>from my_sum import sum</code>，您可以编写以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target = __import__(<span class="string">"my_sum.py"</span>)</span><br><span class="line">sum = target.sum</span><br></pre></td></tr></table></figure><p>使用 <code>__import__()</code> 的好处是您不必将项目文件夹变成一个包，您可以指定文件名。如果您的文件名与任何标准库包冲突，这也很有用。例如，<code>math.py</code>将与<code>math</code>模块碰撞。</p><h3 id="如何构造一个简单的测试">如何构造一个简单的测试</h3><p>在开始编写测试之前，您需要首先做出几个决定：</p><ol type="1"><li>您要测试什么？</li><li>您正在编写单元测试还是集成测试？</li></ol><p>然后，测试的结构应大致遵循以下工作流程：</p><ol type="1"><li>创建您的输入</li><li>执行被测试的代码，捕获输出</li><li>将输出与预期结果进行比较</li></ol><p>对于此应用程序，您正在测试<code>sum()</code>。<code>sum()</code>您可以检查许多行为，例如：</p><ul><li>可以对整数（整数）列表求和吗？</li><li>可以对一个元组或集合求和吗？</li><li>可以汇总一个浮动列表吗？</li><li>为它提供错误的值（例如单个整数或字符串）时会发生什么？</li><li>如果其中一个值为负，会发生什么？</li></ul><p>最简单的测试是整数列表。<code>test.py</code>使用以下Python代码创建文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_sum <span class="keyword">import</span> sum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_int</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that it can sum a list of integers</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        result = sum(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>此代码示例：</p><ol type="1"><li><code>sum()</code>从<code>my_sum</code>您创建的包中导入</li><li>定义一个名为的新测试用例类<code>TestSum</code>，该类继承自<code>unittest.TestCase</code></li><li>定义一种测试方法，<code>.test_list_int()</code>以测试整数列表。该方法<code>.test_list_int()</code>将：<ul><li><code>data</code>用数字列表声明一个变量<code>(1, 2, 3)</code></li><li>将的结果分配<code>my_sum.sum(data)</code>给<code>result</code>变量</li><li><code>unittest.TestCase</code> 类里的 <code>.assertEqual()</code> 方法断言结果值等于</li></ul></li><li>定义一个命令行入口点，该入口点运行<code>unittest</code>测试运行器<code>.main()</code></li></ol><p>如果不确定定义什么<code>self</code>或如何<code>.assertEqual()</code>定义，可以使用<a href="https://realpython.com/python3-object-oriented-programming/" target="_blank" rel="noopener">Python 3面向对象编程复习面向对象的编程</a>。</p><h3 id="如何写断言">如何写断言</h3><p>编写测试的最后一步是根据已知响应验证输出。这称为<strong>断言</strong>。关于如何编写断言，有一些通用的最佳实践：</p><ul><li>确保测试可重复，并多次运行测试以确保每次给出的结果相同</li><li>尝试并声明与输入数据有关的结果，例如检查<code>sum()</code>示例中结果是否为实际值的总和</li></ul><p><code>unittest</code>附带了许多方法来声明变量的值，类型和存在性。以下是一些最常用的方法：</p><table><thead><tr class="header"><th>方法</th><th>相当于</th></tr></thead><tbody><tr class="odd"><td><code>.assertEqual(a, b)</code></td><td><code>a == b</code></td></tr><tr class="even"><td><code>.assertTrue(x)</code></td><td><code>bool(x) is True</code></td></tr><tr class="odd"><td><code>.assertFalse(x)</code></td><td><code>bool(x) is False</code></td></tr><tr class="even"><td><code>.assertIs(a, b)</code></td><td><code>a is b</code></td></tr><tr class="odd"><td><code>.assertIsNone(x)</code></td><td><code>x is None</code></td></tr><tr class="even"><td><code>.assertIn(a, b)</code></td><td><code>a in b</code></td></tr><tr class="odd"><td><code>.assertIsInstance(a, b)</code></td><td><code>isinstance(a, b)</code></td></tr></tbody></table><p><code>.assertIs()</code>，<code>.assertIsNone()</code>，<code>.assertIn()</code>，和<code>.assertIsInstance()</code>所有有相反的方法，命名<code>.assertIsNot()</code>，等等。</p><h3 id="副作用">副作用</h3><p>在编写测试时，通常不像查看函数的返回值那么简单。通常，执行一段代码会更改环境中的其他内容，例如类的属性，文件系统上的文件或数据库中的值。这些被称为<strong>副作用</strong>，是测试的重要组成部分。在将其包含在断言列表之前，请确定是否正在测试副作用。</p><p>如果发现要测试的代码单元有很多副作用，则可能违反了“ <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一职责原则”</a>。违反单一责任原则意味着代码段执行了太多的工作，最好进行重构。遵循“单一职责原则”是一种设计代码的好方法，该代码很容易为最终的可靠应用编写可重复且简单的单元测试。</p><h2 id="执行您的第一个测试">执行您的第一个测试</h2><p>现在您已经创建了第一个测试，您想要执行它。当然，您知道它将通过，但是在创建更复杂的测试之前，应检查是否可以成功执行测试。</p><h3 id="执行测试运行器">执行测试运行器</h3><p>执行测试代码，检查断言并在控制台中提供测试结果的Python应用程序称为<strong>测试运行器</strong>。</p><p>在的底部<code>test.py</code>，添加了以下代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>这是命令行入口点。这意味着，如果您通过<code>python test.py</code>在命令行上运行单独执行脚本，它将调用<code>unittest.main()</code>。这将通过发现此文件中继承自的所有类来执行测试运行程序<code>unittest.TestCase</code>。</p><p>这是执行<code>unittest</code>测试运行程序的多种方法之一。当您有一个名为的测试文件时<code>test.py</code>，调用<code>python test.py</code>是入门的好方法。</p><p>另一种方法是使用<code>unittest</code>命令行。尝试这个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>这将<code>test</code>通过命令行执行相同的测试模块（称为）。</p><p>您可以提供其他选项来更改输出。其中之一是<code>-v</code>冗长的。接下来尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest -v <span class="built_in">test</span></span><br><span class="line">test_list_int (test.TestSum) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 1 tests <span class="keyword">in</span> 0.000s</span><br></pre></td></tr></table></figure><p>这在内部执行了一个测试<code>test.py</code>，并将结果打印到控制台。详细模式列出了它首先执行的测试的名称以及每个测试的结果。</p><p>除了提供包含测试的模块的名称之外，您还可以使用以下方法请求自动发现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest discover</span><br></pre></td></tr></table></figure><p>这将在当前目录中搜索任何已命名的文件，<code>test*.py</code>并尝试对其进行测试。</p><p>一旦有了多个测试文件，只要遵循<code>test*.py</code>命名模式，就可以提供目录名称，而不必使用<code>-s</code>标志和目录名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest discover -s tests</span><br></pre></td></tr></table></figure><p><code>unittest</code> 将在一个测试计划中运行所有测试，并为您提供结果。</p><p>最后，如果您的源代码不在目录根目录中，而是包含在子目录中，例如在名为的文件夹中<code>src/</code>，则可以告诉<code>unittest</code>执行测试的位置，以便可以使用<code>-t</code>标志正确导入模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest discover -s tests -t src</span><br></pre></td></tr></table></figure><p><code>unittest</code>将更改为<code>src/</code>目录，扫描目录中的所有<code>test*.py</code>文件<code>tests</code>，然后执行它们。</p><h3 id="了解测试输出">了解测试输出</h3><p>那是一个非常简单的示例，一切都通过了，因此现在您将尝试失败的测试并解释输出。</p><p><code>sum()</code> 应该能够接受其他数字类型列表，例如小数。</p><p>在<code>test.py</code>文件顶部，添加导入语句以<code>Fraction</code>从<code>fractions</code>标准库中的模块导入类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br></pre></td></tr></table></figure><p>现在添加一个带有断言的测试，该断言期望值不正确，在这种情况下，期望1 / 4、1 / 4和2/5之和为1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_sum <span class="keyword">import</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_int</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that it can sum a list of integers</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        result = sum(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_fraction</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that it can sum a list of fractions</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = [Fraction(<span class="number">1</span>, <span class="number">4</span>), Fraction(<span class="number">1</span>, <span class="number">4</span>), Fraction(<span class="number">2</span>, <span class="number">5</span>)]</span><br><span class="line">        result = sum(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>如果使用再次执行测试<code>python -m unittest test</code>，则应该看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest <span class="built_in">test</span></span><br><span class="line">F.</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_list_fraction (test.TestSum)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"> File <span class="string">"test.py"</span>, line 21, <span class="keyword">in</span> test_list_fraction</span><br><span class="line"> self.assertEqual(result, 1)</span><br><span class="line">AssertionError: Fraction(9, 10) != 1</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 2 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure><p>在输出中，您将看到以下信息：</p><ol type="1"><li><p>第一行显示了所有测试的执行结果，其中一个失败（<code>F</code>）和一个通过（<code>.</code>）。</p></li><li><p>该<code>FAIL</code>条目显示有关失败测试的一些详细信息：</p><ul><li>测试方法名称（<code>test_list_fraction</code>）</li><li>测试模块（<code>test</code>）和测试用例（<code>TestSum</code>）</li><li>追溯到失败的行</li><li>带有预期结果（<code>1</code>）和实际结果（<code>Fraction(9, 10)</code>）的断言的详细信息</li></ul></li></ol><p>请记住，可以通过将<code>-v</code>标志添加到<code>python -m unittest</code>命令来向测试输出添加额外的信息。</p><h3 id="从pycharm运行测试">从PyCharm运行测试</h3><p>如果您使用的是PyCharm IDE，则可以运行<code>unittest</code>或<code>pytest</code>按照以下步骤操作：</p><ol type="1"><li>在项目工具窗口中，选择<code>tests</code>目录。</li><li>在上下文菜单上，选择的运行命令<code>unittest</code>。例如，选择 <em>Run ‘Unittests in my Tests…’.</em>。</li></ol><p>这将<code>unittest</code>在测试窗口中执行，并在PyCharm中为您提供结果：</p><p><img src="https://2020.iosdevlog.com/2020/03/23/test/py_run_test_folder.png" /></p><p>有关更多信息，请访问<a href="https://www.jetbrains.com/help/pycharm/performing-tests.html" target="_blank" rel="noopener">PyCharm网站</a>。</p><h3 id="从visual-studio代码运行测试">从Visual Studio代码运行测试</h3><p>如果你正在使用微软的Visual Studio IDE的代码，支持<code>unittest</code>，<code>nose</code>和<code>pytest</code>执行内置于Python的插件。</p><p>如果安装了Python插件，则可以通过使用 <code>Ctrl+ Shift+ P</code> 打开命令面板并键入 “Python测试” 来设置测试的配置。您将看到一系列选项：</p><p><img src="https://2020.iosdevlog.com/2020/03/23/test/vscode-test-capture.png" /></p><p>选择<em>Debug All Unit Tests</em>，然后VSCode会提示您配置测试框架。单击齿轮以选择测试运行器（<code>unittest</code>）和主目录（<code>.</code>）。</p><p>设置完成后，您将在窗口底部看到测试状态，并且可以通过单击以下图标快速访问测试日志并再次运行测试：</p><p><img src="https://2020.iosdevlog.com/2020/03/23/test/vscode-test-results.png" /></p><p>这表明测试正在执行，但是其中一些失败。</p><h2 id="测试django和flask等web框架">测试Django和Flask等Web框架</h2><p>如果您使用Django或Flask等流行的框架之一为Web应用程序编写测试，则编写和运行测试的方式会有一些重要差异。</p><h3 id="为什么它们与其他应用程序不同">为什么它们与其他应用程序不同</h3><p>考虑一下您将在Web应用程序中测试的所有代码。路线，视图和模型都需要大量导入，并且需要有关所使用框架的知识。</p><p>这类似于本教程开始时的汽车测试：您必须启动汽车的计算机，然后才能运行简单的测试，例如检查车灯。</p><p>Django和Flask通过提供基于的测试框架，使您轻松实现了这一目标<code>unittest</code>。您可以按照学习的方式继续编写测试，但执行方式略有不同。</p><h3 id="如何使用django-test-runner">如何使用Django Test Runner</h3><p>Django <code>startapp</code>模板将<code>tests.py</code>在您的应用程序目录中创建一个文件。如果还没有，则可以使用以下内容创建它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line">    <span class="comment"># Your test methods</span></span><br></pre></td></tr></table></figure><p>到目前为止，这些示例的主要区别在于您需要继承<code>django.test.TestCase</code>而不是<code>unittest.TestCase</code>。这些类具有相同的API，但是Django <code>TestCase</code>类设置了所有必需的状态以进行测试。</p><p>要执行测试套件<code>unittest</code>，请使用<code>manage.py test</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>如果您需要多个测试文件，请<code>tests.py</code>用文件夹替换，在文件夹中<code>tests</code>插入一个空文件<code>__init__.py</code>，然后创建您的<code>test_*.py</code>文件。Django将发现并执行这些。</p><p>有关更多信息，请访问<a href="https://docs.djangoproject.com/en/2.1/topics/testing/overview/" target="_blank" rel="noopener">Django文档网站</a>。</p><h3 id="如何使用unittest和-flask">如何使用<code>unittest</code>和 <code>Flask</code></h3><p>Flask 要求导入该应用，然后将其设置为测试模式。您可以实例化一个测试客户端，并使用该测试客户端向应用程序中的任何路由发出请求。</p><p>所有测试客户端实例化都是通过<code>setUp</code>测试用例的方法完成的。在以下示例中，<code>my_app</code>是应用程序的名称。如果您不知道该怎么做，请不要担心<code>setUp</code>。您将在“ <a href="https://realpython.com/python-testing/#more-advanced-testing-scenarios" target="_blank" rel="noopener">更高级的测试方案”</a>部分中了解到这一点。</p><p>测试文件中的代码应如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> my_app</span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        my_app.app.testing = <span class="literal">True</span></span><br><span class="line">        self.app = my_app.app.test_client()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_home</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.app.get(<span class="string">'/'</span>)</span><br><span class="line">        <span class="comment"># Make your assertions</span></span><br></pre></td></tr></table></figure><p>然后，您可以使用<code>python -m unittest discover</code>命令执行测试用例。</p><p>有关更多信息，请参见<a href="http://flask.pocoo.org/docs/0.12/testing/" target="_blank" rel="noopener">Flask文档网站</a>。</p><h2 id="更多高级测试方案">更多高级测试方案</h2><p>在开始为应用程序创建测试之前，请记住每个测试的三个基本步骤：</p><ol type="1"><li>创建您的输入</li><li>执行代码，捕获输出</li><li>将输出与预期结果进行比较</li></ol><p>这并不总是像为字符串或数字之类的输入创建静态值那样容易。有时，您的应用程序将需要一个类或上下文的实例。那你怎么办呢？</p><p>您创建为输入的数据称为<strong>夹具</strong>。创建固定装置并重复使用它们是常见的做法。</p><p>如果您正在运行相同的测试，并且每次都传递不同的值并期望得到相同的结果，则称为<strong>参数化</strong>。</p><h3 id="处理预期的故障">处理预期的故障</h3><p>之前，当您列出要测试的方案列表时<code>sum()</code>，出现了一个问题：如果为它提供错误的值（例如单个整数或字符串），会发生什么？</p><p>在这种情况下，您可能会<code>sum()</code>引发错误。当它确实引发错误时，将导致测试失败。</p><p>有一种特殊的方法可以处理预期的错误。您可以<code>.assertRaises()</code>用作上下文管理器，然后在<code>with</code>块内执行测试步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> my_sum <span class="keyword">import</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSum</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_int</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that it can sum a list of integers</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">        result = sum(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_list_fraction</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that it can sum a list of fractions</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = [Fraction(<span class="number">1</span>, <span class="number">4</span>), Fraction(<span class="number">1</span>, <span class="number">4</span>), Fraction(<span class="number">2</span>, <span class="number">5</span>)]</span><br><span class="line">        result = sum(data)</span><br><span class="line">        self.assertEqual(result, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_bad_type</span><span class="params">(self)</span>:</span></span><br><span class="line">        data = <span class="string">"banana"</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            result = sum(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>现在，只有<code>sum(data)</code>提高时，此测试用例才能通过<code>TypeError</code>。您可以<code>TypeError</code>用任何选择的异常类型替换。</p><h3 id="隔离应用程序中的行为">隔离应用程序中的行为</h3><p>在本教程的前面，您了解了副作用。副作用使单元测试更加困难，因为每次运行测试时，它可能会给出不同的结果，甚至更糟的是，一个测试可能会影响应用程序的状态并导致另一个测试失败！</p><p><img src="https://2020.iosdevlog.com/2020/03/23/test/test.gif" /></p><p>您可以使用一些简单的技术来测试应用程序的某些部分，这些部分有很多副作用：</p><ul><li>重构代码以遵循单一职责原则</li><li>模拟出任何方法或函数调用以消除副作用</li><li>在此应用程序中使用集成测试代替单元测试</li></ul><p>如果您不熟悉模拟，请参阅<a href="https://realpython.com/python-cli-testing/#mocks" target="_blank" rel="noopener">Python CLI Testing</a>以获取一些出色的示例。</p><h3 id="编写集成测试">编写集成测试</h3><p>到目前为止，您一直在主要学习有关单元测试的知识。单元测试是构建可预测且稳定的代码的好方法。但是，归根结底，您的应用程序需要在启动时才能运行！</p><p>集成测试是对应用程序的多个组件的测试，以检查它们是否可以协同工作。集成测试可能需要通过以下方式像应用程序的使用者或用户一样行动：</p><ul><li>调用HTTP REST API</li><li>调用Python API</li><li>调用网络服务</li><li>运行命令行</li></ul><p>可以按照输入，执行和断言模式，以与单元测试相同的方式编写所有这些类型的集成测试。最大的不同是集成测试一次检查了更多的组件，因此比单元测试有更多的副作用。此外，集成测试将需要更多的固定装置，例如数据库，网络套接字或配置文件。</p><p>这就是为什么最好将单元测试和集成测试分开的原因。创建集成所需的固定装置（例如测试数据库）和测试用例本身通常比单元测试花费更多的时间，因此您可能只想在推送到生产环境之前运行集成测试，而不是每次提交都运行一次。</p><p>分离单元测试和集成测试的简单方法是将它们放在不同的文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_app/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">│</span><br><span class="line">└── tests/</span><br><span class="line">    |</span><br><span class="line">    ├── unit/</span><br><span class="line">    |   ├── __init__.py</span><br><span class="line">    |   └── test_sum.py</span><br><span class="line">    |</span><br><span class="line">    └── integration/</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── test_integration.py</span><br></pre></td></tr></table></figure><p>有很多方法可以仅执行一组选定的测试。指定源目录标志<code>-s</code>可以<code>unittest discover</code>与包含测试的路径一起添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m unittest discover -s tests/integration</span><br></pre></td></tr></table></figure><p><code>unittest</code>将为您提供<code>tests/integration</code>目录中所有测试的结果。</p><h3 id="测试数据驱动的应用程序">测试数据驱动的应用程序</h3><p>许多集成测试将要求后端数据（如数据库）必须具有某些值。例如，您可能需要进行一项测试，以检查应用程序是否正确显示了数据库中的100个以上客户，或者即使产品名称以日语显示，订单页面也可以正常工作。</p><p>这些类型的集成测试将取决于不同的测试装置，以确保它们可重复且可预测。</p><p>使用的一种好方法是将测试数据存储在集成测试文件夹中的一个文件夹中，该文件夹称为<code>fixtures</code>，指示其中包含测试数据。然后，在测试中，您可以加载数据并运行测试。</p><p>如果数据由JSON文件组成，则下面是该结构的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">│</span><br><span class="line">├── my_app/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">│</span><br><span class="line">└── tests/</span><br><span class="line">    |</span><br><span class="line">    └── unit/</span><br><span class="line">    |   ├── __init__.py</span><br><span class="line">    |   └── test_sum.py</span><br><span class="line">    |</span><br><span class="line">    └── integration/</span><br><span class="line">        |</span><br><span class="line">        ├── fixtures/</span><br><span class="line">        |   ├── test_basic.json</span><br><span class="line">        |   └── test_complex.json</span><br><span class="line">        |</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── test_integration.py</span><br></pre></td></tr></table></figure><p>在您的测试用例中，您可以使用该<code>.setUp()</code>方法从已知路径中的夹具文件中加载测试数据，并针对该测试数据执行许多测试。请记住，您可以在一个Python文件中包含多个测试用例，并且<code>unittest</code>发现将同时执行。每个测试数据集可以有一个测试用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBasic</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Load test data</span></span><br><span class="line">        self.app = App(database=<span class="string">'fixtures/test_basic.json'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_customer_count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(len(self.app.customers), <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_existence_of_customer</span><span class="params">(self)</span>:</span></span><br><span class="line">        customer = self.app.get_customer(id=<span class="number">10</span>)</span><br><span class="line">        self.assertEqual(customer.name, <span class="string">"Org XYZ"</span>)</span><br><span class="line">        self.assertEqual(customer.address, <span class="string">"10 Red Road, Reading"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComplexData</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># load test data</span></span><br><span class="line">        self.app = App(database=<span class="string">'fixtures/test_complex.json'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_customer_count</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(len(self.app.customers), <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_existence_of_customer</span><span class="params">(self)</span>:</span></span><br><span class="line">        customer = self.app.get_customer(id=<span class="number">9999</span>)</span><br><span class="line">        self.assertEqual(customer.name, <span class="string">u"バナナ"</span>)</span><br><span class="line">        self.assertEqual(customer.address, <span class="string">"10 Red Road, Akihabara, Tokyo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure><p>如果您的应用程序依赖于远程位置（例如远程API）的数据，则需要确保测试可重复。由于API离线或存在连接问题而导致测试失败，可能会减慢开发速度。在这些类型的情况下，最佳实践是在本地存储远程设备，以便可以调用它们并将其发送到应用程序。</p><p>该<code>requests</code>库有一个名为的免费软件包<code>responses</code>，使您可以创建响应固定装置并将其保存在测试文件夹中。<a href="https://github.com/getsentry/responses" target="_blank" rel="noopener">在其GitHub Page上</a>找到更多<a href="https://github.com/getsentry/responses" target="_blank" rel="noopener">信息</a>。</p><h2 id="在多种环境中测试">在多种环境中测试</h2><p>到目前为止，您已经在使用带有一组特定依赖项的虚拟环境针对Python的单个版本进行了测试。您可能要检查您的应用程序是否可以在多个版本的Python或程序包的多个版本上运行。Tox是在多个环境中自动化测试的应用程序。</p><h3 id="安装毒物">安装毒物</h3><p>Tox可以通过以下方式在PyPI上安装<code>pip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install tox</span><br></pre></td></tr></table></figure><p>现在您已经安装了Tox，需要对其进行配置。</p><h3 id="为您的依赖配置tox">为您的依赖配置Tox</h3><p>Tox通过项目目录中的配置文件进行配置。Tox配置文件包含以下内容：</p><ul><li>为了执行测试而运行的命令</li><li>执行之前需要的任何其他软件包</li><li>要测试的目标Python版本</li></ul><p>您无需学习Tox配置语法，而可以通过运行quickstart应用程序来抢先一步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox-quickstart</span><br></pre></td></tr></table></figure><p>Tox配置工具将询问您这些问题，并在中创建类似于以下内容的文件<code>tox.ini</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tox]</span></span><br><span class="line"><span class="attr">envlist</span> = py27, py36</span><br><span class="line"></span><br><span class="line"><span class="section">[testenv]</span></span><br><span class="line"><span class="attr">deps</span> =</span><br><span class="line"></span><br><span class="line"><span class="attr">commands</span> =</span><br><span class="line"> python -m unittest discover</span><br></pre></td></tr></table></figure><p>在运行Tox之前，它要求<code>setup.py</code>您的应用程序文件夹中包含一个文件，其中包含安装软件包的步骤。如果您还没有，则可以在继续之前按照<a href="https://packaging.python.org/tutorials/packaging-projects/#setup-py" target="_blank" rel="noopener">本指南</a>操作如何创建<code>setup.py</code>。</p><p>或者，如果您的项目不适合在PyPI上分发，则可以通过<code>tox.ini</code>在<code>[tox]</code>标题下的文件中添加以下行来跳过此要求：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tox]</span></span><br><span class="line"><span class="attr">envlist</span> = py27, py36</span><br><span class="line"><span class="attr">skipsdist</span>=<span class="literal">True</span></span><br></pre></td></tr></table></figure><p>如果您不创建<code>setup.py</code>，并且您的应用程序具有PyPI的某些依赖项，则需要在本<code>[testenv]</code>节下的多行中指定这些依赖项。例如，Django需要具备以下条件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[testenv]</span></span><br><span class="line"><span class="attr">deps</span> = django</span><br></pre></td></tr></table></figure><p>一旦完成该阶段，就可以运行测试了。</p><p>现在，您可以执行Tox，它将创建两个虚拟环境：一个用于Python 2.7，一个用于Python 3.6。Tox目录称为<code>.tox/</code>。在<code>.tox/</code>目录内，Tox将<code>python -m unittest discover</code>针对每个虚拟环境执行。</p><p>您可以通过在命令行上调用Tox来运行此过程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox</span><br></pre></td></tr></table></figure><p>Tox将输出针对每种环境的测试结果。Tox第一次运行时，会花一点时间来创建虚拟环境，但是一旦运行起来，第二次执行就会快很多。</p><h3 id="执行毒药">执行毒药</h3><p>Tox的输出非常简单。它为每个版本创建一个环境，安装您的依赖项，然后运行测试命令。</p><p>还有一些其他值得记住的命令行选项。</p><p>仅运行单个环境，例如Python 3.6：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox -e py36</span><br></pre></td></tr></table></figure><p>重新创建虚拟环境，以防您的依存关系已更改或<a href="https://docs.python.org/3/install/#how-installation-works" target="_blank" rel="noopener">站点包</a>损坏：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox -r</span><br></pre></td></tr></table></figure><p>使用更少的详细输出运行Tox：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox -q</span><br></pre></td></tr></table></figure><p>使用更详细的输出运行Tox：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tox -v</span><br></pre></td></tr></table></figure><p>可以在<a href="https://tox.readthedocs.io/en/latest/" target="_blank" rel="noopener">Tox文档网站上</a>找到有关Tox的更多信息。</p><h2 id="自动化执行测试">自动化执行测试</h2><p>到目前为止，您已经通过运行命令手动执行测试。有一些工具可以在您进行更改并将其提交到诸如Git之类的源代码控制存储库时自动执行测试。自动化测试工具通常被称为CI / CD工具，代表“持续集成/持续部署”。他们可以运行您的测试，编译和发布任何应用程序，甚至将它们部署到生产环境中。</p><p><a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>是许多可用的CI（连续集成）服务之一。</p><p>Travis CI与Python配合良好，现在您已经创建了所有这些测试，您可以在云中自动执行它们！Travis CI对于GitHub和GitLab上的任何开源项目都是免费的，并且对私人项目收费。</p><p>首先，请登录网站并使用Gi​​tHub或GitLab凭据进行身份验证。然后创建一个<code>.travis.yml</code>具有以下内容的文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">python</span></span><br><span class="line"><span class="attr">python:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"2.7"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">"3.7"</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">-r</span> <span class="string">requirements.txt</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">python</span> <span class="string">-m</span> <span class="string">unittest</span> <span class="string">discover</span></span><br></pre></td></tr></table></figure><p>此配置指示Travis CI：</p><ol type="1"><li>针对Python 2.7和3.7进行测试（您可以使用任意版本替换这些版本。）</li><li>安装列出的所有软件包<code>requirements.txt</code>（如果没有任何依赖性，则应删除此部分。）</li><li>运行<code>python -m unittest discover</code>以运行测试</li></ol><p>提交并推送此文件后，每次您推送到远程Git存储库时，Travis CI都会运行这些命令。您可以在他们的网站上查看结果。</p><h2 id="下一步是什么">下一步是什么</h2><p>既然您已经了解了如何创建测试，执行测试，将其包含在项目中，甚至自动执行它们，随着测试库的增长，您可能会发现一些方便的高级技术。</p><h3 id="将linters引入您的应用程序">将Linters引入您的应用程序</h3><p>Tox和Travis CI具有测试命令的配置。在本教程中一直使用的测试命令是<code>python -m unittest discover</code>。</p><p>您可以在所有这些工具中提供一个或多个命令，并且该选项使您可以添加更多工具来提高应用程序的质量。</p><p>一种这样的应用程序称为短绒。短毛猫将查看您的代码并对其进行注释。它可以为您提供有关您犯的错误，纠正尾随空格的提示，甚至可以预测您可能引入的错误。</p><p>有关短毛绒的更多信息，请阅读<a href="https://realpython.com/python-code-quality/" target="_blank" rel="noopener">Python代码质量教程</a>。</p><h4 id="被动掉毛-flake8">被动掉毛 <code>flake8</code></h4><p>一个流行的linter可以评论与<a href="https://www.youtube.com/watch?v=Hwckt4J96dI" target="_blank" rel="noopener">PEP 8</a>规范有关的代码样式<code>flake8</code>。</p><p>您可以<code>flake8</code>使用安装<code>pip</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install flake8</span><br></pre></td></tr></table></figure><p>然后，您可以<code>flake8</code>在单个文件，文件夹或模式上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ flake8 test.py</span><br><span class="line">test.py:6:1: E302 expected 2 blank lines, found 1</span><br><span class="line">test.py:23:1: E305 expected 2 blank lines after class or <span class="keyword">function</span> definition, found 1</span><br><span class="line">test.py:24:20: W292 no newline at end of file</span><br></pre></td></tr></table></figure><p>您将看到<code>flake8</code>已找到的代码的错误和警告的列表。</p><p><code>flake8</code> 可在命令行中或项目中的配置文件中进行配置。如果您想忽略某些规则（<code>E305</code>如上所示），则可以在配置中进行设置。<code>flake8</code>将检查<code>.flake8</code>项目文件夹中的文件或<code>setup.cfg</code>文件。如果您决定使用Tox，则可以将<code>flake8</code>配置部分放在里面<code>tox.ini</code>。</p><p>本示例忽略<code>.git</code>和<code>__pycache__</code>目录以及<code>E305</code>规则。此外，它将最大行长设置为90，而不是80个字符。您可能会发现，默认的线宽限制是79个字符，这对于测试来说是非常有限的，因为它们包含长的方法名称，带有测试值的字符串文字以及可能更长的其他数据。通常将测试的行长设置为最多120个字符：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[flake8]</span></span><br><span class="line"><span class="attr">ignore</span> = E305</span><br><span class="line"><span class="attr">exclude</span> = .git,__pycache__</span><br><span class="line"><span class="attr">max-line-length</span> = <span class="number">90</span></span><br></pre></td></tr></table></figure><p>或者，您可以在命令行上提供以下选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flake8 --ignore E305 --exclude .git,__pycache__ --max-line-length=90</span><br></pre></td></tr></table></figure><p><a href="http://flake8.pycqa.org/en/latest/user/options.html" target="_blank" rel="noopener">文档网站</a>上提供了配置选项的完整列表。</p><p>现在，您可以添加<code>flake8</code>到CI配置。对于Travis CI，其外观如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix:</span><br><span class="line">  include:</span><br><span class="line">    - python: <span class="string">"2.7"</span></span><br><span class="line">      script: <span class="string">"flake8"</span></span><br></pre></td></tr></table></figure><p>Travis将在其中读取配置，<code>.flake8</code>如果发生任何棉绒错误，将使构建失败。确保将<code>flake8</code>依赖项添加到<code>requirements.txt</code>文件中。</p><h4 id="使用代码格式化程序进行进取性整理">使用代码格式化程序进行进取性整理</h4><p><code>flake8</code>是一个被动的lint：它建议更改，但是您必须去更改代码。更具攻击性的方法是代码格式化程序。代码格式化程序将自动更改您的代码，以满足一系列样式和布局惯例。</p><p><code>black</code>是一个非常宽容的格式化程序。它没有任何配置选项，并且具有非常特定的样式。这非常适合作为插入测试管道的插入工具。</p><p><strong>注意：</strong> <code>black</code>需要Python 3.6+。</p><p>您可以<code>black</code>通过pip 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install black</span><br></pre></td></tr></table></figure><p>然后，要<code>black</code>在命令行上运行，请提供要格式化的文件或目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ black test.py</span><br></pre></td></tr></table></figure><h3 id="保持测试代码干净">保持测试代码干净</h3><p>编写测试时，您可能会发现复制和粘贴代码的结果比常规应用程序要多得多。测试有时会非常重复，但这绝不是让代码草率且难以维护的原因。</p><p>随着时间的流逝，您将在测试代​​码中<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="noopener">积累</a>许多<a href="https://martinfowler.com/bliki/TechnicalDebt.html" target="_blank" rel="noopener">技术负担</a>，并且如果您对应用程序进行了重大更改，需要对测试进行更改，那么由于结构化方式，这可能是不必要的繁琐任务。</p><p>尝试按照<strong>DRY</strong>编写测试时的原则：<strong>d</strong> on't <strong>[R</strong> EPEAT <strong>ÿ</strong>我们自己。</p><p>测试装置和功能是产生易于维护的测试代码的好方法。另外，可读性也很重要。考虑像<code>flake8</code>测试代码一样部署一个整理工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flake8 --max-line-length=120 tests/</span><br></pre></td></tr></table></figure><h3 id="测试变更之间的性能下降">测试变更之间的性能下降</h3><p>有许多方法可以在Python中对代码进行基准测试。标准库提供了该<code>timeit</code>模块，该模块可以多次计时功能，并为您提供分配。此示例将执行<code>test()</code>100次，并<code>print()</code>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ... your code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    print(timeit.timeit(<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>, number=<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>如果您决定<code>pytest</code>用作测试运行程序，则另一个选择是<code>pytest-benchmark</code>插件。这提供了一个<code>pytest</code>称为的装置<code>benchmark</code>。您可以传递<code>benchmark()</code>任何可调用对象，它将可调用对象的时间记录到的结果中<code>pytest</code>。</p><p>您可以<code>pytest-benchmark</code>使用<code>pip</code>以下方法从PyPI 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pytest-benchmark</span><br></pre></td></tr></table></figure><p>然后，您可以添加一个使用夹具的测试，并通过要执行的可调用对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_my_function</span><span class="params">(benchmark)</span>:</span></span><br><span class="line">    result = benchmark(test)</span><br></pre></td></tr></table></figure><p><code>pytest</code>现在执行将为您提供基准测试结果：</p><p><img src="https://2020.iosdevlog.com/2020/03/23/test/pytest-bench-screen.png" /></p><p>有关更多信息，请访问<a href="https://pytest-benchmark.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档网站</a>。</p><h3 id="测试应用程序中的安全缺陷">测试应用程序中的安全缺陷</h3><p>您将要在应用程序上运行的另一项测试是检查常见的安全错误或漏洞。</p><p>您可以<code>bandit</code>使用<code>pip</code>以下方法从PyPI 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bandit</span><br></pre></td></tr></table></figure><p>然后，您可以通过<code>-r</code>标志传递应用程序模块的名称，它会为您提供一个摘要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ bandit -r my_sum</span><br><span class="line">[main]  INFO    profile include tests: None</span><br><span class="line">[main]  INFO    profile exclude tests: None</span><br><span class="line">[main]  INFO    cli include tests: None</span><br><span class="line">[main]  INFO    cli exclude tests: None</span><br><span class="line">[main]  INFO    running on Python 3.5.2</span><br><span class="line">Run started:2018-10-08 00:35:02.669550</span><br><span class="line"></span><br><span class="line">Test results:</span><br><span class="line"> No issues identified.</span><br><span class="line"></span><br><span class="line">Code scanned:</span><br><span class="line"> Total lines of code: 5</span><br><span class="line"> Total lines skipped (<span class="comment">#nosec): 0</span></span><br><span class="line"></span><br><span class="line">Run metrics:</span><br><span class="line"> Total issues (by severity):</span><br><span class="line"> Undefined: 0.0</span><br><span class="line"> Low: 0.0</span><br><span class="line"> Medium: 0.0</span><br><span class="line"> High: 0.0</span><br><span class="line"> Total issues (by confidence):</span><br><span class="line"> Undefined: 0.0</span><br><span class="line"> Low: 0.0</span><br><span class="line"> Medium: 0.0</span><br><span class="line"> High: 0.0</span><br><span class="line">Files skipped (0):</span><br></pre></td></tr></table></figure><p>与一样<code>flake8</code>，<code>bandit</code>标记的规则是可配置的，并且如果您希望忽略任何标记，则可以使用以下<code>setup.cfg</code>选项将以下部分添加到文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bandit]</span><br><span class="line">exclude: &#x2F;test</span><br><span class="line">tests: B101,B102,B301</span><br></pre></td></tr></table></figure><p>可以在<a href="https://github.com/PyCQA/bandit" target="_blank" rel="noopener">GitHub网站</a>上获得更多详细信息。</p><h2 id="结论">结论</h2><p>Python通过内置所需的命令和库来验证应用程序是否按设计工作，从而使测试变得可访问。使用Python进行测试的入门不必太复杂：您可以使用<code>unittest</code>和编写小型可维护的方法来验证代码。</p><p>随着您了解有关测试的更多信息以及您的应用程序的增长，您可以考虑切换到其他测试框架之一，例如<code>pytest</code>，并开始利用更多高级功能。</p><p>感谢您的阅读。希望您在使用Python时拥有无错误的未来！</p><p>原文：<a href="https://realpython.com/python-testing/" target="_blank" rel="noopener">Getting Started With Testing in Python</a><br />作者：<a href="https://realpython.com/python-testing/#author" target="_blank" rel="noopener">Anthony Shaw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/23/test/Getting-Started-with-Testing-in-Python_Watermarked.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://2020.iosdevlog.com/categories/python/"/>
    
    
      <category term="test" scheme="https://2020.iosdevlog.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何将开源 Python 软件包发布到 PyPI</title>
    <link href="https://2020.iosdevlog.com/2020/03/22/pip/"/>
    <id>https://2020.iosdevlog.com/2020/03/22/pip/</id>
    <published>2020-03-22T14:33:29.000Z</published>
    <updated>2020-03-22T16:03:47.108Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/22/pip/How-to-publish-an-open-source-Python-package-to-PyPI_Watermark.png" /></p><p>本教程有一个由 Real Python 团队创建的相关视频课程。与书面教程一起观看，以加深您的理解：如何将自己的 Python 包发布到 PyPI 。</p><a id="more"></a><p>Python因附带<a href="https://docs.python.org/tutorial/stdlib.html#batteries-included" target="_blank" rel="noopener">电池</a>而闻名。标准库中提供了复杂的功能。您可以找到用于处理 <a href="https://realpython.com/python-sockets/" target="_blank" rel="noopener">套接字</a>，解析 <a href="https://realpython.com/python-csv/" target="_blank" rel="noopener">CSV</a>，<a href="https://realpython.com/python-json/" target="_blank" rel="noopener">JSON</a> 和 <a href="https://docs.python.org/library/xml.html" target="_blank" rel="noopener">XML</a>文件以及处理 <a href="https://docs.python.org/library/shutil.html" target="_blank" rel="noopener">文件</a>和 <a href="https://realpython.com/python-pathlib/" target="_blank" rel="noopener">文件路径的模块</a>。</p><p>尽管Python附带的软件包很棒，但标准库之外还有许多出色的项目可用。这些通常是在<a href="https://pypi.org/" target="_blank" rel="noopener">Python打包索引</a>（PyPI）（历史上被称为<a href="https://www.youtube.com/watch?v=B3KBuQHHKx0" target="_blank" rel="noopener">Cheese Shop</a>）上托管的。在PyPI，您可以找到从<a href="https://pypi.org/search/?q=helloworld" target="_blank" rel="noopener">Hello World</a>到高级<a href="https://pypi.org/project/Keras/" target="_blank" rel="noopener">深度学习库的所有内容</a>。</p><p>在本教程中，您将介绍如何 <strong>将自己的包上传到PyPI</strong>。尽管发布项目比以前要容易，但仍涉及一些步骤。</p><p><strong>您将学习如何：</strong></p><ul><li>准备要发布的Python包</li><li>考虑版本控制</li><li>将您的包上传到PyPI</li></ul><p>在整个教程中，我们将使用一个简单的示例项目：一个<code>reader</code>可用于阅读<em>Real Python</em>教程的软件包。第一部分介绍此项目。</p><p>可以在 PyPI 上和导入时为包使用不同的名称。但是，如果您使用相同或非常相似的名称，则对您的用户而言将更加容易。</p><h2 id="配置程序包">配置程序包</h2><p>为了将您的包上传到PyPI，您需要提供有关它的一些基本信息。该信息通常以 <code>setup.py</code> 文件的形式提供。有一些举措试图简化这种信息收集。目前，这 <code>setup.py</code> 是提供有关包装信息的唯一完全受支持的方法。</p><h2 id="一个小的python包">一个小的Python包</h2><p>本节将描述一个小的 Python 包，我们将使用它作为示例来发布到 PyPI。如果您已经有要发布的软件包，请随意浏览本节，然后在<a href="https://realpython.com/pypi-publish-python-package/#preparing-your-package-for-publication" target="_blank" rel="noopener">下一节</a>的<a href="https://realpython.com/pypi-publish-python-package/#preparing-your-package-for-publication" target="_blank" rel="noopener">开头</a>再次加入。</p><p>我们将使用该软件包，该软件包 <code>reader</code> 是一个可用于下载和阅读<em>Real Python</em>文章的应用程序。如果要继续学习，可以从<a href="https://github.com/realpython/reader" target="_blank" rel="noopener">我们的GitHub存储库中</a>获取完整的源代码。</p><p><strong>注意</strong>：如下所示和说明的源代码是<em>Real Python</em>供稿阅读器的简化版本，但功能齐全。与在<a href="https://pypi.org/project/realpython-reader/" target="_blank" rel="noopener">PyPI</a>和<a href="https://github.com/realpython/reader" target="_blank" rel="noopener">GitHub上</a>发布的软件包相比，此版本缺少一些错误处理和其他选项。</p><p>首先，查看的目录结构<code>reader</code>。该软件包完全位于一个目录中，该目录也名为<code>reader</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reader/</span><br><span class="line">│</span><br><span class="line">├── reader/</span><br><span class="line">│   ├── config.txt</span><br><span class="line">│   ├── feed.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── __main__.py</span><br><span class="line">│   └── viewer.py</span><br><span class="line">│</span><br><span class="line">├── tests/</span><br><span class="line">│   ├── test_feed.py</span><br><span class="line">│   └── test_viewer.py</span><br><span class="line">│</span><br><span class="line">├── MANIFEST.<span class="keyword">in</span></span><br><span class="line">├── README.md</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p>软件包的源代码和<code>reader</code>配置文件位于子目录中。在单独的子目录中有一些测试。这些测试不在此处讨论，但是您可以在<a href="https://github.com/realpython/reader" target="_blank" rel="noopener">GitHub存储库中</a>找到它们。要了解有关测试的更多信息，请参见Anthony Shaw的精彩教程<a href="https://realpython.com/python-testing/" target="_blank" rel="noopener">《 Python测试入门》</a>。</p><p>如果您使用自己的软件包，则可以使用其他结构或在软件​​包目录中包含其他文件。我们的<a href="https://realpython.com/python-application-layouts/" target="_blank" rel="noopener">Python应用程序布局</a>参考讨论了几个不同的选项。本指南中的说明将独立于您使用的布局工作。</p><p>在本节的其余部分，您将看到该 <code>reader</code> 程序包如何工作。在<a href="https://realpython.com/pypi-publish-python-package/#preparing-your-package-for-publication" target="_blank" rel="noopener">接下来的部分</a>，你会得到的特殊文件，其中包括仔细一看<code>setup.py</code>，<code>README.md</code>和<code>MANIFEST.in</code>，这需要发布你的包。</p><h3 id="使用real-python-reader">使用Real Python Reader</h3><p><code>reader</code> 是一个非常基本的 <a href="https://en.wikipedia.org/wiki/Web_feed" target="_blank" rel="noopener">Web提要</a>阅读器，可以从 <a href="https://realpython.com/contact/#rss-atom-feed" target="_blank" rel="noopener">Real Python提要中</a>下载最新的Real Python文章。</p><p>这是一个使用阅读器获取最新文章列表的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ python -m reader</span><br><span class="line">The latest tutorials from Real Python (https://realpython.com/)</span><br><span class="line"> 0 How to Publish an Open-Source Python Package to PyPI</span><br><span class="line"> 1 Python <span class="string">"while"</span> Loops (Indefinite Iteration)</span><br><span class="line"> 2 Writing Comments <span class="keyword">in</span> Python (Guide)</span><br><span class="line"> 3 Setting Up Python <span class="keyword">for</span> Machine Learning on Windows</span><br><span class="line"> 4 Python Community Interview With Michael Kennedy</span><br><span class="line"> 5 Practical Text Classification With Python and Keras</span><br><span class="line"> 6 Getting Started With Testing <span class="keyword">in</span> Python</span><br><span class="line"> 7 Python, Boto3, and AWS S3: Demystified</span><br><span class="line"> 8 Python<span class="string">'s range() Function (Guide)</span></span><br><span class="line"><span class="string"> 9 Python Community Interview With Mike Grouchy</span></span><br><span class="line"><span class="string"> 10 How to Round Numbers in Python</span></span><br><span class="line"><span class="string"> 11 Building and Documenting Python REST APIs With Flask and Connexion – Part 2</span></span><br><span class="line"><span class="string"> 12 Splitting, Concatenating, and Joining Strings in Python</span></span><br><span class="line"><span class="string"> 13 Image Segmentation Using Color Spaces in OpenCV + Python</span></span><br><span class="line"><span class="string"> 14 Python Community Interview With Mahdi Yusuf</span></span><br><span class="line"><span class="string"> 15 Absolute vs Relative Imports in Python</span></span><br><span class="line"><span class="string"> 16 Top 10 Must-Watch PyCon Talks</span></span><br><span class="line"><span class="string"> 17 Logging in Python</span></span><br><span class="line"><span class="string"> 18 The Best Python Books</span></span><br><span class="line"><span class="string"> 19 Conditional Statements in Python</span></span><br></pre></td></tr></table></figure><p>请注意，每篇文章都有编号。要阅读一篇特定的文章，请使用相同的命令，但也要包括文章的编号。例如，要阅读<a href="https://realpython.com/pypi-publish-python-package/" target="_blank" rel="noopener">如何将开源Python程序包发布到PyPI</a>，您可以添加<code>0</code>以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ python -m reader <span class="number">0</span></span><br><span class="line"><span class="comment"># How to Publish an Open-Source Python Package to PyPI</span></span><br><span class="line"></span><br><span class="line">Python <span class="keyword">is</span> famous <span class="keyword">for</span> coming <span class="keyword">with</span> batteries included. Sophisticated</span><br><span class="line">capabilities are available <span class="keyword">in</span> the standard library. You can find modules</span><br><span class="line"><span class="keyword">for</span> working <span class="keyword">with</span> sockets, parsing CSV, JSON, <span class="keyword">and</span> XML files, <span class="keyword">and</span></span><br><span class="line">working <span class="keyword">with</span> files <span class="keyword">and</span> file paths.</span><br><span class="line"></span><br><span class="line">However great the packages included <span class="keyword">with</span> Python are, there are many</span><br><span class="line">fantastic projects available outside the standard library. These are</span><br><span class="line">most often hosted at the Python Packaging Index (PyPI), historically</span><br><span class="line">known <span class="keyword">as</span> the Cheese Shop. At PyPI, you can find everything <span class="keyword">from</span> Hello</span><br><span class="line">World to advanced deep learning libraries.</span><br><span class="line"></span><br><span class="line">[... The full text of the article ...]</span><br></pre></td></tr></table></figure><p>这将使用 <a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">Markdown</a>文本格式将完整的文章打印到控制台。</p><p><strong>注意：</strong> <code>python -m</code> 用于运行<a href="https://docs.python.org/library/__main__.html" target="_blank" rel="noopener">库模块或软件包而不是脚本</a>。如果运行程序包，<code>__main__.py</code> 则将执行文件的内容。有关更多信息，请参见 <a href="https://realpython.com/pypi-publish-python-package/#different-ways-of-calling-a-package" target="_blank" rel="noopener">调用包的不同方式</a>。</p><p>通过更改文章编号，您可以阅读任何可用的文章。</p><h3 id="快速查看代码">快速查看代码</h3><p><code>reader</code> 对于本教程而言，如何工作的细节并不重要。但是，如果您对实现有兴趣，可以展开以下部分。该软件包包含五个文件：</p><h4 id="config.txt"><code>config.txt</code></h4><p>config.txt是一个配置文件，用于指定Real Python教程的feed的URL 。这是一个文本文件，可由configparser标准库读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.txt</span></span><br><span class="line"></span><br><span class="line">[feed]</span><br><span class="line">url = https://realpython.com/atom.xml</span><br></pre></td></tr></table></figure><p>通常，这样的配置文件包含分成部分的键/值对。该特定文件仅包含一个部分（feed）和一个键（url）。</p><p>注意：对于这个简单的程序包，配置文件可能是多余的。我们将其包含在此处用于演示目的。</p><h4 id="main__.py"><code>__main__.py</code></h4><p>我们将看的第一个源代码文件是__main__.py。双下划线表示该文件在Python中具有特殊含义。确实，当使用上述方法将程序包作为脚本运行时-m，Python会执行__main__.py文件的内容。</p><p>换句话说，它__main__.py充当程序的切入点并负责主流程，并根据需要调用其他部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __main__.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> configparser <span class="keyword">import</span> ConfigParser</span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> resources  <span class="comment"># Python 3.7+</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> feed</span><br><span class="line"><span class="keyword">from</span> reader <span class="keyword">import</span> viewer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Read the Real Python article feed"""</span></span><br><span class="line">    <span class="comment"># Read URL of the Real Python feed from config file</span></span><br><span class="line">    cfg = ConfigParser()</span><br><span class="line">    cfg.read_string(resources.read_text(<span class="string">"reader"</span>, <span class="string">"config.txt"</span>))</span><br><span class="line">    url = cfg.get(<span class="string">"feed"</span>, <span class="string">"url"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If an article ID is given, show the article</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        article = feed.get_article(url, sys.argv[<span class="number">1</span>])</span><br><span class="line">        viewer.show(article)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># If no ID is given, show a list of all articles</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        site = feed.get_site(url)</span><br><span class="line">        titles = feed.get_titles(url)</span><br><span class="line">        viewer.show_list(site, titles)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>注意，main()在最后一行调用了该命令。如果我们不调用main()，那么我们的程序将什么也不做。如您先前所见，该程序可以列出所有文章或打印一篇特定文章。这是由if-else内部处理的main()。</p><p>要从配置文件读取提要的URL，我们使用configparser和importlib.resources。后者用于从包中导入非代码（或资源）文件，而不必担心完整的文件路径。在将程序包发布到PyPI时特别有用，因为资源文件可能最终存储在二进制存档中。</p><p>importlib.resources成为Python 3.7中标准库的一部分。如果您使用的是旧版本的Python，则可以importlib_resources改用。这是与Python 2.7和3.4及更高版本兼容的反向端口。importlib_resources可以从PyPI安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install importlib_resources</span><br></pre></td></tr></table></figure><p>有关更多信息，请参见Barry Warzaw在PyCon 2018上的演讲。</p><h4 id="init__.py"><code>__init__.py</code></h4><p>下一个文件是__init__.py。同样，文件名中的双下划线告诉我们这是一个特殊文件。<strong>init</strong>.py表示包的根。它通常应该保持非常简单，但这是放置包常量，文档等的好地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Version of the realpython-reader package</span></span><br><span class="line">__version__ = <span class="string">"1.0.0"</span></span><br></pre></td></tr></table></figure><p>特殊变量__version__是Python中的约定，用于将版本号添加到包中。它是在PEP 396中引入的。稍后我们将详细讨论版本控制。</p><p>中定义的__init__.py变量在包名称空间中可用作变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reader</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reader.__version__</span><br><span class="line"><span class="string">'1.0.0'</span></span><br></pre></td></tr></table></figure><p>您还应该__version__在自己的包中定义变量。</p><h4 id="feed.py"><code>feed.py</code></h4><p>查看__main__.py，您将看到导入了两个模块feed和viewer，并用于从Feed中读取内容并显示结果。这些模块完成大部分实际工作。</p><p>首先考虑一下feed.py。该文件包含用于从Web订阅源读取和解析结果的功能。幸运的是，已经有很棒的库可以做到这一点。feed.py取决于PyPI上已有的两个模块：feedparser和html2text。</p><p>feed.py包含几个功能。我们将一次讨论一次。</p><p>为了避免从Web提要中读取过多信息，我们首先创建一个函数，以在第一次读取提要时记住该提要：</p><h1 id="feed.py-1">feed.py</h1><p>import feedparser<br />import html2text</p><p>_CACHED_FEEDS = dict()</p><p>def _feed(url):<br />"""Only read a feed once, by caching its contents"""<br />if url not in _CACHED_FEEDS:<br />_CACHED_FEEDS[url] = feedparser.parse(url)<br />return _CACHED_FEEDS[url]<br />feedparser.parse()从网络读取提要并以类似于字典的结构返回它。为了避免多次下载该供稿，将其存储在其中_CACHED_FEEDS并在以后调用时重复使用_feed()。两者_CACHED_FEEDS和_feed()均以下划线作为前缀，以表明它们是不打算直接使用的支持对象。</p><p>通过查看.feed元数据，我们可以获得有关提要的一些基本信息。以下功能挑选标题并链接到包含提要的网站：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_site</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""Get name and link to web site of the feed"""</span></span><br><span class="line">    info = _feed(url).feed</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;info.title&#125;</span> (<span class="subst">&#123;info.link&#125;</span>)"</span></span><br><span class="line">除了.title和.link，属性一样.subtitle，.updated和.id是也可以。</span><br><span class="line"></span><br><span class="line">供稿中可用的文章可以在.entries列表内找到。可以通过列表理解找到文章标题：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_titles</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""List titles in feed"""</span></span><br><span class="line">    articles = _feed(url).entries</span><br><span class="line">    <span class="keyword">return</span> [a.title <span class="keyword">for</span> a <span class="keyword">in</span> articles]</span><br><span class="line">.entries列出了Feed中按时间顺序排序的文章，因此最新的文章是.entries[<span class="number">0</span>]。</span><br><span class="line"></span><br><span class="line">为了获取一篇文章的内容，我们将其在.entries列表中的索引用作文章ID：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_article</span><span class="params">(url, article_id)</span>:</span></span><br><span class="line">    <span class="string">"""Get article from feed with the given ID"""</span></span><br><span class="line">    articles = _feed(url).entries</span><br><span class="line">    article = articles[int(article_id)]</span><br><span class="line">    html = article.content[<span class="number">0</span>].value</span><br><span class="line">    text = html2text.html2text(html)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"# <span class="subst">&#123;article.title&#125;</span>\n\n<span class="subst">&#123;text&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>从.entries列表中选择正确的文章后，我们在第28行找到该文章的文本为HTML。接下来，html2text做了一个体面的工作，将HTML转换为可读性更高的文本。由于HTML不包含文章标题，因此标题会在返回之前添加。</p><h4 id="viewer.py"><code>viewer.py</code></h4><p>最后一个模块是viewer.py。目前，它包含两个非常简单的功能。实际上，我们可以print()直接使用in <strong>main</strong>.py而不是调用viewer函数。但是，将功能拆分开可以使以后更轻松地用更高级的功能替换它。也许我们可以在更高版本中添加GUI界面？</p><p>viewer.py 包含两个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># viewer.py</span><br><span class="line"></span><br><span class="line">def show(article):</span><br><span class="line">    &quot;&quot;&quot;Show one article&quot;&quot;&quot;</span><br><span class="line">    print(article)</span><br><span class="line"></span><br><span class="line">def show_list(site, titles):</span><br><span class="line">    &quot;&quot;&quot;Show list of articles&quot;&quot;&quot;</span><br><span class="line">    print(f&quot;The latest tutorials from &#123;site&#125;&quot;)</span><br><span class="line">    for article_id, title in enumerate(titles):</span><br><span class="line">        print(f&quot;&#123;article_id:&gt;3&#125; &#123;title&#125;&quot;)</span><br></pre></td></tr></table></figure><p>show()只需将一篇文章打印到控制台，同时show_list()打印标题列表。后者还会创建在选择阅读一篇特定文章时使用的文章ID。</p><h3 id="调用包裹的不同方式">调用包裹的不同方式</h3><p>当您的项目变得越来越复杂时，挑战之一就是与用户交流如何使用您的项目。由于该软件包包含四个不同的源代码文件，因此用户如何知道要调用哪个文件来运行 <code>reader</code>？</p><p>该 <code>python</code> 解释程序有一个 <code>-m</code> 选项，允许你指定一个模块名称而不是文件名。例如，如果您有一个名为的脚本 <code>hello.py</code>，则以下两个命令是等效的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python hello.py</span><br><span class="line">Hi there!</span><br><span class="line"></span><br><span class="line">$ python -m hello</span><br><span class="line">Hi there!</span><br></pre></td></tr></table></figure><p>后者的优点之一是它还允许您调用Python内置的模块。一个例子是调用<a href="http://python-history.blogspot.com/2010/06/import-antigravity.html" target="_blank" rel="noopener"><code>antigravity</code></a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m antigravity</span><br><span class="line">Created new window <span class="keyword">in</span> existing browser session.</span><br></pre></td></tr></table></figure><p>使用的另一个优点 <code>-m</code> 是它既适用于包又适用于模块。如前所述，您可以通过以下方式调用 <code>reader</code> 软件包 <code>-m</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m reader</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>由于 <code>reader</code> 是软件包，因此名称仅指目录。Python如何确定该目录中要运行的代码？它查找名为的文件 <code>__main__.py</code> 。如果存在这样的文件，则将其执行。如果 <code>__main__.py</code> 不存在，则会显示一条错误消息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -m math</span><br><span class="line">python: No code object available <span class="keyword">for</span> math</span><br></pre></td></tr></table></figure><p>在此示例中，您看到 <code>math</code> 标准库尚未定义 <code>__main__.py</code> 文件。</p><p>如果要创建应该执行的程序包，则应包括一个 <code>__main__.py</code> 文件。<a href="https://realpython.com/pypi-publish-python-package/#configuring-your-package" target="_blank" rel="noopener">稍后</a>，您将看到如何还可以为程序包创建入口点，其行为类似于常规程序。</p><h2 id="准备打包发布">准备打包发布</h2><p>现在，您已经有了要发布的软件包，或者您已经<a href="https://github.com/realpython/reader" target="_blank" rel="noopener">复制了我们的软件包</a>。将包上传到PyPI之前，需要执行哪些步骤？</p><h3 id="命名包裹">命名包裹</h3><p>第一步（可能也是最困难的一步）是为您的包装命名。PyPI上的所有软件包都必须具有唯一的名称。在PyPI上已经有超过150,000个软件包，很可能已经采用了您喜欢的名称。</p><p>您可能需要集思广益，并做一些研究才能找到完美的名字。使用<a href="https://pypi.org/search/" target="_blank" rel="noopener">PyPI搜索</a>来检查名称是否已被使用。您想出的名称将在PyPI上可见。</p><p>为了使该<code>reader</code>包更易于在PyPI上找到，我们给它起了更具描述性的名称，并命名为<code>realpython-reader</code>。使用以下名称来安装软件包<code>pip</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install realpython-reader</span><br></pre></td></tr></table></figure><p>即使我们使用<code>realpython-reader</code>PyPI名称，<code>reader</code>但在导入时仍会调用该包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> reader</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(reader)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> reader <span class="keyword">import</span> feed</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>feed.get_titles()</span><br><span class="line">[<span class="string">'How to Publish an Open-Source Python Package to PyPI'</span>, ...]</span><br></pre></td></tr></table></figure><p>如您所见，您可以在PyPI上和导入时为包使用不同的名称。但是，如果您使用相同或非常相似的名称，则对您的用户而言将更加容易。</p><h3 id="配置程序包-1">配置程序包</h3><p>为了将您的包上传到PyPI，您需要提供有关它的一些基本信息。该信息通常以 <code>setup.py</code> 文件的形式提供。有一些<a href="https://www.python.org/dev/peps/pep-0518/" target="_blank" rel="noopener">举措</a>试图简化这种信息收集。目前，这 <code>setup.py</code> 是提供有关包装信息的唯一完全受支持的方法。</p><p>该 <code>setup.py</code> 文件应放在包的顶部文件夹中。一个相当最小 <code>setup.py</code> 的 <code>reader</code> 看起来像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># The directory containing this file</span></span><br><span class="line">HERE = pathlib.Path(__file__).parent</span><br><span class="line"></span><br><span class="line"><span class="comment"># The text of the README file</span></span><br><span class="line">README = (HERE / <span class="string">"README.md"</span>).read_text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># This call to setup() does all the work</span></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"realpython-reader"</span>,</span><br><span class="line">    version=<span class="string">"1.0.0"</span>,</span><br><span class="line">    description=<span class="string">"Read the latest Real Python tutorials"</span>,</span><br><span class="line">    long_description=README,</span><br><span class="line">    long_description_content_type=<span class="string">"text/markdown"</span>,</span><br><span class="line">    url=<span class="string">"https://github.com/realpython/reader"</span>,</span><br><span class="line">    author=<span class="string">"Real Python"</span>,</span><br><span class="line">    author_email=<span class="string">"office@realpython.com"</span>,</span><br><span class="line">    license=<span class="string">"MIT"</span>,</span><br><span class="line">    classifiers=[</span><br><span class="line">        <span class="string">"License :: OSI Approved :: MIT License"</span>,</span><br><span class="line">        <span class="string">"Programming Language :: Python :: 3"</span>,</span><br><span class="line">        <span class="string">"Programming Language :: Python :: 3.7"</span>,</span><br><span class="line">    ],</span><br><span class="line">    packages=[<span class="string">"reader"</span>],</span><br><span class="line">    include_package_data=<span class="literal">True</span>,</span><br><span class="line">    install_requires=[<span class="string">"feedparser"</span>, <span class="string">"html2text"</span>],</span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">"console_scripts"</span>: [</span><br><span class="line">            <span class="string">"realpython=reader.__main__:main"</span>,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们将仅涵盖 <code>setuptools</code> 此处提供的一些选项。该<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#basic-use" target="_blank" rel="noopener">文档</a>很好地完成了所有细节。</p><p>调用中100％必需的参数 <code>setup()</code> 如下：</p><ul><li><strong><code>name</code>：</strong>将在PyPI上显示的软件包名称</li><li><strong><code>version</code>：</strong>您软件包的当前版本</li><li><strong><code>packages</code>：</strong>包含您的源代码的软件包和子软件包</li></ul><p>稍后我们将<a href="https://realpython.com/pypi-publish-python-package/#versioning-your-package" target="_blank" rel="noopener">详细讨论版本</a>。该<code>packages</code>参数获取软件包列表。在我们的示例中，只有一个包：<code>reader</code>。</p><p>您还需要指定任何子包。在更复杂的项目中，可能会列出许多软件包。为了简化此工作，<code>setuptools</code>包括include <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html#using-find-packages" target="_blank" rel="noopener"><code>find_packages()</code></a>可以很好地发现所有子包。您可以按以下方式<code>find_packages()</code>在<code>reader</code>项目中使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> find_packages, setup</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ...</span><br><span class="line">    packages=find_packages(exclude=(<span class="string">"tests"</span>,)),</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>虽然只是<code>name</code>，<code>version</code>和<code>packages</code>需要，你的包变得更容易找到PyPI上如果添加一些更多的信息。看一下<a href="https://pypi.org/project/realpython-reader/" target="_blank" rel="noopener"><code>realpython-reader</code>PyPI</a>上的<a href="https://pypi.org/project/realpython-reader/" target="_blank" rel="noopener">页面</a>，并将信息与<code>setup.py</code>上面的内容进行比较。所有信息都来自<code>setup.py</code>和<code>README.md</code>。</p><p><img src="https://2020.iosdevlog.com/2020/03/22/pip/pypi_realpython-reader.png" /></p><p>最后两个参数<code>setup()</code>值得特别提及：</p><ul><li><p><strong><code>install_requires</code></strong>用于列出您的软件包对第三方库的任何依赖关系。在<code>reader</code>依赖于<code>feedparser</code>和<code>html2text</code>，因此他们应该在这里列出。</p></li><li><p><strong><code>entry_points</code></strong>用于创建调用程序包中的函数的脚本。在我们的示例中，我们创建了一个在文件内<code>realpython</code>调用的新脚本 <code>reader/__main__.py</code>。</p></li></ul><p><img src="https://2020.iosdevlog.com/2020/03/22/pip/How-to-publish-an-open-source-Python-package-to-PyPI_Watermark.png" /></p><p>有关典型安装文件的另一个示例，请参阅<a href="https://github.com/kennethreitz/setup.py" target="_blank" rel="noopener"><code>setup.py</code>GitHub上的</a> Kenneth Reitz的<a href="https://github.com/kennethreitz/setup.py" target="_blank" rel="noopener">存储库</a>。</p><h3 id="记录包裹">记录包裹</h3><p>在向外界发布您的软件包之前，您应该<a href="https://realpython.com/documenting-python-code/" target="_blank" rel="noopener">添加一些文档</a>。根据您的软件包，文档可以小到一个简单的<code>README</code>文件，也可以大到包括教程，示例库和API参考的完整网页。</p><p>至少，您应该<code>README</code>在项目中包含一个文件。<a href="https://dbader.org/blog/write-a-great-readme-for-your-github-project" target="_blank" rel="noopener">一个好的人<code>README</code></a>应该快速描述您的项目，并告诉您的用户如何安装和使用您的软件包。通常，您希望将包括在内<code>README</code>作为<code>long_description</code>参数<code>setup()</code>。这将<code>README</code>在PyPI上显示您。</p><p>传统上，PyPI使用<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>来包装文档。然而，由于2018三月<a href="https://www.markdownguide.org/basic-syntax" target="_blank" rel="noopener">降价</a>已经<a href="https://dustingram.com/articles/2018/03/16/markdown-descriptions-on-pypi" target="_blank" rel="noopener">也被支持</a>。</p><p>在PyPI之外，Markdown比reStructuredText更受支持。如果您不需要reStructuredText的任何特殊功能，最好将其保留<code>README</code>在Markdown中。请注意，您应该使用<code>setup()</code>参数<code>long_description_content_type</code>来<a href="https://packaging.python.org/guides/making-a-pypi-friendly-readme/?highlight=long_description_content_type" target="_blank" rel="noopener">告诉您使用哪种格式的PyPI</a>。有效值是<code>text/markdown</code>，<code>text/x-rst</code>和<code>text/plain</code>。</p><p>对于较大的项目，您可能想提供比合理地容纳在单个文件中更多的文档。在这种情况下，您可以使用<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>或<a href="https://readthedocs.org/" target="_blank" rel="noopener">Read Docs之</a>类的网站，并使用<code>url</code>参数链接到文档。在<code>setup.py</code>上面的示例中，<code>url</code>用于链接到<a href="https://github.com/realpython/reader" target="_blank" rel="noopener"><code>reader</code>GitHub存储库</a>。</p><h3 id="打包版本">打包版本</h3><p>您的软件包需要有一个版本，而PyPI仅允许您为软件包上传一个特定版本。换句话说，如果要在PyPI上更新软件包，则需要先增加版本号。这是一件好事，因为它保证了可重复性：具有相同版本软件包的两个系统应具有相同的行为。</p><p>有<a href="https://en.wikipedia.org/wiki/Software_versioning" target="_blank" rel="noopener">许多不同的方案</a>，可用于您的版本号。对于Python项目，<a href="https://www.python.org/dev/peps/pep-0440/" target="_blank" rel="noopener">PEP 440</a>提供了一些建议。但是，为了灵活起见，PEP很复杂。对于简单的项目，请坚持使用简单的版本控制方案。</p><p><a href="https://semver.org/" target="_blank" rel="noopener">语义版本控制</a>是一个很好的默认方案。版本号由三个数字部分给出，例如<code>0.1.2</code>。这些组件称为MAJOR，MINOR和PATCH，并且有关于何时增加每个组件的简单规则：</p><blockquote><ul><li>当您更改不兼容的API时，请增加MAJOR版本。</li><li>当您以向后兼容的方式添加功能时，请增加MINOR版本。</li><li>进行向后兼容的错误修复时，请增加PATCH版本。（<a href="https://semver.org/" target="_blank" rel="noopener">来源</a>）</li></ul></blockquote><p>您可能需要在项目内的其他文件中指定版本。在<code>reader</code>项目中，我们在<code>setup.py</code>和中都指定了版本<code>reader/__init__.py</code>。为了确保版本号保持一致，可以使用一个名为<a href="https://pypi.org/project/bumpversion/" target="_blank" rel="noopener">Bumpversion</a>的工具。</p><p>您可以从PyPI安装Bumpversion：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install bumpversion</span><br></pre></td></tr></table></figure><p>要增加MINOR版本<code>reader</code>，您可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bumpversion --current-version <span class="number">1.0</span><span class="number">.0</span> minor setup.py reader/__init__.py</span><br></pre></td></tr></table></figure><p>这将更改从版本号<code>1.0.0</code>以<code>1.1.0</code>两个<code>setup.py</code>和<code>reader/__init__.py</code>。为了简化命令，您还可以在配置文件中提供大多数信息。有关详细信息，请参见<a href="https://pypi.org/project/bumpversion/" target="_blank" rel="noopener">Bumpversion文档</a>。</p><h3 id="将文件添加到包中">将文件添加到包中</h3><p>有时，您的程序包中会包含不是源代码文件的文件。示例包括数据文件，二进制文件，文档以及（如我们在本项目中一样）配置文件。</p><p>要告知<code>setup()</code>要包含此类文件，请使用清单文件。对于许多项目，您无需担心清单，因为它<code>setup()</code>创建了一个清单，其中包括所有代码文件以及<code>README</code>文件。</p><p>如果需要更改清单，请创建一个清单模板，该模板必须命名为<code>MANIFEST.in</code>。该文件为要包含和排除的内容指定了规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include reader/*.txt</span><br></pre></td></tr></table></figure><p>此示例将包括<code>.txt</code>目录中的所有文件，该文件<code>reader</code>实际上是配置文件。请参阅<a href="https://docs.python.org/distutils/commandref.html#creating-a-source-distribution-the-sdist-command" target="_blank" rel="noopener">文档</a>以获取可用规则列表。</p><p>除了创建之外<code>MANIFEST.in</code>，还需要告诉<code>setup()</code>您<a href="https://python-packaging.readthedocs.io/en/latest/non-code-files.html" target="_blank" rel="noopener">复制这些非代码文件</a>。这是通过将<code>include_package_data</code>参数设置为来完成的<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setup(</span><br><span class="line">    ...</span><br><span class="line">    include_package_data=<span class="literal">True</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该<code>include_package_data</code>参数控制在安装软件包时是否复制非代码文件。</p><h2 id="发布到pypi">发布到PyPI</h2><p>您的包裹终于准备就绪，可以与您的计算机外部世界见面！在本节中，您将看到如何实际将软件包上传到PyPI。</p><p>如果您尚未在PyPI上拥有帐户，那么现在该创建一个<a href="https://pypi.org/account/register/" target="_blank" rel="noopener">帐户了：在PyPI上注册您的帐户</a>。在使用它时，还应该<a href="https://test.pypi.org/manage/projects/" target="_blank" rel="noopener">在TestPyPI上注册一个帐户</a>。TestPyPI非常有用，因为如果您搞砸了，可以尝试发布软件包的所有步骤，而不会造成任何后果。</p><p>要将软件包上传到PyPI，您将使用一个名为<a href="https://twine.readthedocs.io/" target="_blank" rel="noopener">Twine</a>的工具。您可以照常使用Pip安装Twine：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install twine</span><br></pre></td></tr></table></figure><p>使用Twine非常简单，您将很快看到如何使用它来检查和发布您的软件包。</p><h3 id="建立你的包裹">建立你的包裹</h3><p>PyPI上的软件包不作为纯源代码分发。而是将它们包装到分发包中。分发程序包最常见的格式是源档案和<a href="https://wheel.readthedocs.io/en/stable/" target="_blank" rel="noopener">Python wheel</a>。</p><p>源归档文件由您的源代码和包装在一个<a href="https://en.wikipedia.org/wiki/Tar_%28computing%29" target="_blank" rel="noopener"><code>tar</code>文件中的</a>所有支持文件组成。同样，轮子实际上是包含您的代码的zip存档。与源归档文件相反，该转轮包括任何可以使用的扩展名。</p><p>要为您的包裹创建一个源档案和一个转轮，您可以运行以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><p>这将在一个新创建的<code>dist</code>目录中创建两个文件，一个源档案和一个转轮：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reader/</span><br><span class="line">│</span><br><span class="line">└── dist/</span><br><span class="line">    ├── realpython_reader<span class="number">-1.0</span><span class="number">.0</span>-py3-none-any.whl</span><br><span class="line">    └── realpython-reader<span class="number">-1.0</span><span class="number">.0</span>.tar.gz</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>在Windows上，<code>.zip</code>默认情况下，源归档文件将是一个文件。您可以<a href="https://python.readthedocs.io/en/stable/distutils/sourcedist.html" target="_blank" rel="noopener">使用<code>--format</code>命令行选项选择</a>源归档的格式。</p><p>您可能想知道如何<code>setup.py</code>知道如何处理<code>sdist</code>and <code>bdist_wheel</code>参数。如果你<a href="https://realpython.com/pypi-publish-python-package/#configuring-your-package" target="_blank" rel="noopener">回头看看</a>如何<code>setup.py</code>被实现的，有没有提及<code>sdist</code>，<code>bdist_wheel</code>或任何其他命令行参数。</p><p>相反，所有命令行参数都在上游<a href="https://github.com/python/cpython/tree/master/Lib/distutils/command" target="_blank" rel="noopener"><code>distutils</code>标准库中实现</a>。您可以通过添加<code>--help-commands</code>选项列出所有可用的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python setup.py --help-commands</span><br><span class="line">Standard commands:</span><br><span class="line"> build             build everything needed to install</span><br><span class="line"> build_py          <span class="string">"build"</span> pure Python modules (copy to build directory)</span><br><span class="line"> build_ext         build C/C++ <span class="keyword">and</span> Cython extensions (compile/link to build directory)</span><br><span class="line">&lt; ... many more commands ...&gt;</span><br></pre></td></tr></table></figure><p>有关一个特定命令的信息，您可以执行类似的操作<code>python setup.py sdist --help</code>。</p><h3 id="测试您的包裹">测试您的包裹</h3><p>首先，您应检查新建的分发程序包是否包含所需的文件。在Linux和macOS上，您应该能够<code>tar</code>如下列出源档案的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ tar tzf realpython-reader<span class="number">-1.0</span><span class="number">.0</span>.tar.gz</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/setup.cfg</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/README.md</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/feed.py</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/__init__.py</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/viewer.py</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/__main__.py</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/reader/config.txt</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/PKG-INFO</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/setup.py</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/MANIFEST.<span class="keyword">in</span></span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/SOURCES.txt</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/requires.txt</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/dependency_links.txt</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/PKG-INFO</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/entry_points.txt</span><br><span class="line">realpython-reader<span class="number">-1.0</span><span class="number">.0</span>/realpython_reader.egg-info/top_level.txt</span><br></pre></td></tr></table></figure><p>在Windows上，您可以使用<a href="https://www.7-zip.org/" target="_blank" rel="noopener">7-zip之</a>类的实用程序来查看相应<code>zip</code>文件的内部。</p><p>您应该看到列出了所有源代码，以及已经创建的一些新文件，其中包含您在中提供的信息<code>setup.py</code>。特别是，请确保包括所有子包和支持文件。</p><p>您也可以通过解压缩轮子来查看轮子内部，就好像它是一个zip文件一样。但是，如果您的源归档文件包含您期望的文件，则转轮也应该很好。</p><p>较新版本的Twine（<code>1.12.0</code>及更高版本）还可以检查您的包装说明可在PyPI上正确呈现。您可以<code>twine check</code>在中创建的文件上运行<code>dist</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ twine check dist/*</span><br><span class="line">Checking distribution dist/realpython_reader<span class="number">-1.0</span><span class="number">.0</span>-py3-none-any.whl: Passed</span><br><span class="line">Checking distribution dist/realpython-reader<span class="number">-1.0</span><span class="number">.0</span>.tar.gz: Passed</span><br></pre></td></tr></table></figure><p>虽然它不能解决您可能遇到的所有问题，但是例如，它将使您知道使用的内容类型是否错误。</p><h3 id="上载您的包裹">上载您的包裹</h3><p>现在，您可以将包实际上传到PyPI了。为此，您将再次使用“ Twine”工具，告诉它上载已构建的分发程序包。首先，您应该上传到<a href="https://packaging.python.org/guides/using-testpypi/" target="_blank" rel="noopener">TestPyPI</a>以确保一切正常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ twine upload --repository-url https://test.pypi.org/legacy/ dist/*</span><br></pre></td></tr></table></figure><p>Twine会询问您您的用户名和密码。</p><p><strong>注意：</strong>如果您以<code>reader</code>软件包为例按照本教程进行操作，则先前的命令可能会失败，并显示一条消息，提示您不允许上载到<code>realpython-reader</code>项目。</p><p>您可以将<code>name</code>in 更改为<code>setup.py</code>唯一的内容，例如<code>test-your-username</code>。然后再次构建项目，并将新建的文件上传到TestPyPI。</p><p>如果上传成功，您可以快速转到<a href="https://test.pypi.org/" target="_blank" rel="noopener">TestPyPI</a>，向下滚动并查看在新版本中自豪地显示的项目！单击您的包裹，并确保一切正常。</p><p>如果您一直在使用该<code>reader</code>软件包，那么教程将在此处结束！尽管您可以随意使用TestPyPI，但不应将虚拟包上传到PyPI进行测试。</p><p>但是，如果您要发布自己的软件包，那么此刻终于来临！完成所有准备工作后，最后一步很短：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ twine upload dist/*</span><br></pre></td></tr></table></figure><p>根据要求提供您的用户名和密码。而已！</p><p>前往<a href="https://pypi.org/" target="_blank" rel="noopener">PyPI</a>并查找您的包裹。您可以通过<a href="https://pypi.org/search/" target="_blank" rel="noopener">搜索</a>，查看“ <a href="https://pypi.org/manage/projects/" target="_blank" rel="noopener"><em>您的项目”</em>页面</a>或直接转到项目的URL：<a href="https://pypi.org/project/realpython-reader/" target="_blank" rel="noopener">pypi.org/project/your-package-name/</a>来找到它。</p><p>恭喜你！您的软件包已在PyPI上发布！</p><h3 id="pip-install-您的包裹"><code>pip install</code> 您的包裹</h3><p>花一点时间沐浴在PyPI网页的蓝色光芒中，（当然）向您的朋友吹牛。</p><p>然后再次打开一个终端。还有一个更大的回报！</p><p>将您的软件包上传到PyPI后，您还可以通过以下方式进行安装<code>pip</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install your-package-name</span><br></pre></td></tr></table></figure><p>替换<code>your-package-name</code>为您为软件包选择的名称。例如，要安装<code>reader</code>软件包，您可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install realpython-reader</span><br></pre></td></tr></table></figure><p>看到自己安装的代码<code>pip</code>是一种美妙的感觉！</p><h2 id="其他有用的工具">其他有用的工具</h2><p>在总结之前，还有一些其他的工具对于创建和发布Python软件包非常有用。</p><h3 id="虚拟环境">虚拟环境</h3><p>在本指南中，我们没有讨论虚拟环境。当使用不同的项目时，虚拟环境非常有用，每个项目都有各自不同的要求和依赖性。</p><p>有关更多信息，请参见以下指南：</p><ul><li><a href="https://realpython.com/python-virtual-environments-a-primer" target="_blank" rel="noopener">Python虚拟环境：入门</a></li><li><a href="https://realpython.com/pipenv-guide" target="_blank" rel="noopener">Pipenv：新Python打包工具指南</a></li><li><a href="https://realpython.com/products/managing-python-dependencies/" target="_blank" rel="noopener">使用Pip和虚拟环境管理Python依赖关系</a></li></ul><p>特别是，在最小的虚拟环境中测试软件包很有用，以确保在<code>setup.py</code>文件中包含所有必需的依赖项。</p><h3 id="切碎机">切碎机</h3><p>开始使用项目的一种好方法是使用<a href="https://cookiecutter.readthedocs.io/" target="_blank" rel="noopener">Cookiecutter</a>。它通过基于模板询问几个问题来设置您的项目。<a href="https://cookiecutter.readthedocs.io/en/latest/README.html#a-pantry-full-of-cookiecutters" target="_blank" rel="noopener">可以使用许多不同的模板</a>。</p><p>首先，请确保您的系统上安装了Cookiecutter。您可以从PyPI安装它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install cookiecutter</span><br></pre></td></tr></table></figure><p>作为示例，我们将使用<a href="https://github.com/kragniz/cookiecutter-pypackage-minimal" target="_blank" rel="noopener">pypackage-minimal</a>模板。要使用模板，请给Cookiecutter指向模板的链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cookiecutter https://github.com/kragniz/cookiecutter-pypackage-minimal</span><br><span class="line">author_name [Louis Taylor]: Real Python</span><br><span class="line">author_email [louis@kragniz.eu]: office@realpython.com</span><br><span class="line">package_name [cookiecutter_pypackage_minimal]: realpython-reader</span><br><span class="line">package_version [<span class="number">0.1</span><span class="number">.0</span>]:</span><br><span class="line">package_description [...]: Read Real Python tutorials</span><br><span class="line">package_url [...]: https://github.com/realpython/reader</span><br><span class="line">readme_pypi_badge [<span class="literal">True</span>]:</span><br><span class="line">readme_travis_badge [<span class="literal">True</span>]: <span class="literal">False</span></span><br><span class="line">readme_travis_url [...]:</span><br></pre></td></tr></table></figure><p>在回答了一系列问题之后，Cookiecutter设置您的项目。在此示例中，模板创建了以下文件和目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">realpython-reader/</span><br><span class="line">│</span><br><span class="line">├── realpython-reader/</span><br><span class="line">│   └── __init__.py</span><br><span class="line">│</span><br><span class="line">├── tests/</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── test_sample.py</span><br><span class="line">│</span><br><span class="line">├── README.rst</span><br><span class="line">├── setup.py</span><br><span class="line">└── tox.ini</span><br></pre></td></tr></table></figure><p><a href="https://cookiecutter.readthedocs.io/" target="_blank" rel="noopener">Cookiecutter的文档</a>内容广泛，包括一长串可用的cookiecutter，以及有关如何创建自己的模板的教程。</p><h3 id="掠过">掠过</h3><p><a href="https://www.pypa.io/en/latest/history/" target="_blank" rel="noopener">Python打包的历史</a>非常混乱。一种<a href="https://www.python.org/dev/peps/pep-0518/#rationale" target="_blank" rel="noopener">普遍的批评</a>是，使用可执行文件之类<code>setup.py</code>的配置信息并不理想。</p><p><a href="https://www.python.org/dev/peps/pep-0518/" target="_blank" rel="noopener">PEP 518</a>定义了一个替代方案：使用一个名为的文件<code>pyproject.toml</code>代替。该<a href="https://github.com/toml-lang/toml" target="_blank" rel="noopener">TOML格式</a>是一个简单的配置文件格式：</p><blockquote><p>[…] it is human-usable (unlike JSON), it is flexible enough (unlike configparser), stems from a standard (also unlike configparser), and it is not overly complex (unlike YAML). (<a href="https://www.python.org/dev/peps/pep-0518/#file-format" target="_blank" rel="noopener">Source</a>)</p></blockquote><p>虽然PEP 518已经使用了几年，但 <code>pyproject.toml</code> 标准工具尚未完全支持该配置文件。</p><p>但是，有一些基于的新工具可以发布到PyPI <code>pyproject.toml</code>。这样的工具就是<a href="https://flit.readthedocs.io/" target="_blank" rel="noopener">Flit</a>，这是一个很棒的小项目，可轻松发布简单的Python包。Flit不支持高级软件包，例如创建C扩展的软件包。</p><p>您可以<code>pip install flit</code>，然后按如下所示开始使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ flit init</span><br><span class="line">Module name [reader]:</span><br><span class="line">Author []: Real Python</span><br><span class="line">Author email []: office@realpython.com</span><br><span class="line">Home page []: https://github.com/realpython/reader</span><br><span class="line">Choose a license (see http://choosealicense.com/ <span class="keyword">for</span> more info)</span><br><span class="line"><span class="number">1</span>\. MIT - simple <span class="keyword">and</span> permissive</span><br><span class="line"><span class="number">2</span>\. Apache - explicitly grants patent rights</span><br><span class="line"><span class="number">3</span>\. GPL - ensures that code based on this <span class="keyword">is</span> shared <span class="keyword">with</span> the same terms</span><br><span class="line"><span class="number">4</span>\. Skip - choose a license later</span><br><span class="line">Enter <span class="number">1</span><span class="number">-4</span> [<span class="number">1</span>]:</span><br><span class="line"></span><br><span class="line">Written pyproject.toml; edit that file to add optional extra info.</span><br></pre></td></tr></table></figure><p>该<code>flit init</code>命令将<code>pyproject.toml</code>根据您对几个问题的答案创建文件。使用该文件之前，您可能需要稍微对其进行编辑。对于该<code>reader</code>项目，<code>pyproject.toml</code>Flit文件最终看起来如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">"flit"</span>]</span><br><span class="line">build-backend = <span class="string">"flit.buildapi"</span></span><br><span class="line"></span><br><span class="line">[tool.flit.metadata]</span><br><span class="line">module = <span class="string">"reader"</span></span><br><span class="line">dist-name = <span class="string">"realpython-reader"</span></span><br><span class="line">description-file = <span class="string">"README.md"</span></span><br><span class="line">author = <span class="string">"Real Python"</span></span><br><span class="line">author-email = <span class="string">"office@realpython.com"</span></span><br><span class="line">home-page = <span class="string">"https://github.com/realpython/reader"</span></span><br><span class="line">classifiers = [</span><br><span class="line"> <span class="string">"License :: OSI Approved :: MIT License"</span>,</span><br><span class="line"> <span class="string">"Programming Language :: Python :: 3"</span>,</span><br><span class="line"> <span class="string">"Programming Language :: Python :: 3.7"</span>,</span><br><span class="line">]</span><br><span class="line">requires-python = <span class="string">"&gt;=3.7"</span></span><br><span class="line">requires = [<span class="string">"feedparser"</span>, <span class="string">"html2text"</span>]</span><br><span class="line"></span><br><span class="line">[tool.flit.scripts]</span><br><span class="line">realpython = <span class="string">"reader.__main__:main"</span></span><br></pre></td></tr></table></figure><p>您应该从我们的原始物品中识别出大多数物品<code>setup.py</code>。但是要注意的一件事是，<code>version</code>并且<code>description</code>缺少。这不是一个错误。Flit实际上通过使用<code>__version__</code>和<code>__init__.py</code>文件中定义的docstring 自己找出了这些。<a href="https://flit.readthedocs.io/" target="_blank" rel="noopener">Flit的文档</a>解释了有关<code>pyproject.toml</code>文件的所有内容。</p><p>Flit可以构建您的包，甚至将其发布到PyPI。要构建您的软件包，只需执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flit build</span><br></pre></td></tr></table></figure><p>就像<code>python setup.py sdist bdist_wheel</code>之前一样，这将创建一个源存档和一个转盘。要将软件包上传到PyPI，您可以像以前一样使用Twine。但是，您也可以直接使用Flit：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flit publish</span><br></pre></td></tr></table></figure><p>如果需要 <code>publish</code>，该命令将构建您的软件包，然后将文件上传到PyPI，并在必要时提示您输入用户名和密码。</p><p>要了解Flit的实际应用，请查看EuroSciPy 2017 的<a href="https://www.youtube.com/watch?v=qTgk2DUM6G0&amp;t=11m50s" target="_blank" rel="noopener">2分钟闪电演讲</a>。Flit <a href="https://flit.readthedocs.io/" target="_blank" rel="noopener">文档</a>是获取更多信息的重要资源。Brett Cannon的<a href="https://snarky.ca/a-tutorial-on-python-package-building/" target="_blank" rel="noopener">打包PyPI的Python代码</a>的<a href="https://snarky.ca/a-tutorial-on-python-package-building/" target="_blank" rel="noopener">教程</a>包括有关Flit的部分。</p><h3 id="诗歌poetry">诗歌（poetry）</h3><p><a href="https://poetry.eustace.io/" target="_blank" rel="noopener">诗歌（poetry）</a>是可以用来构建和上传软件包的另一种工具。它与Flit非常相似，尤其是对于我们在这里要看的东西。</p><p>使用诗歌之前，需要先安装它。也有可能<code>pip install poetry</code>。但是，<a href="https://poetry.eustace.io/docs/#installation" target="_blank" rel="noopener">作者建议</a>您使用自定义安装脚本来避免潜在的依赖冲突。请参阅<a href="https://poetry.eustace.io/docs/#installation" target="_blank" rel="noopener">文档</a>以获取安装说明。</p><p>安装了Poetry之后，您可以通过以下<code>init</code>命令开始使用它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ poetry init</span><br><span class="line"></span><br><span class="line">This command will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [code]: realpython-reader</span><br><span class="line">Version [<span class="number">0.1</span><span class="number">.0</span>]: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">Description []: Read the latest Real Python tutorials</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这将<code>pyproject.toml</code>根据您对包裹问题的回答创建一个文件。不幸的是，《<code>pyproject.toml</code>弗里特》和《诗歌》中的实际规范有所不同。对于诗歌，<code>pyproject.toml</code>文件最终看起来如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">"realpython-reader"</span></span><br><span class="line">version = <span class="string">"1.0.0"</span></span><br><span class="line">description = <span class="string">"Read the latest Real Python tutorials"</span></span><br><span class="line">readme = <span class="string">"README.md"</span></span><br><span class="line">homepage = <span class="string">"https://github.com/realpython/reader"</span></span><br><span class="line">authors = [<span class="string">"Real Python &lt;office@realpython.com&gt;"</span>]</span><br><span class="line">license = <span class="string">"MIT"</span></span><br><span class="line">packages = [&#123;include = <span class="string">"reader"</span>&#125;]</span><br><span class="line">include = [<span class="string">"reader/*.txt"</span>]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">"&gt;=3.7"</span></span><br><span class="line">feedparser = <span class="string">"&gt;=5.2"</span></span><br><span class="line">html2text = <span class="string">"&gt;=2018.1"</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.scripts]</span><br><span class="line">realpython = <span class="string">"reader.__main__:main"</span></span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">"poetry&gt;=0.12"</span>]</span><br><span class="line">build-backend = <span class="string">"poetry.masonry.api"</span></span><br></pre></td></tr></table></figure><p>同样，您应该从的早期讨论中认识到所有这些项目<code>setup.py</code>。需要注意的一件事是，Poetry会根据许可证和您指定的Python版本自动添加分类器。诗歌还要求您明确说明依赖项的版本。实际上，依赖性管理是诗歌的长处之一。</p><p>就像Flit一样，Poetry可以构建软件包并将其上传到PyPI。该<code>build</code>命令创建一个源档案和一个轮子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry build</span><br></pre></td></tr></table></figure><p>这将在<code>dist</code>子目录中创建两个常用文件，您可以像以前一样使用Twine上载这些文件。您还可以使用“诗歌”发布到PyPI：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ poetry publish</span><br></pre></td></tr></table></figure><p>这会将您的包上传到PyPI。除了构建和发布外，Poetry还可以在此过程的早期帮助您。类似于Cookiecutter，Poetry可以帮助您使用该<code>new</code>命令启动新项目。它还支持使用虚拟环境。有关所有详细信息，请参见<a href="https://poetry.eustace.io/docs/" target="_blank" rel="noopener">诗歌的文档</a>。</p><p>除了略有不同的配置文件外，Flit和Poetry的工作原理非常相似。诗歌的范围更广，因为它还旨在帮助进行依属关系管理，而弗利特（Flit）的历史已经更长了。安德鲁·平克汉姆（Andrew Pinkham）的文章《<a href="http://andrewsforge.com/article/python-new-package-landscape/" target="_blank" rel="noopener">Python的新包装</a>格局》涵盖了Flit和Poetry。诗歌是<a href="https://pythonbytes.fm/episodes/show/100/the-big-100-with-special-guests" target="_blank" rel="noopener">Python Bytes播客第100集</a>的特别主题之一。</p><h2 id="结论">结论</h2><p>您现在知道了如何准备项目并将其上传到PyPI，以便其他人可以安装和使用它。尽管您需要完成一些步骤，但是在PyPI上看到自己的软件包是很有意义的。让其他人发现您的项目很有用！</p><p>在本教程中，您已经看到发布自己的程序包所必需的步骤：</p><ul><li>为您的包裹找一个好名字</li><li>使用以下方式配置您的软件包 <code>setup.py</code></li><li>建立你的包裹</li><li>将您的包上传到PyPI</li></ul><p>此外，您还看到了一些用于发布程序包的新工具，这些工具使用新的<code>pyproject.toml</code>配置文件来简化过程。</p><p>如果您仍有疑问，请随时在下面的评论部分中提出。另外，<a href="https://packaging.python.org/" target="_blank" rel="noopener">Python打包机构</a>拥有比我们此处介绍的更多的信息。</p><p>原文：<a href="https://realpython.com/pypi-publish-python-package/" target="_blank" rel="noopener">How to Publish an Open-Source Python Package to PyPI</a><br />作者：<a href="https://realpython.com/team/gahjelle/" target="_blank" rel="noopener">About Geir Arne Hjelle</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/22/pip/How-to-publish-an-open-source-Python-package-to-PyPI_Watermark.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本教程有一个由 Real Python 团队创建的相关视频课程。与书面教程一起观看，以加深您的理解：如何将自己的 Python 包发布到 PyPI 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="code" scheme="https://2020.iosdevlog.com/categories/code/"/>
    
    
      <category term="Python" scheme="https://2020.iosdevlog.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>最有效的 Python 项目源码阅读方式</title>
    <link href="https://2020.iosdevlog.com/2020/03/21/pylint/"/>
    <id>https://2020.iosdevlog.com/2020/03/21/pylint/</id>
    <published>2020-03-21T14:54:29.000Z</published>
    <updated>2020-03-21T15:56:32.036Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/21/pylint/pylint.png" /></p><p>Pylint - Star your Python code!</p><a id="more"></a><p>众所周知，目前（2020年）人工智能项目大部分代码是使用 <code>Python</code> 语言编写的。</p><p>在发 <code>Paper</code> 的学术界有 <code>Pytorch</code>；在工业界部署 <code>First</code> 的工业界，这两个框架已经占据了深度学习的中心地位。</p><p>在机器学习领域有包含几乎所有常用机器学习算法的开源库：<code>sklean</code>。</p><p>如果遇到问题，找开源代码是参考是最简捷的方案。</p><p>目前大部分的人工智能相关项目的源码都是合适 <code>Python</code> 编写的，如何快速阅读这些源码呢？</p><p>这里推荐一套最有效的阅读 <code>Python</code> 源码的方式。</p><ol type="1"><li>下载相关源码：推荐去 <code>GitHub</code> 上下载，也可以用 <code>Chrome</code> 插件看</li><li>查看 <code>README.md</code> 和相关说明文档</li><li>参考 <code>Tutorials</code> 将代码跑起来</li><li>利用 <a href="https://www.pylint.org" target="_blank" rel="noopener">Pyreverse 包含在 Pypylint</a> 生成项目框架图</li><li>找到需要参考的代码，修改</li></ol><p>下面介绍一下如何生成 <code>manim</code> 项目框架图</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pylint</span></span><br><span class="line">pip install pylint</span><br><span class="line"><span class="comment"># touch ....../__init__.py</span></span><br><span class="line">pyreverse -A -o png -p manimlib manim/manimlib</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/21/pylint/pylint.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Pylint - Star your Python code!&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://2020.iosdevlog.com/categories/Python/"/>
    
    
      <category term="Code" scheme="https://2020.iosdevlog.com/tags/Code/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》第 14 章 聚类方法 KMeans</title>
    <link href="https://2020.iosdevlog.com/2020/03/20/kmeans/"/>
    <id>https://2020.iosdevlog.com/2020/03/20/kmeans/</id>
    <published>2020-03-20T15:48:06.000Z</published>
    <updated>2020-03-20T15:52:10.458Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/20/kmeans/kmeans.gif" /></p><a id="more"></a><h2 id="k-均值聚类">k-均值聚类</h2><p>n 个样本分到 k 个不同的类或簇，每个样本到其所属类的中心的距离最小。</p><p>每个样本只能属于一个类，所有 <strong>k-均值聚类</strong> 是 <strong>硬聚类</strong>。</p><h3 id="模型">模型</h3><ul><li>k &lt; n</li></ul><p><span class="math display">\[G_{i} \cap G_{j} = \varnothing, \bigcup_{i=1}^{k}G_{i} = X\]</span></p><!--more--><h3 id="策略">策略</h3><ul><li>距离： 欧式距离</li><li>损失函数：样本与所属类的中心的距离总保</li><li>NP 困难问题</li></ul><h3 id="算法">算法</h3><p>目标函数极小化</p><ol type="1"><li>初始化，随机取 $ k $ 个样本做中心</li><li>对样本进行聚类，计算样本到类中心距离，每个样本指派到与其最近的中心的类</li><li>计算新的类中心。对聚类结果计算样本的均值，做为新的类中心</li><li>如果迭代收敛或符合停止条件，输出。否则，令 $ t = t + 1 $ ，返回 2</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">    self._setup_input(X)</span><br><span class="line">    n_samples, _ = X.shape</span><br><span class="line">    <span class="comment"># 从 X 中随机获取 k 个元素做中心</span></span><br><span class="line">    self._centers = np.array(</span><br><span class="line">        random.sample(list(np.unique(X, axis=<span class="number">0</span>)), self.k))</span><br><span class="line"></span><br><span class="line">    old_clusters = <span class="literal">None</span></span><br><span class="line">    n_iters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        new_clusters = [self._min_k(x) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> new_clusters == old_clusters:</span><br><span class="line">            print(<span class="string">"Training finished after &#123;n_iters&#125; iterations!"</span>.format(n_iters=n_iters))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        old_clusters = new_clusters</span><br><span class="line">        n_iters += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cluster_i <span class="keyword">in</span> range(self.k):</span><br><span class="line">            <span class="comment"># 计算新的中心</span></span><br><span class="line">            points_idx = np.where(np.array(new_clusters) == cluster_i)</span><br><span class="line">            xi = X[points_idx]</span><br><span class="line">            self._centers[cluster_i] = xi.mean(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        self._centers_list.append(np.copy(self._centers))</span><br></pre></td></tr></table></figure><p>源码：<a href="https://github.com/iOSDevLog/slmethod" target="_blank" rel="noopener">https://github.com/iOSDevLog/slmethod</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/20/kmeans/kmeans.gif&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计学习方法" scheme="https://2020.iosdevlog.com/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》导论 anim</title>
    <link href="https://2020.iosdevlog.com/2020/03/19/slm/"/>
    <id>https://2020.iosdevlog.com/2020/03/19/slm/</id>
    <published>2020-03-19T15:35:11.000Z</published>
    <updated>2020-03-19T15:40:27.739Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/19/slm/Model.png" /></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/03/19/slm/Title.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/19/slm/SupervisedStep.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/19/slm/SupervisedLearning.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/19/slm/Statisc.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/19/slm/End.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/19/slm/Model.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="manim" scheme="https://2020.iosdevlog.com/tags/manim/"/>
    
      <category term="统计学习方法" scheme="https://2020.iosdevlog.com/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AI开发日志 代码资源等</title>
    <link href="https://2020.iosdevlog.com/2020/03/18/AIDevLog/"/>
    <id>https://2020.iosdevlog.com/2020/03/18/AIDevLog/</id>
    <published>2020-03-18T15:44:51.000Z</published>
    <updated>2020-03-18T16:30:41.907Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://2020.iosdevlog.com/2020/03/18/AIDevLog/Issues.png" alt="" /><figcaption>Issues</figcaption></figure><a id="more"></a><h2 id="云社区">云<span class="math inline">\(^{+}\)</span>社区</h2><p>昨天收到一个来自 云<span class="math inline">\(^{+}\)</span>社区 的小礼物：一个公仔，一张腾讯视频 VIP 月卡。</p><p>我记得是从简书抓取的文章，我 <a href="https://www.jianshu.com/u/1577b98c62f4" target="_blank" rel="noopener">简书</a> 也有很长时间没有更新。</p><figure><img src="https://2020.iosdevlog.com/2020/03/18/AIDevLog/Tencent.png" alt="" /><figcaption>Tencent</figcaption></figure><h2 id="github-ios">GitHub iOS</h2><p>今天（2020-03-18）收到 GitHub 邮件，说 iOS 版正式发布了。</p><p>Thanks for signing up for the GitHub for mobile beta. The Android and iOS versions are now out of beta and generally available! Head over to Google Play or the App Store to start using the releases.</p><p><a href="https://github.us11.list-manage.com/track/click?u=9d7ced8c4bbd6c2f238673f0f&amp;id=8c49f60050&amp;e=ab5005febc" target="_blank" rel="noopener">Download for Android</a></p><p><a href="https://github.us11.list-manage.com/track/click?u=9d7ced8c4bbd6c2f238673f0f&amp;id=a5ee567519&amp;e=ab5005febc" target="_blank" rel="noopener">Download for iOS</a></p><h3 id="with-github-for-mobile-you-can">With GitHub for mobile, you can: </h3><ul><li><strong>Organize tasks in a swipe:</strong> Get your inbox to zero in no time—swipe to finish a task or save the notification to return to it later.</li><li><strong>Give feedback and respond to issues:</strong> Respond to comments while you’re on the go.</li><li><strong>Review and merge pull requests:</strong> Merge and mark pull requests to breeze through your workflow, wherever you are.</li></ul><p><a href="https://github.us11.list-manage.com/track/click?u=9d7ced8c4bbd6c2f238673f0f&amp;id=69c429f973&amp;e=ab5005febc" target="_blank" rel="noopener">Learn more about GitHub for mobile</a></p><figure><img src="https://2020.iosdevlog.com/2020/03/18/AIDevLog/GitHub.png" alt="" /><figcaption>GitHub</figcaption></figure><p>下载体验后，<code>Issues</code> 里面发现 <a href="https://github.com/iOSDevLog/AIDevLog/" target="_blank" rel="noopener">AIDevLog</a> 里面我从 <a href="https://github.com/iOSDevLog/AIDevLog/projects" target="_blank" rel="noopener">Project</a> 生成的 <a href="https://github.com/iOSDevLog/AIDevLog/issues/10" target="_blank" rel="noopener">Issues</a> 已经是 10 个月前。</p><figure><img src="https://2020.iosdevlog.com/2020/03/18/AIDevLog/Projects.png" alt="" /><figcaption>Issues</figcaption></figure><h2 id="消失-10-个月的-aidevlog">消失 10 个月的 AIDevLog</h2><figure><img src="https://2020.iosdevlog.com/2020/03/18/AIDevLog/AIDevLog.png" alt="" /><figcaption>AIDevLog</figcaption></figure><ol type="1"><li>预备知识<ol type="1"><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/Python%20基础/README.md" target="_blank" rel="noopener">Python 基础</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/数学基础/README.md" target="_blank" rel="noopener">数学基础</a></li></ol></li><li>机器学习<ol type="1"><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/统计学习方法/README.md" target="_blank" rel="noopener">统计学习方法</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/西瓜书/README.md" target="_blank" rel="noopener">统计学习（西瓜书）</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/机器学习实战/README.md" target="_blank" rel="noopener">机器学习实战</a></li></ol></li><li>深度学习<ol type="1"><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/花书/README.md" target="_blank" rel="noopener">深度学习（花书）</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/Tensorflow/README.md" target="_blank" rel="noopener">Tensorflow</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/PyTorch/README.md" target="_blank" rel="noopener">PyTorch</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/计算机视觉/README.md" target="_blank" rel="noopener">CS231n: 计算机视觉</a></li><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/自然语言处理/README.md" target="_blank" rel="noopener">CS224n: 自然语言处理</a></li></ol></li><li>强化学习<ol type="1"><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/简易%20AlphaGo/README.md" target="_blank" rel="noopener">简易 AlphaGo</a></li></ol></li><li>竞赛<ol type="1"><li><a href="https://github.com/iOSDevLog/AIDevLog/blob/master/Kaggle/README.md" target="_blank" rel="noopener">Kaggle</a></li></ol></li></ol><h3 id="进度">进度</h3><p><a href="https://github.com/iOSDevLog/AIDevLog/projects?query=is%3Aopen+sort%3Aname-asc" target="_blank" rel="noopener">https://github.com/iOSDevLog/AIDevLog/projects</a></p><h3 id="联系方式">联系方式</h3><p>网站: <a href="https://2019.iosdevlog.com/" target="_blank" rel="noopener">http://2019.iosdevlog.com/</a></p><p>GitHub: <a href="https://github.com/iOSDevLog/AIDevLog" target="_blank" rel="noopener">https://github.com/iOSDevLog/AIDevLog</a></p><blockquote><p>不积跬步，无以至千里；不积小流，无以成江海</p></blockquote><p>——荀子《劝学篇》</p><p>计划做的再好，没有去实施也终究是计划。</p><p>明日开始在公众号里面更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/18/AIDevLog/Issues.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;Issues&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>微积分的本质（Essence of calculus)</title>
    <link href="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/"/>
    <id>https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/</id>
    <published>2020-03-17T07:30:34.000Z</published>
    <updated>2020-03-17T15:44:45.779Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/1.png" alt="" /><figcaption>Essence of calculus</figcaption></figure><a id="more"></a><h2 id="概论">01. 概论</h2><p>圆的面积</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Circle.png" alt="" /><figcaption>Circle</figcaption></figure><h2 id="导数的悖论">02. 导数的悖论</h2><p>微积分之父</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Fathers_of_Calculus.png" alt="" /><figcaption>Fathers_of_Calculus</figcaption></figure><p>汽车</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/dt.png" alt="" /><figcaption>dt</figcaption></figure><h2 id="用几何来求导">03. 用几何来求导</h2><p>应用</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Applications.png" alt="" /><figcaption>Applications</figcaption></figure><p><span class="math inline">\(x^{2}\)</span></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/2.png" alt="" /><figcaption>2</figcaption></figure><p><span class="math inline">\(x^{3}\)</span></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/3.png" alt="" /><figcaption>3</figcaption></figure><p><span class="math inline">\(x^{n}\)</span></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/n.png" alt="" /><figcaption>n</figcaption></figure><p><span class="math inline">\(\sin(x)\)</span></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Sin.png" alt="" /><figcaption>Sin</figcaption></figure><p><span class="math inline">\(\frac{1}{x})\)</span></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/x.png" /></p><h2 id="直观理解链式法则和乘积法则">04. 直观理解链式法则和乘积法则</h2><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Chain.png" alt="" /><figcaption>Chain</figcaption></figure><p>组合函数 求导</p><ul><li>加 Sum</li><li>乘 Product</li><li>复合 Composition</li></ul><p>加法法则</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Sum.png" alt="" /><figcaption>Sum</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Sum_rule.png" alt="" /><figcaption>Sum rule</figcaption></figure><p>乘积法则</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Product.png" alt="" /><figcaption>Product</figcaption></figure><p>复合：链式法则</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Composition.png" alt="" /><figcaption>Composition</figcaption></figure><h2 id="指数函数求导">05. 指数函数求导</h2><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/e.png" alt="" /><figcaption>e</figcaption></figure><p>2的指数 -&gt; e表示</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/ln2.png" alt="" /><figcaption>ln2</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/ln.png" alt="" /><figcaption>ln</figcaption></figure><h2 id="隐函数求导是怎么回事">06. 隐函数求导是怎么回事</h2><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/hide.png" alt="" /><figcaption>hide</figcaption></figure><p>变化落在函数曲线上</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/1_x.png" alt="" /><figcaption>1_x</figcaption></figure><h2 id="极限">07. 极限</h2><p>目标</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Goal.png" alt="" /><figcaption>Goal</figcaption></figure><p>导数定义</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Derivative.png" alt="" /><figcaption>Derivative</figcaption></figure><p><span class="math inline">\(dx\)</span> -&gt; <span class="math inline">\(h\)</span></p><ol type="1"><li>明确表示 <span class="math inline">\(h\)</span> 是一个普通的数，与无穷小无关</li><li><span class="math inline">\(dx\)</span> 就是无穷小量</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Limit.png" alt="" /><figcaption>Limit</figcaption></figure><p><span class="math inline">\(\frac{0}{0}\)</span></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/0_0.png" alt="" /><figcaption>0_0</figcaption></figure><h2 id="积分与微积分的基本定理">08. 积分与微积分的基本定理</h2><p><code>积分</code></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Calculus.png" alt="" /><figcaption>Calculus</figcaption></figure><p><code>积分：求导的逆运算</code></p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Inverse.png" alt="" /><figcaption>Inverse</figcaption></figure><p><code>积分</code>：小量累积</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Integrates.png" alt="" /><figcaption>Integrates</figcaption></figure><p>微积分基本定理</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Theorem.png" alt="" /><figcaption>Theorem</figcaption></figure><p>原函数 &lt;==&gt; 导数</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Origin.png" alt="" /><figcaption>Origin</figcaption></figure><h2 id="面积与斜率有什么关系">09. 面积与斜率有什么关系</h2><p>平均值</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Average.png" alt="" /><figcaption>Average</figcaption></figure><h2 id="脚注-高阶导数">09脚注-高阶导数</h2><p>二阶导数</p><ul><li>导数的导数</li><li>变化量的变化量</li></ul><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Second_derivatives.png" alt="" /><figcaption>Second_derivatives</figcaption></figure><p>高阶导数</p><figure><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Higher_orders.png" alt="" /><figcaption>Higher_orders</figcaption></figure><h2 id="泰勒级数">10. 泰勒级数</h2><p>泰勒级数是利用函数某单个点的导数来近似这个点附近函数的值</p><p>用多项式 <code>近似</code> 其它函数</p><ul><li>好计算</li><li>好求导</li><li>好积分</li></ul><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos6.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/cos7.png" /></p><ol type="1"><li><span class="math inline">\(c_{0}\)</span>：多项式在 x=0 处与 cos(0) 相等</li><li><span class="math inline">\(c_{1}\)</span>：两者导数一致</li><li><span class="math inline">\(c_{2}\)</span>：两者二阶导数一致</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/not_affect.png" /></p><p>控制</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Control.png" /></p><p>泰勒多项式</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Taylor.png" /></p><p>泰勒公式</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Taylor_formula.png" /></p><p><span class="math inline">\(e^{x}\)</span> 泰勒多项式</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Taylor_e.png" /></p><p>几何表示</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Taylor_geometry.png" /></p><p>泰勒级数</p><ul><li>泰勒多项：有限多项</li><li>泰勒级数：无阶多项</li></ul><p>收敛</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Converge.png" /></p><p>发散</p><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Diverges.png" /></p><h2 id="你在微积分课上学不到的知识">11. 你在微积分课上学不到的知识</h2><p><img src="https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/Knowledge.png" /></p><p>在这里观看完整的“微积分的本质”播放列表：&lt;hhttp://3b1b.co/calculus&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/17/Essence-of-calculus/1.png&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;Essence of calculus&lt;/figcaption&gt;
&lt;/figure&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="manim" scheme="https://2020.iosdevlog.com/tags/manim/"/>
    
      <category term="3b1b" scheme="https://2020.iosdevlog.com/tags/3b1b/"/>
    
      <category term="calculus" scheme="https://2020.iosdevlog.com/tags/calculus/"/>
    
  </entry>
  
</feed>
