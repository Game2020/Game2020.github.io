<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-04-09T12:06:54.824Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法思想</title>
    <link href="https://2020.iosdevlog.com/2020/04/09/algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/09/algorithm/</id>
    <published>2020-04-09T06:09:13.000Z</published>
    <updated>2020-04-09T12:06:54.824Z</updated>
    
    <content type="html"><![CDATA[<p>不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</p><ul><li>贪心算法<ul><li>霍夫曼编码（Huffman Coding）</li><li>Prim 和 Kruskal 最小生成树算法</li><li>Dijkstra 单源最短路径算法</li></ul></li><li>分治算法<ul><li>MapRedue</li></ul></li><li>回溯算法</li><li>动态规划</li></ul><a id="more"></a><h2 id="贪心算法">贪心算法</h2><ol type="1"><li>定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</li><li>是否可以用贪心算法解决<ul><li>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</li></ul></li><li>贪心算法产生的结果是否是最优的</li></ol><p>贪心算法实战分析</p><ol type="1"><li>分糖果</li><li>付钱<ul><li>99 = 50 + 2 * 20 + 10 + 5 + 4 * 1</li></ul></li><li>区间覆盖</li></ol><h3 id="霍夫曼编码">霍夫曼编码</h3><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在20%～90%之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。</p><p>霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？</p><p>根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.1.jpg" /></p><p>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点A、B，然后新建一个节点C，把频率设置为两个节点的频率之和，并把这个新节点C作为节点A、B的父节点。最后再把C节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.2.jpg" /></p><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为0，指向右子节点的边，我们统统标记为1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/37.3.jpg" /></p><p>贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，我们只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="分治算法">分治算法</h2><p><strong>分治算法是一种处理问题的思想，递归是一种编程技巧。</strong></p><p>分治算法一般都比较适合用递归来实现。</p><p>分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ol type="1"><li>分解：将原问题分解成一系列子问题；</li><li>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li>合并：将子问题的结果合并成原问题。</li></ol><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ol type="1"><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</li></ol><p>分治算法应用举例分析</p><ul><li>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</li><li>有两个 <span class="math inline">\(n\*n\)</span> 的矩阵 A，B，如何快速求解两个矩阵的乘积 <span class="math inline">\(C=A\*B\)</span>？</li><li>求出一组数据的有序对个数或者逆序对个数？</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.1.jpg" /></p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。</p><p>我们用分治算法来试试。我们套用分治的思想来求数组A的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/38.2.jpg" /></p><p>实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  num = <span class="number">0</span>;</span><br><span class="line">  mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= a[j]) &#123;</span><br><span class="line">      tmp[k++] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      num += (q-i+<span class="number">1</span>); <span class="comment">// 统计p-q之间，比a[j]大的元素个数</span></span><br><span class="line">      tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123; <span class="comment">// 处理剩下的</span></span><br><span class="line">    tmp[k++] = a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) &#123; <span class="comment">// 从tmp拷贝回a</span></span><br><span class="line">    a[p+i] = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分治算法用四个字概括就是“分而治之”，将原问题划分成n个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><h2 id="回溯算法">回溯算法</h2><ul><li>软件开发<ul><li>正则表达式匹配</li><li>编译原理中的语法分析</li></ul></li><li>数学问题<ul><li>数独</li><li>八皇后</li><li>0-1背包</li><li>图的着色</li><li>旅行商问题</li><li>全排列</li></ul></li></ul><h3 id="八皇后问题">八皇后问题</h3><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/39.1.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 全局或成员变量,下标表示行,值表示queen存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8行棋子都放好了，已经没法再往下递归了，所以就return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有8中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第row行的棋子放到了column列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">//判断row行column列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第i行的column列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第i行leftup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第i行rightup列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">"* "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包">0-1背包</h3><p>有一个背包，背包总的承载重量是Wkg。现在我们有n个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">//存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w背包重量；items表示每个物品的重量；n表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w表示装满了;i==n表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式">正则表达式</h3><ol type="1"><li>“*”匹配任意多个（大于等于0个）任意字符</li><li>“?”匹配零个或者一个任意字符。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// *匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ?匹配0个或者1个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。</p><h2 id="动态规划dynamic-programming">动态规划（Dynamic Programming）</h2><h3 id="初识动态规划">初识动态规划</h3><p>大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。</p><p>动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p><h3 id="动态规划理论">动态规划理论</h3><h4 id="最优子结构">最优子结构</h4><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h4 id="无后效性">无后效性</h4><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><h4 id="重复子问题">重复子问题</h4><p>这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h3 id="动态规划实战">动态规划实战</h3><p>如何量化两个字符串的相似度？</p><p>有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。</p><p>编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。</p><ul><li>莱文斯坦距离允许增加、删除、替换字符这三个编辑操作</li><li>最长公共子串长度只允许增加、删除字符这两个编辑操作。</li></ul><p>两个字符串 <em>mitcmu</em> 和 <em>mtacnu</em> 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><p><img src="https://2020.iosdevlog.com/2020/04/09/algorithm/42.1.jpg" /></p><h2 id="比较">比较</h2><p>贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类。</p><p>前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心算法
&lt;ul&gt;
&lt;li&gt;霍夫曼编码（Huffman Coding）&lt;/li&gt;
&lt;li&gt;Prim 和 Kruskal 最小生成树算法&lt;/li&gt;
&lt;li&gt;Dijkstra 单源最短路径算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分治算法
&lt;ul&gt;
&lt;li&gt;MapRedue&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;回溯算法&lt;/li&gt;
&lt;li&gt;动态规划&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-5-字符串匹配</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/String-searching-algorithm/</id>
    <published>2020-04-08T09:36:23.000Z</published>
    <updated>2020-04-08T10:55:30.824Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th>算法</th><th>预处理时间</th><th>匹配时间</th></tr></thead><tbody><tr class="odd"><td>BF算法 / 朴素算法</td><td>0 (无需预处理)</td><td>Θ(nm)</td></tr><tr class="even"><td>Rabin-Karp算法</td><td>Θ(m)</td><td>平均 Θ(n + m),最差 Θ((n-m)m)</td></tr><tr class="odd"><td>基于有限状态机的搜索</td><td>Θ(mk)</td><td>Θ(n)</td></tr><tr class="even"><td>克努斯-莫里斯-普拉特算法</td><td>Θ(m)</td><td>Θ(n)</td></tr><tr class="odd"><td>Boyer-Moore字符串搜索算法</td><td>Θ(m + k)</td><td>最好Ω(n/m),最坏 O(n)</td></tr><tr class="even"><td>Bitap算法</td><td>Θ(m + k)</td><td>O(mn)</td></tr></tbody></table><a id="more"></a><h2 id="bf算法">BF算法</h2><p>BF算法 中的 <code>BF</code> 是 <em>Brute Force</em> 的缩写，中文叫作 <strong>暴力匹配算</strong>法，也叫 <strong>朴素匹配算法</strong>。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.1.jpg" /></p><ul><li>主串</li><li>模式串</li></ul><p>把主串的长度记作 <code>n</code>，模式串的长度记作 <code>m</code>。</p><p>在主串中查找模式串，所以 <code>n&gt;m</code>。</p><p>BF算法的思想：</p><blockquote><p>在主串中，检查起始位置分别是 <code>0、1、2…n-m</code> 且长度为 <code>m</code> 的 <code>n-m+1</code> 个子串，看有没有跟模式串匹配的。</p></blockquote><p>尽管理论上，BF算法的时间复杂度很高，是O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把m个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有bug也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的 <code>KISS（Keep it Simple and Stupid）</code> 设计原则。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2 id="rk算法">RK算法</h2><p>RK算法的全称叫 <em>Rabin-Karp算法</em>，是由它的两位发明者 <em>Rabin</em> 和 <em>Karp</em> 的名字来命名的。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.4.jpg" /></p><blockquote><p>通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p></blockquote><p>通过查表的方法来提高效率。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/32.5.jpg" /></p><h2 id="bm算法1">BM算法<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h2><p>把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF算法和RK算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.1.jpg" /></p><p>一次性把模式串往后多滑动几位，把模式串移动到c的后面。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.2.jpg" /></p><h3 id="bm算法原理分析">BM算法原理分析</h3><p>坏字符规则（bad character rule）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.3.jpg" /></p><p>没有匹配的字符叫作坏字符（主串中的字符）。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.7.jpg" /></p><p>好后缀规则（good suffix shift）</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.10.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.12.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.13.jpg" /></p><p>BM算法代码实现</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.14.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化bc</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算b[i]的ASCII值</span></span><br><span class="line">    bc[ascii] = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把 <em>BM算法</em> 代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑si-xi计算得到的移动位数可能会出现负数的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span></span><br><span class="line">    i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.15.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.16.jpg" /></p><p>引入最关键的变量 <code>suffix数组</code></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.17.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.18.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.19.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123; <span class="comment">// 初始化</span></span><br><span class="line">    suffix[i] = -<span class="number">1</span>;</span><br><span class="line">    prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123; <span class="comment">// b[0, i]</span></span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) &#123; <span class="comment">// 与b[0, m-1]求公共后缀子串</span></span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] = j+<span class="number">1</span>; <span class="comment">//j+1表示公共后缀子串在b[0, i]中的起始下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    i</span><br><span class="line">    <span class="keyword">if</span> (j == -<span class="number">1</span>) prefix[k] = <span class="keyword">true</span>; <span class="comment">//如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.20.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.21.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/33.22.jpg" /></p><p>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a,b表示主串和模式串；n，m表示主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">  generateBC(b, m, bc); <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">  <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">  <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j表示主串与模式串匹配的第一个字符</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">      <span class="keyword">if</span> (a[i+j] != b[j]) <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) &#123; <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">  <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>) <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kmp算法基本原理">KMP算法基本原理</h3><p>KMP算法是根据三位作者（D.E.Knuth，J.H.Morris和V.R.Pratt）的名字来命名的，算法的全称是Knuth Morris Pratt算法，简称为KMP算法。</p><p>KMP算法的核心思想，跟上一节讲的BM算法非常相近。我们假设主串是a，模式串是b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>这里我们可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作 <em>坏字符</em>，把已经匹配的那段字符串叫作 <em>好前缀</em>。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.3.jpg" /></p><p>好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作最长可匹配后缀子串；对应的前缀子串，叫作最长可匹配前缀子串。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.5.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">      j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">      <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>失效函数计算方法</p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/08/String-searching_algorithm/34.9.jpg" /></p><h2 id="小结">小结</h2><p><em>BF算法</em> 是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是O(n*m)，n、m表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p><em>RK算法</em> 是借助哈希算法对BF算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，<em>RK算法</em> 的时间复杂度是 <span class="math inline">\(O(n\)</span>)，跟BF算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 <span class="math inline">\(O(n*m\)</span>)。</p><p><em>BM算法</em> 尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。如果一遍看不懂的话，你就多看几遍。</p><p>BM算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现BM算法。</p><p>BM算法有两个规则，坏字符和好后缀。KMP算法借鉴BM算法的思想，可以总结成好前缀规则。这里面最难懂的就是next数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。</p><p>一种类似动态规划的方法，按照下标i从小到大，依次计算 <code>next[i]</code>，并且 <code>next[i]</code> 的计算通过前面已经计算出来的 <code>next[0]，next[1]，……，next[i-1]</code> 来推导。</p><p>KMP算法的时间复杂度是 <span class="math inline">\(O(n+m)\)</span>，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf" target="_blank" rel="noopener" class="uri">http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;预处理时间&lt;/th&gt;
&lt;th&gt;匹配时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;BF算法 / 朴素算法&lt;/td&gt;
&lt;td&gt;0 (无需预处理)&lt;/td&gt;
&lt;td&gt;Θ(nm)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Rabin-Karp算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;平均 Θ(n + m),最差 Θ((n-m)m)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;基于有限状态机的搜索&lt;/td&gt;
&lt;td&gt;Θ(mk)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;克努斯-莫里斯-普拉特算法&lt;/td&gt;
&lt;td&gt;Θ(m)&lt;/td&gt;
&lt;td&gt;Θ(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td&gt;Boyer-Moore字符串搜索算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;最好Ω(n/m),最坏 O(n)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td&gt;Bitap算法&lt;/td&gt;
&lt;td&gt;Θ(m + k)&lt;/td&gt;
&lt;td&gt;O(mn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-4-图（Graph）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/graph/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/graph/</id>
    <published>2020-04-08T08:08:48.000Z</published>
    <updated>2020-04-08T11:15:29.012Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>顶点（vertex）：图中的元素</li><li>边（edge）：一个顶点与任意其他顶点建立连接关系</li><li>度（degree）：跟顶点相连接的边的条数<ul><li>入度（In-degree）</li><li>出度（Out-degree）</li></ul></li><li>有向图：边有方向的图</li><li>无向图：边没有方向的图</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg" /></p><a id="more"></a><h2 id="邻接矩阵存储方法">邻接矩阵存储方法</h2><p>图最直观的一种存储方法就是，邻接矩阵（Adjacency Matrix）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点i与顶点j之间有边，我们就将 <code>A[i][j]</code> 和 <code>A[j][i]</code> 标记为 <code>1</code>；对于有向图来说，如果顶点i到顶点j之间，有一条箭头从顶点i指向顶点j的边，那我们就将 <code>A[i][j]</code> 标记为 <code>1</code>。同理，如果有一条箭头从顶点 <code>j</code> 指向顶点i的边，我们就将 <code>A[j][i]</code> 标记为 <code>1</code>。对于带权图，数组中就存储相应的权重。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.3.jpg" /></p><p>稀疏图（Sparse Matrix）浪费存储空间。</p><h2 id="邻接表存储方法">邻接表存储方法</h2><h3 id="邻接表adjacency-list">邻接表（Adjacency List）</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.4.jpg" /></p><h3 id="逆邻接表">逆邻接表</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.5.jpg" /></p><h3 id="哈希算法等数据分片方">哈希算法等数据分片方</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.6.jpg" /></p><h3 id="数据库存储">数据库存储</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/30.7.jpg" /></p><h2 id="无向图代码">无向图代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123; <span class="comment">// 无向图</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.v = v;</span><br><span class="line">    adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索bfs">广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印s-&gt;t的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点q被访问，那相应的 <code>visited[q]</code> 会被设置为 <code>true</code>。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第 <code>k+1</code> 层的顶点。当我们访问到第k层的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第 <code>k+1</code> 层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。<code>prev[w]</code> 存储的是，顶点 <code>w</code> 是从哪个前驱顶点遍历过来的。比如，我们通过顶点2的邻接表访问到顶点3，那 <code>prev[3]</code> 就等于 <code>2</code>。为了正向打印出路径，我们需要递归地来打印，你可以看下 <code>print()</code> 函数的实现方式。</p><p>最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是O(V)。</p><h2 id="深度优先搜索dfs">深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称DFS。最直观的例子就是“走迷宫”。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/graph/31.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 <code>O(E)</code>，E表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 <code>visited</code>、<code>prev</code> 数组和递归调用栈。</p><p><code>visited</code>、<code>prev</code> 数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 <code>O(V)</code>。</p><h2 id="小结">小结</h2><p>无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。</p><p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><ul><li>深度：栈</li><li>广度：队列</li></ul><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如A<em>、IDA</em>等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空间复杂度是O(V)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点（vertex）：图中的元素&lt;/li&gt;
&lt;li&gt;边（edge）：一个顶点与任意其他顶点建立连接关系&lt;/li&gt;
&lt;li&gt;度（degree）：跟顶点相连接的边的条数
&lt;ul&gt;
&lt;li&gt;入度（In-degree）&lt;/li&gt;
&lt;li&gt;出度（Out-degree）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有向图：边有方向的图&lt;/li&gt;
&lt;li&gt;无向图：边没有方向的图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/graph/30.2.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-3-堆（heap）</title>
    <link href="https://2020.iosdevlog.com/2020/04/08/heap/"/>
    <id>https://2020.iosdevlog.com/2020/04/08/heap/</id>
    <published>2020-04-08T05:31:30.000Z</published>
    <updated>2020-04-08T11:14:59.600Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</li></ul><a id="more"></a><h2 id="堆完全二叉树">堆（完全二叉树）</h2><p>比较适合用数组来存储</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.2.jpg" /></p><p>插入一个元素</p><p>堆化（heapify）</p><ul><li>从下往上</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.3.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) &#123; <span class="keyword">return</span>; &#125; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>删除堆顶元素</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.5.jpg" /></p><ul><li>从上往下</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个包含 <span class="math inline">\(n\)</span> 个节点的完全二叉树，树的高度不会超过 <span class="math inline">\(\log_{2}n\)</span>。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <span class="math inline">\(O(\log n)\)</span>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><h2 id="堆排序">堆排序</h2><h3 id="建堆">建堆</h3><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.7.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.8.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxPos = i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对下标从 <span class="math inline">\(\frac{n}{2}\)</span> 开始到 <span class="math inline">\(1\)</span> 的数据进行堆化，下标是 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点是叶子节点，不需要堆化。</p><p>对于完全二叉树来说，下标从 <span class="math inline">\(\frac{n}{2}+1\)</span> 到 <span class="math inline">\(n\)</span> 的节点都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.9.jpg" /></p><h3 id="排序">排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。它跟最后一个元素交换，那最大元素就放到了下标为 <span class="math inline">\(n\)</span> 的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，下标为 <span class="math inline">\(n\)</span> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <span class="math inline">\(n-1\)</span> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <span class="math inline">\(n-1\)</span> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <span class="math inline">\(1\)</span> 的一个元素，排序工作就完成了。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.10.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="keyword">int</span> k = n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序要比堆排序性能好">快速排序要比堆排序性能好？</h2><ul><li>堆排序数据访问的方式没有快速排序友好</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">4</span> -&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.11.jpg" /></p><ul><li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序</li></ul><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br /><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.12.jpg" /></p><h2 id="堆的应用">堆的应用</h2><ul><li>优先级队列<ul><li>依赖<ul><li>赫夫曼编码</li><li>图的最短路径</li><li>最小生成树算法</li></ul></li><li>具体<ul><li>合并有序小文件</li><li>高性能定时器</li></ul></li></ul></li><li>利用堆求 <code>Top K</code><ul><li><span class="math inline">\(n\)</span> 个数据的数组中，查找前 <span class="math inline">\(K\)</span> 大数据<ul><li>维护一个大小为 K 的小顶堆，顺序遍历数组</li></ul></li></ul></li><li>利用堆求中位数<ul><li>1 个大顶堆，1 个小顶堆</li><li>百分位数</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.13.jpg" /></p><p>删除堆顶数据和往堆中插入数据的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>，<span class="math inline">\(n\)</span> 表示堆中的数据个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/08/heap/28.14.jpg" /></p><p>=======<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8<br />## 小结</p><p>堆是一种完全二叉树。</p><p>它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br />除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><p>堆的几个重要的应用，它们分别是：优先级队列、求Top K问题和求中位数问题。</p><h1 id="优先级队列是一种特殊的队列优先级高的数据先出队而不再像普通的队列那样先进先出实际上堆就可以看作优先级队列只是称谓不一样罢了求top-k问题又可以分为针对静态数据和针对动态数据只需要利用一个堆就可以做到非常高效率的查询top-k的数据求中位数实际上还有很多变形比如求99百分位数据90百分位数据等处理的思路都是一样的即利用两个堆一个大顶堆一个小顶堆随着数据的动态添加动态调整两个堆中的数据最后大顶堆的堆顶元素就是要求的数据">优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求Top K问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询Top K的数据。求中位数实际上还有很多变形，比如求99百分位数据、90百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</h1><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 <span class="math inline">\(\frac{n}{2}\)</span> 到 <span class="math inline">\(1\)</span> 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt; fdeec4ae6c162b3f8d1fd176518f9715a0783cd8</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/08/heap/28.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一个完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-2-树（Tree）</title>
    <link href="https://2020.iosdevlog.com/2020/04/06/tree/"/>
    <id>https://2020.iosdevlog.com/2020/04/06/tree/</id>
    <published>2020-04-06T04:10:33.000Z</published>
    <updated>2020-04-09T04:19:12.261Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><p>学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><a id="more"></a><p>每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.2.jpg" /></p><p>A节点就是B节点的父节点，B节点是A节点的子节点。B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫作根节点，也就是图中的节点E。我们把没有子节点的节点叫作叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.3.jpg" /></p><ol type="1"><li>高度（Height）</li><li>深度（Depth）</li><li>层（Level）</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.4.jpg" /></p><h2 id="二叉树binary-tree">二叉树（Binary Tree）</h2><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.5.jpg" /></p><p>两个子节点，分别是 <code>左子节点</code> 和 <code>右子节点</code>。</p><p>概念解释</p><ul><li><strong>节点</strong>：树中的每个元素称为节点</li><li><strong>父子关系</strong>：相邻两节点的连线，称为父子关系</li><li><strong>根节点</strong>：没有父节点的节点</li><li><strong>叶子节点</strong>：没有子节点的节点</li><li><strong>父节点</strong>：指向子节点的节点</li><li><strong>子节点</strong>：被父节点指向的节点</li><li><strong>兄弟节点</strong>：具有相同父节点的多个节点称为兄弟节点关系</li><li><strong>节点的高度</strong>：节点到叶子节点的最长路径所包含的边数</li><li><strong>节点的深度</strong>：根节点到节点的路径所包含的边数</li><li><strong>节点的层数</strong>：节点的深度+1（根节点的层数是1）</li><li><strong>树的高度</strong>：等于根节点的高度</li></ul><p>编号2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作 <strong>满二叉树</strong>。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.6.jpg" /></p><p>编号3的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作 <strong>完全二叉树</strong>。</p><p>如何表示（或者存储）一棵二叉树？</p><ul><li>基于指针或者引用的 <code>链式存储法</code></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.7.jpg" /></p><ul><li>基于数组的 <code>顺序存储法</code><ul><li>根节点存储在下标 <code>i = 1</code> 的位置</li><li>那左子节点存储在下标 <code>2 * i</code> 的位置</li><li>右子节点存储在 <code>2 * i + 1</code> 的位置。</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.8.jpg" /></p><p><strong>堆其实就是一种完全二叉树，最常用的存储方式就是数组</strong></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.9.jpg" /></p><p>二叉树的遍历</p><ul><li>深度优先<ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/23.10.jpg" /></p><p>递推公式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印root节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>。</p><p>树是非线性表数据结构。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 <span class="math inline">\(O(n)\)</span>，你需要理解并能用递归代码来实现。</p><h2 id="二叉查找树-二叉搜索树binary-search-tree">二叉查找树 / 二叉搜索树（Binary Search Tree）</h2><p>快速</p><ul><li>查找</li><li>插入</li><li>删除</li></ul><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.1.jpg" /></p><p>查找操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.2.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; p.data) p = p.left;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.3.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">    tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p = tree;</span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data &lt; p.data</span></span><br><span class="line">      <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”。</p><p>快速地查找 <code>最大节点</code> 和 <code>最小节点</code>、<code>前驱节点</code> 和 <code>后继节点</code>。</p><p>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 <span class="math inline">\(O(n)\)</span>，非常高效。因此，二叉查找树也叫作 <strong>二叉排序树</strong>。</p><p>支持重复数据的二叉查找树</p><ol type="1"><li>对象中的其他字段叫作卫星数据。</li><li>对象的某个字段作为键值（key）来构建二叉查找树。<ol type="1"><li>链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</li><li>插入的数据放到这个节点的右子树。</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/24.7.jpg" /></p><p>时间复杂度分析</p><p>完全二叉树的高度小于等于 <span class="math inline">\(\log_{2} n\)</span></p><h3 id="散列表-vs-二叉查找树">散列表 vs 二叉查找树</h3><ol type="1"><li>散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 <span class="math inline">\(O(1)\)</span>，非常高效。</li><li>叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)。</li></ol><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 <span class="math inline">\(O(n)\)</span> 的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 <span class="math inline">\(O(\log n)\)</span>。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比 <span class="math inline">\(O(\log n)\)</span> 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><h3 id="二叉查找树小结">二叉查找树小结</h3><p>它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。</p><p>对于存在重复数据的二叉查找树，两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是O(n)和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，<code>平衡二叉查找树</code>，时间复杂度可以做到稳定的 <span class="math inline">\(O(logn)\)</span>。</p><h2 id="红黑树red-black-tree">红黑树（Red-Black Tree）</h2><p>平衡二叉查找树</p><ul><li>Splay Tree（伸展树）</li><li>Treap（树堆）</li><li>红黑树（简称 R-B Tree）</li></ul><blockquote><p>二叉树中任意一个节点的左右子树的高度相差不能大于1。</p></blockquote><p>从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.1.jpg" /></p><p>最先被发明的平衡二叉查找树是 <a href="https://zh.wikipedia.org/wiki/AVL树" target="_blank" rel="noopener">AVL树</a>。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</p><p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。</p><ol type="1"><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.2.jpg" /></p><p>画图将黑色的、空的叶子节点都省略</p><blockquote><p>为什么说红黑树是“近似平衡”的？</p></blockquote><ul><li>“平衡”的意思可以等价为性能不退化。</li><li>“近似平衡”就等价为性能不会退化的太严重。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/25.3.jpg" /></p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。</p><p>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 <span class="math inline">\(\log_{2} n\)</span>，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。</p><h3 id="实现红黑树的基本思想">实现红黑树的基本思想</h3><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的 3、4 点恢复过来。</p><p>左旋（rotate left）：围绕某个节点的左旋<br />右旋（rotate right）：围绕某个节点的右旋</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.1.jpg" /></p><h4 id="插入操作的平衡调整">插入操作的平衡调整</h4><p>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</p><ul><li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。</li></ul><p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作 <strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的叔叔节点 d 是红色，我们就依次执行下面的操作：</p><ul><li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑ß色；</li><li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 <code>CASE 2</code> 或者 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.2.jpg" /></p><p><code>CASE 2</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点，我们就依次执行下面的操作：</p><ul><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点 b 左旋；</li><li>跳到 <code>CASE 3</code>。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.3.jpg" /></p><p><code>CASE 3</code>：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点，我们就依次执行下面的操作：</p><p>围绕关注节点 a 的祖父节点 c 右旋；<br />将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。<br />调整结束。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.4.jpg" /></p><h4 id="删除操作的平衡调整">删除操作的平衡调整</h4><p>第一步：针对删除节点初步调整</p><p>初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</p><p><code>CASE 1</code>：如果要删除的节点是 a，它只有一个子节点 b</p><ul><li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li><li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li><li>调整结束，不需要进行二次调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.5.jpg" /></p><p><code>CASE 2</code>：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c 。我们就依次进行下面的操作：</p><ul><li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li><li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.6.jpg" /></p><p><code>CASE 3</code>：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点，我们就依次进行下面的操作：</p><ul><li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 <code>CASE 1</code>；</li><li>将节点 a 替换成后继节点 d ；</li><li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.7.jpg" /></p><p>第二步：针对关注节点进行二次调整</p><p>让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><p>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><code>CASE 1</code>：如果关注节点是a，它的兄弟节点 c 是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.8.jpg" /></p><p><code>CASE 2</code>：如果关注节点是a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d 、e都是黑色的，我们就依次进行下面的操作：</p><ul><li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红-黑”或者“黑-黑”；</li><li>关注节点从a变成其父节点 b ；</li><li>继续从四种情况中选择符合的规则来调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.9.jpg" /></p><p><code>CASE 3</code>：如果关注节点是a，它的兄弟节点 c 是黑色，c的左子节点 d 是红色，c的右子节点e是黑色，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变；</li><li>跳转到 <code>CASE 4</code>，继续调整。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.10.jpg" /></p><p><code>CASE 4</code>：如果关注节点 a 的兄弟节点 c 是黑色的，并且c的右子节点是红色的，我们就依次进行下面的操作：</p><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li><li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li><li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>将关注节点 a 的叔叔节点e设置为黑色；</li><li>调整结束。</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.11.jpg" /></p><blockquote><p>为什么要求叶子节点是黑色的空节点？</p></blockquote><p>为了实现起来方便。</p><p>假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.12.jpg" /></p><p>加上 “叶子节点必须是黑色的空节点”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.13.jpg" /></p><p>会不会比较浪费存储空间呢？答案是不会的。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/26.14.jpg" /></p><h3 id="trie树-字典树">Trie树 / 字典树</h3><p>它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p><em>Trie树</em> 的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><p><code>how，hi，her，hello，so，see</code></p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.1.jpg" /></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.2.jpg" /></p><p>构造过程的每一步，都相当于往Trie树中插入一个字符串。当所有字符串都插入完成之后，Trie树就构造好了。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.3.jpg" /></p><p>“her”</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.4.jpg" /></p><p>“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.5.jpg" /></p><p>如何实现一棵 <em>Trie树</em>？</p><ol type="1"><li>将字符串集合构造成 <em>Trie树</em></li><li>在 <em>Trie树</em> 中查询一个字符串</li></ol><p><em>Trie树</em> 是一个多叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  BinaryTreeNode left;</span><br><span class="line">  BinaryTreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.6.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串中只有从 a 到 z 这26个小写字母</li><li>组中下标为 0 的位置，存储指向子节点 a 的指针</li><li>下标为 1 的位置存储指向子节点 b 的指针</li><li>某个字符的子节点不存在，对应的下标的位置存储 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    TrieNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在pattern</span></span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 找到pattern</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建Trie树的过程，需要扫描所有的字符串，时间复杂度是O(n)（n表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是k，那我们只需要比对大约k个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好Trie树后，在其中查找字符串的时间复杂度是O(k)，k表示要查找的字符串的长度。</p><p>缩点优化</p><p><img src="https://2020.iosdevlog.com/2020/04/06/tree/35.7.jpg" /></p><p>Trie树 与 散列表、红黑树 的比较</p><p>Trie树 比较适合的是查找前缀匹配的字符串</p><p>应用</p><ul><li>自动输入补全<ul><li>输入法自动补全功能</li><li>IDE代码编辑器自动补全功能</li><li>浏览器网址输入的自动补全功能</li></ul></li></ul><h3 id="内容小结">内容小结</h3><p>“红黑树一向都很难学”，有这种想法的人很多。其实主要原因是，很多人试图去记忆它的平衡调整策略。</p><ol type="1"><li><p>第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p></li><li><p>第二点，找准关注节点，不要搞丢、搞错关注节点。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p></li><li><p>第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p></li></ol><p>Trie树是一种解决字符串快速匹配问题的数据结构。如果用来构建Trie树的这一组字符串中，前缀重复的情况不是很多，那Trie树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p><p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 Trie树 中做字符串匹配还是非常高效的，时间复杂度是 <span class="math inline">\(O(k)\)</span>，k表示要匹配的字符串的长度。</p><p>但是，Trie树 的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie树 最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie树 比较经典的应用场景。</p><h2 id="高级">高级</h2><h2 id="实战">实战</h2><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/126</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/06/tree/23.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>《统计学习方法》笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/05/slm/"/>
    <id>https://2020.iosdevlog.com/2020/04/05/slm/</id>
    <published>2020-04-05T14:41:34.000Z</published>
    <updated>2020-04-05T15:03:01.281Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/05/slm/2.png" /></p><a id="more"></a><ul><li>统计学习的定义、研究对象与方法</li><li>监督学习，这是本书的主要内容</li><li>统计学习方法的三要素<ul><li>模型</li><li>策略</li><li>算法</li></ul></li><li>模型选择<ul><li>正则化</li><li>交叉验证</li><li>学习的泛化能力</li></ul></li><li>生成模型与判别模型</li><li>监督学习方法的应用<ul><li>分类问题</li><li>标注问题</li><li>回归问题</li></ul></li></ul><h2 id="统计学习">统计学习</h2><h3 id="统计学习的特点">统计学习的特点</h3><p>统计学习（statistical learning）是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。</p><p><strong>统计学习也称为统计机器学习（statistical machine learning）</strong>。</p><p>统计学习的主要特点是</p><ol type="1"><li>统计学习以计算机及网络为平台，是建立在计算机及网络之上的</li><li>统计学习以数据为研究对象，是数据驱动的学科</li><li>统计学习的目的是对数据进行预测与分析</li><li>统计学习以方法为中心，统计学习方法构建模型并应用模型进行预测与分析</li><li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科，并且在发展中逐步形成独自的理论体系与方法论。</li></ol><p>赫尔伯特·西蒙（Herbert A. Simon）曾对“学习”给出以下定义</p><blockquote><p>“如果一个系统能够通过执行某个过程改进它的性能，这就是学习。”</p></blockquote><p>按照这一观点，统计学习就是计算机系统通过运用数据及统计方法提高系统性能的机器学习。<strong>现在，当人们提及机器学习时，往往是指统计机器学习。</strong></p><h3 id="统计学习的对象">统计学习的对象</h3><p>统计学习的对象是<strong>数据（data）</strong>。</p><p>它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，又回到对数据的分析与预测中去。作为统计学习的对象，数据是多样的，包括存在于计算机及网络上的各种数字、文字、图像、视频、音频数据以及它们的组合。</p><p>统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。这里的同类数据是指具有某种共同性质的数据，例如英文文章、互联网网页、数据库中的数据等。由于它们具有统计规律性，所以可以用概率统计方法来加以处理。比如，可以用随机变量描述数据中的特征，用概率分布描述数据的统计规律。</p><p>在统计学习过程中，以变量或变量组表示数据。数据分为由连续变量和离散变量表示的类型。</p><p><strong>离散变量的方法为主。</strong>另外，本书只涉及利用数据构建模型及利用模型对数据进行 <strong>分析与预测</strong>，对数据的 <strong>观测和收集 </strong>等问题 <strong>不作讨论</strong>。</p><h3 id="统计学习的目的">统计学习的目的</h3><p>统计学习用于对数据进行预测与分析，特别是对未知新数据进行预测与分析。</p><ul><li>对数据的预测可以使计算机更加智能化，或者说使计算机的某些性能得到提高</li><li>对数据的分析可以让人们获取新的知识，给人们带来新的发现。</li></ul><h3 id="统计学习的方法">统计学习的方法</h3><p>统计学习的方法是基于数据构建统计模型从而对数据进行预测与分析。</p><p>统计学习由</p><ul><li>监督学习（supervised learning）</li><li>非监督学习（unsupervised learning）</li><li>半监督学习（semi-supervised learning）</li><li>强化学习（reinforcement learning）</li></ul><p>本书主要讨论 <strong>监督学习</strong>，这种情况下统计学习的方法可以概括如下：</p><ul><li>从给定的、有限的、用于学习的训练数据（training data）集合出发，假设数据是独立同分布产生的</li><li>并且假设要学习的模型属于某个函数的集合，称为假设空间（hypothesis space）</li><li>应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模型，使它对已知训练数据及未知测试数据（test data）在给定的评价准则下有最优的预测</li></ul><p>最优模型的选取由算法实现</p><p>统计学习方法的三要素：<strong>模型（model）、策略（strategy）和算法（algorithm）</strong></p><ul><li>模型： 模型的假设空间</li><li>策略： 模型选择的准则</li><li>算法： 模型学习的算法</li></ul><p>实现统计学习方法的步骤如下：</p><ol type="1"><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的假设空间，即学习模型的集合</li><li>确定模型选择的准则，即学习的策略</li><li>实现求解最优模型的算法，即学习的算法</li><li>通过学习方法选择最优模型</li><li>利用学习的最优模型对新数据进行预测或分析</li></ol><p>本书以介绍 <strong>统计学习方法为主</strong>，特别是 <strong>监督学习方法</strong>，主要包括用于分类、标注与回归问题的方法。这些方法在自然语言处理、信息检索、文本数据挖掘等领域中有着极其广泛的应用。</p><h3 id="统计学习的研究">统计学习的研究</h3><ul><li>统计学习方法（statistical learning method）<ul><li>开发新的学习方法</li></ul></li><li>统计学习理论（statistical learning theory）<ul><li>探求统计学习方法的有效性与效率</li><li>统计学习的基本理论问题</li></ul></li><li>统计学习应用（application of statistical learning）<ul><li>将统计学习方法应用到实际问题中去，解决实际问题</li></ul></li></ul><h3 id="统计学习的重要性">统计学习的重要性</h3><ul><li>统计学习是处理海量数据的有效方法</li><li>统计学习是计算机智能化的有效手段</li><li>统计学习是计算机科学发展的一个重要组成部分</li></ul><h2 id="监督学习">监督学习</h2><ul><li>监督学习</li><li>非监督学习</li><li>半监督学习</li><li>强化学习</li></ul><p>本书主要讨论 <strong>监督学习</strong> 问题。</p><p>监督学习（supervised learning）的 <strong>任务</strong> 是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。</p><h3 id="基本概念">基本概念</h3><h4 id="输入空间特征空间-与-输出空间"><strong>输入空间</strong>、<strong>特征空间 </strong>与 <strong>输出空间</strong></h4><p>在监督学习中，将输入与输出所有可能取值的集合分别称为 <strong>输入空间（input space）与输出空间（output space）</strong>。</p><ul><li><p>输入与输出空间可以是有限元素的集合，也可以是整个欧氏空间</p></li><li><p>输入空间与输出空间可以是同一个空间，也可以是不同的空间</p></li><li><p>但通常输出空间远远小于输入空间</p></li></ul><p>每个具体的输入是一个<strong>实例（instance）</strong>，通常由 <strong>特征向量（feature vector）</strong> 表示。这时，所有特征向量存在的空间称为 <strong>特征空间（feature space）</strong>。</p><p><strong>模型实际上都是定义在特征空间上的</strong></p><p>输入、输出变量用大写字母表示，习惯上输入变量写作 <span class="math inline">\(X\)</span>，输出变量写作 <span class="math inline">\(Y\)</span>。</p><p>输入、输出变量所取的值用小写字母表示，输入变量的取值写作 <span class="math inline">\(x\)</span>，输出变量的取值写作 <span class="math inline">\(y\)</span>。变量可以是标量或向量，都用相同类型字母表示。</p><p>本书中向量均为 <strong>列向量</strong>，输入实例 <span class="math inline">\(x\)</span> 的特征向量记作<br /><span class="math display">\[x=\left(x^{(1)}, x^{(2)}, \cdots, x^{(i)}, \cdots, x^{(n)}\right)^{\mathrm{T}}\]</span><br /><span class="math inline">\(\mathbf{x}^{(\mathrm{i})}\)</span> 表示 <span class="math inline">\(x\)</span> 的第 <span class="math inline">\(i\)</span> 个特征。注意，<span class="math inline">\(\mathbf{x}^{(\mathrm{i})}\)</span> 与 <span class="math inline">\(\mathbf{x}_{\mathbf{i}}\)</span> 不同，本书通常用 <span class="math inline">\(\mathbf{x}_{\mathbf{i}}\)</span> 表示多个输入变量中的第 <span class="math inline">\(i\)</span> 个，即</p><p><span class="math display">\[x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}\]</span></p><p>监督学习从训练数据（training data）集合中学习模型，对测试数据（test data）进行预测。训练数据由输入（或特征向量）与输出对组成，训练集通常表示为</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>测试数据也由相应的输入与输出对组成。输入与输出对又称为 <strong>样本（sample）</strong> 或 <strong>样本点</strong>。</p><p>输入变量 X 和输出变量 <span class="math inline">\(Y\)</span> 有不同的类型，可以是 <strong>连续</strong> 的，也可以是 <strong>离散</strong> 的。</p><p>人们根据输入、输出变量的不同类型，对预测任务给予不同的名称</p><ul><li>回归问题: 输入变量与输出变量均为连续变量的预测问题</li><li>分类问题: 输出变量为有限个离散变量的预测问题</li><li>标注问题: 输入变量与输出变量均为变量序列的预测问题</li></ul><h4 id="联合概率分布">联合概率分布</h4><p>监督学习假设输入与输出的随机变量X和Y遵循联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>。</p><p><span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 表示 <strong>分布函数</strong>，或 <strong>分布密度函数</strong>。注意，在学习过程中，假定这一联合概率分布存在，但对学习系统来说，联合概率分布的具体定义是未知的。训练数据与测试数据被看作是依联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 独立同分布产生的。统计学习假设数据存在一定的统计规律，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 具有联合概率分布的假设就是监督学习关于数据的基本假设。</p><h4 id="假设空间">假设空间</h4><p>监督学习的目的在于学习一个由输入到输出的映射，这一映射由模型来表示。换句话说，学习的目的就在于找到最好的这样的模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间（hypothesis space）。假设空间的确定意味着学习范围的确定。</p><p>监督学习的模型可以是概率模型或非概率模型，由 <strong>条件概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{Y} | \mathrm{X})\)</span> 或 决策函数（decision function）<span class="math inline">\(Y=f(X)\)</span> 表示</strong>，随具体学习方法而定。对具体的输入进行相应的输出预测时，写作 <span class="math inline">\(\mathrm{P}(\mathrm{y} | \mathrm{x})\)</span> 或 <span class="math inline">\(Y=f(x)\)</span>。</p><h3 id="问题的形式化">问题的形式化</h3><p>监督学习利用训练数据集学习一个模型，再用模型对测试样本集进行预测（prediction）。</p><p>由于在这个过程中需要训练数据集，而训练数据集往往是人工给出的，所以称为 <strong>监督学习</strong>。</p><p>监督学习分为学习和预测两个过程</p><ul><li>学习系统</li><li>预测系统</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/1.png" /></p><p>图 1.1　监督学习问题</p><p>首先给定一个训练数据集</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>其中 <span class="math inline">\(\left(\mathrm{x}_{\mathrm{i}}, \mathrm{y}_{\mathrm{i}}\right), \quad \mathrm{i}=1,2, \ldots, \mathrm{N}\)</span>，称为样本或样本点。<span class="math inline">\(\mathbf{x}_{\mathbf{i}} \in \mathbf{X} \subseteq \mathbf{R}_{\mathbf{n}}\)</span> 输入的观测值，也称为输入或实例，<span class="math inline">\(\mathrm{y}_{\mathrm{i}} \in \mathcal{Y}\)</span> 是输出的观测值，也称为输出。</p><p>监督学习中，假设训练数据与测试数据是依联合概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 独立同分布产生的。</p><p>在学习过程中，学习系统利用给定的训练数据集，通过学习（或训练）得到一个模型，表示为条件概率分布 <span class="math inline">\(\hat{P}(\mathrm{Y} | \mathrm{X})\)</span> 或决策函数 <span class="math inline">\(\mathrm{Y}=\hat{f}(\mathrm{X})\)</span>。条件概率分布 <span class="math inline">\(\hat{P}(\mathrm{Y} | \mathrm{X})\)</span> 或决策函数 <span class="math inline">\(\mathrm{Y}=\hat{f}(\mathrm{X})\)</span> 描述输入与输出随机变量之间的映射关系。</p><p>在预测过程中，预测系统对于给定的测试样本集中的输入 <span class="math inline">\(\mathbf{X}_{\mathbf{N}+1}\)</span>，由模型 <span class="math inline">\(y_{N+1}=\arg \max _{y_{N+1}} \hat{P}\left(y_{N+1} | x_{N+1}\right)\)</span> 或 <span class="math inline">\(\mathrm{y}_{\mathrm{N}+1}=\hat{\jmath}\left(\mathrm{x}_{\mathrm{N}+1}\right)\)</span> 给出相应的输出 <span class="math inline">\(\mathbf{y}_{\mathrm{N}+1}\)</span>。</p><p>在学习过程中，<strong>学习系统</strong>（也就是 <strong>学习算法</strong>）试图通过训练数据集中的样本 <span class="math inline">\(\left(\mathbf{x}_{i}, \quad \mathbf{y}_{i}\right)\)</span> 带来的信息学习模型。</p><p>具体地说，</p><ul><li>对输入 <span class="math inline">\(\mathbf{X}_{\mathbf{i}}\)</span>，一个具体的模型 <span class="math inline">\(y=f(x)\)</span> 可以产生一个输出 <span class="math inline">\(\mathrm{f}\left(\mathrm{x}_{\mathrm{i}}\right)\)</span></li><li>训练数据集中对应的输出是 <span class="math inline">\(\mathbf{y}_{\mathrm{i}}\)</span></li><li>如果这个模型有很好的预测能力，训练样本输出 <span class="math inline">\(\mathbf{y}_{\mathrm{i}}\)</span> 和模型输出 <span class="math inline">\(\mathrm{f}\left(\mathrm{x}_{\mathrm{i}}\right)\)</span> 之间的差就应该足够小</li></ul><p>学习系统通过不断的尝试，选取最好的模型，以便对训练数据集有足够好的预测，同时对未知的测试数据集的预测也有尽可能好的推广。</p><h2 id="统计学习三要素">统计学习三要素</h2><p>统计学习方法都是由模型、策略和算法构成的，即统计学习方法由 <strong>三要素</strong> 构成，可以简单地表示为</p><p><strong>方法＝模型＋策略＋算法</strong></p><p>下面论述监督学习中的统计学习三要素。非监督学习、强化学习也同样拥有这三要素。可以说构建一种统计学习方法就是确定具体的统计学习三要素。</p><h3 id="模型">模型</h3><p>统计学习首要考虑的问题是学习什么样的模型。在监督学习过程中，模型就是所要学习的 <strong>条件概率分布</strong> 或 <strong>决策函数</strong>。模型的假设空间（hypothesis space）包含所有可能的条件概率分布或决策函数。</p><p>例如，假设决策函数是输入变量的线性函数，那么模型的假设空间就是所有这些线性函数构成的函数集合。假设空间中的模型一般有无穷多个。</p><p>假设空间用 <span class="math inline">\(\mathcal{F}\)</span> 表示。假设空间可以定义为决策函数的集合</p><p><span class="math display">\[\mathcal{F}=\{f | Y=f(X)\}\]</span></p><p>其中，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是定义在输入空间 <span class="math inline">\(x\)</span> 和输出空间 <span class="math inline">\(\mathcal{Y}\)</span> 上的变量。这时 <span class="math inline">\(\mathcal{F}\)</span> 通常是由一个参数向量决定的函数族：</p><p><span class="math display">\[\mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}\]</span></p><p>参数向量 <span class="math inline">\(\theta\)</span> 取值于 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(\mathbf{R}_{\mathrm{n}}\)</span>，称为参数空间（parameter space）。假设空间也可以定义为条件概率的集合</p><p><span class="math display">\[\mathcal{F}=\{P|P(Y | X)\}\]</span></p><p>其中，<span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 是定义在输入空间 <span class="math inline">\(x\)</span> 和输出空间上的随 <span class="math inline">\(\mathcal{Y}\)</span> 机变量。这时 <span class="math inline">\(\mathcal{Y}\)</span> 通常是由一个参数向量决定的条件概率分布族：</p><p><span class="math display">\[\mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.\]</span></p><p>参数向量 <span class="math inline">\(\theta\)</span> 取值于 <span class="math inline">\(n\)</span> 维欧氏空间 <span class="math inline">\(\mathbf{R}_{\mathrm{n}}\)</span>，也称为参数空间。</p><p>本书中称由决策函数表示的模型为 <strong>非概率模型</strong>，由条件概率表示的模型为 <strong>概率模型</strong>。</p><h3 id="策略">策略</h3><p>有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。</p><p>统计学习的目标: <strong>从假设空间中选取最优模型</strong>。</p><p>首先引入损失函数与风险函数的概念。</p><ul><li>损失函数度量模型一次预测的好坏</li><li>风险函数度量平均意义下模型预测的好坏</li></ul><h4 id="损失函数和风险函数">损失函数和风险函数</h4><p>监督学习问题是在假设空间 <span class="math inline">\(\mathcal{F}\)</span>m中选取模型 <span class="math inline">\(f\)</span> 作为决策函数，对于给定的输入 <span class="math inline">\(X\)</span>，由 <span class="math inline">\(f(X)\)</span> 给出相应的输出 <span class="math inline">\(Y\)</span>，这个输出的预测值 <span class="math inline">\(f(X)\)</span> 与真实值 <span class="math inline">\(Y\)</span> 可能一致也可能不一致，用一个 <strong>损失函数（loss function） </strong>或 <strong>代价函数（cost function） </strong>来度量预测错误的程度。损失函数是 <span class="math inline">\(f(X)\)</span> 和 <span class="math inline">\(Y\)</span> 的非负实值函数，记作 <span class="math inline">\(\mathbf{L}(\mathbf{Y}, \mathrm{f}(\mathbf{X}))\)</span>。</p><p>统计学习常用的损失函数有以下几种：</p><ul><li><strong>0-1 损失函数（0-1 loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=\left\{\begin{array}{ll}{1,} &amp; {Y \neq f(X)} \\ {0,} &amp; {Y=f(X)}\end{array}\right.\]</span></p><ul><li><strong>平方损失函数（quadratic loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=(Y-f(X))^{2}\]</span></p><ul><li><strong>绝对损失函数（absolute loss function）</strong></li></ul><p><span class="math display">\[L(Y, f(X))=|Y-f(X)|\]</span></p><ul><li><strong>对数损失函数（logarithmic loss function）</strong>或 <strong>对数似然损失函数（loglikelihood loss function）</strong></li></ul><p><span class="math display">\[L(Y, P(Y | X))=-\log P(Y | X)\]</span></p><p>损失函数值越小，模型就越好。由于模型的输入、输出 <span class="math inline">\((\mathrm{X}, \mathrm{Y})\)</span> 是随机变量，遵循联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>，所以损失函数的期望是<br /><span class="math display">\[R_{\mathrm{exp}}(f)=E_{p}[L(Y, f(X))]=\int_{X \times y} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y\]</span></p><p>这是理论上模型 <span class="math inline">\(\mathrm{f}(\mathrm{X})\)</span> 关于联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 的平均意义下的损失，称为 <strong>风险函数（risk function）</strong> 或 <strong>期望损失（expected loss）</strong>。</p><p>学习的目标就是选择期望风险最小的模型。由于联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span> 是未知的，<span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 不能直接计算。实际上，如果知道联合分布 <span class="math inline">\(\mathrm{P}(\mathrm{X}, \mathrm{Y})\)</span>，可以从联合分布直接求出条件概率分布 <span class="math inline">\(\mathrm{P}(\mathrm{Y} | \mathrm{X})\)</span>，也就不需要学习了。正因为不知道联合概率分布，所以才需要进行学习。</p><p>这样一来，一方面根据期望风险最小学习模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个 <strong>病态问题（ill-formed problem）</strong>。</p><p>给定一个训练数据集</p><p><span class="math display">\[T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}\]</span></p><p>模型 <span class="math inline">\(\mathrm{f}(\mathrm{X})\)</span> 关于训练数据集的平均损失称为 <strong>经验风险（empirical risk）</strong>或 <strong>经验损失（empirical loss）</strong>，记作 <span class="math inline">\(\mathbf{R}_{\mathrm{emp}}\)</span>：</p><p><span class="math display">\[R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)\]</span></p><p>期望风险 <span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 是模型关于联合分布的期望损失，经验风险 <span class="math inline">\(\mathrm{R}_{\mathrm{emp}}(\mathrm{f})\)</span> 是模型关于训练样本集的平均损失。根据大数定律，当样本容量N趋于无穷时，经验风险 <span class="math inline">\(\mathrm{R}_{\mathrm{emp}}(\mathrm{f})\)</span> 趋于期望风险 <span class="math inline">\(\mathrm{R}_{\mathrm{exp}}(\mathrm{f})\)</span> 。</p><p>这就关系到监督学习的两个基本策略：</p><ul><li>经验风险最小化</li><li>结构风险最小化</li></ul><h4 id="经验风险最小化与结构风险最小化">经验风险最小化与结构风险最小化</h4><p>经验风险最小化（empirical risk minimization，ERM）的策略认为：<strong>经验风险最小的模型是最优的模型</strong>。</p><p>根据这一策略，按照经验风险最小化求最优模型就是求解最优化问题：<br /><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)\]</span><br />其中，<span class="math inline">\(\mathcal{F}\)</span> 是假设空间。</p><p>当样本容量足够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛采用。比如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。</p><p>当模型是 <strong>条件概率</strong> 分布，损失函数是 <strong>对数损失函数</strong> 时，经验风险最小化就等价于 <strong>极大似然估计</strong>。</p><p>但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生后面将要叙述的 <strong>“过拟合(over-fitting)”</strong> 现象。</p><p>结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。</p><p><strong>结构风险最小化</strong> 等价于 <strong>正则化（regularization）</strong>。</p><p><strong>结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term）</strong>。在假设空间、损失函数以及训练数据集确定的情况下，结构风险的定义是<br /><span class="math display">\[R_{\mathrm{smn}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)\]</span><br />结构风险最小化的策略认为结构风险最小的模型是最优的模型。所以求最优模型，就是求解最优化问题：</p><p><span class="math display">\[\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)\]</span><br />这样，监督学习问题就变成了 <strong>经验风险</strong> 或 <strong>结构风险函数</strong> 的最优化问题。</p><p>经验或结构风险函数是 <strong>最优化的目标函数</strong>。</p><h3 id="算法">算法</h3><p><strong>算法是指学习模型的具体计算方法</strong>。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。</p><p>这时，<strong>统计学习问题归结为最优化问题</strong>，统计学习的算法成为求解最优化问题的算法。如果最优化问题有显式的解析解，这个最优化问题就比较简单。但通常解析解不存在，这就需要用数值计算的方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。统计学习可以利用已有的最优化算法，有时也需要开发独自的最优化算法。</p><p><strong>统计学习方法之间的不同，主要来自其模型、策略、算法的不同。确定了模型、策略、算法，统计学习的方法也就确定了。这也就是将其称为统计学习三要素的原因。</strong></p><h2 id="统计学习方法总结">统计学习方法总结</h2><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/05/slm/5.png" /></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/05/slm/2.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="slm" scheme="https://2020.iosdevlog.com/tags/slm/"/>
    
  </entry>
  
  <entry>
    <title>信息论</title>
    <link href="https://2020.iosdevlog.com/2020/04/05/Information-theory/"/>
    <id>https://2020.iosdevlog.com/2020/04/05/Information-theory/</id>
    <published>2020-04-05T14:20:38.000Z</published>
    <updated>2020-04-07T00:50:03.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/05/Information-theory/1.jpg" /></p><p>信息论（英语：information theory）是应用数学、电子学和计算机科学的一个分支，涉及信息的量化、存储和通信等。信息论是由克劳德·香农发展，用来找出信号处理与通信操作的基本限制，如数据压缩、可靠的存储和数据传输等。自创立以来，它已拓展应用到许多其他领域，包括统计推断、自然语言处理、密码学、神经生物学、进化论和分子编码的功能、生态学的模式选择、热物理、量子计算、语言学、剽窃检测、模式识别、异常检测和其他形式的数据分析。<br />熵是信息的一个关键度量，通常用一条消息中需要存储或传输一个符号的平均比特数来表示。熵衡量了预测随机变量的值时涉及到的不确定度的量。例如，指定掷硬币的结果（两个等可能的结果）比指定掷骰子的结果（六个等可能的结果）所提供的信息量更少（熵更少）。</p><a id="more"></a><p>信息论将信息的传递作为一种统计现象来考虑，给出了估算通信信道容量的方法。信息传输和信息压缩是信息论研究中的两大领域。这两个方面又由信道编码定理、信源－信道隔离定理相互联系。</p><p>信息论的基本内容的应用包括无损数据压缩（如ZIP文件）、有损数据压缩（如MP3和JPEG）、信道编码（如数字用户线路（DSL））。这个领域处在数学、统计学、计算机科学、物理学、神经科学和电机工程学的交叉点上。信息论对航海家深空探测任务的成败、光盘的发明、手机的可行性、互联网的发展、语言学和人类感知的研究、对黑洞的了解，以及许多其他领域都影响深远。信息论的重要子领域有信源编码、信道编码、算法复杂性理论、算法信息论、资讯理论安全性和信息度量等。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><ol type="1"><li>信息产生<ul><li>在面对大量信息时，排除噪音，提取利用有效信息，科学做决 策的能力;</li></ul></li><li>信息传播<ul><li>向外界传递信息时，平衡分配有限资源，增加沟通带宽，放大 影响力的能力;</li></ul></li><li>信息应用<ul><li>看懂信息应用的逻辑和通信发展的趋势，提前抓住新机遇的能力。</li></ul></li></ol><p>探索三件事：</p><ol type="1"><li>我们现在的位置</li><li>我们的目标</li><li>以及通向目标的道路</li></ol><h2 id="信息很重要">信息很重要</h2><ol type="1"><li>信息很重要，甚至比钱更重要，它能四两拨千斤。而信息作用的大小和信息量 有关。</li><li>信息量和不确定性有关，大家都知道的事，就没有什么信息量了。</li><li>对一个未知系统(黑盒子)所作出的估计和真实情况的偏离，就是信息的损失， 偏离越多损失越大。</li></ol><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/信息论" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/信息论</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/05/Information-theory/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;信息论（英语：information theory）是应用数学、电子学和计算机科学的一个分支，涉及信息的量化、存储和通信等。信息论是由克劳德·香农发展，用来找出信号处理与通信操作的基本限制，如数据压缩、可靠的存储和数据传输等。自创立以来，它已拓展应用到许多其他领域，包括统计推断、自然语言处理、密码学、神经生物学、进化论和分子编码的功能、生态学的模式选择、热物理、量子计算、语言学、剽窃检测、模式识别、异常检测和其他形式的数据分析。&lt;br /&gt;
熵是信息的一个关键度量，通常用一条消息中需要存储或传输一个符号的平均比特数来表示。熵衡量了预测随机变量的值时涉及到的不确定度的量。例如，指定掷硬币的结果（两个等可能的结果）比指定掷骰子的结果（六个等可能的结果）所提供的信息量更少（熵更少）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="information" scheme="https://2020.iosdevlog.com/tags/information/"/>
    
      <category term="theory" scheme="https://2020.iosdevlog.com/tags/theory/"/>
    
  </entry>
  
  <entry>
    <title>《数据结构与算法之美》-1-线性表</title>
    <link href="https://2020.iosdevlog.com/2020/04/04/algorithm/"/>
    <id>https://2020.iosdevlog.com/2020/04/04/algorithm/</id>
    <published>2020-04-04T01:06:12.000Z</published>
    <updated>2020-04-08T08:44:43.491Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg" /></p><p><a href="https://2020.iosdevlog.com/tags/algorithm/">算法</a></p><p>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>基础架构研发工程师，写出达到开源水平的框架才是你的目标！</p><p>性能好坏起码是其中一个非常重要的评判标准。</p><p>数据结构是为算法服务的，算法要作用在特定的数据结构之上。</p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/algorithm.jpg" /></p><p>重点：</p><ol type="1"><li>首先要掌握一个数据结构与算法中最重要的概念——复杂度分析</li><li>10个数据结构<ol type="1"><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>散列表</li><li>二叉树</li><li>堆</li><li>跳表</li><li>图</li><li>Trie树</li></ol></li><li>10个算法<ol type="1"><li>递归</li><li>排序</li><li>二分查找</li><li>搜索</li><li>哈希算法</li><li>贪心算法</li><li>分治算法</li><li>回溯算法</li><li>动态规划</li><li>字符串匹配算法</li></ol></li><li>技巧<ol type="1"><li>边学边练，适度刷题</li><li>多问、多思考、多互动</li><li>打怪升级学习法</li><li>知识需要沉淀，不要想试图一下子掌握所有</li></ol></li></ol><h2 id="复杂度分析">复杂度分析</h2><ol type="1"><li>测试结果非常依赖测试环境</li><li>测试结果受数据规模的影响很大</li></ol><p>不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</p><p>大O复杂度表示法</p><p>在采用大O标记复杂度的时候，可以忽略系数</p><ul><li>大O时间复杂度表示法<ul><li>表示代码执行时间随数据规模增长的变化趋势</li><li>也叫作 <strong>渐进时间复杂度（asymptotic time complexity）</strong></li><li>简称 <strong>时间复杂度</strong></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.1.png" /></p><p><span class="math display">\[T(n)=O(f(n))\]</span></p><ol type="1"><li><code>n</code>：数据规模的大小</li><li><code>T(n)</code>：代码执行时间</li><li><code>f(n)</code>：每行代码执行的次数总和</li><li>公式中的 <code>O</code>，表示代码的执行时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比</li></ol><p>记录一个最大量级</p><p>时间复杂度分析</p><ol type="1"><li>只关注循环执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><p>几种常见时间复杂度实例分析</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.2.jpg" /></p><ol type="1"><li>多项式量级<ol type="1"><li>常量阶：<span class="math inline">\(O(1)\)</span><ol type="1"><li>不存在循环语句、递归语句</li></ol></li><li>对数阶：<span class="math inline">\(O(\log n)\)</span><ol type="1"><li>忽略对数的“底”</li></ol></li><li>线性阶：<span class="math inline">\(O(n)\)</span><ol type="1"><li><span class="math inline">\(O(m+n)\)</span></li></ol></li><li>线性对数阶： <span class="math inline">\(O(n \log n)\)</span><ol type="1"><li>归并排序</li><li>快速排序</li></ol></li><li>方阶：<ol type="1"><li>平方阶： <span class="math inline">\(O(n^2)\)</span></li><li>立方阶： <span class="math inline">\(O(n^3)\)</span></li><li><span class="math inline">\(k\)</span> 次方阶： <span class="math inline">\(O(n^{k})\)</span></li></ol></li></ol></li><li>非多项式量级（低效）<ol type="1"><li>指数阶：<span class="math inline">\(O(2^{n})\)</span></li><li>阶乘阶：<span class="math inline">\(O(n!)\)</span></li></ol></li></ol><p>空间复杂度分析</p><ul><li>大O时间复杂度表示法<ul><li>算法的存储空间与数据规模之间的增长关系</li><li>也叫作 <strong>渐进空间复杂度（asymptotic space complexity）</strong></li><li>简称 <strong>空间复杂度</strong></li></ul></li></ul><ol type="1"><li><span class="math inline">\(O(1)\)</span></li><li><span class="math inline">\(O(n)\)</span></li><li><span class="math inline">\(O(n^{2})\)</span></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/3.3.jpg" /></p><p>四个复杂度分析</p><ol type="1"><li>最好情况时间复杂度（best case time complexity）<ol type="1"><li>最理想的情况</li></ol></li><li>最坏情况时间复杂度（worst case time complexity）<ol type="1"><li>最糟糕的情况</li></ol></li><li>平均情况时间复杂度（average case time complexity）<ol type="1"><li>加权平均值</li><li>全称：<strong>加权平均时间复杂度</strong></li><li>期望值</li><li>全称：<strong>期望时间复杂度</strong></li></ol></li><li>均摊时间复杂度（amortized time complexity）<ol type="1"><li>摊还分析 / 平摊分析</li><li><strong>均摊时间复杂度</strong> 就是一种 <code>特殊</code> 的 <strong>平均时间复杂度</strong></li></ol></li></ol><h2 id="基础">基础</h2><h3 id="数组array">数组（Array）</h3><p>数组（Array）是一种 <code>线性表</code> 数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><ul><li>线性表（Linear List）<ul><li>线性表就是数据排成像一条线一样的结构</li><li>每个线性表上的数据最多只有前和后两个方向</li><li>类型<ol type="1"><li><strong>数组</strong></li><li>链表</li><li>队列</li><li>栈</li></ol></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg" /></p><ul><li>非线性表<ol type="1"><li>二叉树</li><li>堆</li><li>图</li></ol></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.2.jpg" /></p><ul><li>连续的内存空间和相同类型的数据<ul><li>随机访问</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.3.jpg" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>低效的“插入”和“删除”</p><ul><li>插入操作<ul><li>交换最后</li><li>快排</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.4.jpg" /></p><ul><li>删除操作<ul><li>记录下已经删除的数据</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/5.5.jpg" /></p><h4 id="警惕数组的访问越界问题">警惕数组的访问越界问题</h4><h4 id="容器能否完全替代数组">容器能否完全替代数组？</h4><p><code>Java</code> ： <code>ArrayList</code><br /><code>C++ STL</code>： <code>vector</code></p><ul><li>将很多数组操作的细节封装起来</li><li>支持动态扩容</li></ul><p>数组 vs 容器：</p><ol type="1"><li>数组<ol type="1"><li>底层开发</li><li>关注性能 / 基本类型</li><li>数据大小事先已知 / 操作简单</li><li>多维数组直观</li></ol></li><li>容器<ol type="1"><li>业务开发</li></ol></li></ol><h4 id="数组要从0开始编号">数组要从0开始编号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><ol type="1"><li>“偏移（offset）”</li><li>习惯：C语言设计者用 <span class="math inline">\(0\)</span> 开始计数数组下标，</li></ol><h4 id="小结">小结</h4><p>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h3 id="链表linked-list">链表（Linked list）</h3><p>缓存</p><ol type="1"><li>CPU缓存</li><li>数据库缓存</li><li>浏览器缓存</li></ol><p>缓存淘汰策略</p><ol type="1"><li>先进先出策略 FIFO（First In，First Out）</li><li>最少使用策略 LFU（Least Frequently Used）</li><li>最近最少使用策略 LRU（Least Recently Used）</li></ol><p>底层的存储结构</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.1.jpg" /></p><ol type="1"><li>单链表</li><li>循环链表</li><li>双向链表</li></ol><h4 id="单链表">单链表</h4><p>结点： 内存块<br />后继指针 next</p><ol type="1"><li><strong>头结点</strong>：第一个结点</li><li><strong>尾结点</strong>：最后个结点<ul><li>指向一个空地址 <code>NULL</code></li></ul></li></ol><p>查找、插入和删除操作</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.2.jpg" /></p><h4 id="循环链表">循环链表</h4><p>循环链表是一种特殊的单链表</p><p>约瑟夫问题</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.3.jpg" /></p><h4 id="双向链表">双向链表</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.4.jpg" /></p><p>删除操作</p><ul><li>删除结点中“值等于某个给定值”的结点<ul><li><span class="math inline">\(O(n)\)</span></li></ul></li><li>删除给定指针指向的结点<ul><li><span class="math inline">\(O(1)\)</span></li></ul></li></ul><p><strong>用空间换时间</strong> 的 <code>设计思想</code></p><ol type="1"><li>缓存</li><li>双向链表</li></ol><h4 id="双向循环链表">双向循环链表</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.5.jpg" /></p><h4 id="链表-vs-数组性能">链表 VS 数组性能</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/6.6.jpg" /></p><h4 id="lruleast-recently-used缓存">LRU（Least Recently Used）缓存</h4><ol type="1"><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，又可以分为两种情况：<ol type="1"><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ol></li></ol><h4 id="代码技巧">代码技巧</h4><ol type="1"><li>理解指针或引用的含义</li><li>警惕指针丢失和内存泄漏<ol type="1"><li>插入结点时，一定要注意操作的顺序</li><li>删除链表结点时，也一定要记得手动释放内存空间</li></ol></li><li>利用哨兵简化实现难度<ol type="1"><li>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</li></ol></li><li>重点留意边界条件处理<ol type="1"><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ol></li><li>举例画图，辅助思考</li><li>多写多练，没有捷径<ol type="1"><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ol></li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/7.3.jpg" /></p><h4 id="内容小结">内容小结</h4><p>链表跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h3 id="栈2">栈<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h3><p>后进先出</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.1.jpg" /></p><p>栈是一种“操作受限”的线性表</p><p>操作</p><ul><li>插入：<strong>入栈 push()</strong></li><li>删除：<strong>出栈 pop()</strong></li></ul><p>栈顶指针</p><p>支持动态扩容的顺序栈</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.3.jpg" /></p><p>栈在函数调用中的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">   res = a + ret;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">   reuturn <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.4.jpg" /></p><p>栈在表达式求值中的应用</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.5.jpg" /></p><p>栈在括号匹配中的应用</p><p><span class="math display">\[{[()]}\]</span></p><p>浏览器的前进和后退</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.8.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/8.9.jpg" /></p><h3 id="队列">队列</h3><p>操作受限的线性表数据结构</p><p>操作</p><ul><li>插入：<strong>入队 enqueue()</strong></li><li>删除：<strong>出队 dequeue()</strong></li></ul><p>先进先出</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.1.jpg" /></p><table><thead><tr class="header"><th>实现</th><th>数组</th><th>链表</th></tr></thead><tbody><tr class="odd"><td>栈</td><td>顺序栈</td><td>链式栈</td></tr><tr class="even"><td>队列</td><td>顺序队列</td><td>链式队列</td></tr></tbody></table><ul><li>一个是 <code>head</code> 指针，指向队头</li><li>一个是 <code>tail</code> 指针，指向队尾</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.3.jpg" /></p><p>数据搬移</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.4.jpg" /></p><h4 id="基于链表的队列实现方法">基于链表的队列实现方法</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.5.jpg" /></p><h4 id="循环队列">循环队列</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.6.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.8.jpg" /></p><h4 id="阻塞队列和并发队列">阻塞队列和并发队列</h4><p>阻塞队列：生产者-消费者模型</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/9.10.jpg" /></p><p>并发队列：线程安全的队列</p><p>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</p><h4 id="内容小结-1">内容小结</h4><p>队列：一种跟栈很相似的数据结构。</p><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p><p>循环队列是我们这节的重点。要想写出没有bug的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p><p>除此之外，我们还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h3 id="递归">递归</h3><ul><li>去的过程叫“递”</li><li>回来的过程叫“归”</li></ul><p>递归需要满足的三个条件</p><ol type="1"><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><p>编写递归代码</p><ol type="1"><li>写出递推公式</li><li>找到终止条件</li><li>递推公式 -&gt; 代码</li></ol><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><ul><li><p>递归代码要警惕堆栈溢出</p></li><li><p>递归代码要警惕重复计算</p><ul><li>通过一个数据结构（比如散列表）来保存已经求解过的f(k)</li></ul></li><li><p>递归代码 -&gt; 为非递归代码（迭代循环）</p></li></ul><h4 id="内容小结-2">内容小结</h4><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><h3 id="排序">排序</h3><p>排序比较<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p><table><thead><tr class="header"><th>排序</th><th>排序算法</th></tr></thead><tbody><tr class="odd"><td>理论</td><td>计算复杂性理论 大O符号 全序关系 数据结构列表 原地算法 稳定性 比较排序 自适应排序 排序网络 整数排序 X+Y排序 量子排序</td></tr><tr class="even"><td>交换排序</td><td>冒泡排序 鸡尾酒排序 奇偶排序 梳排序 侏儒排序 快速排序 臭皮匠排序 Bogo排序</td></tr><tr class="odd"><td>选择排序</td><td>选择排序 堆排序 平滑排序 笛卡尔树排序 锦标赛排序 圈排序 弱堆排序</td></tr><tr class="even"><td>插入排序</td><td>插入排序 希尔排序 伸展排序 二叉查找树排序 图书馆排序 耐心排序</td></tr><tr class="odd"><td>归并排序</td><td>归并排序 梯级归并排序 振荡归并排序 多相归并排序</td></tr><tr class="even"><td>分布排序</td><td>美国旗帜排序 珠排序 桶排序 爆炸排序 计数排序 比較計數排序 插值排序 鸽巢排序 相邻图排序 基数排序 闪电排序</td></tr><tr class="odd"><td>并发排序</td><td>双调排序器 Batcher归并网络 两两排序网络</td></tr><tr class="even"><td>混合排序</td><td>塊排序 Tim排序 内省排序 Spread排序 归并插入排序</td></tr><tr class="odd"><td>其他</td><td>拓扑排序 煎餅排序 意粉排序</td></tr></tbody></table><figure><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.en.png" alt="" /><figcaption>en</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.zh.png" alt="" /><figcaption>zh</figcaption></figure><ul><li>均按从小到大排列</li><li>k 代表数值中的"数位"个数</li><li>n 代表数据规模</li><li>m 代表数据的最大值减最小值</li></ul><p>如何分析一个“排序算法”？</p><ol type="1"><li>排序算法的执行效率<ol type="1"><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ol></li><li>排序算法的内存消耗<ol type="1"><li>原地排序（Sorted in place）</li><li>空间复杂度是O(1)</li></ol></li><li>排序算法的稳定性</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.1.jpg" /></p><h4 id="冒泡排序bubble-sort">冒泡排序（Bubble Sort）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure><p>原子操作：</p><ol type="1"><li>比较</li><li>交换</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.3.jpg" /></p><p>优化</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.4.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有序度</p><p>有序元素对：<span class="math inline">\(a[i] &lt;= a[j]\)</span>, 如果 <span class="math inline">\(i &lt; j\)</span>。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.5.jpg" /></p><p>满有序度</p><p><span class="math inline">\(n*(n-1)/2\)</span></p><p><strong>逆序度 = 满有序度 - 有序度</strong></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.6.jpg" /></p><p>交换一次，有序度就加 1。</p><h4 id="插入排序insertion-sort">插入排序（Insertion Sort）</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.7.jpg" /></p><p>数据分为两个区间</p><ol type="1"><li>已排序区间</li><li>未排序区间</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.8.jpg" /></p><p>原子操作：</p><ol type="1"><li>比较</li><li>移动</li></ol><p>移动次数 = 逆序度</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.9.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么插入排序要比冒泡排序更受欢迎？</p></blockquote><p>冒泡排序中数据的交换操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序中数据的移动操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序selection-sort">选择排序（Selection Sort）</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.10.jpg" /></p><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。</p><p>但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><span class="math inline">\(O(n^{2})\)</span> 的排序算法：冒泡排序、插入排序、选择排序</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/11.11.jpg" /></p><h4 id="归并排序merge-sort">归并排序（Merge Sort）</h4><p>归并排序的核心思想</p><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.1.jpg" /></p><p>归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><ul><li><code>分治</code> 是一种解决问题的处理思想</li><li><code>递归</code> 是一种编程技巧</li></ul><p>递推公式：</p><p><span class="math inline">\(merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))\)</span></p><p>终止条件：</p><p><span class="math inline">\(p &gt;= r\)</span> 不用再继续分解</p><p><code>merge_sort(p…r)</code> 表示，给下标从 <code>p</code> 到 <code>r</code> 之间的数组排序。我们将这个排序问题转化为了两个子问题，<code>merge_sort(p…q)</code> 和 <code>merge_sort(q+1…r)</code>，其中下标 <code>q</code> 等于 <code>p</code> 和 <code>r</code> 的中间位置，也就是 <code>(p+r)/2</code>。当下标从 <code>p</code> 到 <code>q</code> 和从 <code>q+1</code> 到 <code>r</code> 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 <code>p</code> 到 <code>r</code> 之间的数据就也排好序了。</p><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A是数组，n表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.2.jpg" /></p><p><code>merge</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r]) &#123;</span><br><span class="line">  <span class="keyword">var</span> i := p，j := q+<span class="number">1</span>，k := <span class="number">0</span> <span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">  <span class="keyword">var</span> tmp := <span class="keyword">new</span> array[<span class="number">0</span>...r-p] <span class="comment">// 申请一个大小跟A[p...r]一样的临时数组</span></span><br><span class="line">  <span class="keyword">while</span> i&lt;=q AND j&lt;=r <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[i] &lt;= A[j] &#123;</span><br><span class="line">      tmp[k++] = A[i++] <span class="comment">// i++等于i:=i+1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmp[k++] = A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">  <span class="keyword">var</span> start := i，end := q</span><br><span class="line">  <span class="keyword">if</span> j&lt;=r then start := j, end:=r</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">  <span class="keyword">while</span> start &lt;= end <span class="keyword">do</span> &#123;</span><br><span class="line">    tmp[k++] = A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将tmp中的数组拷贝回A[p...r]</span></span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">0</span> to r-p <span class="keyword">do</span> &#123;</span><br><span class="line">    A[p+i] = tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序-快排quicksort">快速排序 / 快排（Quicksort）</h4><p>快排的思想：</p><p>如果要排序数组中下标从 <code>p</code> 到 <code>r</code> 之间的一组数据，我们选择 <code>p</code> 到 <code>r</code> 之间的任意一个数据作为 <code>pivot（分区点）</code>。</p><p>遍历 <code>p</code> 到 <code>r</code> 之间的数据，将小于 <code>pivot</code> 的放到左边，将大于 <code>pivot</code> 的放到右边，将 <code>pivot</code> 放到中间。经过这一步骤之后，数组 <code>p</code> 到 <code>r</code> 之间的数据就被分成了三个部分，前面 <code>p</code> 到 <code>q-1</code> 之间都是小于 <code>pivot</code> 的，中间是 <code>pivot</code>，后面的 <code>q+1</code> 到 <code>r</code> 之间是大于 <code>pivot</code> 的。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.3.jpg" /></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从 <code>p</code> 到 <code>q-1</code> 之间的数据和下标从 <code>q+1</code> 到 <code>r</code> 之间的数据，直到区间缩小为 <code>1</code>，就说明所有的数据都有序了。</p><p>递推公式：</p><p><span class="math inline">\(quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)\)</span></p><p>终止条件：</p><p><span class="math inline">\(p &gt;= r\)</span></p><p>伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A是数组，n表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p,r为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">  quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个 <code>merge()</code> 合并函数，我们这里有一个 <code>partition()</code> 分区函数。</p><p><code>partition()</code>分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 <code>pivot</code>（一般情况下，可以选择p到r区间的最后一个元素），然后对 <code>A[p…r]</code> 分区，函数返回 <code>pivot</code> 的下标。</p><p>不考虑空间消耗，申请 2 个新数组</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.4.jpg" /></p><p>考虑空间消耗，原地分区函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot := A[r]</span><br><span class="line">  i := p</span><br><span class="line">  <span class="keyword">for</span> j := p to r-<span class="number">1</span> <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i := i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/12.5.jpg" /></p><p>归并排序 VS 快排</p><ol type="1"><li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。</li><li>快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</li></ol><blockquote><p>为什么 <strong>归并排序</strong> 并没有像 <strong>快排</strong> 应用广泛？</p></blockquote><p>归并排序有一个致命的“弱点”，不是原地排序算法。</p><p>内容小结</p><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 <code>merge()</code> 合并函数。同理，理解快排的重点也是理解递推公式，还有 <code>partition()</code> 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 <span class="math inline">\(O(n)\)</span>。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 <span class="math inline">\(O(n^{2})\)</span>，但是平均情况下时间复杂度都是 <span class="math inline">\(O(n \log n)\)</span>。不仅如此，快速排序算法时间复杂度退化到 <span class="math inline">\(O(n^{2})\)</span> 的概率非常小，我们可以通过合理地选择 <code>pivot</code> 来避免这种情况。</p><h4 id="桶排序bucket-sort">桶排序（Bucket sort）</h4><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.1.jpg" /></p><p>复杂度： <span class="math inline">\(O(n)\)</span></p><p>如果要排序的数据有 <span class="math inline">\(n\)</span> 个，我们把它们均匀地划分到 <span class="math inline">\(m\)</span> 个桶内，每个桶里就有 <span class="math inline">\(k=n/m\)</span> 个元素。每个桶内部使用快速排序，时间复杂度为 <span class="math inline">\(O(k * \log k)\)</span>。m个桶排序的时间复杂度就是 <span class="math inline">\(O(m * k * \log k)\)</span>，因为 <code>k=n/m</code>，所以整个桶排序的时间复杂度就是 <span class="math inline">\(O(n*log(n/m))\)</span>。当桶的个数m接近数据个数 <span class="math inline">\(n\)</span> 时，<span class="math inline">\(log(n/m)\)</span> 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 <span class="math inline">\(O(n)\)</span>。</p><blockquote><p>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</p></blockquote><p>答案当然是否定的。为了让你轻松理解桶排序的核心思想，我刚才做了很多假设。实际上，桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 <code>m</code> 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 <span class="math inline">\(O(n \log n)\)</span> 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><h4 id="计数排序counting-sort桶排序的一种特殊情况">计数排序（Counting sort）：桶排序的一种特殊情况</h4><p>当要排序的n个数据，所处的范围并不大的时候，比如最大值是k，我们就可以把数据划分成k个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>示例：高考分数</p><p>满分是 <span class="math inline">\(900\)</span> 分，最小是 <span class="math inline">\(0\)</span> 分，可以分成 <span class="math inline">\(901\)</span> 个桶，对应分数从 <span class="math inline">\(0\)</span> 分到 <span class="math inline">\(900\)</span> 分。</p><p>桶内的数据都是分数相同的考生，所以并不需要再进行排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">8</span>] = &#123; <span class="number">2</span>，<span class="number">5</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p>C[6] 表示桶 ,其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.3.jpg" /></p><blockquote><p>如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？</p></blockquote><p>思路是这样的：我们对C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数k的考生个数。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.5.jpg" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序只能用在数据范围不大的场景中，如果数据范围 <code>k</code> 比要排序的数据 <code>n</code> 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p><h4 id="基数排序radix-sort">基数排序（Radix sort）</h4><p>手机号码从小到大排序</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/13.6.jpg" /></p><p>按照每位来排序的排序算法要是稳定的。</p><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</p><p>线性排序（Linear sort）/ 复杂度是 <span class="math inline">\(O(n)\)</span> 的排序算法：桶排序、计数排序、基数排序</p><p>它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。</p><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p><h4 id="如何实现一个通用的高性能的排序函数">如何实现一个通用的、高性能的排序函数？</h4><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/14.jpg" /></p><ol type="1"><li>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</li><li>首选时间复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的排序算法<ol type="1"><li>小规模数据进行排序，可以选择时间复杂度是 <span class="math inline">\(O(n^{2})\)</span> 的算法</li><li>大规模数据进行排序，时间复杂度是 <span class="math inline">\(O(n \log n)\)</span> 的算法更加高效</li></ol></li><li>对于小数据量的排序，不需要递归的插入排序算法</li></ol><blockquote><p>如何优化快速排序？</p></blockquote><p>被分区点分开的两个分区中，数据的数量差不多。</p><ol type="1"><li>三数取中法</li><li>随机法</li></ol><p>堆栈溢出</p><ol type="1"><li>限制递归深度<ul><li>超过了我们事先设定的阈值，就停止递归</li></ul></li><li>堆上模拟实现一个函数调用栈<ul><li>手动模拟递归压栈、出栈的过程</li></ul></li></ol><p>分析了一下如何来实现一个工业级的通用的、高效的排序函数，内容比较偏实战，而且贯穿了一些前面几节的内容，你要多看几遍。我们大部分排序函数都是采用O(nlogn)排序算法来实现，但是为了尽可能地提高性能，会做很多优化。</p><p>快速排序的一些优化策略，比如合理选择分区点、避免递归太深等等。</p><p>C语言中 <code>qsort()</code> 的底层实现原理：</p><ol type="1"><li>分区点<ul><li>三数取中法</li></ul></li><li>堆栈溢出<ul><li>实现一个堆上的栈，手动模拟递归</li></ul></li><li>元素的个数 &lt;= 4<ul><li>插入排序</li></ul></li><li>优先使用<ul><li>归并排序</li></ul></li><li>数据量比较大<ul><li>快速排序</li></ul></li></ol><h3 id="二分查找binary-search-折半查找">二分查找（Binary Search）/ 折半查找</h3><p>猜数字游戏</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.2.jpg" /></p><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><p><span class="math inline">\(O(\log n)\)</span> 惊人的查找速度</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/15.3.jpg" /></p><p><span class="math inline">\(O(\log n)\)</span> 对数时间复杂度</p><p>二分查找的递归与非递归实现</p><p>循环实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="comment">// low+((high-low)&gt;&gt;1)</span></span><br><span class="line">    <span class="comment">// low+(high-low)/2</span></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易出错的3个地方</p><ol type="1"><li>循环退出条件</li><li>mid 的取值</li><li>low 和 high 的更新</li></ol><p>递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找应用场景的局限性</p><ol type="1"><li>二分查找依赖的是顺序表结构，简单点说就是数组</li><li>二分查找针对的是有序数据</li><li>数据量太小不适合二分查找</li><li>数据量太大也不适合二分查找<ul><li>连续内存空间</li></ul></li></ol><p>二分查找是一种针对有序数据的高效查找算法，它的时间复杂度是 <span class="math inline">\(O(\log n)\)</span>。</p><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0 。但是二分查找的代码实现比较容易写错。</p><p>着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><p>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第3卷《排序和查找》中说到：“尽管第一个二分查找算法于1946年出现，然而第一个完全正确的二分查找算法实现直到1962年才出现。”</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/16.1.jpg" /></p><h3 id="跳表">跳表</h3><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.2.jpg" /></p><p>这种链表加多级索引的结构，就是跳表。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.3.jpg" /></p><p>空间换时间</p><p>插入操作</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.4.jpg" /></p><p>跳表索引动态更新</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.5.jpg" /></p><p>随机函数生成了值K</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/17.6.jpg" /></p><p>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 <span class="math inline">\(O(\log n)\)</span>。</p><p>跳表的空间复杂度是 <span class="math inline">\(O(n)\)</span>。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p><h3 id="散列表-哈希表-hash表hash-table">散列表 / 哈希表 / Hash表（Hash Table）</h3><p><code>散列表</code> 用的是 <code>数组</code> 支持按照 <em>下标随机访问</em> 数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><p>编号我们叫作 <code>键（key）</code> 或者 <code>关键字</code>。</p><p>编号转化为数组下标的映射方法就叫作 <code>散列函数（或“Hash函数”“哈希函数”）</code>。</p><p>而散列函数计算得到的值就叫作 <code>散列值（或“Hash值”“哈希值”）</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.1.jpg" /></p><p>时间复杂度是 <span class="math inline">\(O(1)\)</span></p><p>散列函数</p><p><code>hash(key)</code> 的值表示经过散列函数计算得到的散列值。</p><p>散列函数设计的基本要求：</p><ol type="1"><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)</code>；</li><li>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)</code>。</li></ol><p>散列冲突</p><ul><li>开放寻址法（open addressing）<ul><li>线性探测（Linear Probing）<ul><li><span class="math inline">\(hash(key)+0，hash(key)+1，hash(key)+2……\)</span></li></ul></li><li>二次探测（Quadratic probing）<ul><li><span class="math inline">\(hash(key)+0，hash(key)+1^{2}，hash(key)+2^{2}……\)</span></li></ul></li><li>双重散列（Double hashing）<ul><li><span class="math inline">\(hash1(key)，hash2(key)，hash3(key)……\)</span></li></ul></li></ul></li></ul><p>插入</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.2.jpg" /></p><p>查找</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.3.jpg" /></p><p>删除：特殊标记为 <code>deleted</code></p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.4.jpg" /></p><p>装载因子（load factor）来表示空位的多少</p><p><span class="math display">\[散列表的装载因子 = 填入表中的元素个数 / 散列表的长度\]</span></p><ul><li>链表法（chaining）</li></ul><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/18.5.jpg" /></p><p>在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是散列函数设计和散列冲突解决。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><h4 id="如何设计散列函数">如何设计散列函数？</h4><ol type="1"><li>散列函数的设计不能太复杂</li><li>散列函数生成的值要尽可能随机并且均匀分布</li></ol><p>方法：</p><ol type="1"><li>数据分析法</li><li>直接寻址法</li><li>平方取中法</li><li>折叠法</li><li>随机数法</li></ol><p>动态扩容的散列表</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.1.jpg" /></p><p>如何避免低效地扩容？</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.2.jpg" /></p><p>如何选择冲突解决方法？</p><ul><li>开放寻址法</li></ul><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</p><p><code>Java</code> 中的 <code>ThreadLocalMap</code> 使用开放寻址法解决散列冲突的原因。</p><ul><li>链表法</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/19.3.jpg" /></p><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><p>工业级散列表举例分析：<code>Java</code> 中的 <code>HashMap</code></p><ol type="1"><li>初始大小<ul><li>默认的初始大小是16</li></ul></li><li>装载因子和动态扩容<ul><li>最大装载因子默认是0.75</li><li>超过 0.75*capacity（capacity表示散列表的容量）的时候，启动扩容</li><li>每次扩容都会扩容为原来的两倍大小</li></ul></li><li>散列冲突解决方法<ul><li>&lt; 8：链表法</li><li>&gt; 8：红黑树</li></ul></li><li>散列函数<ul><li>简单高效</li><li>分布均匀</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capitity -<span class="number">1</span>); <span class="comment">// capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p><p>为什么散列表和链表经常会一起使用</p><p><img src="https://2020.iosdevlog.com/2020/04/04/algorithm/20.1.jpg" /></p><p>使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。</p><p>散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚，另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p><h3 id="哈希算法">哈希算法</h3><p>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是 <code>哈希算法</code>，而通过原始数据映射之后得到的二进制值串就是 <code>哈希值</code>。</p><p>要求：</p><ol type="1"><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。</li></ol><p><code>MD5</code> 的哈希值是 <code>128位</code> 的 <code>Bit</code> 长度</p><p>应用 (盐（salt）)</p><ol type="1"><li>安全加密<ul><li>MD5（MD5 Message-Digest Algorithm，MD5消息摘要算法）</li><li>SHA（Secure Hash Algorithm，安全散列算法）</li><li>DES（Data Encryption Standard，数据加密标准）</li><li>AES（Advanced Encryption Standard，高级加密标准）</li></ul></li><li>唯一标识<ul><li>完整性和正确性</li><li>信息摘要</li><li>网盘秒传</li></ul></li><li>数据校验<ul><li>下载校验</li></ul></li><li>散列函数<ul><li>简单</li><li>追求效率</li></ul></li><li>负载均衡<ul><li>客户端 IP地址 或者 会话ID 与 服务器编号 映射</li></ul></li><li>数据分片<ul><li>MapReduce</li></ul></li><li>分布式存储<ul><li>一致性哈希算法</li></ul></li></ol><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/126" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/126</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener" class="uri">https://github.com/wangzheng0822/algo</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-cn/排序算法" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-cn/排序算法</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/04/algorithm/5.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://2020.iosdevlog.com/tags/algorithm/&quot;&gt;算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基础架构研发工程师，写出达到开源水平的框架才是你的目标！&lt;/p&gt;
&lt;p&gt;性能好坏起码是其中一个非常重要的评判标准。&lt;/p&gt;
&lt;p&gt;数据结构是为算法服务的，算法要作用在特定的数据结构之上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="algorithm" scheme="https://2020.iosdevlog.com/tags/algorithm/"/>
    
      <category term="data" scheme="https://2020.iosdevlog.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>InfoQ 写作平台</title>
    <link href="https://2020.iosdevlog.com/2020/04/03/infoq/"/>
    <id>https://2020.iosdevlog.com/2020/04/03/infoq/</id>
    <published>2020-04-03T15:47:28.000Z</published>
    <updated>2020-04-03T16:24:14.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/1.png" /></p><a id="more"></a><p>前几天收到 InfoQ 的邮件。</p><p>您已通过审核。</p><p>感谢您的内测申请，很高兴邀请您加入 InfoQ 写作平台。<br />以下是关于入驻平台的相关信息，还请仔细阅读：<br />...<br />（具体操作路径及注意事项将在群中通知，请您务必添加小助手微信）</p><h2 id="infoq-是什么">InfoQ 是什么？</h2><p>去 Google 一下。</p><p><a href="www.infoq.com">www.infoq.com</a><br />InfoQ: Software Development News, Videos &amp; Books<br />Curated and peer-reviewed content covering innovation in professional software development, read by over 1 million developers worldwide.</p><p><a href="www.infoq.cn">www.infoq.cn</a><br />InfoQ - 促进软件开发领域知识与创新的传播-极客邦<br />InfoQ是一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。提供架构，云计算，AI，前端，大数据，Java，软件开发，编程等技术资讯及技术 ...</p><p>baike.baidu.com › item › InfoQ<br />InfoQ_百度百科<br />软件正在改变世界！InfoQ（Information Queue）是一个在线新闻/社区网站，旨在通过促进软件开发领域知识与创新的传播，为软件开发者提供帮助。...</p><h2 id="程序员评价">程序员评价</h2><p>知乎上有一个关于 InfoQ 的提问：<a href="https://www.zhihu.com/question/353239355/answer/883885600" target="_blank" rel="noopener">为什么InfoQ新加的话题模块没什么人讨论？</a></p><p>有且仅有一条回答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">infoq 难道不是一个给</span><br><span class="line"></span><br><span class="line">产品经理</span><br><span class="line">不写代码的CTO</span><br><span class="line">大小会议上不断强调自己是“技术出身”的CEO</span><br><span class="line">...</span><br><span class="line">看的，并且在看完网站内容，回头就使用它来指导程序员做设计甚至开发的地方吗？</span><br><span class="line"></span><br><span class="line">那些人和程序员不同，他们不爱和同行讨论。</span><br></pre></td></tr></table></figure><p>——庄严《白话C++》作者</p><h2 id="群公告">群公告</h2><p>今天下午 3 点多终于开始加群了。</p><p>以下群公告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">哈喽，1号创作者们。</span><br><span class="line"></span><br><span class="line">为了方便平台内测信息的同步&amp;交流，请大家把群中备注改为【姓名 &#x2F; 笔名 - 行业领域】，谢谢配合！</span><br><span class="line"></span><br><span class="line">写作平台预计将于【清明假期后】正式向本群的创作者们开放，请大家提前备好【3 篇以上】文章作品，届时大家将首批体验 InfoQ 写作平台编辑器，并自行发布文章。如有任何疑问，可查看 InfoQ 写作平台为大家准备的：《给内容创作者的一封信》：&lt;https:&#x2F;&#x2F;shimo.im&#x2F;docs&#x2F;T9vxKx8qXd688RRX&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">当然，也可以随时艾特或私戳文字君哟~</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/infoq.png" /></p><h2 id="写作经历">写作经历</h2><p>之前在 <a href="https://www.csdn.net" target="_blank" rel="noopener">csdn</a>, <a href="http://www.chinaunix.net" target="_blank" rel="noopener">unixchina</a> 的技术论坛活动。</p><p>2014 年开始自己的博客：<a href="https://www.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://www.iosdevlog.com</a> jekyll。</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/iosdevlog.png" /></p><p>后来开通了 <strong>简书</strong>： <a href="https://www.jianshu.com/u/1577b98c62f4" target="_blank" rel="noopener">iOSDevLog</a>，掘金，知乎，微信公众号：iOSDevLog 和 AIDevLog。</p><p><span class="math inline">\(云^{+}\)</span> 社区是转 <strong>简书</strong> 的。</p><p>小武小久记录: <a href="https://1519.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://1519.iosdevlog.com</a> jekyll<br />游戏开发博客：<a href="https://game.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://game.iosdevlog.com</a> hexo+next<br />2019 年博客：<a href="https://2019.iosdevlog.com" target="_blank" rel="noopener" class="uri">https://2019.iosdevlog.com</a> hexo+next<br />2020 年博客：<a href="https://2020.iosdevlog.com" class="uri">https://2020.iosdevlog.com</a> hexo</p><p><img src="https://2020.iosdevlog.com/2020/04/03/infoq/gamedevlog.png" /></p><p>其中简书参加过几个日更的活动，最近也不怎么在上面更新了。</p><p>最近只在 2020 年博客 和 微信公众号：<em>AI开发日志</em> 上更新。</p><p>现在要准备 InfoQ 上的文章，先写着，再去之前的文章里面找点能用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/03/infoq/1.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作" scheme="https://2020.iosdevlog.com/categories/%E5%86%99%E4%BD%9C/"/>
    
    
      <category term="infoq" scheme="https://2020.iosdevlog.com/tags/infoq/"/>
    
      <category term="geek" scheme="https://2020.iosdevlog.com/tags/geek/"/>
    
  </entry>
  
  <entry>
    <title>《程序员的数学基础课》</title>
    <link href="https://2020.iosdevlog.com/2020/04/02/math/"/>
    <id>https://2020.iosdevlog.com/2020/04/02/math/</id>
    <published>2020-04-02T09:19:25.000Z</published>
    <updated>2020-04-03T14:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg" /></p><blockquote><p>数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力</p></blockquote><p>——《程序员的数学基础课》<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>如何学习新技术</p><ol type="1"><li>第一阶段：怎么使用</li><li>第二阶段：如何实现，原理是什么</li><li>第三阶段：为什么这样实现</li></ol><ul><li>明确需求</li><li>用多少学多少</li><li>理解数学的本质</li><li>数学思想与数学逻辑</li></ul><a id="more"></a><h2 id="基础思想">基础思想</h2><h3 id="二进制">二进制</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/1.jpg" /></p><h3 id="余数">余数</h3><p>余数总是在一个固定的范围内。</p><p>同余定理用来 <code>分类/均分</code> 的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/2.jpg" /></p><h3 id="迭代法">迭代法</h3><p>不断地用旧的变量值，递推计算新的变量值。</p><ul><li>求数值的精确或者近似解<ul><li>二分法(Bisection method)</li><li>牛顿迭代法 (Newton’s method)</li></ul></li><li>在一定范围内查找目标值<ul><li>二分查找</li></ul></li><li>机器学习算法中的迭代<ul><li>K- 均值算法(K-means clustering)</li><li>PageRank 的马尔科夫链(Markov chain)</li><li>梯度下降法(Gradient descent)</li></ul></li></ul><p>很多时候机器学习 的过程，就是根据已知的数据和一定的假设，求一个局部最优解</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/3.jpg" /></p><h3 id="数学归纳法">数学归纳法</h3><p>数学归纳法的一般步骤是这样的:</p><ol type="1"><li>证明基本情况(通常是 <span class="math inline">\(n = 1\)</span> 的时候)是否成立;</li><li>假设 <span class="math inline">\(n = k-1\)</span> 成立，再证明 <span class="math inline">\(n=k\)</span> 也是成立的( <span class="math inline">\(k\)</span> 为任意大于 <span class="math inline">\(1\)</span> 的自然数)。</li></ol><p>和使用迭代法的计算相比，数学归纳法 最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正 确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</p><p>递归调用的代码和数学归纳法的逻辑是一致的。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/4.jpg" /></p><h3 id="递归">递归</h3><ol type="1"><li>初始状态，也就是 <span class="math inline">\(n=1\)</span> 的时候，命题是否成立;</li><li>如果 <span class="math inline">\(n=k-1\)</span> 的时候，命题成立。那么只要证明 <span class="math inline">\(n=k\)</span> 的时候，命题也成立。其中 <span class="math inline">\(k\)</span> 为大于 <span class="math inline">\(1\)</span> 的自然数。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/5.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.3.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/6.jpg" /></p><h3 id="排列">排列</h3><p>排列，一般地，从 <span class="math inline">\(n\)</span> 个不同元素中取出 <span class="math inline">\(m（m≤n）\)</span> 个元素，按照一定的顺序排成一列，叫做从 <span class="math inline">\(n\)</span> 个元素中取出 <span class="math inline">\(m\)</span> 个元素的一个排列(permutation)。特别地，当 <span class="math inline">\(m=n\)</span> 时，这个排列被称作全排列(all permutation)。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/7.jpg" /></p><h3 id="组合">组合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/8.jpg" /></p><h3 id="动态规划">动态规划</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/10.jpg" /></p><h3 id="树的深度优先搜索">树的深度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.2.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/11.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/12.jpg" /></p><h3 id="树的广度优先搜索">树的广度优先搜索</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/13.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/14.jpg" /></p><h3 id="从树到图">从树到图</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/15.jpg" /></p><h3 id="时间和空间复杂度">时间和空间复杂度</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/16.jpg" /></p><h2 id="概率统计">概率统计</h2><h3 id="概率和统计">概率和统计</h3><p>概率(Probability)</p><ul><li>随机变量(Random Variable)：事件所有可能出现的状态</li><li>概率分布 (Probability Distribution)：每个状态出现的可能性<ul><li>离散 型随机变量(Discrete Random Variable)</li><li>连续型随机变量(Continuous Random Variable)</li></ul></li></ul><p>对于离散型随机变量，通过联合概率 <span class="math inline">\(P(x, y)\)</span> 在 <span class="math inline">\(y\)</span> 上求和，就可以得到 <span class="math inline">\(P(x)\)</span>，这个 <span class="math inline">\(P(x)\)</span> 就 是边缘概率(Marginal Probability)</p><p>概率论研究的就是这些概率之间相互转化的关系，比如联合概率、条件概率和边缘概率。</p><ul><li>决策树(Decision Tree)<ul><li>信息熵(Entropy)/ 香农熵(Shannon Entropy)</li><li>信息增益(Information Gain)</li><li>基尼指数(Gini)</li></ul></li></ul><p>概率和统计 <code>互逆</code></p><ul><li>概率论是对数据产生的过程进行建模，然后研究某种模型所产生的数据有什么特性。</li><li>通过已知的数据，来推导产生这些数据的模型是怎样的。</li></ul><h3 id="概率基础">概率基础</h3><p>概率分布描述的其实就是随机变量的概率规律</p><p>参考：看见统计<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p><h3 id="朴素贝叶斯">朴素贝叶斯</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.1.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.3.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.4.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/22.6.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/22.png" /></p><h3 id="文本分类">文本分类</h3><p>文本分类系统的基本框架</p><ol type="1"><li>采集训练样本</li><li>预处理自然语言</li><li>训练模型</li><li>实时分类预测</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/23.png" /></p><p>基于自然语言的预处理</p><ol type="1"><li>分词<ol type="1"><li>基于字符串匹配</li><li>基于统计和机器学习<ol type="1"><li>隐马尔科夫模 型(HMM，Hidden Markov Model)</li><li>条件随机场(CRF，Conditional Random Field)</li></ol></li></ol></li><li>取词干和归一化</li><li>停用词</li><li>同义词和扩展词</li></ol><h3 id="语言模型">语言模型</h3><p>语言模型是什么?</p><ul><li>链式法则</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.2.png" /></p><ul><li>马尔科夫假设</li></ul><p>理解了链式法则，我们再来看看马尔可夫假设。</p><p>这个假设的内容是:</p><p>任何一个词 <span class="math inline">\(w_{i}\)</span> 出现的概率只和它前面的 <span class="math inline">\(1\)</span> 个或若干个词有关。</p><p>基于这个假设，我们可以提出 <code>多元文法 (Ngram)模型</code>。Ngram 中的“N”很重要，它表示任何一个词出现的概率，只和它前 面的 <span class="math inline">\(N-1\)</span> 个词有关。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/24.6.png" /></p><p>语言模型的应用</p><ol type="1"><li>信息检索</li><li>中文分词</li></ol><p>第一，使用联合概率，条件概率和边缘概率的“三角”关系，进行相互推导。链式法则就 是很好的体现。</p><p>第二，使用马尔科夫假设，把受较多随机变量影响的条件概率，简化为受较少随机变量影 响的条件概率，甚至是边缘概率。</p><p>第三，使用贝叶斯定理，通过先验概率推导后验概率。在信息检索中，给定查询的情况下 推导文档的概率，就需要用到这个定理。</p><h3 id="马尔科夫模型">马尔科夫模型</h3><p>假设：每个词出现的概率和 之前的一个或若干个词有关。</p><p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状 态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假 设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是 <code>马尔科夫模型(Markov Model)</code>。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.1.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.4.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.5.jpg" /></p><p>PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.6.png" /></p><p>隐马尔科夫模型</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.7.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.9.jpg" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/25.10.jpg" /></p><h3 id="信息熵">信息熵</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.1.jpg" /></p><ul><li>信息量：信息论中的一个度量<ul><li>信息量应该为正数;</li><li>一个事件的信息量和它发生的概率成反比;</li></ul></li><li>信息熵(Entropy)：集合的 纯净度的一个指标<ol type="1"><li>一个集合里的元素全部是属于同一个分组，这个时候就表示最纯净，我们就说熵为 0;</li><li>如果这个集合里的元素是来自不同的分组，那么熵是大于 0 的值。其具体的计算公式 如下:</li></ol></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.2.png" /></p><p>一个集合中所包含的分组越多、元素在这些分组里分布 得越均匀，熵值也越大。</p><p>而熵值表示了纯净的程度，或者从相反的角度来说，是混乱的程 度。</p><p>信息量期望</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.3.png" /></p><p>对于多个小集合而言，其整体的熵等于各个小集合之熵的加权平均。</p><ul><li>信息增益(Information Gain)：划分后整体熵的下降</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/26.5.png" /></p><h3 id="决策树">决策树</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.1.png" /></p><ol type="1"><li>第一步，根据集合中的样本分类，为每个集合计算信息熵，并通过全部集合的熵之加权平 均，获得整个数据集的熵。注意，一开始集合只有一个，并且包含了所有的样本。</li><li>第二步，根据信息增益，计算每个特征的区分能力。挑选区分能力最强的特征，并对每个 集合进行更细的划分。</li><li>第三步，有了新的划分之后，回到第一步，重复第一步和第二步，直到没有更多的特征， 或者所有的样本都已经被分好类。</li></ol><ul><li>ID3(Iterative Dichotomiser 3，迭代二叉树 3 代)<ul><li>信息增益</li><li>优先考虑具有较多取值的特征</li></ul></li><li>C4.5 算法<ul><li>信息增益率(Information Gain Ratio)</li><li>分裂信息(Split Information)</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.3.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.4.png" /></p><ul><li>CART 算法(Classification and Regression Trees，分类与回归 树)<ul><li>基尼指数(Gini)</li><li>二叉树</li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/27.5.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/27.6.png" /></p><ul><li>优化<ul><li>剪枝<ul><li>预剪枝</li><li>后剪枝</li></ul></li><li>随机森林</li></ul></li></ul><h3 id="熵信息增益和卡方">熵、信息增益和卡方</h3><p>利用卡方检验进行特征选择</p><p>如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。</p><h3 id="归一化和标准化">归一化和标准化</h3><p>为什么需要特征变换?</p><ul><li>线性回归模型：因变量和自变量为线性关系</li><li>非线性回归分析模型：因变量和自变量为非线性关系</li></ul><p>多元线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.1.png" /></p><p>两种常见的特征变换方法</p><ul><li>归一化(Normalization)。</li></ul><p>它其实就是获取原始数据的最大值和最小值，然后把原始值线性变换到 [0,1] 之间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.2.png" /></p><ul><li>标准化</li></ul><p>基于正态分布的 z 分数(z-score)标准化(Standardization)。</p><p>该方法假设数据呈现标准正态分布。</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/29.3.png" /></p><p><span class="math display">\[x^{\prime}=\frac{(x-\mu)}{\sigma}\]</span></p><p>其中 <span class="math inline">\(x\)</span> 为原始值，<span class="math inline">\(\mu\)</span> 为均值，<span class="math inline">\(\sigma\)</span> 为标准差，<span class="math inline">\(x^{\prime}\)</span> 是变换后的值。</p><h3 id="统计意义">统计意义</h3><p>A/B 测试</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/30.png" /></p><p>显著性差异(Significant Difference)</p><ol type="1"><li>第一，两个分布之间的差异。<ul><li>“有显著性差异”</li></ul></li><li>第二，采样引起的差异。<ul><li>“无显著性差异”</li></ul></li></ol><p>“具有显著性差异”，称为“差异具有统计意义”或者“差异具有显著性”</p><p>统计假设检验和显著性检验</p><p>统计假设检验是指事先对随机变量的参数或总体分布做出一个假设，然后利用样本信息来 判断这个假设是否合理。</p><p>在统计学上，我们称这种假设为虚无假设(Null Hypothesis)，也叫原假设或零假设，通常记作 <code>H0</code>。</p><p>而和虚无假设对立的假设，我们称为对立假设(Alternative Hypothesis)，通常记作 <code>H1</code>。也就是说，如果证明虚无假设不成立，那么就可以推出对立假设成立。</p><p>通常我们把概率不超 过 0.05 的事件称为“小概率事件”</p><p>P 值(P-value)</p><p>P 值中的 P 代表 Probability，就是当 H0 假 设为真时，样本出现的概率，或者换句话说，其实就是我们所观测到的样本数据符合原假 设 H0 的可能性有多大。</p><p>方差分析</p><p>方差分析(Analysis of Variance, ANOVA)，也叫 <strong>F检验</strong>。</p><ul><li>随机性：样本是随机采样的;</li><li>独立性：来自不同组的样本是相互独立的;</li><li>正态分布性：组内样本都来自一个正态分布;</li><li>方差齐性：不同组的方差相等或相近。</li></ul><p>自由度(degree of freedom)，英文缩写是 df，它是指采样中能够自由变化的数据个 数。</p><h3 id="拟合">拟合</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/32.png" /></p><ul><li><strong>欠拟合问题</strong> 产生的主要原因 是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大。</li><li><strong>过拟合问题</strong> 产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符 合训练样本，但是无法适应测试样本或者说新的数据。</li></ul><p>交叉验证(Cross Validation)的划分方式来保持训练数 据和测试数据的一致性。</p><h2 id="线性代数">线性代数</h2><h3 id="线性代数-1">线性代数</h3><p>向量和向量空间</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.1.png" /></p><p>向量的每个元素就代表 一维特征，而元素的值代表了相应特征的值，我们称这类向量为 <strong>特征向量(Feature Vector)</strong>。</p><p><strong>矩阵的特征向量(Eigenvector)</strong></p><p>向量的运算</p><ul><li>加法</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.2.png" /><br /><img src="https://2020.iosdevlog.com/2020/04/02/math/33.3.png" /></p><ul><li>乘法(或点乘)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.4.png" /></p><ul><li>距离</li><li>夹角</li></ul><p>矩阵的运算</p><p>矩阵由多个长度相等的向量组成，其中的每列或者每行就是一个向量。</p><p>因此，我们把向量延伸一下就能得到矩阵(Matrix)。</p><p>矩阵乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.5.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.6.png" /></p><p>两个矩阵中对应元素进行相乘，称它为 <strong>元素对应乘积</strong>，或者 <strong>Hadamard 乘积</strong></p><p>转置(Transposition)是指矩阵内的元素行索引和纵索引互换</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.7.png" /></p><p>单位矩阵(Identity Matrix)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.8.png" /></p><p>矩阵逆(Matrix Inversion)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/33.9.png" /></p><h3 id="向量空间模型">向量空间模型</h3><p>向量之间的距离</p><ul><li>曼哈顿距离(Manhattan Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.3.png" /></p><ul><li>欧氏距离(Euclidean Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.4.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.5.png" /></p><ul><li>切比雪夫距离(Chebyshev Distance)</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.6.png" /></p><p>向量的长度</p><ul><li><span class="math inline">\(L_{1}\)</span> 范数 <span class="math inline">\(\|x\|\)</span> ，它是为 <span class="math inline">\(x\)</span> 向量各个元素绝对值之和，对应于向量和原点之间的曼哈顿距离。<br /><span class="math inline">\(L_{2}\)</span> 范数 <span class="math inline">\(\|x\|_2\)</span> ，它是向量 <span class="math inline">\(x\)</span> 各个元素平方和的 <span class="math inline">\(\frac{1}{2}\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的欧氏距离。<br /><span class="math inline">\(L_{p}\)</span> 范数 <span class="math inline">\(\|x\|_p\)</span> ，为向量各个元素绝对值 <span class="math inline">\(p\)</span> 次方和的 <span class="math inline">\(1/p\)</span> 次方，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的闵氏距离。<br /><span class="math inline">\(L_{\infty}\)</span> 范数 <span class="math inline">\(\|x\|_{\infty}\)</span>，为 <span class="math inline">\(x\)</span> 向量各个元素绝对值最大那个元素的绝对值，对应于向量 <span class="math inline">\(x\)</span> 和原点之间的切比雪夫距离。</li></ul><p>所以，在讨论向量的长度时，我们需要弄清楚是 <code>L几范数</code>。</p><p>向量之间的夹角</p><p><span class="math display">\[\operatorname{cosine}(X, Y)=\frac{\sum_{i=1}^{n}\left(x_{i} \times y_{i}\right)}{\sqrt{\sum_{i=1}^{n} x_{i}^{2} \times \sum_{i=1}^{n} y_{i}^{2}}}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.7.png" /></p><p>向量空间模型(Vector Space Model)</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/34.8.png" /></p><h3 id="文本检索">文本检索</h3><p>信息检索就是让计算机根据用户信息需求，从大规模、非结构化的数据中，找 出相关的资料。</p><p>信息检索中的向量空间模型</p><ol type="1"><li>第一步，把文档集合都转换成向量的形式。</li><li>第二步，把用户输入的查询转换成向量的形式，然后把这个查询的向量和所有文档的向 量，进行比对，计算出基于距离或者夹角余弦的相似度。</li><li>第三步，根据查询和每个文档的相似度，找出相似度最高的文档，认为它们是和指定查询 最相关的。</li><li>第四步，评估查询结果的相关性。</li></ol><h3 id="文本聚类">文本聚类</h3><p>聚类算法</p><p>K 均值(K-Means)聚类算法</p><p>尽量最大化总的 群组内相似度，同时尽量最小化群组之间的相似度。</p><ol type="1"><li>从 N 个数据对象中随机选取 k 个对象作为质心，这里每个群组的质心定义是，群组内 所有成员对象的平均值。因为是第一轮，所以第 i 个群组的质心就是第 i 个对象，而且 这时候我们只有这一个组员。</li><li>对剩余的对象，测量它和每个质心的相似度，并把它归到最近的质心所属的群组。这里 我们可以说距离，也可以说相似度，只是两者呈现反比关系。</li><li>重新计算已经得到的各个群组的质心。这里质心的计算是关键，如果使用特征向量来表 示的数据对象，那么最基本的方法是取群组内成员的特征向量，将它们的平均值作为质心的向量表示。</li><li>迭代上面的第 2 步和第 3 步，直至新的质心与原质心相等或相差之值小于指定阈值，算法结束。</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/36.png" /></p><h3 id="矩阵">矩阵</h3><p>PageRank 链接分析算法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.1.png" /></p><p>简化 PageRank 公式</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.2.png" /></p><p>矩阵点乘</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.3.png" /></p><p>拓扑图</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.4.png" /></p><p>原始矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.5.png" /></p><p>归一化</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.6.png" /></p><p>初始值都设为 1</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.7.png" /></p><p>考虑随机跳转</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.8.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/37.9.png" /></p><p>用矩阵实现推荐系统的核心思想</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.1.png" /></p><p>基于用户的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.2.png" /></p><p>基于物品的过滤</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/38.3.png" /></p><h3 id="线性回归">线性回归</h3><p><span class="math display">\[\begin{aligned}&amp;2 x_{1}+x_{2}+x_{3}=0\\&amp;4 x_{1}+2 x_{2}+x_{3}=56\\&amp;2 x_{1}-x_{2}+4 x_{3}=4\end{aligned}\]</span></p><h4 id="高斯消元法">高斯消元法</h4><p>使用矩阵实现高斯消元法</p><p>系数矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.1.png" /></p><p>消元</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.2.png" /></p><p>系数</p><p><span class="math display">\[\begin{array}{l}1 \cdot x_{1}+0 \cdot x_{2}+0 \cdot x_{3}=71 \\0 \cdot x_{1}+1 \cdot x_{2}+0 \cdot x_{3}=-86 \\0 \cdot x_{1}+0 \cdot x_{2}+1 \cdot x_{3}=-56\end{array}\]</span></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.3.png" /></p><p>增广矩阵</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/39.4.png" /></p><p>线性回归</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.1.png" /></p><p>最小二乘法</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/40.2.png" /></p><h3 id="pca主成分分析principal-component-analysis">PCA主成分分析(Principal Component Analysis)</h3><ol type="1"><li><p>标准化样本矩阵中的原始数据;</p></li><li><p>获取标准化数据的协方差矩阵;</p></li><li><p>计算协方差矩阵的特征值和特征向量;</p></li><li><p>依照特征值的大小，挑选主要的特征向量; 5. 生成新的特征。</p></li><li><p>标准化原始数据</p></li></ol><p><span class="math display">\[x^{\prime}=\frac{x-\mu}{\sigma}\]</span></p><ol start="2" type="1"><li>获取协方差矩阵</li></ol><ul><li>协方差(Covariance)：衡量两个变 量的总体误差</li></ul><p><span class="math display">\[\operatorname{cov}(x, y)=\frac{\sum_{k=1}^{m}\left(x_{k}-\bar{x}\right)\left(y_{k}-\bar{y}\right)}{m-1}\]</span></p><ul><li>协方差矩阵</li></ul><p><span class="math display">\[\operatorname{cov}\left(X_{, i}, X_{, j}\right)=\frac{\sum_{k=1}^{m}\left(x_{k, i}-\bar{X}_{, i}\right)\left(x_{k, j}-\bar{X}_{, j}\right)}{m-1}\]</span></p><p><span class="math display">\[C O V=\left[\begin{array}{ccccc}\operatorname{cov}\left(X_{1}, X_{1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{1}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{1}, X_{n}\right) \\\operatorname{cov}\left(X_{2}, X_{1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{2}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{2}, X_{n}\right) \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\\operatorname{cov}\left(X_{n}, X_{1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{2}\right) &amp; \cdots &amp; \operatorname{cov}\left(X_{n}, X_{n-1}\right) &amp; \operatorname{cov}\left(X_{n}, X_{n}\right)\end{array}\right]\]</span></p><ol start="3" type="1"><li>计算协方差矩阵的特征值和特征向量</li></ol><p><span class="math display">\[X v=\lambda v\]</span></p><p>特征 值的推导过程</p><p><span class="math display">\[\begin{aligned}&amp;X v=\lambda v\\&amp;X v-\lambda v=0\\&amp;X v-\lambda I v=0\\&amp;(X-\lambda I) v=0\end{aligned}\]</span></p><p>矩阵的行列式</p><p><span class="math display">\[|(X-\lambda I)|=\left| \left[ \begin{array}{cccccc}x_{1,1}-\lambda &amp; x_{1,2} &amp; x_{1,3} &amp; \cdots &amp; x_{1, n-1} &amp; x_{1, n} \\x_{2,1} &amp; x_{2,2}-\lambda &amp; x_{2,3} &amp; \cdots &amp; x_{2, n-1} &amp; x_{2, n} \\x_{3,1} &amp; x_{3,2} &amp; x_{3,3}-\lambda &amp; \cdots &amp; x_{3, n-1} &amp; x_{3, n} \\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\x_{n-1,1} &amp; x_{n-1,2} &amp; x_{n-1,3} &amp; \cdots &amp; x_{n-1, n-1}-\lambda &amp; x_{n-1, n} \\x_{n, 1} &amp; x_{n, 2} &amp; x_{n, 3} &amp; \cdots &amp; x_{n, n-1} &amp; x_{n, n}-\lambda\end{array}\right] \right| =0\]</span></p><p><span class="math display">\[(\lambda I-X)\left[\begin{array}{l}x_{1} \\x_{2} \\\dots \\x_{n}\end{array}\right]\]</span></p><ol start="4" type="1"><li>挑选主要的特征向量，转换原始数据</li></ol><h3 id="svd-奇异值分解singular-value-decomposition">SVD 奇异值分解(Singular Value Decomposition)</h3><p>方阵的特征分解</p><p><code>方阵(Square Matrix)</code> 是一种特殊的矩阵，它的行数和列数相等。如果一个矩阵的行数和列数 都是 n，那么我们把它称作 n 阶方阵。</p><p>如果一个矩阵和其转置矩阵相乘得到的是单位矩阵，那么它就是一个 <code>酉矩阵(Unitary Matrix)</code>。</p><p><span class="math display">\[X^{\prime} X=I\]</span></p><p>其中 X’表示 X 的转置，I 表示单位矩阵。</p><p>换句话说，矩阵 X 为酉矩阵的充分必要条件是 X 的转 置矩阵和 X 的逆矩阵相等。</p><p><span class="math display">\[X^{\prime}=X^{-1}\]</span></p><p>特征分解(Eigendecomposition)</p><p><span class="math display">\[\begin{aligned}&amp;X V V^{-1}=V \Sigma V^{-1}\\&amp;X I=V \Sigma V^{-1}\\&amp;X=V \Sigma V^{-1}\end{aligned}\]</span></p><p>主要考量因素</p><ol type="1"><li>硬件的性能</li><li>命中率</li><li>更新周期</li></ol><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/46.2.png" /></p><h3 id="搜索引擎">搜索引擎</h3><p>搜索引擎的设计框架</p><ul><li>离线的预处理</li><li>在线的查询</li></ul><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.1.png" /></p><p>倒排索引的设计</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.2.png" /></p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.3.png" /></p><p>向量空间和倒排索引的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/47.4.png" /></p><p>查询分类和搜索引擎的结合</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/48.png" /></p><h3 id="推荐系统">推荐系统</h3><p><img src="https://2020.iosdevlog.com/2020/04/02/math/51.jpg" /></p><h2 id="程序员需要读哪些数学书">程序员需要读哪些数学书？</h2><p>基础思想篇推荐书籍:《离散数学及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_1.jpg" /></p><p>概率统计篇推荐书籍:《概率统计》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_2.png" /></p><p>线性代数篇推荐书籍:《线性代数及其应用》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_3.png" /></p><p>入门、通识类书籍推荐：《程序员的数学》</p><p>《程序员的数学》<br />《程序员的数 学:概率统计》<br />《程序员的数学:线性代数》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_4.png" /></p><p>计算机领域:《数学之美》</p><p><img src="https://2020.iosdevlog.com/2020/04/02/math/book_5.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/235" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/235</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://2020.iosdevlog.com/2020/03/11/seeing-theory/" class="uri">https://2020.iosdevlog.com/2020/03/11/seeing-theory/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/02/math/0.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数学它其实是一种思维模式，考验的是一个 人归纳、总结和抽象的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——《程序员的数学基础课》&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何学习新技术&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;第一阶段：怎么使用&lt;/li&gt;
&lt;li&gt;第二阶段：如何实现，原理是什么&lt;/li&gt;
&lt;li&gt;第三阶段：为什么这样实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;明确需求&lt;/li&gt;
&lt;li&gt;用多少学多少&lt;/li&gt;
&lt;li&gt;理解数学的本质&lt;/li&gt;
&lt;li&gt;数学思想与数学逻辑&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="math" scheme="https://2020.iosdevlog.com/categories/math/"/>
    
    
      <category term="basic" scheme="https://2020.iosdevlog.com/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>理解机器学习的24本书（免费）</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/ml/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/ml/</id>
    <published>2020-04-01T14:53:31.000Z</published>
    <updated>2020-04-01T15:22:09.605Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/ml/1.jpg" /></p><a id="more"></a><blockquote><p><em>我们想要的是一台能从经验中学习的机器</em></p></blockquote><p>——艾伦·图灵</p><p>毫无疑问，机器学习已成为当今最受欢迎的主题之一。根据一项<a href="http://blog.indeed.com/2019/03/14/best-jobs-2019/" target="_blank" rel="noopener">研究</a>，机器学习工程师被评为 2019年 美国最佳工作之一。</p><p>展望这一趋势，我们整理了一些最佳（免费）机器学习书籍的清单，这些书籍将证明对有志于在该领域发展职业的每个人都有帮助。</p><h2 id="islr">1. <a href="http://faculty.marshall.usc.edu/gareth-james/ISL/" target="_blank" rel="noopener">ISLR</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/2.jpg" /></p><p>机器学习理论的最佳入门书。甚至付费书籍也不比它好。很好地介绍了数学知识，并在 <code>R</code> 中有练习材料。</p><h2 id="神经网络与深度学习">2. <strong><a href="http://neuralnetworksanddeeplearning.com/" target="_blank" rel="noopener">神经网络与深度学习</a></strong></h2><p>这本免费的在线书是其中最好的和最快的关于深度学习的介绍。阅读只需几天，即可为您提供有关深度学习的所有基础知识。</p><h2 id="模式识别与机器学习">3. <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">模式识别与机器学习</a></h2><p>它是最著名的理论性机器学习书籍之一，因此无需撰写过多的介绍。</p><h2 id="深度学习花书">4. <strong><a href="https://www.deeplearningbook.org/" target="_blank" rel="noopener">深度学习/花书</a></strong></h2><p>这本书是《深度学习》的圣经，是对深度学习算法和方法的介绍，对初学者和从业者都非常有用。</p><h2 id="了解机器学习从理论到算法">5. <a href="https://www.cse.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf" target="_blank" rel="noopener">了解机器学习：从理论<strong>到算法</strong></a></h2><p>关于机器学习理论的文章确实很棒。</p><h2 id="成功的七个步骤实践中的机器学习">6. <strong><a href="https://daoudclarke.github.io/guide.pdf" target="_blank" rel="noopener">成功的七个步骤：实践中的机器学习</a></strong></h2><p>进入该领域的非技术产品经理和非机器学习软件工程师都不应错过本教程。写得很好（略旧，不涉及深度学习，但可以用于所有实际目的）。</p><h2 id="机器学习规则机器学习工程的最佳实践">7. <strong><a href="http://martin.zinkevich.org/rules_of_ml/rules_of_ml.pdf" target="_blank" rel="noopener">机器学习规则：机器学习工程的最佳实践</a></strong></h2><p>想知道 <code>Google</code> 如何看待其机器学习产品吗？这是一个非常好的机器学习产品管理教程。</p><h2 id="面向工程师的机器学习简介">8. <strong><a href="https://arxiv.org/abs/1709.02840" target="_blank" rel="noopener">面向工程师的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="无需深度学习的机器学习简介">9. <strong><a href="https://docs.google.com/document/d/1Rp6sf129T0j1isIQByyUeby4fwKgwTyiVleNwX7JGmg/edit" target="_blank" rel="noopener">无需深度学习的机器学习简介</a></strong></h2><p>涵盖几乎所有机器学习技术的独白。易于理解数学（对于害怕数学符号表示难以理解的人）。</p><h2 id="机器学习入门笔记">10. <strong><a href="http://lcsl.mit.edu/courses/ml/1718/MLNotes.pdf" target="_blank" rel="noopener">机器学习入门笔记</a></strong></h2><p>面向绝对初学者的机器学习指南。</p><h2 id="机器学习基础">11. <strong><a href="https://cs.nyu.edu/~mohri/mlbook/" target="_blank" rel="noopener">机器学习基础</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/3.jpg" /></p><p>关于机器学习数学概念的详细论述。</p><h2 id="变量和特征选择简介">12. <strong><a href="https://dl.acm.org/doi/10.5555/944919.944968" target="_blank" rel="noopener">变量和特征选择简介</a></strong></h2><p>特征工程和变量选择可能是传统机器学习算法中最重要的人工输入。（在深度学习方法中不那么重要，但是深度学习并不能解决所有问题）。本教程介绍了不同的要素工程方法。</p><h2 id="automl-frank-hutterlars-kotthoffjoaquin-vanschoren">13. <strong><a href="https://www.automl.org/book/" target="_blank" rel="noopener">AutoML– Frank Hutter，Lars Kotthoff，Joaquin Vanschoren</a></strong></h2><p>在完成功能工程后，近来的传统机器学习实际上已经减少到运行 <code>AutoML</code> 模型（h2o，auto sklearn或tpot，这是ParallelDots的最爱）。（实际上，也有几种方法可以进行自动化的非特定于域的自动要素工程）。本书介绍了AutoML中使用的方法。</p><h2 id="用pytorch进行深度学习">14. <strong><a href="https://pytorch.org/deep-learning-with-pytorch" target="_blank" rel="noopener">用Pytorch进行深度学习</a></strong></h2><p>一本免费的书，可帮助您使用 <code>PyTorch</code> 学习深度学习。<code>PyTorch</code> 是ParallelDots 上我们最喜欢的深度学习库，我们建议所有人进行深度学习的应用研究/开发。</p><h2 id="深度学习">15. <strong><a href="http://d2l.ai/" target="_blank" rel="noopener">深度学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/4.png" /></p><p>另一本有关深度学习的详细书，该书使用亚马逊的 <code>MXN​​et</code> 库教授深度学习。</p><h2 id="kerasbook-github-笔记本">16. <strong><a href="https://github.com/fchollet/deep-learning-with-python-notebooks" target="_blank" rel="noopener">Kerasbook Github 笔记本</a></strong></h2><p>Francois Chollet 是 <code>Keras</code> 库的负责人。他撰写的《用Python进行深度学习》一书在Keras教授《深度学习》，获得了很好的评价。这本书 <strong>不是</strong> 免费提供的，但是它的所有代码都可以在 <code>Github</code> 上以笔记本的形式获得（用深度学习示例构成一本书），并且是很好的资源。几年前我在学习 <code>Keras</code> 时就读了它，这是非常好的资源。</p><h2 id="基于模型的机器学习">17. <strong><a href="http://mbmlbook.com/" target="_blank" rel="noopener">基于模型的机器学习</a></strong></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/5.png" /></p><p>贝叶斯机器学习的绝佳资源。使用 <code>Microsoft</code> 的 <code>Infer.Net</code> 库进行教学，因此您可能必须安装 <code>IronPython</code> 才能阅读/实现本书的示例。</p><h2 id="机器学习的贝叶斯模型">18. <strong><a href="http://www.columbia.edu/~jwp2128/Teaching/E6720/BayesianModelsMachineLearning2016.pdf" target="_blank" rel="noopener">机器学习的贝叶斯模型</a></strong></h2><p>另一本书详细介绍了机器学习中的各种贝叶斯方法。</p><h2 id="爱森斯坦自然语言处理笔记">19. <strong><a href="https://github.com/jacobeisenstein/gt-nlp-class/blob/master/notes/eisenstein-nlp-notes.pdf" target="_blank" rel="noopener">爱森斯坦自然语言处理笔记</a></strong></h2><p>自然语言处理是机器学习中最流行的用途。GATech课程中的这些注释很好地概述了如何使用机器学习来解释人类语言。</p><h2 id="强化学习-sutton和barto">20. <strong><a href="http://www.incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">强化学习– Sutton和Barto</a></strong></h2><p>强化学习的圣经。这是进入强化学习领域的任何人都必须阅读的。</p><h2 id="机器学习的高斯过程">21. <a href="http://www.gaussianprocess.org/gpml/" target="_blank" rel="noopener">机器学习的高斯过程</a></h2><p><img src="https://2020.iosdevlog.com/2020/04/01/ml/6.gif" /></p><p>使用贝叶斯优化和高斯过程进行机器学习。借助基于变分推理的库（例如Edward / GpyTorch / BOTorch等），此方法正在卷土重来。</p><h2 id="机器学习访谈机器学习系统设计chip-huyen">22. <strong><a href="https://github.com/chiphuyen/machine-learning-systems-design" target="_blank" rel="noopener">机器学习访谈机器学习系统设计Chip Huyen</a></strong></h2><p>要参加机器学习工作的面试吗？这些问题可能有助于在回答机器学习系统问题时找出策略。</p><h2 id="机器学习的算法方面">23. <strong><a href="https://people.csail.mit.edu/moitra/docs/bookex.pdf" target="_blank" rel="noopener">机器学习的算法方面</a></strong></h2><p>本书涉及机器学习的各个部分，其中涉及计算算法和数值方法，以解决诸如分解模型，字典学习和高斯模型之类的问题。</p><h2 id="机器学习的因果关系">24. <strong><a href="https://arxiv.org/abs/1911.10500" target="_blank" rel="noopener">机器学习的因果关系</a></strong></h2><p>随着因果关系进入数据科学领域，机器学习也摆脱了讨论。尽管没有详细的资料可解决，但是这里是一个简短的教程，试图解释机器学习因果关系的关键概念。</p><p>原文：<a href="https://blog.paralleldots.com/data-science/24-best-and-free-books-to-understand-machine-learning/" target="_blank" rel="noopener">24 Best (and Free) Books To Understand Machine Learning</a></p><p>作者：<a href="https://blog.paralleldots.com/author/reashikaa/" target="_blank" rel="noopener">Reashikaa Verma</a></p><p>时间：2020/03/12</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/ml/1.jpg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ml" scheme="https://2020.iosdevlog.com/tags/ml/"/>
    
      <category term="book" scheme="https://2020.iosdevlog.com/tags/book/"/>
    
      <category term="free" scheme="https://2020.iosdevlog.com/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>《艰难的制造》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/04/01/9787550298637/"/>
    <id>https://2020.iosdevlog.com/2020/04/01/9787550298637/</id>
    <published>2020-04-01T08:28:03.000Z</published>
    <updated>2020-04-01T08:43:01.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg" /></p><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />副标题: 讲述制造业在政策和市场夹缝中的生存故事<br />出版年: 2017-6<br />页数: 672<br />定价: 69.90<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550298637</p><a id="more"></a><h2 id="内容简介">内容简介</h2><p>宁炒一座楼，不办一家厂，开厂为啥干不过炒房，做实业的为啥干不过搞金融的？作为立国之本、创造财富的制造业发生了什么？市场的大手，政策的大手，究竟在其中起到什么样的作用？</p><p>小说以一家中小型机械制造厂切入，以手术解剖的方式娓娓道来秉持实业理想的柳钧和从事金融的好友钱宏明的典型遭遇。无论是山寨模仿、技术剽窃、恶意抢单、黑社会威胁、税务查账、环保穿小鞋还是信用证诈骗、房地产投机、民间高利贷、非法集资，从起步到发展过程中大到政策，小到员工管理的九九八十一难一一为你呈现。</p><p>本书作者阿耐曾为浙江某著名民营制造业高管，几十年经营管理经验，写出来的都是“实打实的真材实料”。自连载以来，引发珠三角、长三角众多制造业老板及金融从业者的广泛共鸣。</p><h2 id="结局对比">结局对比</h2><p>最后一章里面，这一（2008）年，<strong>柳钧</strong> 失去最好的朋友，却还晦气得在年底前出国洽商的时候撞见宿仇 <strong>杨巡</strong>。</p><p><strong>柳钧</strong> 以为 <strong>杨巡</strong> 要逃，杨巡说：</p><blockquote><p>"人在青山在，只要公司不倒，所有债务都只是账面数字，哪家公司不是负债运行的。"</p></blockquote><p><strong>杨巡</strong> 的世界只有利益相关，<strong>柳钧</strong> 和 <strong>宋运辉</strong> 观点：</p><blockquote><p>“创造力无价。”</p></blockquote><blockquote><p>“你该不会还以为我送了宋总和梁姐很多好处？”两人对视，柳钧从杨巡眼里看出一丝恍惚。“或许，你的世界只有利益相关，但我们的世界里有一些傻傻的东西，比如你近来才意识到知识无价，因为这个社会发展到现阶段，人力成本上升趋势已不可逆转，无论国内外的市场竞争都将越来越靠科研技术。只是眼下的大环境并不支持这种脚踏实地的竞争方式，有很多傻傻的人内心很焦虑，很着急，很想尽一己之力稍微改变一下这样的结构问题。我们都在努力，我非常感谢宋总支持我的努力。他是个很有精神感召力的人。</p></blockquote><p>——第106章 2008年新劳动合同法和新政策带来的负担(14) / 最后一章</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/04/01/9787550298637/1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;作者: 阿耐&lt;br /&gt;
出版社: 北京联合出版公司&lt;br /&gt;
副标题: 讲述制造业在政策和市场夹缝中的生存故事&lt;br /&gt;
出版年: 2017-6&lt;br /&gt;
页数: 672&lt;br /&gt;
定价: 69.90&lt;br /&gt;
装帧: 平装&lt;br /&gt;
丛书: 读客·知识小说文库&lt;br /&gt;
ISBN: 9787550298637&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="改革" scheme="https://2020.iosdevlog.com/tags/%E6%94%B9%E9%9D%A9/"/>
    
      <category term="大江大河" scheme="https://2020.iosdevlog.com/tags/%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
  </entry>
  
  <entry>
    <title>《大江东去》读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/03/31/9787550230552/"/>
    <id>https://2020.iosdevlog.com/2020/03/31/9787550230552/</id>
    <published>2020-03-31T05:50:41.000Z</published>
    <updated>2020-04-01T09:14:51.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg" /></p><a id="more"></a><p>作者: 阿耐<br />出版社: 北京联合出版公司<br />出品方: 读客文化<br />副标题: 经典收藏版全三册<br />出版年: 2014-7-15<br />页数: 1992<br />定价: 168.00<br />装帧: 平装<br />丛书: 读客·知识小说文库<br />ISBN: 9787550230552</p><h2 id="内容简介">内容简介</h2><p>《大江东去》是著名财经作家阿耐创作的一部全景表现改革开放30年来中国经济和社会生活变迁历史的长篇小说。</p><p>小说以经济改革为主线，全面、细致、深入地表现了1978年以来中国改革开放30年的伟大历史进程。展现了中国改革开放30年来经济领域的改革、社会生活的变化、政治领域的变革 以及人们精神面貌的变化等方方面面；生动而真实地刻画了活跃在改革开放前沿的代表人物，如国营企业的领导、农民企业家、个体户、政府官员、海归派、知识分子等等。人物典型深刻，故事跌宕磅礴。</p><p>从表现历史的深度和广度上来说，在表现中国改革开放历史进程这一题材里，这部作品具有很重的分量和特殊意义，被誉为“描写改革开放30年的第一小说”，荣获中宣部“五个一工程奖”。</p><h2 id="宋运辉">宋运辉</h2><blockquote><p>出国考察和谈判，出差的地方与美国隔个太平洋。开颜一直担心 去见你（宋运辉）那个女学生（梁思申）。</p></blockquote><blockquote><p>宋运辉厌恶地再看一眼他的内裤，调头离开。从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p><p>从结婚解释到现在，以前他只是觉得程开颜没安全感，他虽然讨厌可还是屡屡解释。可是今天这一幕让他备感侮辱，他出差途中渴望回家的一颗心彻底凉到冰点，他无法原谅。</p></blockquote><p>——第143章 1992年(7)</p><blockquote><p>宋运辉愣愣地看着好友，却道：“冰冻三尺非一日之寒，原来我一直看不起她。”</p><p>宋运辉摇头愤怒地道：“没办法，知道这婚姻是程家设计的，我……你让我傻瓜一直当到底？”</p></blockquote><p>——第144章 1992年(8)</p><blockquote><p>那么用与程开颜婚姻和美来洗刷告发。他若想离婚，那就坐实告发。谁让他确实与梁思申认识呢。程父是料定他与梁思申没关联，又更料定他爱事业胜过一切，推定他肯定会不惜代价坚持项目，才会出此下策。程父大概也很清楚，他若真因此与程开颜重修旧好，以后就没脸再提离婚。宋运辉无法不感叹，姜是老的辣，程父打蛇打七寸，落点一分不差。</p></blockquote><p>——第161章 1992年(25)</p><blockquote><p>这一刻，宋运辉意识到，他再找多少理由，都无法掩盖一条事实，结婚至今，他变心了。他犹豫良久，才勉强挤出一句：“没有。”</p><p>可心中也清楚，他心虚，他无法再为自己找任何理由。</p></blockquote><p>——第170章 1993年(9)</p><h2 id="梁思申">梁思申</h2><blockquote><p>“那是你傻。”外公都不要听梁思申的申诉，“我走遍全世界，哪儿都一样，什么事只要跟钱搭一起，都没个干净的。你们那行当算计的都是大钱，即使规则也是黑的，你还什么讲规则，你是给洗脑了才不觉得黑。你跟我说秃鹫，秃鹫是干什么的？你做秃鹫玩得高兴，你想过被秃鹫吃的人是什么想法？股票又是什么？衍生品又是什么？都是内行人空对空玩外行人的游戏。只有你才以为是数字是科学，笨蛋！难怪你一会儿控诉你爸一会儿又控诉小辉，敢情你学校出来还没长大过啊，会不会太弱智，难道以前是我高看你了？”</p></blockquote><p>——第294章 1998年(3)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/31/9787550230552/1.svg&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书 - 改革 - 大江大河" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6-%E6%94%B9%E9%9D%A9-%E5%A4%A7%E6%B1%9F%E5%A4%A7%E6%B2%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP 路线图</title>
    <link href="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/"/>
    <id>https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/</id>
    <published>2020-03-30T14:28:50.000Z</published>
    <updated>2020-03-30T15:29:06.909Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png" /></p><p>nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。</p><a id="more"></a><ul><li>关键字之间的关系可以用模棱两可的方式解释，因为它们以语义思维导图的格式表示。请只关注方框中的关键字，并将其视为学习的必要部分。</li><li>仅在图像中包含大量关键字和知识的工作就具有挑战性。因此，请注意，此路线图是建议或想法之一。</li><li>您有资格自由使用材料（包括商业目的），但强烈希望提供参考。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></li></ul><h2 id="概率统计">概率统计</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/prob.png" /></p><h2 id="机器学习">机器学习</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/ml.png" /></p><h2 id="文字挖掘">文字挖掘</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/textmining.png" /></p><h2 id="自然语言处理">自然语言处理</h2><p><img src="https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/nlp.png" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/graykode/nlp-roadmap" target="_blank" rel="noopener" class="uri">https://github.com/graykode/nlp-roadmap</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/30/nlp-roadmap/main.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;nlp-roadmap 是对有兴趣学习自然语言处理的学生的 Natural Language Processing ROADMAP（思维导图）和 KEYWORD（关键词）。该路线图涵盖了从基本概率/统计数据到 SOTA NLP 模型的材料。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="nlp" scheme="https://2020.iosdevlog.com/tags/nlp/"/>
    
  </entry>
  
  <entry>
    <title>Docker Cheat Sheet</title>
    <link href="https://2020.iosdevlog.com/2020/03/29/docker/"/>
    <id>https://2020.iosdevlog.com/2020/03/29/docker/</id>
    <published>2020-03-29T14:41:44.000Z</published>
    <updated>2020-03-29T14:49:22.932Z</updated>
    
    <content type="html"><![CDATA[<p>想要一起来完善这份速查表吗？<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 参见<a href="#贡献手册contributing">贡献手册</a>部分吧！</p><blockquote><p>译者注：以下部分链接需科学上网后使用。</p><p>Due to GFW, varies links below could not be accessed in China Mainland.</p></blockquote><h2 id="目录">目录</h2><ul><li><a href="#为何使用-docker">为何使用 Docker</a></li><li><a href="#系统环境">系统环境(Prerequisites)</a></li><li><a href="#安装">安装(Installation)</a></li><li><a href="#容器container">容器(Containers)</a></li><li><a href="#镜像images">镜像(Images)</a></li><li><a href="#网络networks">网络(Networks)</a></li><li><a href="#仓管中心和仓库registry--repository">仓管中心和仓库(Registry &amp; Repository)</a></li><li><a href="#dockerfile">Dockerfile</a></li><li><a href="#层layers">层(Layers)</a></li><li><a href="#链接links">链接(Links)</a></li><li><a href="#卷标volumes">卷标(Volumes)</a></li><li><a href="#暴露端口exposing-ports">暴露端口(Exposing Ports)</a></li><li><a href="#最佳实践">最佳实践(Best Practices)</a></li><li><a href="#安全security">安全(security)</a></li><li><a href="#小贴士">小贴士(Tips)</a></li><li><a href="#贡献手册contributing">贡献手册(Contributing)</a></li></ul><a id="more"></a><h2 id="为何使用-docker">为何使用 Docker</h2><p>「通过 Docker，开发者可以使用任何语言任何工具创建任何应用。“Dockerized” 的应用是完全可移植的，能在任何地方运行 - 不管是同事的 OS X 和 Windows 笔记本，或是在云端运行的 Ubuntu QA 服务，还是在虚拟机运行的 Red Hat 产品数据中心。</p><p>Docker Hub 上有 13000+ 的应用，开发者可以从中选取一个进行快速扩展开发。Docker 跟踪管理变更和依赖关系，让系统管理员能更容易理解开发人员是如何让应用运转起来的。而开发者可以通过 Docker Hub 的共有/私有仓库，构建他们的自动化编译，与其他合作者共享成果。</p><p>Docker 帮助开发者更快地构建和发布高质量的应用。」—— <a href="https://www.docker.com/what-docker/#copy1" target="_blank" rel="noopener">什么是 Docker</a></p><h2 id="系统环境">系统环境</h2><p>我用的是 <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">Oh My Zsh</a> 和 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins#docker" target="_blank" rel="noopener">Docker 插件</a>，它可以自动补全 Docker 命令。你的环境可能有所不同。</p><h3 id="linux">Linux</h3><p>Docker 对于 Linux 内核版本的 <a href="https://docs.docker.com/engine/installation/binaries/#check-kernel-dependencies" target="_blank" rel="noopener">最低要求</a> 为 <code>3.10.x</code>。</p><h3 id="macos">MacOS</h3><p>10.8「Mountain Lion」或更新版本。</p><h3 id="检查版本">检查版本</h3><p>时刻关注你当前正在使用的 Docker 版本是十分重要的，这能够帮助你了解可用的特性。同时，可以让你在查找镜像时选择使用的版本。接下来让我们看看如何操作。</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/version/" target="_blank" rel="noopener"><code>docker version</code></a> 查看你正在运行的 Docker 版本。</li></ul><p>获取 Docker 服务版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version --format &#39;&#123;&#123;.Server.Version&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">1.8.0</span><br></pre></td></tr></table></figure><p>你也可以输出原始的 JSON 数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version --format &#39;&#123;&#123;json .&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#123;&quot;Client&quot;:&#123;&quot;Version&quot;:&quot;1.8.0&quot;,&quot;ApiVersion&quot;:&quot;1.20&quot;,&quot;GitCommit&quot;:&quot;f5bae0a&quot;,&quot;GoVersion&quot;:&quot;go1.4.2&quot;,&quot;Os&quot;:&quot;linux&quot;,&quot;Arch&quot;:&quot;am&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="安装">安装</h2><h3 id="linux-1">Linux</h3><p>Docker 官方提供了快速、易用的安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.docker.com&#x2F; | sh</span><br></pre></td></tr></table></figure><p>如果你不想执行一个不明不白的 Shell 脚本，那么请看 <a href="https://docs.docker.com/engine/installation/linux/" target="_blank" rel="noopener">安装说明</a>，选择你在用的发行版本。</p><p>如果你是一个 Docker 超新手，那么你应当先去看看 <a href="https://docs.docker.com/engine/getstarted/" target="_blank" rel="noopener">系列教程</a>。</p><h3 id="macos-1">macOS</h3><p>下载并安装 <a href="https://www.docker.com/community-edition" target="_blank" rel="noopener">Docker Community Edition</a>。如果你在使用 Homebrew-Cask，只需在命令行输入 <code>brew cask install docker</code> 即可。下载安装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a> 亦可。<a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker For Mac</a> 很赞，但是它的安装过程与 VirtualBox 不太一样。详情请查阅 <a href="https://docs.docker.com/docker-for-mac/docker-toolbox/" target="_blank" rel="noopener">比较</a>。</p><blockquote><p><strong>注意</strong>：Docker Toolbox 已经过时。你应当使用 Docker Community Edition，详见 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a></p></blockquote><p>安装好 Docker Community Edition 后，点击 Launchpad 内的 Docker 图标。接着即可启动容器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>好了，现在你有了一个运行中的 Docker 容器了。</p><h2 id="容器container">容器(Container)</h2><p><a href="http://etherealmind.com/basics-docker-containers-hypervisors-coreos/" target="_blank" rel="noopener">关于 Docker 进程隔离的基础</a>。容器 (Container) 之于虚拟机 (Virtual Machine) 就好比线程之于进程。或者你可以把他们想成是「吃了类固醇的 chroots」。</p><h3 id="生命周期">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/create" target="_blank" rel="noopener"><code>docker create</code></a> 创建容器但不启动它。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rename/" target="_blank" rel="noopener"><code>docker rename</code></a> 用于重命名容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/run" target="_blank" rel="noopener"><code>docker run</code></a> 一键创建并同时启动该容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rm" target="_blank" rel="noopener"><code>docker rm</code></a> 删除容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/update/" target="_blank" rel="noopener"><code>docker update</code></a> 调整容器的资源限制。</li></ul><p>通常情况下，不使用任何命令行选项启动一个容器，该容器将会立即启动并停止。若需保持其运行，你可以使用 <code>docker run -td container_id</code> 命令。选项 <code>-t</code> 表示分配一个 pseudo-TTY 会话，<code>-d</code> 表示自动将容器与终端分离（也就是说在后台运行容器，并输出容器 ID）。</p><p>如果你需要一个临时容器，可使用 <code>docker run --rm</code> 会在容器停止之后删除它。</p><p>如果你需要映射宿主机 (host) 的目录到 Docker 容器内，可使用 <code>docker run -v $HOSTDIR:$DOCKERDIR</code>。详见 <a href="#卷标volumes">卷标(Volumes)</a> 一节。</p><p>如果你想同时删除与容器相关联的卷标，那么在删除容器的时候必须包含 <code>-v</code> 选项，像这样 <code>docker rm -v</code>。</p><p>从 Docker 1.10 起，其内置一套各容器独立的 <a href="https://docs.docker.com/engine/admin/logging/overview/" target="_blank" rel="noopener">日志引擎</a>，每个容器可以独立使用。你可以使用 <code>docker run --log-driver=syslog</code> 来自定义日志引擎（例如以上的 <code>syslog</code>）。</p><h3 id="启动和停止">启动和停止</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/start" target="_blank" rel="noopener"><code>docker start</code></a> 启动已存在的容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/stop" target="_blank" rel="noopener"><code>docker stop</code></a> 停止运行中的容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/restart" target="_blank" rel="noopener"><code>docker restart</code></a> 重启容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/pause/" target="_blank" rel="noopener"><code>docker pause</code></a> 暂停运行中的容器，将其「冻结」在当前状态。</li><li><a href="https://docs.docker.com/engine/reference/commandline/unpause/" target="_blank" rel="noopener"><code>docker unpause</code></a> 结束容器暂停状态。</li><li><a href="https://docs.docker.com/engine/reference/commandline/wait" target="_blank" rel="noopener"><code>docker wait</code></a> 阻塞地等待某个运行中的容器直到停止。</li><li><a href="https://docs.docker.com/engine/reference/commandline/kill" target="_blank" rel="noopener"><code>docker kill</code></a> 向运行中的容器发送 SIGKILL 指令。</li><li><a href="https://docs.docker.com/engine/reference/commandline/attach" target="_blank" rel="noopener"><code>docker attach</code></a> 连接到运行中的容器。</li></ul><p>如果你想将容器的端口 (ports) 暴露至宿主机，请见 <a href="#暴露端口exposing-ports">暴露端口</a> 一节。</p><p>关于 Docker 实例崩溃后的重启策略，详见 <a href="http://container42.com/2014/09/30/docker-restart-policies/" target="_blank" rel="noopener">本文</a>。</p><h4 id="cpu-限制">CPU 限制</h4><p>你可以限制 CPU 资源占用，无论是指定百分比，或是特定核心数。</p><p>例如，你可以设置 <a href="https://docs.docker.com/engine/reference/run/#/cpu-share-constraint" target="_blank" rel="noopener"><code>cpu-shares</code></a>。该配置看起来有点奇怪 -- 1024 表示 100% CPU，因此如果你希望容器使用所有 CPU 内核的 50%，应将其设置为 512：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --c 512 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure><p>更多信息请参阅 <a href="https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu" target="_blank" rel="noopener" class="uri">https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/#_cpu</a>。</p><p>通过 <a href="https://docs.docker.com/engine/reference/run/#/cpuset-constraint" target="_blank" rel="noopener"><code>cpuset-cpus</code></a> 可使用特定 CPU 内核。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --cpuset-cpus&#x3D;0,4,6 agileek&#x2F;cpuset-test</span><br></pre></td></tr></table></figure><p>请参阅 <a href="https://agileek.github.io/docker/2014/08/06/docker-cpuset/" target="_blank" rel="noopener" class="uri">https://agileek.github.io/docker/2014/08/06/docker-cpuset/</a> 获取更多细节以及一些不错的视频。</p><p>注意，Docker 在容器内仍然能够 <strong>看到</strong> 全部 CPU -- 它仅仅是不使用全部而已。请参阅 <a href="https://github.com/docker/docker/issues/20770" target="_blank" rel="noopener" class="uri">https://github.com/docker/docker/issues/20770</a> 获取更多细节。</p><h4 id="内存限制">内存限制</h4><p>同样，亦可给 Docker 设置 <a href="https://docs.docker.com/engine/reference/run/#/user-memory-constraints" target="_blank" rel="noopener">内存限制</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -m 300M ubuntu:14.04 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h4 id="能力capabilities">能力(Capabilities)</h4><p>Linux 的 Capability 可以通过使用 <code>cap-add</code> 和 <code>cap-drop</code> 设置。请参阅 <a href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener" class="uri">https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities</a> 获取更多细节。这有助于提高安全性。</p><p>如需要挂载基于 FUSE 的文件系统，你需要结合 <code>--cap-add</code> 和 <code>--device</code> 使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it --cap-add SYS_ADMIN --device &#x2F;dev&#x2F;fuse sshfs</span><br></pre></td></tr></table></figure><p>授予对某个设备的访问权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --device&#x3D;&#x2F;dev&#x2F;ttyUSB0 debian bash</span><br></pre></td></tr></table></figure><p>授予对所有设备的访问权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged -v &#x2F;dev&#x2F;bus&#x2F;usb:&#x2F;dev&#x2F;bus&#x2F;usb debian bash</span><br></pre></td></tr></table></figure><p>有关容器特权的更多信息请参阅 <a href="https://docs.docker.com/engine/reference/run/#/runtime-privilege-and-linux-capabilities" target="_blank" rel="noopener">本文</a>。</p><h3 id="信息">信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/ps" target="_blank" rel="noopener"><code>docker ps</code></a> 查看运行中的所有容器。</li><li><a href="https://docs.docker.com/engine/reference/commandline/logs" target="_blank" rel="noopener"><code>docker logs</code></a> 从容器中读取日志。（你也可以使用自定义日志驱动，不过在 1.10 中，它只支持 <code>json-file</code> 和 <code>journald</code>）。</li><li><a href="https://docs.docker.com/engine/reference/commandline/inspect" target="_blank" rel="noopener"><code>docker inspect</code></a> 查看某个容器的所有信息（包括 IP 地址）。</li><li><a href="https://docs.docker.com/engine/reference/commandline/events" target="_blank" rel="noopener"><code>docker events</code></a> 从容器中获取事件 (events)。</li><li><a href="https://docs.docker.com/engine/reference/commandline/port" target="_blank" rel="noopener"><code>docker port</code></a> 查看容器的公开端口。</li><li><a href="https://docs.docker.com/engine/reference/commandline/top" target="_blank" rel="noopener"><code>docker top</code></a> 查看容器中活动进程。</li><li><a href="https://docs.docker.com/engine/reference/commandline/stats" target="_blank" rel="noopener"><code>docker stats</code></a> 查看容器的资源使用量统计信息。</li><li><a href="https://docs.docker.com/engine/reference/commandline/diff" target="_blank" rel="noopener"><code>docker diff</code></a> 查看容器文件系统中存在改动的文件。</li></ul><p><code>docker ps -a</code> 将显示所有容器，包括运行中和已停止的。</p><p><code>docker stats --all</code> 同样将显示所有容器，默认仅显示运行中的容器。</p><h3 id="导入-导出">导入 / 导出</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/cp" target="_blank" rel="noopener"><code>docker cp</code></a> 在容器和本地文件系统之间复制文件或目录。</li><li><a href="https://docs.docker.com/engine/reference/commandline/export" target="_blank" rel="noopener"><code>docker export</code></a> 将容器的文件系统打包为归档文件流 (tarball archive stream) 并输出至标准输出 (STDOUT)。</li></ul><h3 id="执行命令">执行命令</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/exec" target="_blank" rel="noopener"><code>docker exec</code></a> 在容器内执行命令。</li></ul><p>例如，进入正在运行的 <code>foo</code> 容器，并连接 (attach) 到一个新的 Shell 进程：<code>docker exec -it foo /bin/bash</code>。</p><h2 id="镜像images">镜像(Images)</h2><p>镜像是 <a href="https://docs.docker.com/engine/understanding-docker/#how-does-a-docker-image-work" target="_blank" rel="noopener">Docker 容器的模板</a>。</p><h3 id="生命周期-1">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/images" target="_blank" rel="noopener"><code>docker images</code></a> 查看所有镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/import" target="_blank" rel="noopener"><code>docker import</code></a> 从归档文件创建镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/build" target="_blank" rel="noopener"><code>docker build</code></a> 从 Dockerfile 创建镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/commit" target="_blank" rel="noopener"><code>docker commit</code></a> 为容器创建镜像，如果容器正在运行则会临时暂停。</li><li><a href="https://docs.docker.com/engine/reference/commandline/rmi" target="_blank" rel="noopener"><code>docker rmi</code></a> 删除镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/load" target="_blank" rel="noopener"><code>docker load</code></a> 从标准输入 (STDIN) 加载归档包 (tar archive) 作为镜像，包括镜像本身和标签 (tags, 0.7 起)。</li><li><a href="https://docs.docker.com/engine/reference/commandline/save" target="_blank" rel="noopener"><code>docker save</code></a> 将镜像打包为归档包，并输出至标准输出 (STDOUT)，包括所有的父层、标签和版本 (parent layers, tags, versions, 0.7 起)。</li></ul><h3 id="其它信息">其它信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/history" target="_blank" rel="noopener"><code>docker history</code></a> 查看镜像的历史记录。</li><li><a href="https://docs.docker.com/engine/reference/commandline/tag" target="_blank" rel="noopener"><code>docker tag</code></a> 给镜像打标签命名（本地或者仓库均可）。</li></ul><h3 id="清理">清理</h3><p>虽然你可以用 <code>docker rmi</code> 命令来删除指定的镜像，不过有个名为 <a href="https://github.com/spotify/docker-gc" target="_blank" rel="noopener">docker-gc</a> 的工具，它可以以一种安全的方式，清理掉那些不再被任何容器使用的镜像。Docker 1.13 起，使用 <code>docker image prune</code> 亦可删除未使用的镜像。参见 <a href="#清理">清理</a>。</p><h3 id="加载-保存镜像">加载 / 保存镜像</h3><p>从文件中加载镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; my_image.tar.gz</span><br></pre></td></tr></table></figure></p><p>保存既有镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save my_image:my_tag | gzip &gt; my_image.tar.gz</span><br></pre></td></tr></table></figure></p><h3 id="导入-导出容器">导入 / 导出容器</h3><p>从文件中导入容器镜像：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_container.tar.gz | docker import - my_image:my_tag</span><br></pre></td></tr></table></figure></p><p>导出既有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export my_container | gzip &gt; my_container.tar.gz</span><br></pre></td></tr></table></figure></p><h3 id="加载已保存的镜像-与-导入已导出为镜像的容器-的不同">加载已保存的镜像 与 导入已导出为镜像的容器 的不同</h3><p>通过 <code>load</code> 命令来加载镜像，会创建一个新的镜像，并继承原镜像的所有历史。<br />通过 <code>import</code> 将容器作为镜像导入，也会创建一个新的镜像，但并不包含原镜像的历史，因此会比使用 <code>load</code> 方式生成的镜像更小。</p><h2 id="网络networks">网络(Networks)</h2><p>Docker 具备 <a href="https://docs.docker.com/engine/userguide/networking/" target="_blank" rel="noopener">网络</a> 功能。我并不是很了解它，所以这是一个扩展本文的好地方。文档 <a href="https://docs.docker.com/engine/userguide/networking/work-with-networks/" target="_blank" rel="noopener">使用网络</a> 指出，这是一种无需暴露端口即可实现 Docker 容器间通信的好方法。</p><h3 id="生命周期-2">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank" rel="noopener"><code>docker network create</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_rm/" target="_blank" rel="noopener"><code>docker network rm</code></a></li></ul><h3 id="其它信息-1">其它信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_ls/" target="_blank" rel="noopener"><code>docker network ls</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/" target="_blank" rel="noopener"><code>docker network inspect</code></a></li></ul><h3 id="建立连接">建立连接</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/network_connect/" target="_blank" rel="noopener"><code>docker network connect</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/" target="_blank" rel="noopener"><code>docker network disconnect</code></a></li></ul><p>你可以 <a href="https://blog.jessfraz.com/post/ips-for-all-the-things/" target="_blank" rel="noopener">为容器指定 IP 地址</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 使用你自己的子网和网关创建一个桥接网络</span><br><span class="line">docker network create --subnet 203.0.113.0&#x2F;24 --gateway 203.0.113.254 iptastic</span><br><span class="line"></span><br><span class="line"># 基于以上创建的网络，运行一个 Nginx 容器并指定 IP</span><br><span class="line">$ docker run --rm -it --net iptastic --ip 203.0.113.2 nginx</span><br><span class="line"></span><br><span class="line"># 在其他地方使用 CURL 访问这个 IP（假设该 IP 为公网）</span><br><span class="line">$ curl 203.0.113.2</span><br></pre></td></tr></table></figure><h2 id="仓管中心和仓库registry-repository">仓管中心和仓库(Registry &amp; Repository)</h2><p>仓库 (repository) 是 <em>被托管(hosted)</em> 的已命名镜像 (tagged images) 的集合，这组镜像用于构建容器文件系统。</p><p>仓管中心 (registry) 则是 <em>托管服务(host)</em> -- 用于存储仓库并提供 HTTP API，以便 <a href="https://docs.docker.com/engine/tutorials/dockerrepos/" target="_blank" rel="noopener">管理仓库的上传和下载</a>。</p><p>Docker 官方托管着自己的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">仓管中心</a>，包含着数量众多的仓库。不过话虽如此，这个仓管中心 <a href="https://titanous.com/posts/docker-insecurity" target="_blank" rel="noopener">并没有很好地验证镜像</a>，所以如果你担心安全问题的话，请尽量避免使用它。</p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/login" target="_blank" rel="noopener"><code>docker login</code></a> 登入仓管中心。</li><li><a href="https://docs.docker.com/engine/reference/commandline/logout" target="_blank" rel="noopener"><code>docker logout</code></a> 登出仓管中心。</li><li><a href="https://docs.docker.com/engine/reference/commandline/search" target="_blank" rel="noopener"><code>docker search</code></a> 从仓管中心检索镜像。</li><li><a href="https://docs.docker.com/engine/reference/commandline/pull" target="_blank" rel="noopener"><code>docker pull</code></a> 从仓管中心拉取镜像到本地。</li><li><a href="https://docs.docker.com/engine/reference/commandline/push" target="_blank" rel="noopener"><code>docker push</code></a> 从本地推送镜像到仓管中心。</li></ul><h3 id="本地仓管中心">本地仓管中心</h3><p>你可以使用 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener">docker distribution</a> 项目搭建本地的仓管中心，详情参阅 <a href="https://github.com/docker/docker.github.io/blob/master/registry/deploying.md" target="_blank" rel="noopener">本地发布 (local deploy)</a> 的介绍。</p><p>科学上网后，也可以看看 <a href="https://groups.google.com/a/dockerproject.org/forum/#!forum/distribution" target="_blank" rel="noopener">Google+ Group</a>。</p><h2 id="dockerfile">Dockerfile</h2><p>当你执行 <code>docker build</code> 时，Docker 将会根据 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">配置文件</a> 启动 Docker 容器。远优于使用 <code>docker commit</code>。</p><p>以下是一些编写 Dockerfile 的常用编辑器，并链接到适配的语法高亮模块︰</p><ul><li>如果你在使用 <a href="http://jedit.org" target="_blank" rel="noopener">jEdit</a>，你可以使用我开发的 Dockerfile <a href="https://github.com/wsargent/jedit-docker-mode" target="_blank" rel="noopener">语法高亮模块</a>。</li><li><a href="https://packagecontrol.io/packages/Dockerfile%20Syntax%20Highlighting" target="_blank" rel="noopener">Sublime Text 2</a></li><li><a href="https://atom.io/packages/language-docker" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/ekalinin/Dockerfile.vim" target="_blank" rel="noopener">Vim</a></li><li><a href="https://github.com/spotify/dockerfile-mode" target="_blank" rel="noopener">Emacs</a></li><li><a href="https://github.com/docker/docker/tree/master/contrib/syntax/textmate" target="_blank" rel="noopener">TextMate</a></li><li>更多信息请参阅 <a href="https://domeide.github.io/" target="_blank" rel="noopener">Docker 遇上 IDE</a></li></ul><h3 id="指令">指令</h3><ul><li><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="noopener">.dockerignore</a></li><li><a href="https://docs.docker.com/engine/reference/builder/#from" target="_blank" rel="noopener">FROM</a> 为其他指令设置基础镜像 (Base Image)。</li><li><a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated" target="_blank" rel="noopener">MAINTAINER (deprecated - use LABEL instead)</a> 为生成的镜像设置作者字段。</li><li><a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank" rel="noopener">RUN</a> 在当前镜像的基础上生成一个新层并执行命令。</li><li><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">CMD</a> 设置容器默认执行命令。</li><li><a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank" rel="noopener">EXPOSE</a> 告知 Docker 容器在运行时所要监听的网络端口。注意：并没有实际上将端口设置为可访问。</li><li><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">ENV</a> 设置环境变量。</li><li><a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener">ADD</a> 将文件、目录或远程文件复制到容器中。缓存无效。请尽量用 <code>COPY</code> 代替 <code>ADD</code>。</li><li><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener">COPY</a> 将文件或文件夹复制到容器中。注意：将使用 ROOT 用户复制文件，故无论 USER / WORKDIR 指令如何配置，你都需要手动修改其所有者（<code>chown</code>），<code>ADD</code> 也是一样。</li><li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">ENTRYPOINT</a> 将容器设为可执行的。</li><li><a href="https://docs.docker.com/engine/reference/builder/#volume" target="_blank" rel="noopener">VOLUME</a> 在容器内部创建挂载点 (mount point) 指向外部挂载的卷标或其他容器。</li><li><a href="https://docs.docker.com/engine/reference/builder/#user" target="_blank" rel="noopener">USER</a> 设置随后执行 RUN / CMD / ENTRYPOINT 命令的用户名。</li><li><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="noopener">WORKDIR</a> 设置工作目录 (working directory)。</li><li><a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARG</a> 定义编译时 (build-time) 变量。</li><li><a href="https://docs.docker.com/engine/reference/builder/#onbuild" target="_blank" rel="noopener">ONBUILD</a> 添加触发指令，当该镜像被作为其他镜像的基础镜像时该指令会被触发。</li><li><a href="https://docs.docker.com/engine/reference/builder/#stopsignal" target="_blank" rel="noopener">STOPSIGNAL</a> 设置停止容器时，向容器内发送的系统调用信号 (system call signal)。</li><li><a href="https://docs.docker.com/config/labels-custom-metadata/" target="_blank" rel="noopener">LABEL</a> 将键值对元数据 (key/value metadata) 应用到镜像、容器或是守护进程。</li></ul><h3 id="教程">教程</h3><ul><li><a href="http://flux7.com/blogs/docker/docker-tutorial-series-part-3-automation-is-the-word-using-dockerfile/" target="_blank" rel="noopener">Flux7's Dockerfile Tutorial</a></li></ul><h3 id="例子">例子</h3><ul><li><a href="https://docs.docker.com/engine/reference/builder/#dockerfile-examples" target="_blank" rel="noopener">Examples</a></li><li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">Best practices for writing Dockerfiles</a></li><li><a href="http://crosbymichael.com/" target="_blank" rel="noopener">Michael Crosby</a> 还有更多的 <a href="http://crosbymichael.com/dockerfile-best-practices.html" target="_blank" rel="noopener">Dockerfiles best practices</a> / <a href="http://crosbymichael.com/dockerfile-best-practices-take-2.html" target="_blank" rel="noopener">take 2</a></li><li><a href="http://jonathan.bergknoff.com/journal/building-good-docker-images" target="_blank" rel="noopener">Building Good Docker Images</a> / <a href="http://jonathan.bergknoff.com/journal/building-better-docker-images" target="_blank" rel="noopener">Building Better Docker Images</a></li><li><a href="https://speakerdeck.com/garethr/managing-container-configuration-with-metadata" target="_blank" rel="noopener">Managing Container Configuration with Metadata</a></li></ul><h2 id="层layers">层(Layers)</h2><p>Docker 的版本化文件系统是基于层的。就像 <a href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/" target="_blank" rel="noopener">Git 的提交或文件变更系统</a> 一样。</p><h2 id="链接links">链接(Links)</h2><p>链接 (links) <a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank" rel="noopener">通过 TCP/IP 端口</a> 实现 Docker 容器之间的通讯。<a href="https://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/" target="_blank" rel="noopener">Atlassian</a> 展示了可用的例子。你还可以 <a href="https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/#/updating-the-etchosts-file" target="_blank" rel="noopener">通过主机名 (hostname) 链接</a>。</p><p>在某种意义上来说，该特性已经被 <a href="https://docs.docker.com/network/" target="_blank" rel="noopener">自定义网络</a> 所替代。</p><p>注意: 如果你希望容器之间<strong>只</strong>通过链接进行通讯，在启动 Docker 守护进程时，请使用 <code>-icc=false</code> 来禁用内部进程通讯。</p><p>假设你有一个名为 CONTAINER 的容器（通过 <code>docker run --name CONTAINER</code> 指定）并且在 Dockerfile 中，暴露了一个端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 1337</span><br></pre></td></tr></table></figure><p>然后，我们创建另外一个名为 LINKED 的容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --link CONTAINER:ALIAS --name LINKED user&#x2F;wordpress</span><br></pre></td></tr></table></figure><p>然后 CONTAINER 暴露的端口和别名将会以如下的环境变量出现在 LINKED 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ALIAS_PORT_1337_TCP_PORT</span><br><span class="line">$ALIAS_PORT_1337_TCP_ADDR</span><br></pre></td></tr></table></figure><p>那么你便可以通过这种方式来连接它了。</p><p>使用 <code>docker rm --link</code> 即可删除链接。</p><p>通常，Docker 容器（亦可理解为「服务」）之间的链接，是「服务发现」的一个子集。如果你打算在生产中大规模使用 Docker，这将是一个很大的问题。请参阅<a href="https://www.digitalocean.com/community/tutorials/the-docker-ecosystem-service-discovery-and-distributed-configuration-stores" target="_blank" rel="noopener">The Docker Ecosystem: Service Discovery and Distributed Configuration Stores</a> 获取更多信息。</p><h2 id="卷标volumes">卷标(Volumes)</h2><p>Docker 的卷标 (volumes) 是 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/" target="_blank" rel="noopener">独立的文件系统</a>。它们并非必须连接到特定的容器上。</p><h3 id="生命周期-3">生命周期</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank" rel="noopener"><code>docker volume create</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/" target="_blank" rel="noopener"><code>docker volume rm</code></a></li></ul><h3 id="信息-1">信息</h3><ul><li><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/" target="_blank" rel="noopener"><code>docker volume ls</code></a></li><li><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" target="_blank" rel="noopener"><code>docker volume inspect</code></a></li></ul><p>卷标在不能使用链接（只有 TCP/IP）的情况下非常有用。例如，如果你有两个 Docker 实例需要通讯并在文件系统上留下记录。</p><p>你可以一次性将其挂载到多个 docker 容器上，通过 <code>docker run --volumes-from</code>。</p><p>因为卷标是独立的文件系统，它们通常被用于存储各容器之间的瞬时状态。也就是说，你可以配置一个无状态临时容器，关掉之后，当你有第二个这种临时容器实例的时候，你可以从上一次保存的状态继续执行。</p><p>查看 <a href="http://crosbymichael.com/advanced-docker-volumes.html" target="_blank" rel="noopener">卷标进阶</a> 来获取更多细节。<a href="http://container42.com/2014/11/03/docker-indepth-volumes/" target="_blank" rel="noopener">Container42</a> 非常有用。</p><p>你可以 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume" target="_blank" rel="noopener">将宿主 MacOS 的文件夹映射为 Docker 卷标</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v &#x2F;Users&#x2F;wsargent&#x2F;myapp&#x2F;src:&#x2F;src</span><br></pre></td></tr></table></figure><p>你也可以用远程 NFS 卷标，如果你觉得你 <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#/mount-a-shared-storage-volume-as-a-data-volume" target="_blank" rel="noopener">有足够勇气</a>。</p><p>还可以考虑运行一个纯数据容器，像 <a href="http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/" target="_blank" rel="noopener">这里</a> 所说的那样，提供可移植数据。</p><p>记得，<a href="#将文件挂载为卷标">文件也可以被挂载为卷标</a>。</p><h2 id="暴露端口exposing-ports">暴露端口(Exposing ports)</h2><p>通过宿主容器暴露输入端口相当 <a href="https://docs.docker.com/engine/reference/run/#expose-incoming-ports" target="_blank" rel="noopener">繁琐但有效的</a>。</p><p>例如使用 <code>-p</code> 将容器端口映射到宿主端口上（只使用本地主机 (localhost) 接口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 127.0.0.1:$HOSTPORT:$CONTAINERPORT --name CONTAINER -t someimage</span><br></pre></td></tr></table></figure><p>你可以使用 <a href="https://docs.docker.com/engine/reference/builder/#expose" target="_blank" rel="noopener">EXPOSE</a> 告知 Docker，该容器在运行时监听指定的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;CONTAINERPORT&gt;</span><br></pre></td></tr></table></figure><p>但是注意 EXPOSE 并不会直接暴露端口，你需要用参数 <code>-p</code> 。比如说你要在 localhost 上暴露容器的端口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A DOCKER -p tcp --dport &lt;LOCALHOSTPORT&gt; -j DNAT --to-destination &lt;CONTAINERIP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>如果你是在 Virtualbox 中运行 Docker，那么你需要配置端口转发 (forward the port)。使用 <a href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html" target="_blank" rel="noopener">forwarded_port</a> 在 Vagrantfile 上配置暴露的端口范围，这样你就可以动态地映射了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  (49000..49900).each do |port|</span><br><span class="line">    config.vm.network :forwarded_port, :host &#x3D;&gt; port, :guest &#x3D;&gt; port</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>如果你忘记了将什么端口映射到宿主机上的话，可使用 <code>docker port</code> 查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port CONTAINER $CONTAINERPORT</span><br></pre></td></tr></table></figure><h2 id="最佳实践">最佳实践</h2><p>这里有一些最佳实践，以及争论焦点：</p><ul><li><a href="http://gregoryszorc.com/blog/2014/10/16/the-rabbit-hole-of-using-docker-in-automated-tests/" target="_blank" rel="noopener">The Rabbit Hole of Using Docker in Automated Tests</a></li><li><a href="https://twitter.com/bridgetkromhout" target="_blank" rel="noopener">Bridget Kromhout</a> has a useful blog post on <a href="http://sysadvent.blogspot.co.uk/2014/12/day-1-docker-in-production-reality-not.html" target="_blank" rel="noopener">running Docker in production</a> at Dramafever.<br /></li><li>There's also a best practices <a href="http://developers.lyst.com/devops/2014/12/08/docker/" target="_blank" rel="noopener">blog post</a> from Lyst.</li><li><a href="https://engineering.salesforceiq.com/2013/11/05/a-docker-dev-environment-in-24-hours-part-2-of-2.html" target="_blank" rel="noopener">A Docker Dev Environment in 24 Hours!</a></li><li><a href="https://tersesystems.com/2013/11/20/building-a-development-environment-with-docker/" target="_blank" rel="noopener">Building a Development Environment With Docker</a></li><li><a href="https://samsaffron.com/archive/2013/11/07/discourse-in-a-docker-container" target="_blank" rel="noopener">Discourse in a Docker Container</a></li></ul><h2 id="安全security">安全(Security)</h2><p>这节准备讨论一些关于 Docker 安全性的问题。Docker 官方文档 <a href="https://docs.docker.com/articles/security/" target="_blank" rel="noopener">安全</a> 页面讲述了更多细节。</p><p>首先第一件事：Docker 是有 root 权限的。如果你在 <code>docker</code> 组，那么你就有 <a href="https://web.archive.org/web/20161226211755/http://reventlov.com/advisories/using-the-docker-command-to-root-the-host" target="_blank" rel="noopener">root 权限</a>。如果你将 Docker 的 Unix Socket 暴露给容器，意味着你赋予了容器 <a href="https://www.lvh.io/posts/dont-expose-the-docker-socket-not-even-to-a-container/" target="_blank" rel="noopener">宿主机 root 权限</a>。</p><p>Docker 不应当作为唯一的防御措施。你应当使其更加安全可靠。</p><p>为了更好地理解容器暴露了什么，可参阅由 <a href="https://twitter.com/dyn___" target="_blank" rel="noopener">Aaron Grattafiori</a> 编写的 <a href="https://www.nccgroup.trust/globalassets/our-research/us/whitepapers/2016/april/ncc_group_understanding_hardening_linux_containers-1-1.pdf" target="_blank" rel="noopener">Understanding and Hardening Linux Containers</a>。这是一个完整全面且包含大量链接和脚注的容器问题指南，介绍了许多有用的内容。即使你已经加固过容器，以下的安全提示依然十分有帮助，但并不能代替理解的过程。</p><h3 id="安全提示">安全提示</h3><p>为了最大的安全性，你应当考虑在虚拟机上运行 Docker。这是直接从 Docker 安全团队拿来的资料 -- <a href="http://www.slideshare.net/jpetazzo/linux-containers-lxc-docker-and-security" target="_blank" rel="noopener">slides</a> / <a href="http://www.projectatomic.io/blog/2014/08/is-it-safe-a-look-at-docker-and-security-from-linuxcon/" target="_blank" rel="noopener">notes</a>。之后，可使用 AppArmor、seccomp、SELinux、grsec 等来 <a href="http://linux-audit.com/docker-security-best-practices-for-your-vessel-and-containers/" target="_blank" rel="noopener">限制容器的权限</a>。更多细节，请查阅 <a href="https://blog.docker.com/2016/02/docker-engine-1-10-security/" target="_blank" rel="noopener">Docker 1.10 security features</a>。</p><p>Docker 镜像 ID 属于 <a href="https://medium.com/@quayio/your-docker-image-ids-are-secrets-and-its-time-you-treated-them-that-way-f55e9f14c1a4" target="_blank" rel="noopener">敏感信息</a> 所以它不应该向外界公开。请将它们当作密码来对待。</p><p>阅读由 <a href="https://github.com/konstruktoid" target="_blank" rel="noopener">Thomas Sjögren</a> 编写的 <a href="https://github.com/konstruktoid/Docker/blob/master/Security/CheatSheet.adoc" target="_blank" rel="noopener">Docker Security Cheat Sheet</a>：关于加固容器的不错的建议。</p><p>查看 <a href="https://github.com/docker/docker-bench-security" target="_blank" rel="noopener">Docker 安全测试脚本</a>，下载 <a href="https://blog.docker.com/2015/05/understanding-docker-security-and-best-practices/" target="_blank" rel="noopener">最佳实践白皮书</a>。</p><p>你应当远离使用非稳定版本 grsecurity / pax 的内核，比如 <a href="https://en.wikipedia.org/wiki/Alpine_Linux" target="_blank" rel="noopener">Alpine Linux</a>。如果在产品中用了 grsecurity，那么你应该考虑使用有 <a href="https://grsecurity.net/business_support.php" target="_blank" rel="noopener">商业支持</a> 的 <a href="https://grsecurity.net/announce.php" target="_blank" rel="noopener">稳定版本</a>，就像你对待 RedHat 那样。虽然要 $200 每月，但对于你的运维预算来说不值一提。</p><p>从 Docker 1.11 开始，你可以轻松的限制在容器中可用的进程数，以防止 fork 炸弹。 这要求 Linux 内核 &gt;= 4.3，并且要在内核配置中打开 CGROUP_PIDS=y。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --pids-limit&#x3D;64</span><br></pre></td></tr></table></figure><p>同时，你也可以限制进程再获取新权限。该功能是 Linux 内核从 3.5 版本开始就拥有的。你可以从 <a href="http://www.projectatomic.io/blog/2016/03/no-new-privs-docker/" target="_blank" rel="noopener">这篇博客</a> 中阅读到更多关于这方面的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --security-opt&#x3D;no-new-privileges</span><br></pre></td></tr></table></figure><p>以下内容摘选自 <a href="http://container-solutions.com/is-docker-safe-for-production/" target="_blank" rel="noopener">Container Solutions</a> 的 <a href="http://container-solutions.com/content/uploads/2015/06/15.06.15_DockerCheatSheet_A2.pdf" target="_blank" rel="noopener">Docker Security Cheat Sheet</a>（PDF 版本，难以使用，故复制至此）：</p><p>关闭内部进程通讯：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -d --icc&#x3D;false --iptables</span><br></pre></td></tr></table></figure><p>设置容器为只读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --read-only</span><br></pre></td></tr></table></figure><p>通过 hashsum 来验证卷标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull debian@sha256:a25306f3850e1bd44541976aa7b5fd0a29be</span><br></pre></td></tr></table></figure><p>设置卷标为只读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v $(pwd)&#x2F;secrets:&#x2F;secrets:ro debian</span><br></pre></td></tr></table></figure><p>在 Dockerfile 中定义用户并以该用户运行，避免在容器中以 ROOT 身份操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r user &amp;&amp; useradd -r -g user user</span><br><span class="line">USER user</span><br></pre></td></tr></table></figure><h3 id="用户命名空间user-namespaces">用户命名空间(User Namespaces)</h3><p>还可以通过使用 <a href="https://s3hh.wordpress.com/2013/07/19/creating-and-using-containers-without-privilege/" target="_blank" rel="noopener">用户命名空间</a> -- 自 1.10 版本起已内置，但默认并未启用。</p><p>要在 Ubuntu 15.10 中启用用户命名空间 (remap the userns)，请 <a href="https://raesene.github.io/blog/2016/02/04/Docker-User-Namespaces/" target="_blank" rel="noopener">跟着这篇博客的例子</a> 来做。</p><h3 id="安全相关视频">安全相关视频</h3><ul><li><a href="https://youtu.be/04LOuMgNj9U" target="_blank" rel="noopener">Using Docker Safely</a></li><li><a href="https://youtu.be/KmxOXmPhZbk" target="_blank" rel="noopener">Securing your applications using Docker</a></li><li><a href="https://youtu.be/a9lE9Urr6AQ" target="_blank" rel="noopener">Container security: Do containers actually contain?</a></li><li><a href="https://www.youtube.com/watch?v=iN6QbszB1R8" target="_blank" rel="noopener">Linux Containers: Future or Fantasy?</a></li></ul><h3 id="安全路线图">安全路线图</h3><p>Docker 的路线图提到关于 <a href="https://github.com/docker/docker/blob/master/ROADMAP.md#11-security" target="_blank" rel="noopener">seccomp 的支持</a>。<br />一个名为 <a href="https://github.com/jfrazelle/bane" target="_blank" rel="noopener">bane</a> 的 AppArmor 策略生成器正在实现 <a href="https://github.com/docker/docker/issues/17142" target="_blank" rel="noopener">安全配置文件</a>。</p><h2 id="小贴士">小贴士</h2><p>链接：</p><ul><li><a href="http://sssslide.com/speakerdeck.com/bmorearty/15-docker-tips-in-5-minutes" target="_blank" rel="noopener">15 Docker Tips in 5 minutes</a></li><li><a href="https://codefresh.io/blog/everyday-hacks-docker/" target="_blank" rel="noopener">CodeFresh Everyday Hacks Docker</a></li></ul><h3 id="清理-1">清理</h3><p>最新的 <a href="https://github.com/docker/docker/pull/26108" target="_blank" rel="noopener">数据管理命令</a> 已在 Docker 1.13 实现：</p><ul><li><code>docker system prune</code></li><li><code>docker volume prune</code></li><li><code>docker network prune</code></li><li><code>docker container prune</code></li><li><code>docker image prune</code></li></ul><h3 id="df-命令">df 命令</h3><p><code>docker system df</code> 将显示当前 Docker 各部分占用的磁盘空间。</p><h3 id="heredoc-声明-docker-容器">Heredoc 声明 Docker 容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t htop - &lt;&lt; EOF</span><br><span class="line">FROM alpine</span><br><span class="line">RUN apk --no-cache add htop</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="最近一次的容器-id">最近一次的容器 ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias dl&#x3D;&#39;docker ps -l -q&#39;</span><br><span class="line">docker run ubuntu echo hello world</span><br><span class="line">docker commit $(dl) helloworld</span><br></pre></td></tr></table></figure><h3 id="带命令的提交需要-dockerfile">带命令的提交（需要 Dockerfile）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -run&#x3D;&#39;&#123;&quot;Cmd&quot;:[&quot;postgres&quot;, &quot;-too -many -opts&quot;]&#125;&#39; $(dl) postgres</span><br></pre></td></tr></table></figure><h3 id="获取-ip-地址">获取 IP 地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | grep -wm1 IPAddress | cut -d &#39;&quot;&#39; -f 4</span><br></pre></td></tr></table></figure><p>或使用 <a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">jq</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect $(dl) | jq -r &#39;.[0].NetworkSettings.IPAddress&#39;</span><br></pre></td></tr></table></figure><p>或使用 <a href="https://docs.docker.com/engine/reference/commandline/inspect" target="_blank" rel="noopener">go 模板</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#39; &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p>或在通过 Dockerfile 构建镜像时，通过构建参数 (build argument) 传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_HOST_IP&#x3D;&#96;ifconfig | grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&quot; | grep -v 127.0.0.1 | awk &#39;&#123; print $2 &#125;&#39; | cut -f2 -d: | head -n1&#96;</span><br><span class="line">echo DOCKER_HOST_IP &#x3D; $DOCKER_HOST_IP</span><br><span class="line">docker build \</span><br><span class="line">  --build-arg ARTIFACTORY_ADDRESS&#x3D;$DOCKER_HOST_IP </span><br><span class="line">  -t sometag \</span><br><span class="line">  some-directory&#x2F;</span><br></pre></td></tr></table></figure><h3 id="获取端口映射">获取端口映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123;range $p, $conf :&#x3D; .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;&#39; &lt;containername&gt;</span><br></pre></td></tr></table></figure><h3 id="通过正则匹配容器">通过正则匹配容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(docker ps -a | grep &quot;REGEXP_PATTERN&quot; | cut -f1 -d&quot; &quot;); do echo $i; done&#96;</span><br></pre></td></tr></table></figure><h3 id="获取环境变量配置">获取环境变量配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm ubuntu env</span><br></pre></td></tr></table></figure><h3 id="强行终止运行中的容器">强行终止运行中的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id="删除所有容器强行删除无论容器运行或停止">删除所有容器（强行删除！无论容器运行或停止）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -qa)</span><br></pre></td></tr></table></figure><h3 id="删除旧容器">删除旧容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep &#39;weeks ago&#39; | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm</span><br></pre></td></tr></table></figure><h3 id="删除已停止的容器">删除已停止的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v &#96;docker ps -a -q -f status&#x3D;exited&#96;</span><br></pre></td></tr></table></figure><h3 id="停止并删除容器">停止并删除容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -aq) &amp;&amp; docker rm -v $(docker ps -aq)</span><br></pre></td></tr></table></figure><h3 id="删除无用-dangling-的镜像">删除无用 (dangling) 的镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><h3 id="删除所有镜像">删除所有镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id="删除无用-dangling-的卷标">删除无用 (dangling) 的卷标</h3><p>Docker 1.9 版本起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>1.9.0 中，参数 <code>dangling=false</code> 居然 <em>没</em> 用 - 它会被忽略然后列出所有的卷标。</p><h3 id="查看镜像依赖">查看镜像依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -viz | dot -Tpng -o docker.png</span><br></pre></td></tr></table></figure><h3 id="docker-容器瘦身">Docker 容器瘦身</h3><ul><li>在某层 (RUN layer) 清理 APT</li></ul><p>这应当和其他 apt 命令在同一层中完成。<br />否则，前面的层将会保持原有信息，而你的镜像则依旧臃肿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN &#123;apt commands&#125; \</span><br><span class="line">  &amp;&amp; apt-get clean \  </span><br><span class="line">  &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* &#x2F;tmp&#x2F;* &#x2F;var&#x2F;tmp&#x2F;*</span><br></pre></td></tr></table></figure><ul><li><p>压缩镜像<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">docker export $ID | docker import – flat-image-name</span><br></pre></td></tr></table></figure></p></li><li><p>备份<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ID&#x3D;$(docker run -d image-name &#x2F;bin&#x2F;bash)</span><br><span class="line">(docker export $ID | gzip -c &gt; image.tgz)</span><br><span class="line">gzip -dc image.tgz | docker import - flat-image-name</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="监视运行中容器的系统资源利用率">监视运行中容器的系统资源利用率</h3><p>检查某个容器的 CPU、内存以及网络 I/O 使用情况，你可以：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats &lt;container&gt;</span><br></pre></td></tr></table></figure></p><p>按 ID 列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps -q)</span><br></pre></td></tr></table></figure></p><p>按名称列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats $(docker ps --format &#39;&#123;&#123;.Names&#125;&#125;&#39;)</span><br></pre></td></tr></table></figure></p><p>按指定镜像名称列出所有容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a -f ancestor&#x3D;ubuntu</span><br></pre></td></tr></table></figure></p><p>删除所有未标签命名 (untagged) 的容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | grep “^” | awk &#39;&#123;split($0,a,&quot; &quot;); print a[3]&#125;&#39;)</span><br></pre></td></tr></table></figure></p><p>通过正则匹配删除指定容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep wildfly | awk &#39;&#123;print $1&#125;&#39; | xargs docker rm -f</span><br></pre></td></tr></table></figure></p><p>删除所有已退出 (exited) 的容器：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -a | grep Exit | awk &#39;&#123; print $1 &#125;&#39;)</span><br></pre></td></tr></table></figure></p><h3 id="将文件挂载为卷标">将文件挂载为卷标</h3><p>文件也可以被挂载为卷标。例如你可以仅仅注入单个配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从容器复制文件</span></span><br><span class="line">docker run --rm httpd cat /usr/<span class="built_in">local</span>/apache2/conf/httpd.conf &gt; httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件</span></span><br><span class="line">vim httpd.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载修改后的配置启动容器</span></span><br><span class="line">docker run --rm -ti -v <span class="string">"<span class="variable">$PWD</span>/httpd.conf:/usr/local/apache2/conf/httpd.conf:ro"</span> -p <span class="string">"80:80"</span> httpd</span><br></pre></td></tr></table></figure><h2 id="贡献手册contributing">贡献手册(Contributing)</h2><p>以下是如何贡献本速查表的说明。</p><h3 id="打开-readme.md">打开 README.md</h3><p>点击 <a href="https://github.com/wsargent/docker-cheat-sheet/blob/master/README.md" target="_blank" rel="noopener">README.md</a></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/wsargent/docker-cheat-sheet/tree/master/zh-cn" target="_blank" rel="noopener">GitHub docker-cheat-sheet</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要一起来完善这份速查表吗？&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 参见&lt;a href=&quot;#贡献手册contributing&quot;&gt;贡献手册&lt;/a&gt;部分吧！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：以下部分链接需科学上网后使用。&lt;/p&gt;
&lt;p&gt;Due to GFW, varies links below could not be accessed in China Mainland.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#为何使用-docker&quot;&gt;为何使用 Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#系统环境&quot;&gt;系统环境(Prerequisites)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安装&quot;&gt;安装(Installation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#容器container&quot;&gt;容器(Containers)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#镜像images&quot;&gt;镜像(Images)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#网络networks&quot;&gt;网络(Networks)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#仓管中心和仓库registry--repository&quot;&gt;仓管中心和仓库(Registry &amp;amp; Repository)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dockerfile&quot;&gt;Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#层layers&quot;&gt;层(Layers)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#链接links&quot;&gt;链接(Links)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#卷标volumes&quot;&gt;卷标(Volumes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#暴露端口exposing-ports&quot;&gt;暴露端口(Exposing Ports)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#最佳实践&quot;&gt;最佳实践(Best Practices)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安全security&quot;&gt;安全(security)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#小贴士&quot;&gt;小贴士(Tips)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#贡献手册contributing&quot;&gt;贡献手册(Contributing)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://2020.iosdevlog.com/categories/docker/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>《DevOps 实战笔记》</title>
    <link href="https://2020.iosdevlog.com/2020/03/28/DevOps/"/>
    <id>https://2020.iosdevlog.com/2020/03/28/DevOps/</id>
    <published>2020-03-28T01:49:24.000Z</published>
    <updated>2020-04-03T14:46:11.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/0.png" /></p><blockquote><p>DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>——维基百科<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>DevOps经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。</p><a id="more"></a><p>团队间沟通和协作的重要性一点也不亚于写代码、写文档、做测试之类的常规工作。</p><p>如何快速地持续交付高质量的软件，满足用户的多样化需求，并借此提升企业的利润和市场占有率，已经成为企业必须要面对的现实问题。</p><p>软件开发过程的改进，除了依赖于技术进步，还依赖于流程、理念、文化等全方位的改进，而这正是 DevOps 带给软件开发方式的一场革命。</p><p>DevOps 已经成为了所有 IT 从业人员应知应会的必备技能。</p><h2 id="devops-实践指南2">《DevOps 实践指南》<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><ul><li>如何梳理出一套清晰的 DevOps 理念和完整的知识体系？</li><li>如何获得一线大厂的实践经验，让 DevOps 真正落地？</li><li>如何获得一条渐进式的 DevOps 学习曲线，让自己在正确的方向上不断增值？</li></ul><h2 id="基础知识篇">基础知识篇</h2><p>DevOps 的定义、价值、实施与衡量，在最开始帮你建立起正确的 DevOps 体系认知。</p><p>软件工程诞生以来所历经的三个重要发展阶</p><ol type="1"><li>瀑布式开发模式</li><li>敏捷式开发模式</li><li>DevOps 模式</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/1.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/2.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/3.png" /></p><p>整个软件交付过程中，不仅只有开发和运维，业务也是重要的一环。</p><blockquote><p>DevOps 是通过平台（Platform）、流程（Process）和人（People）的有机整合，以 C（协作）A（自动化）L（精益）M（度量）S（共享）文化为指引，旨在建立一种可以快速交付价值并且具有持续改进能力的现代化 IT 组织。</p></blockquote><p>软件慢慢从企业内部的支撑系统和成本中心，变成了企业服务的直接载体和利润中心。</p><p>VUCA 时代</p><ol type="1"><li>易变性（Volatility）</li><li>不确定性（Uncertainty）</li><li>复杂性（Complexity）</li><li>模糊性（Ambiguity）</li></ol><p>软件交付的效率和质量成了当今企业的核心价值和核心竞争力。</p><p>“工业革命消灭了绝大多数的手工业群体，却催生了程序员这个现存最大的手工业群体”。</p><p>DevOps 的 4 个结果指标</p><ol type="1"><li><strong>部署频率</strong>：指应用和服务向生产环境部署代码的频率。</li><li><strong>变更前置时间</strong>：指代码从提交到成功运行在生产环境的时长。</li><li><strong>服务恢复时间</strong>：指线上应用和服务出现故障到恢复运行的时长。</li><li><strong>变更失败率</strong>：指应用和服务在生产环境部署失败或者部署后导致服务降级的比例。</li></ol><p>软件交付</p><ol type="1"><li>交付效率</li><li>交付质量</li></ol><p>高效能的组织不仅做到了高效率，还实现了高质量。</p><p><code>工具和文化</code></p><ul><li>DevOps 工具</li></ul><p>一切软件交付过程中的手动环节，都是未来可以尝试进行优化的方向。</p><ul><li>DevOps 文化</li></ul><p>在不同的文化制度下，相同的人发挥出来的生产力也会有天壤之别。</p><p>DevOps 的 3 个支柱</p><ol type="1"><li>人（People）</li><li>流程（Process）</li><li>平台（Platform）</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/4.png" /></p><p>技术采纳生命周期定律</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/5.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/6.png" /></p><p>步骤与原则</p><p><code>道法术器</code> DevOps：<code>法</code></p><ol type="1"><li>识别差距</li><li>锚定目标</li><li>关注能力</li><li>持续改进</li></ol><p>DevOps 实施的过程</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/7.png" alt="" /><figcaption>部署引力图</figcaption></figure><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/8.png" /></p><h2 id="落地实践篇">落地实践篇</h2><h3 id="转型路径">转型路径</h3><p>最核心的部分。我将带你通盘梳理 DevOps 的转型路径。</p><p><code>VSM</code> 是 Value Stream Mapping 的缩写，也就是我们常说的价值流图。</p><p>VSM 是企业 DevOps 转型的第一步。</p><p>《DevOps 实践指南》三步工作法</p><ul><li><strong>第一步：流动。</strong> 通过工作可视化，限制在制品数量，并注入一系列的工程实践，从而加速从开发到运营的流动过程，实现低风险的发布。</li><li><strong>第二步：反馈。</strong> 通过注入流动各个过程的反馈能力，使缺陷在第一时间被发现，用户和运营数据第一时间展示，从而提升组织的响应能力。</li><li><strong>第三步：持续学习和试验。</strong> 没有任何文化和流程是天生完美的，通过团队激励学习分享，将持续改进注入日常工作，使组织不断进步。</li></ul><p>通过流程和平台的结合，来驱动流程的自动化流转，这才是 DevOps 的正确姿势。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/9.png" alt="" /><figcaption>价值流交付图</figcaption></figure><p>价值</p><ol type="1"><li>看见全貌</li><li>识别问题</li><li>促进沟通</li><li>驱动度量</li><li>价值展现</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/10.jpeg" alt="" /><figcaption>VSM</figcaption></figure><h4 id="实施-devops-的常见路径">实施 DevOps 的常见路径</h4><ul><li>自底向上</li><li>自顶向下</li></ul><p>通用路径</p><ol type="1"><li>寻找合适的试点项目<ol type="1"><li>贴近核心业务</li><li>倾向敏捷业务</li><li>改进意愿优先</li></ol></li><li>寻找团队痛点</li><li>快速建立初期成功</li><li>快速展示和持续改进</li></ol><p>DevOps 转型的 J 型曲线</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/11.png" alt="" /><figcaption>J</figcaption></figure><p>转型小组</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/12.jpg" /></p><h3 id="敏捷实践">敏捷实践</h3><h4 id="如果业务不够敏捷it-再怎么努力也没用">如果业务不够敏捷，IT 再怎么努力也没用</h4><p>业务敏捷和交付能力二者缺一不可</p><p>关于需求分析： 影响地图</p><p>"Why-Who-How-What” 分析方法</p><ul><li>Why 代表目标，它可以是一个核心的业务目标，也可以是一个实际的用户需求。</li><li>Who 代表影响对象，也就是通过影响谁来实现这个目标。</li><li>How 代表影响，也就是怎样影响用户以实现我们的目标。</li><li>What 代表需要交付什么样的功能，可以带来期望的影响。</li></ul><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/13.png" alt="" /><figcaption>影响地图</figcaption></figure><p>卡诺模型（Kano Model）</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/14.png" alt="" /><figcaption>卡诺模型（Kano Model）</figcaption></figure><ol type="1"><li><strong>兴奋型</strong>：指超乎用户想象的需求，是可遇不可求的功能。比如用户想要一个更好的功能手机，乔布斯带来了 iPhone，这会给用户带来极大的满足感。</li><li><strong>期望型</strong>：用户的满意度会随着这类需求数量的增多而线性增长，做得越多，效果越好，但难以有质的突破。比如，一个电商平台最开始是卖书，后面逐步扩展到卖电脑、家居用品等多个类别。用户更多的线性需求被满足，满意度自然也会提升。</li><li><strong>必备型</strong>：这些是产品必须要有的功能，如果没有的话，会带来非常大的影响。不过有这些功能的话，也没人会夸你做得有多好，比如安全机制和风控机制等。</li><li><strong>无差别型</strong>：做了跟没做一样，这就是典型的无用功。比如你花了好大力气做了一个需求，但是几乎没有用户使用，这个需求就属于无差别型。</li><li><strong>反向型</strong>：无中生有类需求，实际上根本不具备使用条件，或者用户压根不这么想。这类需求做出来以后，通常会给用户带来很大的困扰，成为被吐槽的对象。</li></ol><p>核心要做到 3 点</p><ol type="1"><li>优先规划期望型和必备型需求，将其纳入日常的交付迭代中，保持一定的交付节奏；</li><li>识别无差别型和反向型需求，这些对于用户来说并没有产生价值。如果团队对需求的分类有争议，可以进一步开展用户调研和分析。</li><li>追求兴奋型需求，因为它会带来产品的竞争壁垒和差异化。</li></ol><p>用户故事拆分粒度，遵循 INVEST 原则</p><ul><li><strong>Independent（独立的）</strong>：减少用户故事之间的依赖，可以让用户故事更加灵活地验证和交付，而避免大批量交付对于业务敏捷性而言至关重要。</li><li><strong>Negotiable（可协商的）</strong>：用户故事不应该是滴水不漏、行政命令式的，而是要抛出一个场景描述，并在需求沟通阶段不断细化完成。</li><li><strong>Valuable（有价值的）</strong>：用户故事是以用户价值为核心的，所以每个故事都是在对用户交付价值，所以要站在用户的视角思考问题，避免像最近特别火的那句话一样：“我不要你觉得，我要我觉得。”</li><li><strong>Estimatable（可评估的）</strong>：用户故事应该可以粗略评估工作量，无论是故事点数还是时间，都可以。如果是一个预研性质的故事，则需要进一步深挖可行性，避免不知道为什么做而做。</li><li><strong>Small（小的）</strong>：用户故事应该是最小的交付颗粒度，所以按照敏捷开发方式，无论迭代还是看板，都需要在一个交付周期内完成。</li><li><strong>Testable（可测试的）</strong>：也就是验收条件，如果没有办法证明需求已经完成，也就没有办法进行验收和交付。</li></ul><p>MVP 原则</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/15.png" alt="" /><figcaption>MVP 原则</figcaption></figure><p>BizDevOps</p><p>引入业务的 DevOps，就成了 BizDevOps，这也是 DevOps 发展的一种潮流。</p><p>核心理念：</p><ul><li>对齐业务和开发目标、指标；</li><li>把握安全、合规指标；</li><li>及时对齐需求，减少无用开发；</li><li>体现 DevOps 的价值；</li><li>让开发团队开始接触业务，不单单是执行，调动积极性。</li></ul><h4 id="精益看板">精益看板</h4><p>《改变世界的机器》</p><p>加快价值流动是精益看板的核心</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/16.png" /></p><p>精益看板的实践方法</p><ol type="1"><li><p>可视化流程</p></li><li><p>定义清晰的规则</p><ol type="1"><li>可视化规则<ol type="1"><li>卡片的颜色<ol type="1"><li>需求（绿色）</li><li>缺陷（红色）</li><li>改进事项（蓝色）</li></ol></li><li>卡片的内容</li><li>卡片的依赖和阻塞状态</li></ol></li><li>显式化规则</li></ol></li><li><p>限制在制品数量</p><ol type="1"><li>需求流入节点</li><li>需求流出节点</li></ol></li><li><p>管理工作流程</p><ol type="1"><li>每日站会</li><li>队列填充会议</li><li>发布规划会议</li></ol></li><li><p>建立反馈和持续改进</p></li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/17.png" alt="" /><figcaption>看板</figcaption></figure><p>看板创始人 David J Anderson 总结了看板方法的成熟度模型，用于指导中大型团队实践看板方法</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/18.png" alt="" /><figcaption>kmm</figcaption></figure><h3 id="工程实践">工程实践</h3><h4 id="配置管理工程实践基础">配置管理：工程实践基础</h4><ol type="1"><li>版本变更标准化 Git<ol type="1"><li>提交概要信息</li><li>提交详细信息</li><li>提交关联需求</li></ol></li><li>将一切纳入版本控制<ol type="1"><li>制品管理</li><li>生成物不需要版本控制</li></ol></li><li>全流程可追溯</li><li>单一可信数据源</li></ol><h4 id="分支策略让研发高效协作的关键要素">分支策略：让研发高效协作的关键要素</h4><p><code>git flow</code></p><ol type="1"><li>主干开发，分支发布</li><li>分支开发，主干发布</li><li>主干开发，主干发布</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/19.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/20.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/21.png" /></p><p><code>git checkout feature1 &amp;&amp; git fetch origin &amp;&amp; git rebase -i origin/master</code></p><p>最常见的操作包括：</p><ol type="1"><li>p：选择提交；</li><li>r：更新提交的注释信息；</li><li>e：编辑提交，可以将一个提交拆分成多个；</li><li>s：压合提交，将多个提交合并成一个；</li><li>f：类似压合提交，但是放弃这个提交的注释信息，直接使用合并提交的注释信息；</li></ol><p>当然，在 git rebase 的交互界面中，你也可以调整提交的顺序，比如将特性功能和关联的 Bugfix 整合在一起。</p><h4 id="持续集成-ci">持续集成 CI</h4><p>CI 是 Continuous Integration 的缩写，也就是我们熟悉的持续集成</p><blockquote><p>CI 是一种软件开发实践，团队成员频繁地将他们的工作成果集成到一起（通常每人每天至少提交一次，这样每天就会有多次集成），并且在每次提交后，自动触发运行一次包含自动化验证集的构建任务，以便尽早地发现集成问题。</p></blockquote><p>——马丁·福勒（Martin Fowler）</p><p>越是痛苦的事情，就要越频繁地做。</p><p>实施 CI 三个阶段</p><ol type="1"><li>第一阶段：每次提交触发完整的流水线<ol type="1"><li>统一的分支策略</li><li>清晰的集成规则</li><li>标准化的资源池</li><li>足够快的反馈周期</li></ol></li><li>第二阶段：每次流水线触发自动化测试<ol type="1"><li>匹配合适的测试活动</li><li>树立测试结果的公信度</li><li>提升测试活动的有效性</li></ol></li><li>第三阶段：出了问题可以在第一时间修复</li></ol><h4 id="自动化测试devops的阿克琉斯之踵">自动化测试：DevOps的阿克琉斯之踵</h4><p>自动化测试建设也面临着一些问题</p><ol type="1"><li>投入产出比</li><li>上手门槛</li><li>维护成本高</li><li>测试设备投入高</li></ol><p>自动化测试的设计</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/22.png" /></p><p>DevOps Handbook</p><p>Web 应用</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/23.png" /></p><p>自动化测试的开发</p><ul><li>cURL</li><li>Postman</li><li>JMeter</li></ul><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/24.png" /></p><p>如果自动化测试覆盖率足够高，那么软件质量一定不会差到哪儿去。</p><p>自动化测试结果分析</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/25.png" /></p><h4 id="内建质量丰田和亚马逊给我们的启示">内建质量：丰田和亚马逊给我们的启示</h4><ol type="1"><li>问题发现得越早，修复成本就越低；</li><li>质量是每个人的责任，而不是质量团队的责任。</li></ol><p>在开发阶段，代码评审和持续集成就是一个非常好的内建质量的实践。</p><p>内建质量的实施步骤</p><ol type="1"><li>第一步：选择适合的检查类型</li><li>第二步：定义指标并达成一致<ol type="1"><li>参考值的定义是一门艺术</li><li>静态指标就是固定值</li></ol></li><li>第三步：建立自动化执行和检查能力</li><li>第四步：定义问题处理方式</li><li>第五步：持续优化和改进</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/26.png" /></p><p>核心目标不是为了通过质量门禁，而是为了质量提升，这才是最重要的。</p><p>内建质量的常见问题</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/27.jpg" /></p><h4 id="技术债务那些不可忽视的潜在问题">技术债务：那些不可忽视的潜在问题</h4><p>什么是技术债务？</p><blockquote><p>老板拍下来一个紧急需求，要求你在 3 天内开发完成上线。</p></blockquote><ul><li>方案 1：采用分层架构，引入消息队列。这样做的好处是结构清晰，功能解耦，但是需要 1 周的时间；</li><li>方案 2：直接在原有代码的基础上修修补补，硬塞进去一块逻辑和页面，这样做需要 2 天时间，还有 1 天时间来测试。</li></ul><p>代码维护的时间越长，引入的技术债务就会越多，从而使团队背上沉重的负担。</p><p>技术债务长什么样？</p><ul><li>一份代码里面定义了一堆全局变量，各个角落都在引用；</li><li>一个脚本仓库里面，一大堆名字看起来差不多的脚本，内容也都差不多；</li><li>一个函数里面修修补补写了上千行；数据表查询各种神奇的关联；</li><li>参数传递纯靠肉眼计算顺序；</li><li>因为修改一段代码引发了一系列莫名其妙的问题；</li><li>……</li></ul><p>七宗罪</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/28.jpg" /></p><p>为什么要重视技术债务？</p><ol type="1"><li>额外的研发成本</li><li>不稳定的产品质量</li><li>难以维护的产品</li></ol><p>如何量化技术债务？</p><p>目前业界比较常用的开源软件，就是 SonarQube。</p><p>解决方法和原则</p><p>解决技术债务步骤</p><ol type="1"><li>共识</li><li>可见</li><li>止损</li><li>改善</li></ol><p>4 条原则</p><ol type="1"><li>让技术债务呈良性下降趋势。</li><li>优先解决高频修改的问题。</li><li>在新项目中启动试点。</li><li>技术债务无法被消灭，也不要等到太晚。</li></ol><p>优先处理</p><ul><li>大量重复代码；</li><li>类之间的耦合严重；</li><li>方法过于复杂；</li><li>条件判断嵌套太多；</li><li>缺少必要的异常处理；</li><li>多表关联和缺少索引；</li><li>代码风险和缺陷；</li><li>安全漏洞。</li></ul><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/29.jpeg" /></p><h3 id="部署实践">部署实践</h3><h4 id="环境管理一切皆代码">环境管理：一切皆代码</h4><p>环境就成了软件行业的“头号背锅侠”。</p><p>环境管理的挑战</p><ol type="1"><li>环境种类繁多</li><li>环境复杂性上升</li><li>环境一致性难以保证</li><li>环境交付速度慢</li><li>环境变更难以追溯</li></ol><p>基础设施即代码就是用一种描述性的语言，通过文本管理环境配置，并且自动化完成环境配置的方式。</p><p>典型的就是以 <code>CAPS</code> 为代表的自动化环境配置管理工具，也就是 <code>Chef、Ansible、Puppet 和 Saltstacks</code> 四个开源工具的首字母缩写。</p><p>开发运维打通的 GitOps 实践</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/30.png" /></p><p>开发环境的治理实践</p><p>采用基础设施即代码的方法，生成一个包含全部工具依赖的 <code>Docker</code> 镜像，并分发给开发团队。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  harbor.devops.com:<span class="number">5000</span>/test:ansible </span><br><span class="line"><span class="keyword">MAINTAINER</span> XX &lt;xx@devops.com&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./docker  /docker</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /docker</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">export</span> TMPDIR=/var/tmp &amp;&amp; ansible-playbook -v -i playbooks/inventories/docker playbooks/docker_container.yml</span></span><br></pre></td></tr></table></figure><h4 id="部署管理低风险的部署发布策略">部署管理：低风险的部署发布策略</h4><p>部署和发布这两个概念，经常会被混用，但严格来说，部署和发布代表两种不同的实践。</p><p><code>部署</code> 是一组技术实践，表示通过技术手段，将本次开发测试完成的功能实体（比如代码、二进制包、配置文件、数据库等）应用到指定环境的过程，包括开发环境、预发布环境、生产环境等。部署的结果是对服务器进行变更，但是这个变更结果不一定对外可见。</p><p><code>发布，也就是 Release</code>，更偏向一种业务实践，也就是将部署完成的功能正式生效，对用户可见和提供服务的过程。</p><p>要在保障一定的质量水平的前提下，尽量加快发布节奏，并通过低风险发布手段，以及线上测试和监控能力，尽早地发现问题，并以一种最简单的手段来快速恢复。</p><ul><li>一定的质量水平</li><li>低风险发布手段</li><li>线上测试和监控</li><li>快速恢复</li></ul><p>低风险的发布手段</p><ol type="1"><li>蓝绿部署</li><li>灰度发布</li><li>暗部署</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/31.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/32.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/33.png" /></p><p><a href="https://www.gocd.org/2017/07/25/blue-green-deployments.html" target="_blank" rel="noopener" class="uri">https://www.gocd.org/2017/07/25/blue-green-deployments.html</a></p><p>线上测试和监控</p><p>开源的 GoReplay 工具</p><ol type="1"><li>采用灰度发布、用户众测等方式，逐步观察用户行为并收集用户数据，以验证新版本的可用性是否符合预期。</li><li>用户反馈</li><li>使用线上流量测试</li></ol><p>快速恢复</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/34.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/35.png" /></p><h4 id="混沌工程软件领域的反脆弱">混沌工程：软件领域的反脆弱</h4><blockquote><p>Chaos Engineering is the discipline of experimenting on a distributed system in order to build confidence in the system’s capability to withstand turbulent conditions in production.</p><p>混沌工程是一门在分布式系统上进行实验的学科，目的是建立人们对于复杂系统在生产环境中抵御突发事件的信心。</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/36.jpeg" /></p><p>故障演练就是针对以往发生过的问题进行有针对性地模拟演练。</p><p>混沌工程不是为了制造问题，而是为了揭示问题。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/37.png" /></p><p>混沌工程的原则</p><ul><li>建立稳定状态的假设</li><li>真实世界的事件</li><li>在生产中试验</li><li>持续的自动化实验</li><li>最小影响范围</li></ul><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/38.jpg" alt="" /><figcaption>参考指标</figcaption></figure><h3 id="度量改进">度量改进</h3><h4 id="正向度量如何建立完整的devops度量体系">正向度量：如何建立完整的DevOps度量体系？</h4><p>DevOps 希望做到的就是持续、快速和高质量的价值交付。</p><p>指标典型特征</p><ol type="1"><li>明确受众</li><li>直指问题</li><li>量化趋势</li><li>充满张力</li></ol><p>定义指标原则</p><ol type="1"><li><strong>全局指标优于局部指标</strong>：过度的局部优化可能对整体产出并无意义，从而偏离了度量的核心，也就是提升交付速度和交付质量。</li><li><strong>综合指标优于单一指标</strong>：从单一维度入手会陷入只见树木不见森林的困境，综合指标更加客观。所以，要解决一个问题，就需要一组指标来客观指引。</li><li><strong>结果指标优于过程指标</strong>：首先要有结果指标，以结果为导向，以过程为途径，一切过程指标都应该归结到结果指标。</li><li><strong>团队指标优于个人指标</strong>：优先考核团队指标而非个人指标，团队共享指标有助于形成内部合力，减少内部的割裂。</li><li><strong>灵活指标优于固化指标</strong>：指标的设立是为了有针对性地实施改进，需要考虑业务自身的差异性和改进方向，而非简单粗暴的“一刀切”，并且随着团队能力的上升，指标也需要适当的调整，从而不断挑战团队的能力。</li></ol><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/39.jpeg" /></p><p>如何开启度量工作？</p><ol type="1"><li>第 1 步：细化指标</li><li>第 2 步：收集度量数据</li><li>第 3 步：建立可视化平台</li><li>第 4 步：识别瓶颈并持续改进</li></ol><p>指标宜少不宜多，宜精不宜烂</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/40.jpg" /></p><h4 id="持续改进pdca体系和持续改进的意义">持续改进：PDCA体系和持续改进的意义</h4><p>核心就是团队已经具备了持续改进的能力，而不只是简简单单地引入了几个工具，建立了几个度量指标而已。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/41.png" /></p><p>鼓励正向回溯和总结</p><p>故障回溯并不一定以确定责任为第一要务，更重要的是，要识别系统流程中的潜在问题和漏洞，并通过后续机制来进行保障，比如增加测试用例、增加产品走查事项等等。</p><p>其实，大到线上故障，小到日常错误，都值得回溯和总结。</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/42.png" /></p><p>预留固定时间进行改进</p><p>在团队的 Backlog 中新增一类任务，专门用于记录和跟踪这类持续改进的内容。</p><h2 id="平台工具篇">平台工具篇</h2><p>涵盖平台建设的 3 个阶段、产品研发和设计、不可忽视的开源工具等，帮你找到快速搭建平台的钥匙。</p><h3 id="开源还是自研企业devops平台建设的三个阶段">开源还是自研：企业DevOps平台建设的三个阶段</h3><p>企业 DevOps 平台建设的三个阶段</p><p>阶段一：从无到有</p><p>核心原则就是选择主流工具</p><ul><li>需求管理工具 Jira；</li><li>知识管理工具 Confluence；</li><li>版本控制系统 GitLab；</li><li>持续集成工具 Jenkins；</li><li>代码质量工具 SonarQube；</li><li>构建工具 Maven/Gradle；</li><li>制品管理 Artifactory/Harbor；</li><li>配置管理工具 Ansible；</li><li>配置中心 Apollo；</li><li>测试工具 RF/Selenium/Appium/Jmeter/TestNG；安</li><li>全合规工具 BlackDuck/Fortify；</li><li>……</li></ul><p>阶段二：从小到大</p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/43.png" /></p><p>阶段三：从繁到简</p><p>你要提供的不再是一个工具，而是一整套的解决方案；不是解决一个问题，而是解决交付过程中方方面面的问题。</p><p>DevOps 核心理念</p><ol type="1"><li>标准化：一切皆有规则，一切皆有标准；</li><li>自动化：干掉一切不必要的手工操作环节，能一键完成的，绝不操作两次；</li><li>服务化：面向用户设计，而不是面向专家设计，让每个人都能在没有外界依赖的前提下，完成自己的工作；</li><li>数据化：对数据进行收集、汇总、分析和展示，让客观数据呈现出来，让数据指导持续改进。</li></ol><h3 id="产品设计之道devops产品设计的五个层次">产品设计之道：DevOps产品设计的五个层次</h3><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/44.png" /></p><h3 id="持续交付平台现代流水线必备的十大特征">持续交付平台：现代流水线必备的十大特征</h3><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/45.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/46.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/47.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/48.png" /></p><h3 id="让数据说话如何建设企业级数据度量平台">让数据说话：如何建设企业级数据度量平台？</h3><p>事前：指标共识</p><p><strong>数据本身不会说话，是人们赋予了数据意义</strong>，而“这个意义“就是度量指标。</p><p>事中：平台建设</p><p>挑战一：大量数据源平台对接</p><p>插件化：数据采集器</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/49.png" alt="" /><figcaption>数据采集器</figcaption></figure><p>挑战二：海量数据存储分析</p><ol type="1"><li>数据量大</li><li>数据结构不统一</li><li>数据访问频</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/50.png" alt="" /><figcaption>数据度量的架构图</figcaption></figure><p>事后：规则落地</p><h3 id="平台产品研发">平台产品研发</h3><p>开发策略</p><p><strong>研发环境容器化</strong></p><p>开发协作流程</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/51.png" alt="" /><figcaption>图片版</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/52.png" alt="" /><figcaption>文字版</figcaption></figure><p>产品运营策略</p><p>团队不仅要做得好，还要善于运营和宣传，而这又是技术团队的一大软肋。</p><p>很多事情其实没有没有多难，关键就看有没有想，有没有坚持做。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/53.png" alt="" /><figcaption>文字版</figcaption></figure><p>团队文化建设</p><ol type="1"><li>让专业的人做专业的事情</li><li>抓大放小，适当地忽略细节</li></ol><h3 id="开源工具">开源工具</h3><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/54.png" alt="" /><figcaption>系统的架构图</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/55.png" alt="" /><figcaption>系统关系示意图</figcaption></figure><h3 id="迈向云端云原生应用时代的平台思考">迈向云端：云原生应用时代的平台思考</h3><blockquote><p>Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization.</p><p>云原生使用一种开源软件技术栈来部署微服务应用，将每个组件打包到它自己的容器中，并且通过动态编排来优化资源的利用率。</p></blockquote><p>开源软件、微服务应用、容器化部署和动态编排</p><ol type="1"><li>自动化生成依赖的配置文件<ol type="1"><li>Dockerfile：用于生成 Docker 镜像</li><li>Jenkinsfile：应用关联的流水线配置</li><li>Helm Chart：把应用打包并部署运行在 Kubernetes 上的资源文件</li><li>Skaffold：用于在 Kubernetes 中生成 Docker image 的工具</li></ol></li><li>自动化流水线过程<ol type="1"><li>流水线即代码</li><li>流水线的抽象和复用</li><li>流水线的条件判断</li></ol></li><li>自动化多环境部署</li><li>使用云原生流水线</li></ol><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/56.jpeg" alt="" /><figcaption>Serverless Jenkins 和 Tekton 的关系示意图</figcaption></figure><h2 id="转型案例篇">转型案例篇</h2><p>提到的理论、落地实践和工具融入其中，融会贯通。</p><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/57.png" alt="" /><figcaption>微软的 Azure DevOps 平台</figcaption></figure><figure><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/58.jpeg" alt="" /><figcaption>爆炸半径</figcaption></figure><h2 id="成为devops工程师的必备技能">成为DevOps工程师的必备技能</h2><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/59.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/60.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/61.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/62.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/63.jpeg" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/64.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/28/DevOps/65.jpg" /></p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p><a href="https://zh.wikipedia.org/zh-hans/DevOps" target="_blank" rel="noopener" class="uri">https://zh.wikipedia.org/zh-hans/DevOps</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://time.geekbang.org/column/intro/235" target="_blank" rel="noopener" class="uri">https://time.geekbang.org/column/intro/235</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/28/DevOps/0.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DevOps（Development 和 Operations 的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;——维基百科&lt;a href=&quot;#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot; role=&quot;doc-noteref&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DevOps经常被描述为“开发团队与运营团队之间更具协作性、更高效的关系”。由于团队间协作关系的改善，整个组织的效率因此得到提升，伴随频繁变化而来的生产环境的风险也能得到降低。&lt;/p&gt;
    
    </summary>
    
    
      <category term="geek" scheme="https://2020.iosdevlog.com/categories/geek/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
      <category term="action" scheme="https://2020.iosdevlog.com/tags/action/"/>
    
  </entry>
  
  <entry>
    <title>设计图生成 App，Supernova 限时免费</title>
    <link href="https://2020.iosdevlog.com/2020/03/27/supernova/"/>
    <id>https://2020.iosdevlog.com/2020/03/27/supernova/</id>
    <published>2020-03-27T14:05:53.000Z</published>
    <updated>2020-03-27T14:23:28.036Z</updated>
    
    <content type="html"><![CDATA[<figure><img src="https://2020.iosdevlog.com/2020/03/27/supernova/supernano.jpg" alt="" /><figcaption>Supernano</figcaption></figure><ul><li>Sketch 和 Adobe XD 原型</li><li>----&gt;</li><li>Flutter，iOS，Android，React Native App</li></ul><p>Supernano 可以帮助设计师直接创建出可运行的原生 App，或是帮助工程师们大大减少花费在拼 UI 上的时间消耗。</p><a id="more"></a><p>由于 <strong>COVID-19 新型冠状病毒</strong> 引起的近期事件，<em>Supernova 公司</em>将免费开放 Supernova 的所有功能，直到 2020年6月1日。</p><p>他们希望消除创建应用程序的所有限制，可能会增加构建工具以协助和应对这种前所未有的情况以及未来发展的可能性。 <em>Supernova 公司</em> 还希望它减轻当前经济不确定性所造成的任何财务负担。</p><h2 id="如何加入-supernova">如何加入 Supernova</h2><p>如果您是 Supernova 的新手，请在 <a href="https://supernova.io/" target="_blank" rel="noopener">supernova.io</a>（mac only！）上下载它，打开该应用程序，然后完成注册过程。</p><p>如果您已经是用户，请登录并更新到8.5版。</p><p>您应该会收到以下公告：</p><p><img src="https://2020.iosdevlog.com/2020/03/27/supernova/unlock.png" /></p><p>单击“解锁所有功能”以消除对该产品的所有限制。</p><p>请享用。</p><h2 id="问答环节">问答环节</h2><p>Windows可用吗？</p><blockquote><p>很不幸的是，不行。 <em>Supernova 公司</em> 已按原样解锁了当前产品的所有功能。它仍然是仅Mac应用程序。 <em>Supernova 公司</em> 正在努力尽快发布基于云的版本。</p></blockquote><p>我对 Supernova 的使用有什么限制吗？</p><blockquote><p>不，所有功能均已解锁，因此您可以充分利用 Supernova 的潜力。您可以导入Sketch 和 Adobe XD 文件，原型并转换为 Flutter，iOS，Android 和React Native，而没有任何产品限制。有关使用 Supernova 的更多信息，请访问 <em>Supernova 公司</em> 的文档。</p></blockquote><p>我已经支付了每月或每年的 Supernova 许可证，这对我来说意味着什么？</p><blockquote><p><em>Supernova 公司</em> 已经为您的帐户免费提供了三个月的信用额。</p></blockquote><p>当这结束时会发生什么？</p><blockquote><p><em>Supernova 公司</em> 会在6月1日前一周提醒所有用户更改其帐户，以避免不必要的费用。您可以在帐户设置中选择退订或继续使用 Supernova 的付费版本。查看 <em>Supernova 公司</em> 的定价页面以获取有关计划的更多详细信息。</p></blockquote><p>详情：<a href="https://medium.com/@appsupernova/full-supernova-functionality-free-408bf912237f" target="_blank" rel="noopener">Full Supernova Functionality, Free</a></p>]]></content>
    
    <summary type="html">
    
      &lt;figure&gt;
&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/27/supernova/supernano.jpg&quot; alt=&quot;&quot; /&gt;&lt;figcaption&gt;Supernano&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Sketch 和 Adobe XD 原型&lt;/li&gt;
&lt;li&gt;----&amp;gt;&lt;/li&gt;
&lt;li&gt;Flutter，iOS，Android，React Native App&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Supernano 可以帮助设计师直接创建出可运行的原生 App，或是帮助工程师们大大减少花费在拼 UI 上的时间消耗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="software" scheme="https://2020.iosdevlog.com/categories/software/"/>
    
    
      <category term="Android" scheme="https://2020.iosdevlog.com/tags/Android/"/>
    
      <category term="iOS" scheme="https://2020.iosdevlog.com/tags/iOS/"/>
    
      <category term="UI" scheme="https://2020.iosdevlog.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Docker 实践</title>
    <link href="https://2020.iosdevlog.com/2020/03/27/docker/"/>
    <id>https://2020.iosdevlog.com/2020/03/27/docker/</id>
    <published>2020-03-27T10:55:24.000Z</published>
    <updated>2020-03-28T16:34:59.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/27/docker/docker-cheat-sheet.png" /></p><ul><li>Image/镜像: 系统镜像 CentOS.iso</li><li>Container/容器: 虚拟机 VM</li><li>Docker Hub: 镜像中心 GitHub</li></ul><a id="more"></a><p>查看 container ID / Get the ID of the container by using the docker ps command.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>停止 container / Use the docker stop command to stop the container.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Swap out &lt;the-container-id&gt; with the ID from docker ps</span></span><br><span class="line">docker stop &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><p>删除 container，<code>-f</code> 强删 / Once the container has stopped, you can remove it by using the docker rm command.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><h2 id="centos-8-新用户">CentOS 8 新用户</h2><p><code>root</code> 帐号添加新用户</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser iosdevlog</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure><p>添加 <code>iosdevlog</code> 那一行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Allow root to run any commands anywhere</span></span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">iosdevlog       ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure><p>切换到 iosdevlog</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - iosdevlog</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><h2 id="安装-docker">安装 Docker</h2><p><a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Get Started with Docker</a></p><p>设置仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装 Docker Engine-Community</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io --nobest</span><br></pre></td></tr></table></figure><p>启动 Docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="非-root-用户运行">非 root 用户运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/group | grep docker</span><br><span class="line"><span class="comment"># sudo groupadd -g 999 docker </span></span><br><span class="line">sudo gpasswd -a <span class="variable">$USER</span> docker <span class="comment"># 将当前用户加入到 docker 用户组中</span></span><br><span class="line">newgrp docker  <span class="comment"># 更新用户组</span></span><br><span class="line">sudo systemctl restart docker <span class="comment"># 重启 docker-daemon</span></span><br><span class="line">docker version <span class="comment"># 运行 docker</span></span><br></pre></td></tr></table></figure><h2 id="docker-101-tutorial"><a href="https://www.docker.com/101-tutorial" target="_blank" rel="noopener">Docker 101 Tutorial</a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 docker/getting-started</span><br></pre></td></tr></table></figure><p>You'll notice a few flags being used. Here's some more info on them:</p><ul><li><code>-d</code> - run the container in detached mode (in the background)</li><li><code>-p 80:80</code> - map port 80 of the host to port 80 in the container</li><li><code>docker/getting-started</code> - the image to use</li></ul><p>查看 <code>container</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>remove container</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;the-container-id&gt;</span><br></pre></td></tr></table></figure><h2 id="dev-开发">dev 开发</h2><p><code>Dockerfile</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install --production</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>创建 <code>image</code> -t tag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><p>运行刚才创建的 <code>getting-started</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 getting-started</span><br></pre></td></tr></table></figure><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-                &lt;p className="text-center"&gt;No items yet! Add one above!&lt;/p&gt;</span></span><br><span class="line"><span class="addition">+                &lt;p className="text-center"&gt;You have no todo items yet! Add one above!&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/diff.png" /></p><h2 id="docker-hub"><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></h2><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/docker_hub.png" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login -u iosdevlog</span><br><span class="line">docker tag getting-started iosdevlog/getting-started</span><br><span class="line">docker push iosdevlog/getting-started</span><br></pre></td></tr></table></figure><h2 id="play-with-docker"><a href="http://play-with-docker.com/" target="_blank" rel="noopener">Play with Docker</a></h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 iosdevlog/getting-started</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/Play_with_Docker.png" /></p><p>打开 3000 按钮</p><h3 id="持久化-persisting-our-todo-data">持久化 Persisting our Todo Data¶</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create todo-db</span><br><span class="line">docker run -dp 3000:3000 -v todo-db:&#x2F;etc&#x2F;todos iosdevlog&#x2F;getting-started</span><br></pre></td></tr></table></figure><p>数据保存位置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect todo-db</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"CreatedAt"</span>: <span class="string">"2020-03-27T12:28:25Z"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/todo-db/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"todo-db"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/data.png" /></p><h3 id="绑定挂载-using-bind-mounts">绑定挂载 Using Bind Mounts</h3><ul><li><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>Named Volumes</th><th>Bind Mounts</th><th></th></tr></thead><tbody><tr class="odd"><td>Host Location</td><td>Docker chooses</td><td>You control</td></tr><tr class="even"><td>Mount Example (using -v)</td><td>my-volume:/usr/local/data</td><td>/path/to/data:/usr/local/data</td></tr><tr class="odd"><td>Populates new volume with container contents</td><td>Yes</td><td>No</td></tr><tr class="even"><td>Supports Volume Drivers</td><td>Yes</td><td>No</td></tr></tbody></table></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">    -w /app -v <span class="variable">$PWD</span>:/app \</span><br><span class="line">    node:12-alpine \</span><br><span class="line">    sh -c <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br></pre></td></tr></table></figure><p>查看 logs</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f &lt;container-id&gt;</span><br><span class="line">$ nodemon src/index.js</span><br><span class="line">[nodemon] 1.19.2</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Using sqlite database at /etc/todos/todo.db</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p><code>src/static/js/app.js</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-                         &#123;submitting ? 'Adding...' : 'Add Item'&#125;</span></span><br><span class="line"><span class="addition">+                         &#123;submitting ? 'Adding...' : 'Add'&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/add.png" /></p><p>Using bind mounts is very common for local development setups.</p><p>在本地开发设置中，使用绑定挂载很常见。</p><p>开发完成后就可以创建自己的 <code>image</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><h2 id="多个容器-multi-container-apps">多个容器 Multi-Container Apps</h2><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/multi-app-architecture.png" /></p><h3 id="create-the-network.">Create the network.</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create todo-app</span><br></pre></td></tr></table></figure><p>Start a MySQL container and attach it the network.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --network todo-app --network-alias mysql \</span><br><span class="line">    -v todo-mysql-data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=secret \</span><br><span class="line">    -e MYSQL_DATABASE=todos \</span><br><span class="line">    mysql:5.7</span><br></pre></td></tr></table></figure><p>connect to the database</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;mysql-container-id&gt; mysql -p</span><br><span class="line">Enter password: secret</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| todos              |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.05 sec)</span><br></pre></td></tr></table></figure><h3 id="connecting-to-mysql">Connecting to MySQL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network todo-app nicolaka/netshoot</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nicolaka/netshoot:latest</span><br><span class="line">                    dP            dP                           dP   </span><br><span class="line">                    88            88                           88   </span><br><span class="line">88d888b. .d8888b. d8888P .d8888b. 88d888b. .d8888b. .d8888b. d8888P </span><br><span class="line">88<span class="string">'  `88 88ooood8   88   Y8ooooo. 88'</span>  `88 88<span class="string">'  `88 88'</span>  `88   88   </span><br><span class="line">88    88 88.  ...   88         88 88    88 88.  .88 88.  .88   88   </span><br><span class="line">dP    dP `88888P<span class="string">'   dP   `88888P'</span> dP    dP `88888P<span class="string">' `88888P'</span>   dP   </span><br><span class="line">                                                                    </span><br><span class="line">Welcome to Netshoot! (github.com/nicolaka/netshoot)</span><br></pre></td></tr></table></figure><p><code>dig</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig mysql</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="number">9.14</span><span class="number">.8</span> &lt;&lt;&gt;&gt; mysql</span><br><span class="line">;; <span class="keyword">global</span> options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="number">61687</span></span><br><span class="line">;; flags: qr rd ra; QUERY: <span class="number">1</span>, ANSWER: <span class="number">1</span>, AUTHORITY: <span class="number">0</span>, ADDITIONAL: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;mysql.<span class="keyword">IN</span>A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">mysql.<span class="number">600</span><span class="keyword">IN</span>A<span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="number">7</span> msec</span><br><span class="line">;; SERVER: <span class="number">127.0</span><span class="number">.0</span><span class="number">.11</span><span class="meta">#53(127.0.0.11)</span></span><br><span class="line">;; <span class="keyword">WHEN</span>: Fri Mar <span class="number">27</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">31</span> UTC <span class="number">2020</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="number">44</span></span><br></pre></td></tr></table></figure><ul><li>MYSQL_HOST - the hostname for the running MySQL server</li><li>MYSQL_USER - the username to use for the connection</li><li>MYSQL_PASSWORD - the password to use for the connection</li><li>MYSQL_DB - the database to use once connected</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -dp 3000:3000 \</span><br><span class="line">  -w /app -v <span class="variable">$PWD</span>:/app \</span><br><span class="line">  --network todo-app \</span><br><span class="line">  -e MYSQL_HOST=mysql \</span><br><span class="line">  -e MYSQL_USER=root \</span><br><span class="line">  -e MYSQL_PASSWORD=secret \</span><br><span class="line">  -e MYSQL_DB=todos \</span><br><span class="line">  node:12-alpine \</span><br><span class="line">  sh -c <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br></pre></td></tr></table></figure><p><code>docker logs &lt;container-id&gt;</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yarn install v1.22.0</span><br><span class="line">[1/4] Resolving packages...</span><br><span class="line">success Already up-to-date.</span><br><span class="line">Done <span class="keyword">in</span> 0.54s.</span><br><span class="line">yarn run v1.22.0</span><br><span class="line">$ nodemon src/index.js</span><br><span class="line">[nodemon] 1.19.2</span><br><span class="line">[nodemon] to restart at any time, enter `rs`</span><br><span class="line">[nodemon] watching dir(s): *.*</span><br><span class="line">[nodemon] starting `node src/index.js`</span><br><span class="line">Waiting <span class="keyword">for</span> mysql:3306.</span><br><span class="line">Connected!</span><br><span class="line">Connected to mysql db at host mysql</span><br><span class="line">Listening on port 3000</span><br></pre></td></tr></table></figure><p><code>docker exec -ti &lt;mysql-container-id&gt; mysql -p todos</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  select * from todo_items;</span><br><span class="line">+--------------------------------------+---------------------------------------+-----------+</span><br><span class="line">| id                                   | name                                  | completed |</span><br><span class="line">+--------------------------------------+---------------------------------------+-----------+</span><br><span class="line">| 9b3dc86c-2ec9-4413-8a71-28b3c3515358 | DevOps                                |         0 |</span><br><span class="line">| 9428c285-e5e1-4f50-bf11-ee854cc8554f | Hello, I<span class="string">'m AIDevLog. Welcome to 2020! |         0 |</span></span><br><span class="line"><span class="string">+--------------------------------------+---------------------------------------+-----------+</span></span><br><span class="line"><span class="string">2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/03/27/docker/MySQL.png" /></p><h2 id="docker-compose">docker-compose</h2><p><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener" class="uri">https://docs.docker.com/compose/install/</a></p><p>Compose 使用的三个步骤：</p><ol type="1"><li>使用 Dockerfile 定义应用程序的环境。</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.4/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><p>output</p><blockquote><p>docker-compose version 1.25.4, build 8d51620a</p></blockquote><p>Creating our Compose File</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pwd: app</span><br><span class="line">cat docker-compose.yml</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.7"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">node:12-alpine</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">"yarn install &amp;&amp; yarn run dev"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/app</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/app</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">secret</span></span><br><span class="line">      <span class="attr">MYSQL_DB:</span> <span class="string">todos</span></span><br></pre></td></tr></table></figure><p>Running our Application Stack</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f &lt;container-id&gt;</span><br></pre></td></tr></table></figure><p>docker-compose up</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>output</p><blockquote><p>Creating network "app_default" with the default driver<br /><br />Creating volume "app_todo-mysql-data" with default driver<br /><br />Creating app_mysql_1 ... done<br /><br />Creating app_app_1 ... done</p></blockquote><p><code>log</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><p>output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Attaching to app_mysql_1, app_app_1</span><br><span class="line">app_1    | yarn install v1.22.0</span><br><span class="line">app_1    | [1&#x2F;4] Resolving packages...</span><br><span class="line">...</span><br><span class="line">app_1    | Waiting for mysql:3306...............</span><br><span class="line">app_1    | Connected!</span><br><span class="line">app_1    | Connected to mysql db at host mysql</span><br><span class="line">app_1    | Listening on port 3000</span><br><span class="line">mysql_1  | 2020-03-27 16:37:47+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.29-1debian10 started.</span><br><span class="line">...</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.309134Z 0 [Note] Event Scheduler: Loaded 0 events</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.309309Z 0 [Note] mysqld: ready for connections.</span><br><span class="line">mysql_1  | Version: &#39;5.7.29&#39;  socket: &#39;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock&#39;  port: 3306  MySQL Community Server (GPL)</span><br><span class="line">mysql_1  | 2020-03-27T16:38:06.365195Z 2 [Note] Got an error reading communication packets</span><br></pre></td></tr></table></figure><p>Tearing it All Down</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><h2 id="image-building-best-practices">Image Building Best Practices</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">history</span> getting-started</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">7e58c32dc1b5        5 hours ago         /bin/sh -c <span class="comment">#(nop)  CMD ["node" "/app/src/ind…   0B                  </span></span><br><span class="line">ebe4a0dcca7e        5 hours ago         /bin/sh -c yarn install --production            83.2MB              </span><br><span class="line">3fd0eef12d70        5 hours ago         /bin/sh -c <span class="comment">#(nop) COPY dir:2f31be1c05e031e42…   6.65MB              </span></span><br><span class="line">c164b9c205a1        5 hours ago         /bin/sh -c <span class="comment">#(nop) WORKDIR /app                  0B                  </span></span><br><span class="line">f77abbe89ac1        3 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["node"]                 0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENTRYPOINT ["docker-entry…   0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop) COPY file:238737301d473041…   116B                </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c apk add --no-cache --virtual .bui…   7.62MB              </span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENV YARN_VERSION=1.22.0      0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.9MB              </span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  ENV NODE_VERSION=12.16.1     0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/sh"]              0B                  </span></span><br><span class="line">&lt;missing&gt;           3 days ago          /bin/sh -c <span class="comment">#(nop) ADD file:0c4555f363c2672e3…   5.6MB</span></span><br></pre></td></tr></table></figure><h3 id="layer-caching">Layer Caching¶</h3><p>Update the Dockerfile to copy in the <code>package.json</code></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json yarn.lock ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install --production</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span></span><br></pre></td></tr></table></figure><p>Build a new image using docker build</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t getting-started .</span><br></pre></td></tr></table></figure><p>更改 <code>src/static/index.html</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/static/index.html b/src/static/index.html</span><br><span class="line">index a606bf1..19cfb57 100644</span><br><span class="line"><span class="comment">--- a/src/static/index.html</span></span><br><span class="line"><span class="comment">+++ b/src/static/index.html</span></span><br><span class="line"><span class="meta">@@ -8,7 +8,7 @@</span></span><br><span class="line">     &lt;link rel="stylesheet" href="css/font-awesome/all.min.css" crossorigin="anonymous" /&gt;</span><br><span class="line">     &lt;link href="https://fonts.googleapis.com/css?family=Lato&amp;display=swap" rel="stylesheet" /&gt;</span><br><span class="line">     &lt;link rel="stylesheet" href="css/styles.css" /&gt;</span><br><span class="line"><span class="deletion">-    &lt;title&gt;Todo App&lt;/title&gt;</span></span><br><span class="line"><span class="addition">+    &lt;title&gt;AIDevLog Todo App&lt;/title&gt;</span></span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">     &lt;div id="root"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>docker build</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t getting-started .</span><br><span class="line">Sending build context to Docker daemon  65.73MB</span><br><span class="line">Step 1/6 : FROM node:12-alpine</span><br><span class="line"> ---&gt; f77abbe89ac1</span><br><span class="line">Step 2/6 : WORKDIR /app</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; c164b9c205a1</span><br><span class="line">Step 3/6 : COPY package.json yarn.lock ./</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 77446d8145bc</span><br><span class="line">Step 4/6 : RUN yarn install --production</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f0323073e6ce</span><br><span class="line">Step 5/6 : COPY . .</span><br><span class="line"> ---&gt; 0e1288f88991</span><br><span class="line">Step 6/6 : CMD [<span class="string">"node"</span>, <span class="string">"/app/src/index.js"</span>]</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> f3a0bd941311</span><br><span class="line">Removing intermediate container f3a0bd941311</span><br><span class="line"> ---&gt; 2abff2421550</span><br><span class="line">Successfully built 2abff2421550</span><br><span class="line">Successfully tagged getting-started:latest</span><br></pre></td></tr></table></figure><h2 id="docker-cheatsheets.md"><a href="https://gist.github.com/JustinTW/10236453" target="_blank" rel="noopener">Docker-Cheatsheets.md</a></h2><h3 id="clean-all">Clean all</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop `docker ps -a -q` </span><br><span class="line">docker rm `docker ps -a -q` </span><br><span class="line">docker rmi -f `sudo docker images -q`</span><br><span class="line">docker volume rm $(docker volume ls -f dangling=<span class="literal">true</span> -q)</span><br></pre></td></tr></table></figure><h3 id="clean-image">Clean <none> image</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images --no-trunc | grep none | awk <span class="string">'&#123;print $3&#125;'</span> | xargs docker rmi -f</span><br></pre></td></tr></table></figure><h3 id="change-docker-image-location">Change docker image location</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btrfs subvolume create /mnt/disk/@docker</span><br><span class="line">rsync -aqxP /var/lib/docker/* /mnt/disk/@docker</span><br></pre></td></tr></table></figure><ul><li>method 1: <code>變更 docker 儲存路徑</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>:[<span class="string">"https://cache-docker.hopebaytech.com"</span>],</span><br><span class="line">  <span class="string">"insecure-registries"</span>:[<span class="string">"docker:5000"</span>],</span><br><span class="line">  <span class="string">"dns"</span>:[<span class="string">"172.16.1.254"</span>, <span class="string">"8.8.8.8"</span>],</span><br><span class="line">  <span class="string">"graph"</span>: <span class="string">"/mnt/disk/docker"</span>,</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"btrfs"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新啟動服務</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="啟動設定檔位置">啟動設定檔位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#x2F;etc&#x2F;default&#x2F;docker</span><br><span class="line">&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;docker.conf</span><br></pre></td></tr></table></figure><h3 id="attach-a-running-container">Attach a running container</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list containers</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach a running containers</span></span><br><span class="line">docker attach [CONTAINER ID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach a running containers into bash</span></span><br><span class="line">docker <span class="built_in">exec</span> -i -t arkease-pro-web bash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/27/docker/docker-cheat-sheet.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Image/镜像: 系统镜像 CentOS.iso&lt;/li&gt;
&lt;li&gt;Container/容器: 虚拟机 VM&lt;/li&gt;
&lt;li&gt;Docker Hub: 镜像中心 GitHub&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://2020.iosdevlog.com/categories/docker/"/>
    
    
      <category term="devops" scheme="https://2020.iosdevlog.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>AI Cheatsheets</title>
    <link href="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/"/>
    <id>https://2020.iosdevlog.com/2020/03/26/aicheatsheets/</id>
    <published>2020-03-26T15:45:13.000Z</published>
    <updated>2020-03-26T16:41:00.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scipy.png" /></p><p>我什么时候能总结得这么好呢？</p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Numpy.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Pandas-3.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/matplotlib-cheatsheet.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Matplotlib.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scikit_learn.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_network_cells.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_network_graphs.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Neural_networks_zoo.png" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-1.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-2.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/tensorflow_v_2.0-3.jpg" /><br /><img src="https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Keras.jpg" /></p><p><a href="https://aicheatsheets.com" target="_blank" rel="noopener" class="uri">https://aicheatsheets.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/26/aicheatsheets/Scipy.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我什么时候能总结得这么好呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="cheatsheets" scheme="https://2020.iosdevlog.com/tags/cheatsheets/"/>
    
      <category term="numpy" scheme="https://2020.iosdevlog.com/tags/numpy/"/>
    
      <category term="scipy" scheme="https://2020.iosdevlog.com/tags/scipy/"/>
    
      <category term="matplotlib" scheme="https://2020.iosdevlog.com/tags/matplotlib/"/>
    
      <category term="pandas" scheme="https://2020.iosdevlog.com/tags/pandas/"/>
    
      <category term="tf" scheme="https://2020.iosdevlog.com/tags/tf/"/>
    
      <category term="keras" scheme="https://2020.iosdevlog.com/tags/keras/"/>
    
  </entry>
  
  <entry>
    <title>表格化数据挖掘</title>
    <link href="https://2020.iosdevlog.com/2020/03/25/table/"/>
    <id>https://2020.iosdevlog.com/2020/03/25/table/</id>
    <published>2020-03-25T10:06:00.000Z</published>
    <updated>2020-03-25T13:52:39.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/03/25/table/0.png" /></p><a id="more"></a><h2 id="经典的结构化数据挖掘方法">经典的结构化数据挖掘方法</h2><h3 id="什么是结构化数据">什么是结构化数据</h3><ul><li><p>结构化数据指的主要是表格数据(Tabular Data)</p></li><li><p>最简单的想象:可以记载在 Excel 表格中的均是表格数据</p><ul><li><p>每列数据一般称之为一个变量(字段)</p></li><li><p>变量可以分为离散型变量和连续型变量</p></li></ul></li><li><p>绝大多数的数据都是表格数据(或可以转化为表格数据)</p></li></ul><h3 id="结构化数据的传统建模流程">结构化数据的传统建模流程</h3><ul><li><p>传统来说(在某种意义上仍是如此)，结构化数据常常要求大量的业务理解</p></li><li><p>探索性数据分析往往占很大成分</p></li><li><p>90% 时间花在清洗数据和探索性分析上</p></li></ul><h3 id="传统建模流程的问题">传统建模流程的问题</h3><ul><li><p>最核心的悖论:业务理解从哪里来?</p></li><li><p>一些实际的问题</p><ul><li><p>高维稀疏变量</p></li><li><p>较差的变量质量</p></li><li><p>类似的业务理解能力</p></li><li><p>业务的多变性</p></li></ul></li></ul><h2 id="表格化数据挖掘基本流程">表格化数据挖掘基本流程</h2><h3 id="数据挖掘竞赛和新的建模流程">数据挖掘竞赛和新的建模流程</h3><ul><li><p>竞赛基本流程</p></li><li><p>挑战</p><ul><li><p>无业务理解</p></li><li><p>少数提交机会</p></li><li><p>测试集和训练集可能不一样-&gt; 建模结果必须稳定</p></li><li><p>时间短暂，必须充分利用时间</p></li></ul></li><li><p>数据挖掘竞赛和实际业务中的建模有类似挑战，但有一点重要不同</p><ul><li>实际业务建模必须要逐步引入更多变量，而竞赛中变量已经给定</li></ul></li></ul><h3 id="新的流程">新的流程</h3><ul><li><p>数据清理和EDA</p></li><li><p>半自动的变量构建+手动构建</p></li><li><p>一类模型主要提高准确率，另一些模型做集成备选</p><ul><li><p>传统来说主要用于提高准确率的是靠集成树的方法</p></li><li><p>近年来神经网络为基础的建模越来越多</p></li></ul></li><li><p>集成学习</p><ul><li><p>被集成的模型必须有一定准确性</p></li><li><p>被集成的模型必须有一定的多样性</p></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/03/25/table/1.png" /></p><p><img src="https://2020.iosdevlog.com/2020/03/25/table/2.png" /></p><h3 id="关于新的流程的一些说明">关于新的流程的一些说明</h3><ul><li><p>前三个环节经常需要反复进行</p></li><li><p>基本原则:尽可能利用算力和时间</p></li><li><p>不同人对于 EDA 重要性说法不同，个人建议初学者以实验为主</p></li><li><p>非常重要的原则:结合全局和局部信息</p></li></ul><h2 id="半自动特征构建">半自动特征构建</h2><h3 id="target-mean-encoding">Target Mean Encoding</h3><ul><li><p>Target Mean Encoding 简介</p><ul><li><p>对于离散变量最有效编码方法之一</p></li><li><p>对于维度较高的离散性变量效果很好</p></li><li><p>重点在于防止过拟合</p></li></ul></li><li><p>其他的 Groupby 函数应用</p><ul><li><p>实现 Target Mean Encoding 可以使用 df.groupby([A,B])[C].agg(func)</p></li><li><p>Groupby 函数可以应用于任何其他变量，在某种程度上捕捉了多变量之间的交叉效应</p></li><li><p>Func 可以是多种函数，如 mean，std，kurtosis，min，max 等等</p></li><li><p>可以对残差进行以上操作</p></li></ul></li></ul><h3 id="categorical-encoders">Categorical Encoders</h3><ul><li><p>One-hot Encoder</p></li><li><p>Ordinal Encoder</p></li><li><p>其他 Encoder</p><ul><li><p>Count Encoder</p></li><li><p>HashMap</p></li></ul></li></ul><h3 id="连续变量的离散化方法">连续变量的离散化方法</h3><ul><li><p>为什么要对连续变量进行离散化</p><ul><li><p>捕捉非线性效应</p></li><li><p>捕捉交叉效应</p></li></ul></li><li><p>常见的离散化方法</p><ul><li><p>Uniform</p></li><li><p>基于 Quantile</p></li><li><p>基于聚类</p></li><li><p>基于树</p></li></ul></li><li><p>树模型</p></li></ul><h3 id="entity-embedding">Entity Embedding</h3><ul><li><p>Entity Embedding 基础</p></li><li><p>如何加入 Vincinal Information</p></li></ul><h3 id="连续变量的转换">连续变量的转换</h3><ul><li><p>常见的数据转换方法</p></li><li><p>基于 ECDF 的方法</p></li><li><p>Box-Cox 变换和 Yeo-Johnson Transform</p></li></ul><h3 id="缺失值和异常值的处理">缺失值和异常值的处理</h3><ul><li><p>概述</p><ul><li><p>异常值和缺失值的定义常常是难以确定的</p></li><li><p>异常值的检验最可靠的方法</p><ul><li><p>EDA 加上业务逻辑</p></li><li><p>可以根据分位数或其他方法(其他方法未必靠谱)</p></li><li><p>如果异常值是由于输入失误造成的，则可以将之作为缺失值处理</p></li></ul></li><li><p>缺失值的填充往往可以根据业务决定</p><ul><li><p>其他可以采用平均值、中位数或众数进行填充</p></li><li><p>也可以单独构建模型进行预测</p></li></ul></li></ul></li><li><p>常见处理方法</p><ul><li><p>缺失值的填充往往可以根据业务决定</p></li><li><p>缺失和异常本身可能是有信息量的，可以构造哑变量进行处理</p><ul><li>成租的缺失值和异常值本身可能是有信息的</li></ul></li><li><p>对于部分异常值，还需要进行截断处理</p></li><li><p>对于重要的缺失变量，很有可能需要进行预测</p></li><li><p>R 中的一些包，如 MICE，可以帮助进行缺失值和异常值的处理</p></li></ul></li></ul><h2 id="自动特征构建方法">自动特征构建方法</h2><h3 id="自动特征挖掘">自动特征挖掘</h3><ul><li><p>应用</p></li><li><p>难点:组合优化问题</p></li></ul><h3 id="遗传算法简介">遗传算法简介</h3><h3 id="symbolic-learning-简介">Symbolic Learning 简介</h3><ul><li><p>采用遗传算法找寻如何构造衍生变量</p></li><li><p>在 gplearn 库当中已经实现</p></li></ul><h3 id="autocross-简介">AutoCross 简介</h3><ul><li><p>第四范式开发(未开源)</p></li><li><p>主要目的:寻找交叉效应</p></li><li><p>创新</p><ul><li><p>Beam Search</p></li><li><p>简化的逻辑回归求解方式</p></li></ul></li><li><p>可以进行提升</p><ul><li><p>Meta Feature</p></li><li><p>更好的优化方法</p></li></ul></li></ul><h2 id="降维方法">降维方法</h2><h3 id="pcanmf-和-tsne">PCA，NMF 和 tSNE</h3><ul><li><p>为什么要降维</p><ul><li><p>找到宏观信息</p></li><li><p>找到交叉效应</p></li><li><p>不建议先降维再拟合模型</p></li></ul></li><li><p>PCA和NMF简介</p></li><li><p>tSNE 简介</p></li><li><p>实现</p><ul><li><p>在 sklearn 当中均有实现</p><ul><li><p>PCA</p></li><li><p>NMF</p></li><li><p>tSNE</p></li></ul></li></ul></li><li><p>应用</p><ul><li><p>隐藏维度的选择取决于数据</p></li><li><p>数据需要进行预处理</p></li><li><p>标准化</p></li><li><p>选取重要变量</p></li><li><p>去掉过于稀疏的个别变量</p></li><li><p>可构建2折和3折交叉效应</p></li><li><p>降维方法的参数并不十分重要，一般来说如果有时间，选取所有参数并拟合模型进行测试</p></li></ul></li></ul><h3 id="denoising-autoencoder">Denoising AutoEncoder</h3><ul><li><p>Denoising AutoEncoder 简介</p></li><li><p>实践中的注意事项</p><ul><li><p>DAE 一般对多模态有很好效果</p></li><li><p>一般的噪声范畴:5%-20%</p></li><li><p>其他降维方法的 trick 也适用于 DAE</p></li><li><p>注意将中间层均拿出来进行预测</p></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/03/25/table/3.png" /></p><h3 id="variational-autoencoder">Variational AutoEncoder</h3><ul><li><p>Variational AutoEncoder 的数学形式</p></li><li><p>实践中的注意事项</p><ul><li><p>VAE 的实现可见</p></li><li><p>VAE 是很火的研究领域</p></li><li><p>训练常常难以收敛</p></li><li><p>在实际应用中较罕见</p></li></ul></li></ul><h2 id="变量选择方法">变量选择方法</h2><h3 id="概述">概述</h3><ul><li><p>变量重要 = 哲学问题</p></li><li><p>优化角度 = 组合优化问题</p></li><li><p>初步选择可根据数据特点</p><ul><li>最重要的指标为缺失值和变化率</li></ul></li><li><p>其他的一些选择方法</p><ul><li><p>“去一”的选择方法(主要方法)</p></li><li><p>模型相关的方法-&gt;和模型高度相关，不可靠</p></li><li><p>其他优化方法-&gt;不成熟</p></li></ul></li></ul><h3 id="去一选择法">“去一”选择法</h3><ul><li><p>整体流程</p></li><li><p>问题</p></li></ul><h2 id="集成树模型">集成树模型</h2><h3 id="概述-1">概述</h3><ul><li><p>树模型的缺点和优点</p><ul><li><p>优点</p><ul><li><p>非线性效应</p></li><li><p>交叉效应</p></li><li><p>稀疏</p></li></ul></li><li><p>缺点</p><ul><li><p>不稳定</p></li><li><p>表现力差</p></li><li><p>精度差</p></li></ul></li></ul></li><li><p>集成树模型分类</p><ul><li><p>基本思路</p><ul><li>将多个树模型构成进行平均</li></ul></li><li><p>方法</p><ul><li><p>随机森林类</p></li><li><p>随机森林</p></li><li><p>ExtraTrees</p></li><li><p>梯度提升树</p><ul><li><p>GBDT</p></li><li><p>XGBoost</p></li><li><p>LightGBM</p></li><li><p>CatBoost</p></li></ul></li></ul></li></ul></li></ul><h3 id="gbdt-和-xgboost">GBDT 和 XgBoost</h3><ul><li><p>GBDT 的数学</p></li><li><p>XgBoost 的数学</p></li><li><p>XgBoost 的实现</p></li><li><p>XgBoost 的重要参数</p><ul><li><p>最重要的参数</p><ul><li>树的深度</li></ul></li><li><p>其他参数</p><ul><li><p>Eta:一般选取为 0.01-0.2</p></li><li><p>min_child_weight:建议进行 CV finetune</p></li><li><p>Gamma:建议进行 CV finetune</p></li></ul></li></ul></li></ul><p>整理自：<a href="https://github.com/geektime-geekbang/NLP" target="_blank" rel="noopener">《NLP实战高手课》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/03/25/table/0.png&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="DataMining" scheme="https://2020.iosdevlog.com/tags/DataMining/"/>
    
  </entry>
  
</feed>
