<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Game 2020</title>
  
  <subtitle>https://2020.iosdevlog.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://2020.iosdevlog.com/"/>
  <updated>2020-02-19T09:59:27.736Z</updated>
  <id>https://2020.iosdevlog.com/</id>
  
  <author>
    <name>iOSDevLog</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《东野圭吾作品：11字谜案》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/19/9787020156047/"/>
    <id>https://2020.iosdevlog.com/2020/02/19/9787020156047/</id>
    <published>2020-02-19T03:34:10.000Z</published>
    <updated>2020-02-19T09:59:27.736Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/19/9787020156047/1.svg" alt="《东野圭吾作品：11字谜案》人物关系图"></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/02/19/9787020156047/2.jpg" alt="《东野圭吾作品：11字谜案》"></p><p>东野圭吾作品：11字谜案<br>作者：[日]东野圭吾<br>译者：羊恩媺<br>出版社：人民文学出版社<br>出版时间：2020-01<br>ISBN：9787020156047</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/19/9787020156047/1.svg&quot; alt=&quot;《东野圭吾作品：11字谜案》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch iOS</title>
    <link href="https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/"/>
    <id>https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/</id>
    <published>2020-02-18T14:30:04.000Z</published>
    <updated>2020-02-19T15:42:25.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/1.png" alt="小武"></p><a id="more"></a><h2 id="Xcode-Reset"><a href="#Xcode-Reset" class="headerlink" title="Xcode Reset"></a>Xcode Reset</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default delete com.apple.Xcode</span><br></pre></td></tr></table></figure><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br><span class="line">cat Podfile</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Uncomment the next line to define a global platform for your project</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'12.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'PyTorch_iOS'</span> <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Comment the next line if you don't want to use dynamic frameworks</span></span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Pods for PyTorch_iOS</span></span><br><span class="line">  pod <span class="string">'LibTorch'</span>, <span class="string">'~&gt; 1.4.0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><p><code>trace_model.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">model = torchvision.models.mobilenet_v2(pretrained=<span class="literal">True</span>)</span><br><span class="line">model.eval()</span><br><span class="line">example = torch.rand(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">traced_script_module = torch.jit.trace(model, example)</span><br><span class="line">traced_script_module.save(<span class="string">"model.pt"</span>)</span><br></pre></td></tr></table></figure><p>模型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://download.pytorch.org/models/mobilenet_v2-b0353104.pth</span><br><span class="line">cp mobilenet_v2-b0353104.pth /Users/iosdevlog/.cache/torch/checkpoints/mobilenet_v2-b0353104.pth</span><br><span class="line">python trace_model.py</span><br></pre></td></tr></table></figure><p>拖动生成的 <code>model.pt</code> 到 <code>iOS</code> 项目。</p><h2 id="拍照-相册"><a href="#拍照-相册" class="headerlink" title="拍照/相册"></a>拍照/相册</h2><p><code>Info.plist</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSCameraUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Camera Usage Description<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSPhotoLibraryUsageDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>Photo Library Usage Description<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>拍照/相册选择图片</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://pytorch.org/mobile/ios/" alt="官文教程"></h2><p>要在 <code>iOS</code> 上开始使用 <code>PyTorch</code>，我们建议您浏览以下<a href="https://github.com/pytorch/ios-demo-app/tree/master/HelloWorld" target="_blank" rel="noopener">HelloWorld</a>。</p><h2 id="HELLO-WORLD示例快速入门"><a href="#HELLO-WORLD示例快速入门" class="headerlink" title="HELLO WORLD示例快速入门"></a>HELLO WORLD示例快速入门<a href="https://pytorch.org/mobile/ios/#quickstart-with-a-hello-world-example" target="_blank" rel="noopener"></a></h2><p>HelloWorld是一个简单的图像分类应用程序，演示了如何在iOS上使用PyTorch C ++库。该代码用Swift编写，并使用Objective-C作为桥梁。</p><h3 id="模型准备"><a href="#模型准备" class="headerlink" title="模型准备"></a>模型准备<a href="https://pytorch.org/mobile/ios/#model-preparation" target="_blank" rel="noopener"></a></h3><p>让我们从模型准备开始。如果您熟悉PyTorch，您可能应该已经知道如何训练和保存模型。如果您没有，我们将使用预先训练的图像分类模型<a href="https://pytorch.org/hub/pytorch_vision_mobilenet_v2/" target="_blank" rel="noopener">-MobileNet v2</a>，该模型已经包装在<a href="https://pytorch.org/docs/stable/torchvision/index.html" target="_blank" rel="noopener">TorchVision中</a>。要安装它，请运行以下命令。</p><blockquote><p>我们强烈建议您遵循<a href="https://github.com/pytorch/pytorch" target="_blank" rel="noopener">Pytorch Github页面</a>在本地计算机上设置Python开发环境。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure><p>成功安装TorchVision后，让我们导航到HelloWorld文件夹并运行<code>trace_model.py</code>。该脚本包含跟踪和保存可在移动设备上运行的<a href="https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html" target="_blank" rel="noopener">Torchscript模型</a>的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python trace_model.py</span><br></pre></td></tr></table></figure><p>如果一切正常，我们应该<code>model.pt</code>在<code>HelloWorld</code>文件夹中生成模型。现在将模型文件复制到我们的应用程序文件夹中<code>HelloWorld/model</code>。</p><blockquote><p>要了解有关TorchScript的更多详细信息，请访问<a href="https://pytorch.org/tutorials/advanced/cpp_export.html" target="_blank" rel="noopener">pytorch.org上的教程。</a></p></blockquote><h3 id="通过Cocoapods安装LibTorch"><a href="#通过Cocoapods安装LibTorch" class="headerlink" title="通过Cocoapods安装LibTorch"></a>通过Cocoapods安装LibTorch<a href="https://pytorch.org/mobile/ios/#install-libtorch-via-cocoapods" target="_blank" rel="noopener"></a></h3><p>PyTorch C++库在<a href="https://cocoapods.org/" target="_blank" rel="noopener">Cocoapods中</a>可用，可以将其集成到我们的项目中，只需运行即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>现在是时候<code>HelloWorld.xcworkspace</code>在XCode中打开，选择一个iOS模拟器并启动它（cmd + R）。如果一切正常，我们应该在模拟器屏幕上看到狼的图片以及预测结果。</p><p>我已经加了一张新图片。</p><p>![iOS 模拟器]](<a href="https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/Simulator.png">https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/Simulator.png</a>)</p><h3 id="代码演练"><a href="#代码演练" class="headerlink" title="代码演练"></a>代码演练<a href="https://pytorch.org/mobile/ios/#code-walkthrough" target="_blank" rel="noopener"></a></h3><p>在这一部分中，我们将逐步介绍代码。</p><h4 id="图片载入"><a href="#图片载入" class="headerlink" title="图片载入"></a>图片载入<a href="https://pytorch.org/mobile/ios/#image-loading" target="_blank" rel="noopener"></a></h4><p>让我们从图像加载开始。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="type">UIImage</span>(named: <span class="string">"image.jpg"</span>)!</span><br><span class="line">imageView.image = image</span><br><span class="line"><span class="keyword">let</span> resizedImage = image.resized(to: <span class="type">CGSize</span>(width: <span class="number">224</span>, height: <span class="number">224</span>))</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">var</span> pixelBuffer = resizedImage.normalized() <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先从包中加载图像，然后将其调整为224x224。然后，我们将此<code>normalized()</code>类别方法称为归一化像素缓冲区。让我们仔细看看下面的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> normalizedBuffer: [<span class="type">Float32</span>] = [<span class="type">Float32</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: w * h * <span class="number">3</span>)</span><br><span class="line"><span class="comment">// normalize the pixel buffer</span></span><br><span class="line"><span class="comment">// see https://pytorch.org/hub/pytorch_vision_resnet/ for more detail</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; w * h &#123;</span><br><span class="line">    normalizedBuffer[i]             = (<span class="type">Float32</span>(rawBytes[i * <span class="number">4</span> + <span class="number">0</span>]) / <span class="number">255.0</span> - <span class="number">0.485</span>) / <span class="number">0.229</span> <span class="comment">// R</span></span><br><span class="line">    normalizedBuffer[w * h + i]     = (<span class="type">Float32</span>(rawBytes[i * <span class="number">4</span> + <span class="number">1</span>]) / <span class="number">255.0</span> - <span class="number">0.456</span>) / <span class="number">0.224</span> <span class="comment">// G</span></span><br><span class="line">    normalizedBuffer[w * h * <span class="number">2</span> + i] = (<span class="type">Float32</span>(rawBytes[i * <span class="number">4</span> + <span class="number">2</span>]) / <span class="number">255.0</span> - <span class="number">0.406</span>) / <span class="number">0.225</span> <span class="comment">// B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看，这些代码可能看起来很奇怪，但是一旦我们理解了模型，它就会变得有意义。输入数据是形状为（3 x H x W）的3通道RGB图像，其中H和W至少应为224。图像必须加载到的范围内<code>[0, 1]</code>，然后使用<code>mean = [0.485, 0.456, 0.406]</code>和进行归一化<code>std = [0.229, 0.224, 0.225]</code>。</p><h4 id="TorchScript模块"><a href="#TorchScript模块" class="headerlink" title="TorchScript模块"></a>TorchScript模块<a href="https://pytorch.org/mobile/ios/#torchscript-module" target="_blank" rel="noopener"></a></h4><p>现在我们已经对输入数据进行了预处理，并且有了预先训练的TorchScript模型，下一步就是使用它们来运行谓词。为此，我们首先将模型加载到应用程序中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> module: <span class="type">TorchModule</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> filePath = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"model"</span>, ofType: <span class="string">"pt"</span>),</span><br><span class="line">        <span class="keyword">let</span> module = <span class="type">TorchModule</span>(fileAtPath: filePath) &#123;</span><br><span class="line">        <span class="keyword">return</span> module</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Can't find the model file!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>请注意，<code>TorchModule</code>该类是的Objective-C包装器<code>torch::jit::script::Module</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch::jit::script::<span class="type">Module</span> module = torch::jit::load(filePath.<span class="type">UTF8String</span>);</span><br></pre></td></tr></table></figure><p>由于Swift无法直接与C ++对话，因此我们必须使用Objective-C类作为桥梁，或者为C ++库创建C包装器。出于演示目的，我们将把所有内容包装在这个Objective-C类中。但是，我们正在努力为PyTorch提供Swift / Objective-C API包装器。敬请关注！</p><h4 id="运行推断"><a href="#运行推断" class="headerlink" title="运行推断"></a>运行推断<a href="https://pytorch.org/mobile/ios/#run-inference" target="_blank" rel="noopener"></a></h4><p>现在该进行推断并获取结果了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> outputs = module.predict(image: <span class="type">UnsafeMutableRawPointer</span>(&amp;pixelBuffer)) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，该<code>predict</code>方法只是一个Objective-C包装器。在后台，它调用C ++ <code>forward</code>函数。让我们看一下它是如何实现的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">at::<span class="type">Tensor</span> tensor = torch::from_blob(imageBuffer, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>&#125;, at::kFloat);</span><br><span class="line">torch::autograd::<span class="type">AutoGradMode</span> <span class="keyword">guard</span>(<span class="literal">false</span>);</span><br><span class="line">auto outputTensor = _impl.forward(&#123;tensor&#125;).toTensor();</span><br><span class="line">float* floatBuffer = outputTensor.data_ptr&lt;float&gt;();</span><br></pre></td></tr></table></figure><p>C ++函数<code>torch::from_blob</code>将从像素缓冲区创建输入张量。请注意，张量的形状<code>{1,3,224,224}</code>代表<code>NxCxWxH</code>我们在上一节中讨论的形状。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch::autograd::<span class="type">AutoGradMode</span> <span class="keyword">guard</span>(<span class="literal">false</span>);</span><br><span class="line">at::<span class="type">AutoNonVariableTypeMode</span> non_var_type_mode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>以上两行告诉PyTorch引擎仅进行推断。这是因为默认情况下，PyTorch内置了对进行自动分化的支持，这也称为<a href="https://pytorch.org/docs/stable/notes/autograd.html" target="_blank" rel="noopener">autograd</a>。由于我们不进行手机培训，因此我们可以禁用自动毕业模式。</p><p>最后，我们可以调用此<code>forward</code>函数以获取输出张量并将其转换为<code>float</code>缓冲区。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto outputTensor = _impl.forward(&#123;tensor&#125;).toTensor();</span><br><span class="line">float* floatBuffer = outputTensor.data_ptr&lt;float&gt;();</span><br></pre></td></tr></table></figure><h3 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果<a href="https://pytorch.org/mobile/ios/#collect-results" target="_blank" rel="noopener"></a></h3><p>输出张量是形状为1x1000的一维浮点数组，其中每个值表示从图像预测标签的置信度。下面的代码对数组进行排序，并检索前三个结果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zippedResults = <span class="built_in">zip</span>(labels.<span class="built_in">indices</span>, outputs)</span><br><span class="line"><span class="keyword">let</span> sortedResults = zippedResults.sorted &#123; $<span class="number">0.1</span>.floatValue &gt; $<span class="number">1.1</span>.floatValue &#125;.<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="PyTorch演示应用"><a href="#PyTorch演示应用" class="headerlink" title="PyTorch演示应用"></a>PyTorch演示应用<a href="https://pytorch.org/mobile/ios/#pytorch-demo-app" target="_blank" rel="noopener"></a></h3><p>对于更复杂的用例，我们建议您检查<a href="https://github.com/pytorch/ios-demo-app" target="_blank" rel="noopener">PyTorch演示应用程序</a>。该演示应用程序包含两个展示柜。一个运行量化模型的相机应用程序，可以实时预测来自设备后置相机的图像。还有一个基于文本的应用程序，它使用文本分类模型来根据输入字符串预测主题。</p><h2 id="从源代码构建PYTORCH-IOS库"><a href="#从源代码构建PYTORCH-IOS库" class="headerlink" title="从源代码构建PYTORCH IOS库"></a>从源代码构建PYTORCH IOS库<a href="https://pytorch.org/mobile/ios/#build-pytorch-ios-libraries-from-source" target="_blank" rel="noopener"></a></h2><p>要跟踪iOS的最新更新，您可以从源代码构建PyTorch iOS库。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --recursive https:<span class="comment">//github.com/pytorch/pytorch</span></span><br><span class="line">cd pytorch</span><br><span class="line"># <span class="keyword">if</span> you are updating an existing checkout</span><br><span class="line">git submodule sync</span><br><span class="line">git submodule update --<span class="keyword">init</span> --recursive</span><br></pre></td></tr></table></figure><blockquote><p>确保已<code>cmake</code>在本地计算机上正确安装了Python。我们建议您遵循<a href="https://github.com/pytorch/pytorch" target="_blank" rel="noopener">Pytorch Github页面</a>来设置Python开发环境</p></blockquote><h3 id="为iOS模拟器构建LibTorch"><a href="#为iOS模拟器构建LibTorch" class="headerlink" title="为iOS模拟器构建LibTorch"></a>为iOS模拟器构建LibTorch<a href="https://pytorch.org/mobile/ios/#build-libtorch-for-ios-simulators" target="_blank" rel="noopener"></a></h3><p>打开终端并导航到PyTorch根目录。运行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUILD_PYTORCH_MOBILE=1 IOS_PLATFORM=SIMULATOR ./scripts/build_ios.sh</span><br></pre></td></tr></table></figure><p>构建成功后，所有静态库和头文件将在 <code>build_ios/install</code></p><h3 id="为arm64设备构建LibTorch"><a href="#为arm64设备构建LibTorch" class="headerlink" title="为arm64设备构建LibTorch"></a>为arm64设备构建LibTorch<a href="https://pytorch.org/mobile/ios/#build-libtorch-for-arm64-devices" target="_blank" rel="noopener"></a></h3><p>打开终端并导航到PyTorch根目录。运行以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUILD_PYTORCH_MOBILE=1 IOS_ARCH=arm64 ./scripts/build_ios.sh</span><br></pre></td></tr></table></figure><p>构建成功后，所有静态库和头文件将在 <code>build_ios/install</code></p><h3 id="XCode设置"><a href="#XCode设置" class="headerlink" title="XCode设置"></a>XCode设置<a href="https://pytorch.org/mobile/ios/#xcode-setup" target="_blank" rel="noopener"></a></h3><p>在XCode中打开您的项目，将所有静态库以及头文件复制到您的项目中。导航到项目设置，将“ <strong>Header Search Paths</strong> ”值设置为刚复制的头文件的路径。</p><p>在构建设置中，搜索<strong>其他链接器标志</strong>。在下面添加自定义链接器标志</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-force_load $(PROJECT_DIR)/<span class="variable">$&#123;path-to-libtorch.a&#125;</span></span><br></pre></td></tr></table></figure><p>最后，通过选择“构建设置”，搜索“ <strong>启用位码”</strong>，然后将值设置为<strong>No</strong>，为目标禁用位码。</p><h3 id="API文件"><a href="#API文件" class="headerlink" title="API文件"></a>API文件<a href="https://pytorch.org/mobile/ios/#api-docs" target="_blank" rel="noopener"></a></h3><p>当前，iOS框架直接使用Pytorch C ++前端API。可以在<a href="https://pytorch.org/cppdocs/" target="_blank" rel="noopener">这里</a>找到C ++文档。要了解更多信息，我们建议在PyTorch网页上浏览<a href="https://pytorch.org/tutorials/advanced/cpp_frontend.html" target="_blank" rel="noopener">C ++前端教程</a>。同时，我们正在努力为PyTorch提供Swift / Objective-C API包装器。</p><h3 id="定制版"><a href="#定制版" class="headerlink" title="定制版"></a>定制版<a href="https://pytorch.org/mobile/ios/#custom-build" target="_blank" rel="noopener"></a></h3><p>从1.4.0开始，PyTorch支持自定义构建。现在，您可以构建PyTorch库，其中仅包含模型所需的运算符。为此，请按照以下步骤操作</p><p>1.确认您的PyTorch版本为1.4.0或更高版本。您可以通过检查的值来实现<code>torch.__version__</code>。</p><p>2.要转储模型中的运算符，请说<code>MobileNetV2</code>运行以下几行Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch, yaml</span><br><span class="line">model = torch.jit.load(<span class="string">'MobileNetV2.pt'</span>)</span><br><span class="line">ops = torch.jit.export_opnames(model)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'MobileNetV2.yaml'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> output:</span><br><span class="line">    yaml.dump(ops, output)</span><br></pre></td></tr></table></figure><p>在上面的代码段中，您首先需要加载ScriptModule。然后，使用<code>export_opnames</code>来返回ScriptModule及其子模块的运算符名称的列表。最后，将结果保存在yaml文件中。</p><p>3.要使用准备好的yaml运算符列表在本地运行iOS构建脚本，请将从最后一步生成的yaml文件传递到环境变量中<code>SELECTED_OP_LIST</code>。同样在自变量中，指定<code>BUILD_PYTORCH_MOBILE=1</code>以及平台/架构类型。以arm64构建为例，命令应为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECTED_OP_LIST=MobileNetV2.yaml BUILD_PYTORCH_MOBILE=1 IOS_ARCH=arm64 ./scripts/build_ios.sh</span><br></pre></td></tr></table></figure><p>4.构建成功后，您可以按照上面的<a href="https://pytorch.org/mobile/ios/#xcode-setup" target="_blank" rel="noopener">XCode Setup</a>部分将结果库集成到项目中。</p><p>5.最后一步是在运行之前添加一行C ++代码<code>forward</code>。这是因为默认情况下，JIT将对运算符进行一些优化（例如，融合），这可能会破坏我们从模型中转储的操作的一致性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch::jit::<span class="function">GraphOptimizerEnabledGuard <span class="title">guard</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="问题与贡献"><a href="#问题与贡献" class="headerlink" title="问题与贡献"></a>问题与贡献<a href="https://pytorch.org/mobile/ios/#issues-and-contribution" target="_blank" rel="noopener"></a></h2><p>如果您有任何疑问或想为PyTorch做出贡献，请随时提出问题或打开请求请求以取得联系。</p><p>PyTorch iOS 官方：</p><p><a href="https://github.com/pytorch/ios-demo-app" target="_blank" rel="noopener">https://github.com/pytorch/ios-demo-app</a></p><p>带拍照和相册的源码：</p><p><a href="https://github.com/Game2020/PyTorch_iOS" target="_blank" rel="noopener">https://github.com/Game2020/PyTorch_iOS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/18/PyTorch-iOS/1.png&quot; alt=&quot;小武&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>《放学后》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/18/9787544291224/"/>
    <id>https://2020.iosdevlog.com/2020/02/18/9787544291224/</id>
    <published>2020-02-17T16:22:29.000Z</published>
    <updated>2020-02-19T09:59:44.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/1.svg" alt="《放学后》人物关系图"></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/2.jpg" alt="《放学后》"></p><p>书名：放学后<br>作者：[日]东野圭吾<br>译者：赵峻<br>出版社：南海出版公司出版<br>时间：2017-09<br>ISBN：9787544291224</p><h2 id="更衣室"><a href="#更衣室" class="headerlink" title="更衣室"></a>更衣室</h2><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/3.jpg" alt="更衣室简图"></p><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/4.jpg" alt="门"></p><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/5.jpg" alt="北条雅美 推理"></p><h2 id="体育节"><a href="#体育节" class="headerlink" title="体育节"></a>体育节</h2><table><thead><tr><th>时间</th><th>事件</th></tr></thead><tbody><tr><td>14:15</td><td>来宾、教职员趣味赛跑</td></tr><tr><td>14:30</td><td>三人拉力赛（一年级）</td></tr><tr><td>14:45</td><td>师生对抗障碍赛</td></tr><tr><td>15:00</td><td>创编舞（三年级）</td></tr><tr><td>15:20</td><td>化装游行（运动社团）</td></tr></tbody></table><h2 id="更衣室解迷"><a href="#更衣室解迷" class="headerlink" title="更衣室解迷"></a>更衣室解迷</h2><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/6.jpg" alt="更衣室解迷"></p><p><img src="https://2020.iosdevlog.com/2020/02/18/9787544291224/7.jpg" alt="更衣室解迷"></p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><blockquote><p>“对她们来说，最重要的应该是美丽、纯粹、真实的东西，比如友情、爱情，也可能是自己的身体或容貌。很多时候，更抽象的回忆或梦想对她们来说也很重要。反过来说，她们最憎恨企图破坏或者从她们手中夺</p></blockquote><ol><li>自慰被看到的惠美<ul><li>惠美&amp;惠子：杀害看到学生自慰的老师</li></ul></li><li>“他根本不知道头发被剪得乱七八糟对我来说有多痛苦。”-阳子<ul><li>阳子：试图诬陷教导主任性骚扰</li></ul></li><li>“我没有给过她任何东西,甚至一直都是从她身上予取予求,更夺走了她的自由、快乐, 以及孩子。” 冷漠的丈夫和婚姻给她的精神带来的创痛。-裕美子<ul><li>裕美子&amp;情夫：杀害前岛的</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/18/9787544291224/1.svg&quot; alt=&quot;《放学后》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
  </entry>
  
  <entry>
    <title>《Python深度学习：基于PyTorch》 读书笔记</title>
    <link href="https://2020.iosdevlog.com/2020/02/17/pytorch/"/>
    <id>https://2020.iosdevlog.com/2020/02/17/pytorch/</id>
    <published>2020-02-17T05:28:39.000Z</published>
    <updated>2020-02-17T15:42:20.233Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/1.jpg" alt="《Python深度学习：基于PyTorch》"></p><p>书名：Python深度学习：基于PyTorch<br>作者：吴茂贵，郁明敏，杨本法，李涛，张粤磊<br>出版社：机械工业出版社<br>出版时间：2019-10<br>ISBN：9787111637172</p><a id="more"></a><p>建议初学者选择PyTorch的主要依据是：</p><ol><li>PyTorch是动态计算图，其用法更贴近Python，并且，PyTorch与Python共用了许多Numpy的命令，可以降低学习的门槛，比TensorFlow更容易上手。</li><li>PyTorch需要定义网络层、参数更新等关键步骤，这非常有助于理解深度学习的核心；而Keras虽然也非常简单，且容易上手，但封装粒度很粗，隐藏了很多关键步骤。</li><li>PyTorch的动态图机制在调试方面非常方便，如果计算图运行出错，马上可以跟踪问题。PyTorch的调试与Python的调试一样，通过断点检查就可以高效解决问题。</li><li>PyTorch的流行度仅次于TensorFlow。而最近一年，在GitHub关注度和贡献者的增长方面，PyTorch跟TensorFlow基本持平。PyTorch的搜索热度持续上涨，加上FastAI的支持，PyTorch将受到越来越多机器学习从业者的青睐。</li></ol><p>本书特点</p><ul><li>内容选择<ul><li>广泛涉猎</li><li>精讲</li><li>注重实战</li></ul></li><li>内容安排<ul><li>简单实例开始</li><li>循序渐进</li></ul></li><li>表达形式<ul><li>让图说话</li><li>一张好图胜过千言万语</li></ul></li></ul><p>本书内容</p><ol><li>PyTorch基础</li><li>深度学习基本原理</li><li>实战部分</li></ol><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="PyTorch基础"><a href="#PyTorch基础" class="headerlink" title="PyTorch基础"></a>PyTorch基础</h3><h3 id="第1章-Numpy（Numerical-Python）基础"><a href="#第1章-Numpy（Numerical-Python）基础" class="headerlink" title="第1章 Numpy（Numerical Python）基础"></a>第1章 Numpy（Numerical Python）基础</h3><p>基本的对像</p><ol><li>ndarray（N-dimensional Array Object）<ul><li>单一数据类型的多维数组</li></ul></li><li>ufunc（UniversalFunction Object）<ul><li>对数组进行处理的函数</li></ul></li></ol><p>Numpy的主要特点：</p><ol><li>ndarray，快速节省空间的多维数组，提供数组化的算术运算和高级的广播功能。</li><li>使用标准数学函数对整个数组的数据进行快速运算，且不需要编写循环。</li><li>读取/写入磁盘上的阵列数据和操作存储器映像文件的工具。</li><li>线性代数、随机数生成和傅里叶变换的能力。</li><li>集成C、C++、Fortran代码的工具。</li></ol><h4 id="1-1-生成Numpy数组"><a href="#1-1-生成Numpy数组" class="headerlink" title="1.1 生成Numpy数组"></a>1.1 生成Numpy数组</h4><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/3.jpg" alt="Tab"></p><h5 id="从已有数据中创建数组"><a href="#从已有数据中创建数组" class="headerlink" title="从已有数据中创建数组"></a>从已有数据中创建数组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.array(l)</span><br></pre></td></tr></table></figure><h5 id="利用random模块生成数组"><a href="#利用random模块生成数组" class="headerlink" title="利用random模块生成数组"></a>利用random模块生成数组</h5><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>np.random.random</td><td>生成0到1之间的随机数</td></tr><tr><td>np.random.uniform</td><td>生成均匀分布的随机数</td></tr><tr><td>np.random.randn</td><td>生成标准正态的随机数</td></tr><tr><td>np.random.randint</td><td>生成随机的整数</td></tr><tr><td>np.random.normal</td><td>生成正态分布</td></tr><tr><td>np.random.shuffle</td><td>随机打乱顺序</td></tr><tr><td>np.random.seed</td><td>设置随机数种子</td></tr><tr><td>random._sample</td><td>生成随机的浮点数</td></tr></tbody></table><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/4.jpg" alt="np.random模块常用函数"></p><h5 id="创建特定形状的多维数组"><a href="#创建特定形状的多维数组" class="headerlink" title="创建特定形状的多维数组"></a>创建特定形状的多维数组</h5><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>np.zeros((3, 4))</td><td>创建3×4的元素全为0的数组</td></tr><tr><td>np.ones((3, 4))</td><td>创建3×4的元素全为1的数组</td></tr><tr><td>np.empty( (2, 3))</td><td>创建2×3的空数组,空数据中的值并不为0,而是未初始化的垃圾值</td></tr><tr><td>np.zeros.like(darr)</td><td>以 darr相同维度创建元素全为0数组</td></tr><tr><td>np.ones.like(darr)</td><td>以 narr相同维度创建元素全为1数组</td></tr><tr><td>np.empty.like(ndarr)</td><td>以 darr相同维度创建空数组</td></tr><tr><td>np.eye(5)</td><td>该函数用于创建一个5×5的矩阵,对角线为1,其余为0</td></tr><tr><td>np.full((3, 5), 666)</td><td>创建3×5的元素全为666的数组,666为指定值</td></tr></tbody></table><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/5.jpg" alt="Numpy数组创建函数"></p><h5 id="利用arange、linspace函数生成数组"><a href="#利用arange、linspace函数生成数组" class="headerlink" title="利用arange、linspace函数生成数组`````"></a>利用arange、linspace函数生成数组`````</h5><p>arange是numpy模块中的函数，其格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">help(np.arange)</span><br><span class="line">arange([start,] stop[, step,], dtype=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>其中start与stop用来指定范围，step用来设定步长。在生成一个ndarray时，start默认为0，步长step可为小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="1-2-获取元素"><a href="#1-2-获取元素" class="headerlink" title="1.2 获取元素"></a>1.2 获取元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2020</span>)</span><br><span class="line">nd11 = np.random.random([<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定位置的数据,获取第4个元素</span></span><br><span class="line">nd11[<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 截取一段数据</span></span><br><span class="line">nd11[<span class="number">3</span>:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 截取固定间隔数据</span></span><br><span class="line">nd11[<span class="number">1</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 倒序取数</span></span><br><span class="line">nd11[::<span class="number">-2</span>]</span><br><span class="line"><span class="comment"># 截取一个多维数组的一个区域内数据</span></span><br><span class="line">nd12 = np.arange(<span class="number">25</span>).reshape([<span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">nd12[<span class="number">1</span>:<span class="number">31</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 截取一个多维数组中,数值在一个值域之內的数据</span></span><br><span class="line">nd12[(nd12 &gt; <span class="number">3</span>) &amp; (nd12 &lt; <span class="number">10</span>)]</span><br><span class="line"><span class="comment"># 截取多维数组中,指定的行,如读取第2,3行</span></span><br><span class="line">nd12[[<span class="number">1</span>, <span class="number">2</span>]]  <span class="comment"># 或nd12[1:3,:]</span></span><br><span class="line"><span class="comment"># 并截取多维数组中,指定的列,如读取第2,3列</span></span><br><span class="line">nd12[:, <span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/6.jpg" alt="获取多维数组中的元素"></p><p>随机抽取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> random <span class="keyword">as</span> nr</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">1</span>, <span class="number">25</span>, dtype=float)</span><br><span class="line">c1 = nr.choice(a, size=(<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># size指定输出数组形状</span></span><br><span class="line">c2 = nr.choice(a, size=(<span class="number">3</span>, <span class="number">4</span>), replace=<span class="literal">False</span>)  <span class="comment"># replace缺省为True，即可重复抽取。</span></span><br><span class="line"><span class="comment"># 下式中参数p指定每个元素对应的抽取概率，缺省为每个元素被抽取的概率相同。</span></span><br><span class="line">c3 = nr.choice(a, size=(<span class="number">3</span>, <span class="number">4</span>), p=a / np.sum(a))</span><br><span class="line">print(<span class="string">"随机可重复抽取"</span>)</span><br><span class="line">print(c1)</span><br><span class="line">print(<span class="string">"随机但不重复抽取"</span>)</span><br><span class="line">print(c2)</span><br><span class="line">print(<span class="string">"随机但按制度概率抽取"</span>)</span><br><span class="line">print(c3)</span><br></pre></td></tr></table></figure><h4 id="1-3-Numpy的算术运算"><a href="#1-3-Numpy的算术运算" class="headerlink" title="1.3 Numpy的算术运算"></a>1.3 Numpy的算术运算</h4><h5 id="1-3-1-对应元素相乘"><a href="#1-3-1-对应元素相乘" class="headerlink" title="1.3.1 对应元素相乘"></a>1.3.1 对应元素相乘</h5><p><code>np.info(np.multiply)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiply(x1, x2, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">'same_kind'</span>, order=<span class="string">'K'</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">-1</span>, <span class="number">4</span>]])</span><br><span class="line">B = np.array([[<span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">A*B</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">array([[<span class="number">2</span>,  <span class="number">0</span>],</span><br><span class="line">       [<span class="number">-3</span>, <span class="number">16</span>]])</span><br><span class="line"><span class="comment"># 或另一种表示方法</span></span><br><span class="line">np.multiply(A, B)</span><br><span class="line"><span class="comment"># 运算结果也是</span></span><br><span class="line">array([[<span class="number">2</span>,  <span class="number">0</span>],</span><br><span class="line">       [<span class="number">-3</span>, <span class="number">16</span>]])</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/7.jpg" alt="对应元素相乘示意图"></p><h5 id="1-3-2-点积运算"><a href="#1-3-2-点积运算" class="headerlink" title="1.3.2 点积运算"></a>1.3.2 点积运算</h5><p>点积运算（Dot Product）又称为内积</p><p><code>np.info(np.dot)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot(a, b, out=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X1=np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">X2=np.array([[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]])</span><br><span class="line">X3=np.dot(X1,X2)</span><br><span class="line">print(X3)</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/8.jpg" alt="矩阵的点积示意图，对应维度的元素个数需要保持一致"></p><h4 id="1-4-数组变形"><a href="#1-4-数组变形" class="headerlink" title="1.4 数组变形"></a>1.4 数组变形</h4><h5 id="1-4-1-更改数组的形状"><a href="#1-4-1-更改数组的形状" class="headerlink" title="1.4.1 更改数组的形状"></a>1.4.1 更改数组的形状</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/9.jpg" alt="Numpy中改变向量形状的一些函数"></p><h5 id="1-4-2-合并数组"><a href="#1-4-2-合并数组" class="headerlink" title="1.4.2 合并数组"></a>1.4.2 合并数组</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/10.jpg" alt="Numpy数组合并方法"></p><ol><li>append、concatenate以及stack都有一个axis参数，用于控制数组的合并方式是按行还是按列。</li><li>对于append和concatenate，待合并的数组必须有相同的行数或列数（满足一个即可）。</li><li>stack、hstack、dstack，要求待合并的数组必须具有相同的形状（shape）。</li></ol><h4 id="1-5-批量处理"><a href="#1-5-批量处理" class="headerlink" title="1.5 批量处理"></a>1.5 批量处理</h4><ol><li>得到数据集</li><li>随机打乱数据</li><li>定义批大小</li><li>批处理数据集</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 生成10000个形状为2X3的矩阵</span></span><br><span class="line">data_train = np.random.randn(<span class="number">10000</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 这是一个3维矩阵，第1个维度为样本数，后两个是数据形状</span></span><br><span class="line">print(data_train.shape)</span><br><span class="line"><span class="comment"># (10000,2,3)</span></span><br><span class="line"><span class="comment"># 打乱这10000条数据</span></span><br><span class="line">np.random.shuffle(data_train)</span><br><span class="line"><span class="comment"># 定义批量大小</span></span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line"><span class="comment"># 进行批处理</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(data_train), batch_size):</span><br><span class="line">    x_batch_sum = np.sum(data_train[i:i+batch_size])</span><br><span class="line">    print(<span class="string">"第&#123;&#125;批次,该批次的数据之和:&#123;&#125;"</span>.format(i, x_batch_sum))</span><br></pre></td></tr></table></figure><p>【说明】批次从0开始，所以最后一个批次是9900。</p><h4 id="1-6-通用函数"><a href="#1-6-通用函数" class="headerlink" title="1.6 通用函数"></a>1.6 通用函数</h4><p>ufunc是universalfunction的缩写，它是一种能对数组的每个元素进行操作的函数。</p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/11.jpg" alt="Numpy中的几个常用通用函数"></p><h4 id="1-7-广播"><a href="#1-7-广播" class="headerlink" title="1.7 广播"></a>1.7 广播</h4><p>Numpy的Universal functions中要求输入的数组shape是一致的，当数组的shape不相等时，则会使用广播机制。不过，调整数组使得shape一样，需要满足一定的规则，否则将出错。</p><p>这些规则可归纳为以下4条。</p><ol><li>让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐，如：<ul><li>a：2×3×2</li><li>b：3×2</li><li>则b向a看齐，在b的前面加1，变为：1×3×2</li></ul></li><li>输出数组的shape是输入数组shape的各个轴上的最大值</li><li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时，这个数组能被用来计算，否则出错</li><li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用（或复制）此轴上的第一组值。</li></ol><p>广播在整个Numpy中用于决定如何处理形状迥异的数组，涉及的算术运算包括（+，-，*，/…）。</p><p>这些规则说得很严谨，但不直观，下面我们结合图形与代码来进一步说明。</p><p>目的：A+B，其中A为4×1矩阵，B为一维向量（3,）。</p><p>要相加，需要做如下处理：</p><ol><li>根据规则1，B需要向看齐，把B变为（1,3）</li><li>根据规则2，输出的结果为各个轴上的最大值，即输出结果应该为（4,3）矩阵，那么A如何由（4,1）变为（4,3）矩阵？B又如何由（1,3）变为（4,3）矩阵？</li><li>根据规则4，用此轴上的第一组值（要主要区分是哪个轴），进行复制（但在实际处理中不是真正复制，否则太耗内存，而是采用其他对象如ogrid对象，进行网格处理）即可，详细处理过程如图所示。</li></ol><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/12.jpg" alt="Numpy广播规则示意图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">0</span>, <span class="number">40</span>, <span class="number">10</span>).reshape(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">print(<span class="string">"A矩阵的形状:&#123;&#125;,B矩阵的形状:&#123;&#125;"</span>.format(A.shape, B.shape))</span><br><span class="line">C = A+B</span><br><span class="line">print(<span class="string">"C矩阵的形状:&#123;&#125;"</span>.format(C.shape))</span><br><span class="line">print(C)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A矩阵的形状:(4, 1),B矩阵的形状:(3,)</span><br><span class="line">C矩阵的形状:(4, 3)</span><br><span class="line">[[ 0  1  2]</span><br><span class="line"> [10 11 12]</span><br><span class="line"> [20 21 22]</span><br><span class="line"> [30 31 32]]</span><br></pre></td></tr></table></figure><h3 id="第2章-Pytorch基础"><a href="#第2章-Pytorch基础" class="headerlink" title="第2章 Pytorch基础"></a>第2章 Pytorch基础</h3><h4 id="2-1-为何选择Pytorch？"><a href="#2-1-为何选择Pytorch？" class="headerlink" title="2.1 为何选择Pytorch？"></a>2.1 为何选择Pytorch？</h4><p>PyTorch由4个主要的包组成：</p><ol><li><code>torch</code>：类似于Numpy的通用数组库，可将张量类型转换为torch.cuda.TensorFloat，并在GPU上进行计算。</li><li><code>torch.autograd</code>：用于构建计算图形并自动获取梯度的包。</li><li><code>torch.nn</code>：具有共享层和损失函数的神经网络库。</li><li><code>torch.optim</code>：具有通用优化算法（如SGD、Adam等）的优化包。</li></ol><h4 id="2-2-安装配置"><a href="#2-2-安装配置" class="headerlink" title="2.2 安装配置"></a>2.2 安装配置</h4><p>参考 <a href="https://pytorch.org" target="_blank" rel="noopener">https://pytorch.org</a> 就可以了。</p><h5 id="2-2-1-CPU版Pytorch"><a href="#2-2-1-CPU版Pytorch" class="headerlink" title="2.2.1 CPU版Pytorch"></a>2.2.1 CPU版Pytorch</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/13.jpg" alt="下载Anaconda界面"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-MacOSX-x86_64.sh</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/14.jpg" alt="PyTorch安装界面"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure><p>当前最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4.0</span><br></pre></td></tr></table></figure><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/15.jpg" alt="验证安装是否成功"></p><h5 id="2-2-2-GPU版Pytorch"><a href="#2-2-2-GPU版Pytorch" class="headerlink" title="2.2.2 GPU版Pytorch"></a>2.2.2 GPU版Pytorch</h5><h6 id="安装NVIDIA驱动"><a href="#安装NVIDIA驱动" class="headerlink" title="安装NVIDIA驱动"></a>安装NVIDIA驱动</h6><p><a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/16.jpg" alt="NVIDIA的下载界面"></p><p>安装完成后，在命令行输入 <code>nvidia-smi</code>，用来显示GPU卡的基本信息</p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/17.jpg" alt="显示GPU卡的基本信息"></p><h6 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h6><p>CUDA（Compute Unified Device Architecture），是英伟达公司推出的一种基于新的并行编程模型和指令集架构的通用计算架构，它能利用英伟达GPU的并行计算引擎，比CPU更高效地解决许多复杂计算任务。安装CUDA Driver时，其版本需与NVIDIA GPU Driver的版本一致，这样CUDA才能找到显卡。</p><h6 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h6><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。注册NVIDIA并下载cuDNN包，获取地址为<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-archive</a>。</p><h6 id="安装Python及PyTorch"><a href="#安装Python及PyTorch" class="headerlink" title="安装Python及PyTorch"></a>安装Python及PyTorch</h6><p>安装GPU版PyTorch相同，只是选择CUDA时，不是None，而是对应CUDA的版本号。</p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/18.jpg" alt="安装GPU版PyTorch"></p><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat test_gpu.py</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 测试 CUDA</span></span><br><span class="line">    print(<span class="string">"Support CUDA ?: "</span>, torch.cuda.is_available())</span><br><span class="line">    x = torch.tensor([<span class="number">10.0</span>])</span><br><span class="line">    x = x.cuda()</span><br><span class="line">    print(x)</span><br><span class="line">    y = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    y = y.cuda()</span><br><span class="line">    print(y)</span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">   <span class="comment"># 测试 CUDNN</span></span><br><span class="line">    <span class="keyword">from</span> torch.backends <span class="keyword">import</span> cudnn</span><br><span class="line">    print(<span class="string">"Support cudnn ?: "</span>, cudnn.is_acceptable(x))</span><br></pre></td></tr></table></figure><p><code>python torch</code></p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/19.jpg" alt="运行test_gpu.py的结果"></p><p>在命令行运行：<code>nvidia-smi</code></p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/20.jpg" alt="含GPU进程的显卡信息"></p><h4 id="2-3-Jupyter-Notebook环境配置"><a href="#2-3-Jupyter-Notebook环境配置" class="headerlink" title="2.3 Jupyter Notebook环境配置"></a>2.3 Jupyter Notebook环境配置</h4><ul><li>编程时具有语法高亮、缩进、Tab补全的功能</li><li>可直接通过浏览器运行代码，同时在代码块下方展示运行结果</li><li>以富媒体格式展示计算结果。富媒体格式包括：HTML、LaTeX、PNG、SVG等</li><li>对代码编写说明文档或语句时，支持Markdown语法</li><li>支持使用LaTeX编写数学性说明。</li></ul><ol><li>生成配置文件。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br></pre></td></tr></table></figure><p>执行上述代码，将在当前用户目录下生成文件：<code>.jupyter/jupyter_notebook_config.py</code></p><ol><li>生成当前用户登录Jupyter密码。打开Ipython，创建一个密文密码。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from notebook.auth import passwd</span><br><span class="line">In [2]: passwd()</span><br><span class="line">Enter password: </span><br><span class="line">Verify password:</span><br></pre></td></tr></table></figure><ol><li>修改配置文件。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><p>进行如下修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'*'</span>  <span class="comment"># 就是设置所有ip皆可访问</span></span><br><span class="line">c.NotebookApp.password = u<span class="string">'sha:ce...刚才复制的那个密文'</span></span><br><span class="line">c.NotebookApp.open_browser = False  <span class="comment"># 禁止自动打开浏览器</span></span><br><span class="line">c.NotebookApp.port = 8888  <span class="comment"># 这是缺省端口，也可指定其他端口</span></span><br></pre></td></tr></table></figure><ol><li>启动Jupyter Notebook。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台启动jupyter：不记日志：</span></span><br><span class="line">nohup jupyter notebook &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>在浏览器上，输入IP:port，即可看到与下图类似的界面。</p><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/21.jpg" alt="Jupyter Notebook网页界面"></p><p>接下来就可以在浏览器进行开发调试PyTorch、Python等任务了。</p><h4 id="2-4-Numpy与Tensor"><a href="#2-4-Numpy与Tensor" class="headerlink" title="2.4 Numpy与Tensor"></a>2.4 Numpy与Tensor</h4><p>Numpy存取数据非常方便，而且还拥有大量的函数，所以深得数据处理、机器学习者喜爱。</p><p>Tensor，它可以是零维（又称为标量或一个数）、一维、二维及多维的数组。</p><p>Tensor自称为神经网络界的Numpy，它与Numpy相似，二者可以共享内存，且之间的转换非常方便和高效。</p><p>不过它们也有不同之处，最大的区别就是Numpy会把ndarray放在CPU中进行加速运算，而由Torch产生的Tensor会放在GPU中进行加速运算（假设当前环境有GPU）。</p><h5 id="2-4-1-Tensor概述"><a href="#2-4-1-Tensor概述" class="headerlink" title="2.4.1 Tensor概述"></a>2.4.1 Tensor概述</h5><p>对Tensor的操作很多，从接口的角度来划分，可以分为两类：</p><ol><li>torch.function，如torch.sum、torch.add等</li><li>tensor.function，如tensor.view、tensor.add等</li></ol><p>如果从修改方式的角度来划分，可以分为以下两类：</p><ol><li>不修改自身数据，如x.add(y)，x的数据不变，返回一个新的Tensor。</li><li>修改自身数据，如x.add_(y)（运行符带下划线后缀），运算结果存在x中，x被修改。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.tensor([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">y = torch.tensor([<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">z = x.add(y)</span><br><span class="line">print(z)</span><br><span class="line">print(x)</span><br><span class="line">x.add_(y)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">tensor([<span class="number">4</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><h5 id="2-4-2-创建Tensor"><a href="#2-4-2-创建Tensor" class="headerlink" title="2.4.2 创建Tensor"></a>2.4.2 创建Tensor</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/22.jpg" alt="常见的创建Tensor的方法"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 根据list数据生成Tensor</span></span><br><span class="line">torch.Tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 根据指定形状生成Tensor</span></span><br><span class="line">torch.Tensor(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 根据给定的Tensor的形状</span></span><br><span class="line">t = torch.Tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 查看Tensor的形状</span></span><br><span class="line">t.size()</span><br><span class="line"><span class="comment"># shape与size()等价方式</span></span><br><span class="line">t.shape</span><br><span class="line"><span class="comment"># 根据已有形状创建Tensor</span></span><br><span class="line">torch.Tensor(t.size())</span><br></pre></td></tr></table></figure><h5 id="2-4-3-修改Tensor形状"><a href="#2-4-3-修改Tensor形状" class="headerlink" title="2.4.3 修改Tensor形状"></a>2.4.3 修改Tensor形状</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/23.jpg" alt="为tensor常用修改形状的函数"></p><h5 id="2-4-4-索引操作"><a href="#2-4-4-索引操作" class="headerlink" title="2.4.4 索引操作"></a>2.4.4 索引操作</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/24.jpg" alt="常用选择操作函数"></p><h5 id="2-4-5-广播机制"><a href="#2-4-5-广播机制" class="headerlink" title="2.4.5 广播机制"></a>2.4.5 广播机制</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">0</span>, <span class="number">40</span>, <span class="number">10</span>).reshape(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">B = np.arange(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 把ndarray转换为Tensor</span></span><br><span class="line">A1 = torch.from_numpy(A)  <span class="comment"># 形状为4x1</span></span><br><span class="line">B1 = torch.from_numpy(B)  <span class="comment"># 形状为3</span></span><br><span class="line"><span class="comment"># Tensor自动实现广播</span></span><br><span class="line">C = A1+B1</span><br><span class="line"><span class="comment"># 我们可以根据广播机制，手工进行配置</span></span><br><span class="line"><span class="comment"># 根据规则1，B1需要向A1看齐，把B变为（1,3）</span></span><br><span class="line">B2 = B1.unsqueeze(<span class="number">0</span>)  <span class="comment"># B2的形状为1x3</span></span><br><span class="line"><span class="comment"># 使用expand函数重复数组，分别的4x3的矩阵</span></span><br><span class="line">A2 = A1.expand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">B3 = B2.expand(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 然后进行相加,C1与C结果一致</span></span><br><span class="line">C1 = A2+B3</span><br></pre></td></tr></table></figure><h5 id="2-4-6-逐元素操作"><a href="#2-4-6-逐元素操作" class="headerlink" title="2.4.6 逐元素操作"></a>2.4.6 逐元素操作</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/25.jpg" alt="常见逐元素操作"></p><h5 id="2-4-7-归并操作"><a href="#2-4-7-归并操作" class="headerlink" title="2.4.7 归并操作"></a>2.4.7 归并操作</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/26.jpg" alt="常见的归并操作"></p><h5 id="2-4-8-比较操作"><a href="#2-4-8-比较操作" class="headerlink" title="2.4.8 比较操作"></a>2.4.8 比较操作</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/27.jpg" alt="常用的比较函数"></p><h5 id="2-4-9-矩阵操作"><a href="#2-4-9-矩阵操作" class="headerlink" title="2.4.9 矩阵操作"></a>2.4.9 矩阵操作</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/28.jpg" alt="常用矩阵函数"></p><h5 id="2-4-10-Pytorch与Numpy比较"><a href="#2-4-10-Pytorch与Numpy比较" class="headerlink" title="2.4.10 Pytorch与Numpy比较"></a>2.4.10 Pytorch与Numpy比较</h5><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/29.jpg" alt="PyTorch与Numpy函数对照表"></p><h4 id="2-5-Tensor与Autograd"><a href="#2-5-Tensor与Autograd" class="headerlink" title="2.5 Tensor与Autograd"></a>2.5 Tensor与Autograd</h4><h5 id="2-5-1-自动求导要点"><a href="#2-5-1-自动求导要点" class="headerlink" title="2.5.1 自动求导要点"></a>2.5.1 自动求导要点</h5><h5 id="2-5-2计算图"><a href="#2-5-2计算图" class="headerlink" title="2.5.2计算图"></a>2.5.2计算图</h5><h5 id="2-5-3-标量反向传播"><a href="#2-5-3-标量反向传播" class="headerlink" title="2.5.3 标量反向传播"></a>2.5.3 标量反向传播</h5><h5 id="2-5-4-非标量反向传播"><a href="#2-5-4-非标量反向传播" class="headerlink" title="2.5.4 非标量反向传播"></a>2.5.4 非标量反向传播</h5><h4 id="2-6-使用Numpy实现机器学习"><a href="#2-6-使用Numpy实现机器学习" class="headerlink" title="2.6 使用Numpy实现机器学习"></a>2.6 使用Numpy实现机器学习</h4><h4 id="2-7-使用Tensor及antograd实现机器学习"><a href="#2-7-使用Tensor及antograd实现机器学习" class="headerlink" title="2.7 使用Tensor及antograd实现机器学习"></a>2.7 使用Tensor及antograd实现机器学习</h4><h4 id="2-8-使用TensorFlow架构"><a href="#2-8-使用TensorFlow架构" class="headerlink" title="2.8 使用TensorFlow架构"></a>2.8 使用TensorFlow架构</h4><h3 id="第3章-Pytorch实现神经网络工具箱"><a href="#第3章-Pytorch实现神经网络工具箱" class="headerlink" title="第3章 Pytorch实现神经网络工具箱"></a>第3章 Pytorch实现神经网络工具箱</h3><h4 id="3-1-神经网络核心组件"><a href="#3-1-神经网络核心组件" class="headerlink" title="3.1 神经网络核心组件"></a>3.1 神经网络核心组件</h4><h4 id="3-2实现神经网络实例"><a href="#3-2实现神经网络实例" class="headerlink" title="3.2实现神经网络实例"></a>3.2实现神经网络实例</h4><h5 id="3-2-1背景说明"><a href="#3-2-1背景说明" class="headerlink" title="3.2.1背景说明"></a>3.2.1背景说明</h5><h5 id="3-2-2准备数据"><a href="#3-2-2准备数据" class="headerlink" title="3.2.2准备数据"></a>3.2.2准备数据</h5><h5 id="3-2-3可视化源数据"><a href="#3-2-3可视化源数据" class="headerlink" title="3.2.3可视化源数据"></a>3.2.3可视化源数据</h5><h5 id="3-2-4-构建模型"><a href="#3-2-4-构建模型" class="headerlink" title="3.2.4 构建模型"></a>3.2.4 构建模型</h5><h5 id="3-2-5-训练模型"><a href="#3-2-5-训练模型" class="headerlink" title="3.2.5 训练模型"></a>3.2.5 训练模型</h5><h4 id="3-3-如何构建神经网络？"><a href="#3-3-如何构建神经网络？" class="headerlink" title="3.3 如何构建神经网络？"></a>3.3 如何构建神经网络？</h4><h5 id="3-3-1-构建网络层"><a href="#3-3-1-构建网络层" class="headerlink" title="3.3.1 构建网络层"></a>3.3.1 构建网络层</h5><h5 id="3-3-2-前向传播"><a href="#3-3-2-前向传播" class="headerlink" title="3.3.2 前向传播"></a>3.3.2 前向传播</h5><h5 id="3-3-3-反向传播"><a href="#3-3-3-反向传播" class="headerlink" title="3.3.3 反向传播"></a>3.3.3 反向传播</h5><h5 id="3-3-4-训练模型"><a href="#3-3-4-训练模型" class="headerlink" title="3.3.4 训练模型"></a>3.3.4 训练模型</h5><h4 id="3-4-nn-Module"><a href="#3-4-nn-Module" class="headerlink" title="3.4 nn.Module"></a>3.4 nn.Module</h4><h4 id="3-5-nn-functional"><a href="#3-5-nn-functional" class="headerlink" title="3.5 nn.functional"></a>3.5 nn.functional</h4><h4 id="3-6-优化器"><a href="#3-6-优化器" class="headerlink" title="3.6 优化器"></a>3.6 优化器</h4><h4 id="3-7-动态修改学习率参数"><a href="#3-7-动态修改学习率参数" class="headerlink" title="3.7 动态修改学习率参数"></a>3.7 动态修改学习率参数</h4><h4 id="3-8-优化器比较"><a href="#3-8-优化器比较" class="headerlink" title="3.8 优化器比较"></a>3.8 优化器比较</h4><h3 id="第4章-Pytorch数据处理工具箱"><a href="#第4章-Pytorch数据处理工具箱" class="headerlink" title="第4章 Pytorch数据处理工具箱"></a>第4章 Pytorch数据处理工具箱</h3><h4 id="4-1-数据处理工具箱概述"><a href="#4-1-数据处理工具箱概述" class="headerlink" title="4.1 数据处理工具箱概述"></a>4.1 数据处理工具箱概述</h4><h4 id="4-2-utils-data简介"><a href="#4-2-utils-data简介" class="headerlink" title="4.2 utils.data简介"></a>4.2 utils.data简介</h4><h4 id="4-3-torchvision简介"><a href="#4-3-torchvision简介" class="headerlink" title="4.3 torchvision简介"></a>4.3 torchvision简介</h4><h5 id="4-3-1-transforms"><a href="#4-3-1-transforms" class="headerlink" title="4.3.1 transforms"></a>4.3.1 transforms</h5><h5 id="4-3-2-ImageFolder"><a href="#4-3-2-ImageFolder" class="headerlink" title="4.3.2 ImageFolder"></a>4.3.2 ImageFolder</h5><h4 id="4-4-可视化工具"><a href="#4-4-可视化工具" class="headerlink" title="4.4 可视化工具"></a>4.4 可视化工具</h4><h5 id="4-4-1-tensorboardX简介"><a href="#4-4-1-tensorboardX简介" class="headerlink" title="4.4.1 tensorboardX简介"></a>4.4.1 tensorboardX简介</h5><h5 id="4-4-2用tensorboardX可视化神经网络"><a href="#4-4-2用tensorboardX可视化神经网络" class="headerlink" title="4.4.2用tensorboardX可视化神经网络"></a>4.4.2用tensorboardX可视化神经网络</h5><h5 id="4-4-3用tensorboardX可视化损失值"><a href="#4-4-3用tensorboardX可视化损失值" class="headerlink" title="4.4.3用tensorboardX可视化损失值"></a>4.4.3用tensorboardX可视化损失值</h5><h5 id="4-4-4用tensorboardX可视化特征图"><a href="#4-4-4用tensorboardX可视化特征图" class="headerlink" title="4.4.4用tensorboardX可视化特征图"></a>4.4.4用tensorboardX可视化特征图</h5><h2 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h2><h3 id="第5章-机器学习基础"><a href="#第5章-机器学习基础" class="headerlink" title="第5章 机器学习基础"></a>第5章 机器学习基础</h3><h4 id="5-1-机器学习的基本任务"><a href="#5-1-机器学习的基本任务" class="headerlink" title="5.1 机器学习的基本任务"></a>5.1 机器学习的基本任务</h4><h5 id="5-1-1监督学习"><a href="#5-1-1监督学习" class="headerlink" title="5.1.1监督学习"></a>5.1.1监督学习</h5><h5 id="5-1-2-无监督学习"><a href="#5-1-2-无监督学习" class="headerlink" title="5.1.2 无监督学习"></a>5.1.2 无监督学习</h5><h5 id="5-1-3-半监督学习"><a href="#5-1-3-半监督学习" class="headerlink" title="5.1.3 半监督学习"></a>5.1.3 半监督学习</h5><h5 id="5-1-4-强化学习"><a href="#5-1-4-强化学习" class="headerlink" title="5.1.4 强化学习"></a>5.1.4 强化学习</h5><h4 id="5-2-机器学习一般流程"><a href="#5-2-机器学习一般流程" class="headerlink" title="5.2 机器学习一般流程"></a>5.2 机器学习一般流程</h4><h5 id="5-2-1-明确目标"><a href="#5-2-1-明确目标" class="headerlink" title="5.2.1 明确目标"></a>5.2.1 明确目标</h5><h5 id="5-2-2收集数据"><a href="#5-2-2收集数据" class="headerlink" title="5.2.2收集数据"></a>5.2.2收集数据</h5><h5 id="5-2-3-数据探索与预处理"><a href="#5-2-3-数据探索与预处理" class="headerlink" title="5.2.3 数据探索与预处理"></a>5.2.3 数据探索与预处理</h5><h5 id="5-2-4-选择模型"><a href="#5-2-4-选择模型" class="headerlink" title="5.2.4 选择模型"></a>5.2.4 选择模型</h5><h5 id="5-2-5-评估及优化模型"><a href="#5-2-5-评估及优化模型" class="headerlink" title="5.2.5 评估及优化模型"></a>5.2.5 评估及优化模型</h5><h4 id="5-3-过拟合与欠拟合"><a href="#5-3-过拟合与欠拟合" class="headerlink" title="5.3 过拟合与欠拟合"></a>5.3 过拟合与欠拟合</h4><h5 id="5-3-1-权重正则化"><a href="#5-3-1-权重正则化" class="headerlink" title="5.3.1 权重正则化"></a>5.3.1 权重正则化</h5><h5 id="5-3-2-dropout正则化"><a href="#5-3-2-dropout正则化" class="headerlink" title="5.3.2 dropout正则化"></a>5.3.2 dropout正则化</h5><h5 id="5-3-3-批量正则化"><a href="#5-3-3-批量正则化" class="headerlink" title="5.3.3 批量正则化"></a>5.3.3 批量正则化</h5><h5 id="5-3-4权重初始化"><a href="#5-3-4权重初始化" class="headerlink" title="5.3.4权重初始化"></a>5.3.4权重初始化</h5><h4 id="5-4-选择合适激活函数"><a href="#5-4-选择合适激活函数" class="headerlink" title="5.4 选择合适激活函数"></a>5.4 选择合适激活函数</h4><h4 id="5-5-选择合适的损失函数"><a href="#5-5-选择合适的损失函数" class="headerlink" title="5.5 选择合适的损失函数"></a>5.5 选择合适的损失函数</h4><h4 id="5-6-选择合适优化器"><a href="#5-6-选择合适优化器" class="headerlink" title="5.6 选择合适优化器"></a>5.6 选择合适优化器</h4><h5 id="5-6-1传统梯度优化的不足"><a href="#5-6-1传统梯度优化的不足" class="headerlink" title="5.6.1传统梯度优化的不足"></a>5.6.1传统梯度优化的不足</h5><h5 id="5-6-2动量算法"><a href="#5-6-2动量算法" class="headerlink" title="5.6.2动量算法"></a>5.6.2动量算法</h5><h5 id="5-6-3-AdaGrad算法"><a href="#5-6-3-AdaGrad算法" class="headerlink" title="5.6.3 AdaGrad算法"></a>5.6.3 AdaGrad算法</h5><h5 id="5-6-4-RMSProp算法"><a href="#5-6-4-RMSProp算法" class="headerlink" title="5.6.4 RMSProp算法"></a>5.6.4 RMSProp算法</h5><h5 id="5-6-5-Adam算法"><a href="#5-6-5-Adam算法" class="headerlink" title="5.6.5 Adam算法"></a>5.6.5 Adam算法</h5><h4 id="5-7GPU加速"><a href="#5-7GPU加速" class="headerlink" title="5.7GPU加速"></a>5.7GPU加速</h4><h5 id="5-7-1-单GPU加速"><a href="#5-7-1-单GPU加速" class="headerlink" title="5.7.1 单GPU加速"></a>5.7.1 单GPU加速</h5><h5 id="5-7-2-多GPU加速"><a href="#5-7-2-多GPU加速" class="headerlink" title="5.7.2 多GPU加速"></a>5.7.2 多GPU加速</h5><h5 id="5-7-3使用GPU注意事项"><a href="#5-7-3使用GPU注意事项" class="headerlink" title="5.7.3使用GPU注意事项"></a>5.7.3使用GPU注意事项</h5><h3 id="第6章-视觉处理基础"><a href="#第6章-视觉处理基础" class="headerlink" title="第6章 视觉处理基础"></a>第6章 视觉处理基础</h3><h4 id="6-1卷积神经网络简介"><a href="#6-1卷积神经网络简介" class="headerlink" title="6.1卷积神经网络简介"></a>6.1卷积神经网络简介</h4><h4 id="6-2卷积层"><a href="#6-2卷积层" class="headerlink" title="6.2卷积层"></a>6.2卷积层</h4><h5 id="6-2-1-卷积核"><a href="#6-2-1-卷积核" class="headerlink" title="6.2.1 卷积核"></a>6.2.1 卷积核</h5><h5 id="6-2-2步幅"><a href="#6-2-2步幅" class="headerlink" title="6.2.2步幅"></a>6.2.2步幅</h5><h5 id="6-2-3-填充"><a href="#6-2-3-填充" class="headerlink" title="6.2.3 填充"></a>6.2.3 填充</h5><h5 id="6-2-4-多通道上的卷积"><a href="#6-2-4-多通道上的卷积" class="headerlink" title="6.2.4 多通道上的卷积"></a>6.2.4 多通道上的卷积</h5><h5 id="6-2-5激活函数"><a href="#6-2-5激活函数" class="headerlink" title="6.2.5激活函数"></a>6.2.5激活函数</h5><h5 id="6-2-6卷积函数"><a href="#6-2-6卷积函数" class="headerlink" title="6.2.6卷积函数"></a>6.2.6卷积函数</h5><h5 id="6-2-7转置卷积"><a href="#6-2-7转置卷积" class="headerlink" title="6.2.7转置卷积"></a>6.2.7转置卷积</h5><h4 id="6-3池化层"><a href="#6-3池化层" class="headerlink" title="6.3池化层"></a>6.3池化层</h4><h5 id="6-3-1局部池化"><a href="#6-3-1局部池化" class="headerlink" title="6.3.1局部池化"></a>6.3.1局部池化</h5><h5 id="6-3-2全局池化"><a href="#6-3-2全局池化" class="headerlink" title="6.3.2全局池化"></a>6.3.2全局池化</h5><h4 id="6-4现代经典网络"><a href="#6-4现代经典网络" class="headerlink" title="6.4现代经典网络"></a>6.4现代经典网络</h4><h5 id="6-4-1-LeNet-5模型"><a href="#6-4-1-LeNet-5模型" class="headerlink" title="6.4.1 LeNet-5模型"></a>6.4.1 LeNet-5模型</h5><h5 id="6-4-2-AlexNet模型"><a href="#6-4-2-AlexNet模型" class="headerlink" title="6.4.2 AlexNet模型"></a>6.4.2 AlexNet模型</h5><h5 id="6-4-3-VGG模型"><a href="#6-4-3-VGG模型" class="headerlink" title="6.4.3 VGG模型"></a>6.4.3 VGG模型</h5><h5 id="6-4-4-GoogleNet模型"><a href="#6-4-4-GoogleNet模型" class="headerlink" title="6.4.4 GoogleNet模型"></a>6.4.4 GoogleNet模型</h5><h5 id="6-4-5-ResNet模型"><a href="#6-4-5-ResNet模型" class="headerlink" title="6.4.5 ResNet模型"></a>6.4.5 ResNet模型</h5><h5 id="6-4-6-胶囊网络简介"><a href="#6-4-6-胶囊网络简介" class="headerlink" title="6.4.6 胶囊网络简介"></a>6.4.6 胶囊网络简介</h5><h4 id="6-5-Pytorch实现cifar10多分类"><a href="#6-5-Pytorch实现cifar10多分类" class="headerlink" title="6.5 Pytorch实现cifar10多分类"></a>6.5 Pytorch实现cifar10多分类</h4><h5 id="6-5-1-数据集说明"><a href="#6-5-1-数据集说明" class="headerlink" title="6.5.1 数据集说明"></a>6.5.1 数据集说明</h5><h5 id="6-5-2-加载数据"><a href="#6-5-2-加载数据" class="headerlink" title="6.5.2 加载数据"></a>6.5.2 加载数据</h5><h5 id="6-5-3-构建网络"><a href="#6-5-3-构建网络" class="headerlink" title="6.5.3 构建网络"></a>6.5.3 构建网络</h5><h5 id="6-5-4-训练模型"><a href="#6-5-4-训练模型" class="headerlink" title="6.5.4 训练模型"></a>6.5.4 训练模型</h5><h5 id="6-5-5-测试模型"><a href="#6-5-5-测试模型" class="headerlink" title="6.5.5 测试模型"></a>6.5.5 测试模型</h5><h5 id="6-5-6-采用全局平均池化"><a href="#6-5-6-采用全局平均池化" class="headerlink" title="6.5.6 采用全局平均池化"></a>6.5.6 采用全局平均池化</h5><h5 id="6-5-7像keras一样显示各层参数"><a href="#6-5-7像keras一样显示各层参数" class="headerlink" title="6.5.7像keras一样显示各层参数"></a>6.5.7像keras一样显示各层参数</h5><h4 id="6-6-模型集成提升性能"><a href="#6-6-模型集成提升性能" class="headerlink" title="6.6 模型集成提升性能"></a>6.6 模型集成提升性能</h4><h5 id="6-6-1-使用模型"><a href="#6-6-1-使用模型" class="headerlink" title="6.6.1 使用模型"></a>6.6.1 使用模型</h5><h5 id="6-6-2-集成方法"><a href="#6-6-2-集成方法" class="headerlink" title="6.6.2 集成方法"></a>6.6.2 集成方法</h5><h5 id="6-6-3-集成效果"><a href="#6-6-3-集成效果" class="headerlink" title="6.6.3 集成效果"></a>6.6.3 集成效果</h5><h4 id="6-7使用经典模型提升性能"><a href="#6-7使用经典模型提升性能" class="headerlink" title="6.7使用经典模型提升性能"></a>6.7使用经典模型提升性能</h4><h3 id="第7章-自然语言处理基础"><a href="#第7章-自然语言处理基础" class="headerlink" title="第7章 自然语言处理基础"></a>第7章 自然语言处理基础</h3><h4 id="7-1-循环神经网络基本结构"><a href="#7-1-循环神经网络基本结构" class="headerlink" title="7.1 循环神经网络基本结构"></a>7.1 循环神经网络基本结构</h4><h4 id="7-2前向传播与随时间反向传播"><a href="#7-2前向传播与随时间反向传播" class="headerlink" title="7.2前向传播与随时间反向传播"></a>7.2前向传播与随时间反向传播</h4><h4 id="7-3-循环神经网络变种"><a href="#7-3-循环神经网络变种" class="headerlink" title="7.3 循环神经网络变种"></a>7.3 循环神经网络变种</h4><h5 id="7-3-1-LSTM"><a href="#7-3-1-LSTM" class="headerlink" title="7.3.1 LSTM"></a>7.3.1 LSTM</h5><h5 id="7-3-2-GRU"><a href="#7-3-2-GRU" class="headerlink" title="7.3.2 GRU"></a>7.3.2 GRU</h5><h5 id="7-3-3-Bi-RNN"><a href="#7-3-3-Bi-RNN" class="headerlink" title="7.3.3 Bi-RNN"></a>7.3.3 Bi-RNN</h5><h4 id="7-4-循环神经网络的Pytorch实现"><a href="#7-4-循环神经网络的Pytorch实现" class="headerlink" title="7.4 循环神经网络的Pytorch实现"></a>7.4 循环神经网络的Pytorch实现</h4><h5 id="7-4-1-RNN实现"><a href="#7-4-1-RNN实现" class="headerlink" title="7.4.1 RNN实现"></a>7.4.1 RNN实现</h5><h5 id="7-4-2LSTM实现"><a href="#7-4-2LSTM实现" class="headerlink" title="7.4.2LSTM实现"></a>7.4.2LSTM实现</h5><h5 id="7-4-3GRU实现"><a href="#7-4-3GRU实现" class="headerlink" title="7.4.3GRU实现"></a>7.4.3GRU实现</h5><h4 id="7-5文本数据处理"><a href="#7-5文本数据处理" class="headerlink" title="7.5文本数据处理"></a>7.5文本数据处理</h4><h4 id="7-6词嵌入"><a href="#7-6词嵌入" class="headerlink" title="7.6词嵌入"></a>7.6词嵌入</h4><h5 id="7-6-1Word2Vec原理"><a href="#7-6-1Word2Vec原理" class="headerlink" title="7.6.1Word2Vec原理"></a>7.6.1Word2Vec原理</h5><h5 id="7-6-2-CBOW模型"><a href="#7-6-2-CBOW模型" class="headerlink" title="7.6.2 CBOW模型"></a>7.6.2 CBOW模型</h5><h5 id="7-6-3-Skim-gram模型"><a href="#7-6-3-Skim-gram模型" class="headerlink" title="7.6.3 Skim-gram模型"></a>7.6.3 Skim-gram模型</h5><h4 id="7-7-Pytorch实现词性判别"><a href="#7-7-Pytorch实现词性判别" class="headerlink" title="7.7 Pytorch实现词性判别"></a>7.7 Pytorch实现词性判别</h4><h5 id="7-7-1-词性判别主要步骤"><a href="#7-7-1-词性判别主要步骤" class="headerlink" title="7.7.1 词性判别主要步骤"></a>7.7.1 词性判别主要步骤</h5><h5 id="7-7-2-数据预处理"><a href="#7-7-2-数据预处理" class="headerlink" title="7.7.2 数据预处理"></a>7.7.2 数据预处理</h5><h5 id="7-7-3-构建网络"><a href="#7-7-3-构建网络" class="headerlink" title="7.7.3 构建网络"></a>7.7.3 构建网络</h5><h5 id="7-7-4-训练网络"><a href="#7-7-4-训练网络" class="headerlink" title="7.7.4 训练网络"></a>7.7.4 训练网络</h5><h5 id="7-7-5-测试模型"><a href="#7-7-5-测试模型" class="headerlink" title="7.7.5 测试模型"></a>7.7.5 测试模型</h5><h4 id="7-8循环神经网络应用场景"><a href="#7-8循环神经网络应用场景" class="headerlink" title="7.8循环神经网络应用场景"></a>7.8循环神经网络应用场景</h4><h3 id="第8章-生成式深度学习"><a href="#第8章-生成式深度学习" class="headerlink" title="第8章 生成式深度学习"></a>第8章 生成式深度学习</h3><h4 id="8-1-用变分自编码器生成图像"><a href="#8-1-用变分自编码器生成图像" class="headerlink" title="8.1 用变分自编码器生成图像"></a>8.1 用变分自编码器生成图像</h4><h5 id="8-1-1-自编码器"><a href="#8-1-1-自编码器" class="headerlink" title="8.1.1 自编码器"></a>8.1.1 自编码器</h5><h5 id="8-1-2变分自编码器"><a href="#8-1-2变分自编码器" class="headerlink" title="8.1.2变分自编码器"></a>8.1.2变分自编码器</h5><h5 id="8-1-3用变分自编码器生成图像"><a href="#8-1-3用变分自编码器生成图像" class="headerlink" title="8.1.3用变分自编码器生成图像"></a>8.1.3用变分自编码器生成图像</h5><h4 id="8-2-GAN简介"><a href="#8-2-GAN简介" class="headerlink" title="8.2 GAN简介"></a>8.2 GAN简介</h4><h5 id="8-2-1-GAN架构"><a href="#8-2-1-GAN架构" class="headerlink" title="8.2.1 GAN架构"></a>8.2.1 GAN架构</h5><h5 id="8-2-2-GAN的损失函数"><a href="#8-2-2-GAN的损失函数" class="headerlink" title="8.2.2 GAN的损失函数"></a>8.2.2 GAN的损失函数</h5><h4 id="8-3用GAN生成图像"><a href="#8-3用GAN生成图像" class="headerlink" title="8.3用GAN生成图像"></a>8.3用GAN生成图像</h4><h5 id="8-3-1判别器"><a href="#8-3-1判别器" class="headerlink" title="8.3.1判别器"></a>8.3.1判别器</h5><h5 id="8-3-2-生成器"><a href="#8-3-2-生成器" class="headerlink" title="8.3.2 生成器"></a>8.3.2 生成器</h5><h5 id="8-3-3-训练模型"><a href="#8-3-3-训练模型" class="headerlink" title="8.3.3 训练模型"></a>8.3.3 训练模型</h5><h5 id="8-3-4-可视化结果"><a href="#8-3-4-可视化结果" class="headerlink" title="8.3.4 可视化结果"></a>8.3.4 可视化结果</h5><h4 id="8-4-VAE与GAN的异同"><a href="#8-4-VAE与GAN的异同" class="headerlink" title="8.4 VAE与GAN的异同"></a>8.4 VAE与GAN的异同</h4><h4 id="8-5-Condition-GAN"><a href="#8-5-Condition-GAN" class="headerlink" title="8.5 Condition GAN"></a>8.5 Condition GAN</h4><h5 id="8-5-1-CGAN的架构"><a href="#8-5-1-CGAN的架构" class="headerlink" title="8.5.1 CGAN的架构"></a>8.5.1 CGAN的架构</h5><h5 id="8-5-2-CGAN-生成器"><a href="#8-5-2-CGAN-生成器" class="headerlink" title="8.5.2 CGAN 生成器"></a>8.5.2 CGAN 生成器</h5><h5 id="8-5-3-CGAN-判别器"><a href="#8-5-3-CGAN-判别器" class="headerlink" title="8.5.3 CGAN 判别器"></a>8.5.3 CGAN 判别器</h5><h5 id="8-5-4-CGAN-损失函数"><a href="#8-5-4-CGAN-损失函数" class="headerlink" title="8.5.4 CGAN 损失函数"></a>8.5.4 CGAN 损失函数</h5><h5 id="8-5-5-CGAN-可视化"><a href="#8-5-5-CGAN-可视化" class="headerlink" title="8.5.5 CGAN 可视化"></a>8.5.5 CGAN 可视化</h5><h5 id="8-5-6-查看指定标签的数据"><a href="#8-5-6-查看指定标签的数据" class="headerlink" title="8.5.6 查看指定标签的数据"></a>8.5.6 查看指定标签的数据</h5><h5 id="8-5-7-可视化损失值"><a href="#8-5-7-可视化损失值" class="headerlink" title="8.5.7 可视化损失值"></a>8.5.7 可视化损失值</h5><h4 id="8-6-DCGAN"><a href="#8-6-DCGAN" class="headerlink" title="8.6 DCGAN"></a>8.6 DCGAN</h4><h4 id="8-7-提升GAN训练效果的一些技巧"><a href="#8-7-提升GAN训练效果的一些技巧" class="headerlink" title="8.7 提升GAN训练效果的一些技巧"></a>8.7 提升GAN训练效果的一些技巧</h4><h2 id="深度学习实战"><a href="#深度学习实战" class="headerlink" title="深度学习实战"></a>深度学习实战</h2><h3 id="第9章-人脸检测与识别"><a href="#第9章-人脸检测与识别" class="headerlink" title="第9章 人脸检测与识别"></a>第9章 人脸检测与识别</h3><h4 id="9-1-人脸识别一般流程"><a href="#9-1-人脸识别一般流程" class="headerlink" title="9.1 人脸识别一般流程"></a>9.1 人脸识别一般流程</h4><h5 id="9-1-1图像采集"><a href="#9-1-1图像采集" class="headerlink" title="9.1.1图像采集"></a>9.1.1图像采集</h5><h5 id="9-1-2-人脸检测"><a href="#9-1-2-人脸检测" class="headerlink" title="9.1.2 人脸检测"></a>9.1.2 人脸检测</h5><h4 id="9-3特征提取"><a href="#9-3特征提取" class="headerlink" title="9.3特征提取"></a>9.3特征提取</h4><h4 id="9-4人脸识别"><a href="#9-4人脸识别" class="headerlink" title="9.4人脸识别"></a>9.4人脸识别</h4><h5 id="9-4-1-人脸识别主要原理"><a href="#9-4-1-人脸识别主要原理" class="headerlink" title="9.4.1 人脸识别主要原理"></a>9.4.1 人脸识别主要原理</h5><h5 id="9-4-2人脸识别发展"><a href="#9-4-2人脸识别发展" class="headerlink" title="9.4.2人脸识别发展"></a>9.4.2人脸识别发展</h5><h4 id="9-5-人脸检测与识别实例"><a href="#9-5-人脸检测与识别实例" class="headerlink" title="9.5 人脸检测与识别实例"></a>9.5 人脸检测与识别实例</h4><h5 id="9-5-1-验证检测代码"><a href="#9-5-1-验证检测代码" class="headerlink" title="9.5.1.验证检测代码"></a>9.5.1.验证检测代码</h5><h5 id="9-5-2-检测图像"><a href="#9-5-2-检测图像" class="headerlink" title="9.5.2.检测图像"></a>9.5.2.检测图像</h5><h5 id="9-5-3-检测后进行预处理"><a href="#9-5-3-检测后进行预处理" class="headerlink" title="9.5.3.检测后进行预处理"></a>9.5.3.检测后进行预处理</h5><h5 id="9-5-4-查看经检测后的图片"><a href="#9-5-4-查看经检测后的图片" class="headerlink" title="9.5.4.查看经检测后的图片"></a>9.5.4.查看经检测后的图片</h5><h5 id="9-5-5-人脸识别"><a href="#9-5-5-人脸识别" class="headerlink" title="9.5.5.人脸识别"></a>9.5.5.人脸识别</h5><h3 id="第10章-迁移学习实例"><a href="#第10章-迁移学习实例" class="headerlink" title="第10章 迁移学习实例"></a>第10章 迁移学习实例</h3><p>10.1 迁移学习简介<br>10.2 特征提取<br>10.2.1 Pytorch提供的预处理模块<br>10.2.2 特征提取实例<br>10.3 数据增强<br>10.3.1 按比例缩放<br>10.3.2 裁剪<br>10.3.3翻转<br>10.3.4改变颜色<br>10.3.5组合多种增强方法<br>10.4 微调实例<br>10.4.1 数据预处理<br>10.4.2 加载预训练模型<br>10.4.3 修改分类器<br>10.4.4 选择损失函数及优化器<br>10.4.5 训练及验证模型<br>10.5 用预训练模型清除图像中的雾霾<br>10.5.1 导入需要的模块<br>10.5.2 查看原来的图像<br>10.5.3 定义一个神经网络<br>10.5.4 训练模型<br>10.5.5 查看处理后的图像</p><h3 id="第11章-神经网络机器翻译实例"><a href="#第11章-神经网络机器翻译实例" class="headerlink" title="第11章 神经网络机器翻译实例"></a>第11章 神经网络机器翻译实例</h3><p>11.1 Encode-Decoder模型原理<br>11.2 注意力框架<br>11.3 Pytorch实现注意力Decoder<br>11.3.1 构建Encoder<br>11.3.2 构建简单Decoder<br>11.3.3 构建注意力Decoder<br>11.4 用注意力机制实现中英文互译<br>11.4.1 导入需要的模块<br>11.4.2数据预处理<br>11.4.3构建模型<br>11.4.4训练模型<br>11.4.5随机采样，对模型进行测试<br>11.4.6可视化注意力</p><h3 id="第12章-实战生成式模型"><a href="#第12章-实战生成式模型" class="headerlink" title="第12章 实战生成式模型"></a>第12章 实战生成式模型</h3><p>12.1 Deep Dream模型<br>12.1.1 Deep Dream原理<br>12.1.2 DeepDream算法流程<br>12.1.3 用Pytorch实现Deep Dream<br>12.2 风格迁移<br>12.2.1 内容损失<br>12.2.2 风格损失<br>12.2.3 用Pytorch实现神经网络风格迁移<br>12.3 Pytorch实现图像修复<br>12.3.1 网络结构<br>12.3.2 损失函数<br>12.3.3 图像修复实例<br>12.4 Pytorch实现DiscoGAN<br>12.4.1 DiscoGAN架构<br>12.4.2 损失函数<br>12.4.3 DiscoGAN实现<br>12.4.4 用Pytorch实现从边框生成鞋子</p><h3 id="第13章-Caffe2模型迁移实例"><a href="#第13章-Caffe2模型迁移实例" class="headerlink" title="第13章 Caffe2模型迁移实例"></a>第13章 Caffe2模型迁移实例</h3><p>13.1 Caffe2简介<br>13.2 Caffe如何迁移到Caffe2<br>13.3 Pytorch如何迁移到caffe2</p><h3 id="第14章-AI新方向：对抗攻击"><a href="#第14章-AI新方向：对抗攻击" class="headerlink" title="第14章 AI新方向：对抗攻击"></a>第14章 AI新方向：对抗攻击</h3><p>14.1对抗攻击简介<br>14.1.1白盒攻击与黑盒攻击<br>14.1.2无目标攻击与有目标攻击<br>14.2常见对抗样本生成方式<br>14.2.1快速梯度符号法<br>14.2.2快速梯度算法<br>14.3 Pytorch实现对抗攻击<br>14.3.1 实现无目标攻击<br>14.3.2 实现有目标攻击<br>14.4 对抗攻击和防御措施<br>14.4.1 对抗攻击<br>14.4.2 常见防御方法分类<br>14.5 总结</p><h3 id="第15章-强化学习"><a href="#第15章-强化学习" class="headerlink" title="第15章 强化学习"></a>第15章 强化学习</h3><p>15.1 强化学习简介<br>15.2Q Learning 原理<br>15.2.1 Q Learning主要流程<br>15.2.2 Q函数<br>15.2.3 贪婪策略<br>15.3 用Pytorch实现Q Learning<br>15.3.1 定义Q-Learing主函数<br>15.3.2执行Q-Learing<br>15.4 SARSA 算法<br>15.4.1 SARSA算法主要步骤<br>15.4.2 用Pytorch实现SARSA算法</p><p>第16章 深度强化学习<br>16.1 DSN算法原理<br>16.1.1 Q-Learning方法的局限性<br>16.1.2 用DL处理RL需要解决的问题<br>16.1.3 用DQN解决方法<br>16.1.4 定义损失函数<br>16.1.5 DQN的经验回放机制<br>16.1.6 目标网络<br>16.1.7 网络模型<br>16.1.8 DQN算法<br>16.2 用Pytorch实现 DQN算法</p><h2 id="AI在各行业的最新应用"><a href="#AI在各行业的最新应用" class="headerlink" title="AI在各行业的最新应用"></a>AI在各行业的最新应用</h2><h3 id="AI-电商"><a href="#AI-电商" class="headerlink" title="AI+电商"></a>AI+电商</h3><h3 id="AI-金融"><a href="#AI-金融" class="headerlink" title="AI+金融"></a>AI+金融</h3><h3 id="AI-医疗"><a href="#AI-医疗" class="headerlink" title="AI+医疗"></a>AI+医疗</h3><h3 id="AI-零售"><a href="#AI-零售" class="headerlink" title="AI+零售"></a>AI+零售</h3><h3 id="AI-投行"><a href="#AI-投行" class="headerlink" title="AI+投行"></a>AI+投行</h3><h3 id="AI-制造"><a href="#AI-制造" class="headerlink" title="AI+制造"></a>AI+制造</h3><h3 id="AI-IT服务"><a href="#AI-IT服务" class="headerlink" title="AI+IT服务"></a>AI+IT服务</h3><h3 id="AI-汽车"><a href="#AI-汽车" class="headerlink" title="AI+汽车"></a>AI+汽车</h3><h3 id="AI-公共安全"><a href="#AI-公共安全" class="headerlink" title="AI+公共安全"></a>AI+公共安全</h3><p><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/30.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/31.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/32.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/33.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/34.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/35.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/36.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/37.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/38.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/39.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/40.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/41.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/42.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/43.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/44.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/45.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/46.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/47.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/48.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/49.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/50.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/51.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/52.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/53.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/54.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/55.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/56.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/57.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/58.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/59.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/60.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/61.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/62.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/63.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/64.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/65.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/66.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/67.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/68.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/69.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/70.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/71.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/72.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/73.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/74.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/75.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/76.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/77.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/78.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/79.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/80.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/81.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/82.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/83.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/84.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/85.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/86.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/87.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/88.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/89.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/90.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/91.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/92.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/93.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/94.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/95.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/96.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/97.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/98.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/99.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/100.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/101.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/102.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/103.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/104.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/105.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/106.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/107.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/108.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/109.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/110.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/111.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/112.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/113.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/114.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/115.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/116.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/117.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/118.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/119.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/120.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/121.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/122.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/123.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/124.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/125.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/126.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/127.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/128.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/129.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/130.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/131.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/132.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/133.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/134.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/135.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/136.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/137.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/138.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/139.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/140.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/141.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/142.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/143.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/144.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/145.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/146.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/147.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/148.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/149.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/150.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/151.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/152.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/153.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/154.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/155.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/156.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/157.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/158.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/159.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/160.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/161.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/162.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/163.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/164.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/165.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/166.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/167.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/168.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/169.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/170.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/171.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/172.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/173.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/174.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/175.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/176.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/177.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/178.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/179.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/180.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/181.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/182.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/183.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/184.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/185.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/186.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/187.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/188.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/189.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/190.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/191.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/192.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/193.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/194.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/195.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/196.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/197.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/198.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/199.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/200.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/201.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/202.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/203.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/204.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/205.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/206.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/207.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/208.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/209.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/210.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/211.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/212.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/213.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/214.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/215.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/216.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/217.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/218.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/219.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/220.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/221.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/222.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/223.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/224.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/225.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/226.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/227.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/228.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/229.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/230.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/231.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/232.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/233.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/234.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/235.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/236.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/237.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/238.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/239.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/240.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/241.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/242.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/243.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/244.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/245.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/246.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/247.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/248.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/249.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/250.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/251.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/252.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/253.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/254.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/255.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/256.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/257.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/258.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/259.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/260.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/261.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/262.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/263.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/264.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/265.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/266.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/267.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/268.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/269.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/270.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/271.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/272.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/273.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/274.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/275.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/276.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/277.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/278.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/279.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/280.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/281.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/282.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/283.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/284.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/285.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/286.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/287.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/288.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/289.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/290.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/291.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/292.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/293.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/294.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/295.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/296.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/297.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/298.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/299.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/300.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/301.jpg" alt=""><br><img src="https://2020.iosdevlog.com/2020/02/17/pytorch/302.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/17/pytorch/1.jpg&quot; alt=&quot;《Python深度学习：基于PyTorch》&quot;&gt;&lt;/p&gt;
&lt;p&gt;书名：Python深度学习：基于PyTorch&lt;br&gt;作者：吴茂贵，郁明敏，杨本法，李涛，张粤磊&lt;br&gt;出版社：机械工业出版社&lt;br&gt;出版时间：2019-10&lt;br&gt;ISBN：9787111637172&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="PyTorch" scheme="https://2020.iosdevlog.com/tags/PyTorch/"/>
    
      <category term="Python" scheme="https://2020.iosdevlog.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>智能安卓恶意软件检测系统</title>
    <link href="https://2020.iosdevlog.com/2020/02/16/android/"/>
    <id>https://2020.iosdevlog.com/2020/02/16/android/</id>
    <published>2020-02-16T10:50:36.000Z</published>
    <updated>2020-02-16T11:04:03.888Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/16/android/1.png" alt="HinDroid"></p><p><a href="https://dl.acm.org/doi/10.1145/3097983.3098026" target="_blank" rel="noopener">HinDroid: An Intelligent Android Malware Detection System Based on Structured Heterogeneous Information Network</a></p><a id="more"></a><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>这篇论文希望解决的问题是如何有效地监测安卓手机系统下的恶意软件。</p><p>之前很多恶意软件的分析和检测都是基于某种 <strong>指纹签字</strong> 技术，然而这种技术常常被恶意软件开发者的新手段绕过。</p><p>因此，寻找更加复杂有效的检测方式就成了各种信息安全公司所追逐的目标。</p><p>这篇论文的主要贡献是根据安卓的 API，提出了一种新的基于结构性异构信息网络的方法，来对安卓程序的 API 模式进行更加复杂的建模，从而能够理解整个安卓程序的语义。作者们还采用了多核学习（Multi-Kernel Learning）的方法，在结构性异构信息网络的基础上对程序语义模式进行分类。</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>首先，需要将安卓的程序代码转换为可以分析的形式。一般来说，安卓的软件被打包为后缀名为 Dex 的 Dalivik 执行文件，这个执行文件无法被直接分析。于是，需要把这个执行文件通过一个叫 Smali 的反汇编器解析成 Smali 代码。这个时候，软件的语义就能够通过 Smali 代码来解析了。作者们从 Smali 代码中提取所有的 API 调用，通过对 API 的分析来对程序行为建模。下一步，就是要从繁复的 API 调用中摸索出这里面的规律。</p><p>作者们这个时候构建了四类矩阵来表达 API 和某个 App 之间的基本特征：</p><ol><li>某一个 App 是否包含了某一个 API；</li><li>某两个 API 是否同时出现在某一段代码中；</li><li>某两个 API 是否出现在同一个 App 中；</li><li>某两个 API 是否使用了相同的调用方法。</li></ol><p>为了发现更加复杂的规律，作者们在这里引入了一个工具叫异构信息网络。异构信息网络的概念最早由伊利诺伊大学香槟分校的数据挖掘权威韩家炜（Jiawei Han）和他当时的学生孙怡舟（Yizhou Sun，目前在加州大学洛杉矶分校任教）提出。异构信息网络的核心思想就是希望能够表达一系列实体（Entity）之间的复杂规律。</p><p>把 App 和 API 的关系描述成为异构信息网络以后，下面的工作就是定义更高阶的规律关系。</p><p>利用异构信息网络和元路径构建了程序的语义表达后，下一步就是进行恶意软件的判别。</p><p><img src="https://2020.iosdevlog.com/2020/02/16/android/2.png" alt="Multi-kernel Learning"></p><p>参考: <a href="https://time.geekbang.org/column/article/394" target="_blank" rel="noopener">https://time.geekbang.org/column/article/394</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/16/android/1.png&quot; alt=&quot;HinDroid&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dl.acm.org/doi/10.1145/3097983.3098026&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HinDroid: An Intelligent Android Malware Detection System Based on Structured Heterogeneous Information Network&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="paper" scheme="https://2020.iosdevlog.com/tags/paper/"/>
    
      <category term="Android" scheme="https://2020.iosdevlog.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>《白夜行》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/16/9787544242516/"/>
    <id>https://2020.iosdevlog.com/2020/02/16/9787544242516/</id>
    <published>2020-02-15T16:00:48.000Z</published>
    <updated>2020-02-16T11:25:23.613Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/16/9787544242516/1.svg" alt="《白夜行》人物关系图"></p><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 南海出版公司<br>出品方: 新经典文化<br>原作名: 白夜行<br>译者: 刘姿君<br>出版年: 2008-9<br>页数: 467<br>定价: 29.80元<br>装帧: 平装<br>丛书: 新经典文库·东野圭吾作品<br>ISBN: 9787544242516</p><p><img src="https://2020.iosdevlog.com/2020/02/16/9787544242516/2.png" alt="《白夜行》"></p><h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>“只希望能手牵手在太阳下散步”，这个象征故事内核的绝望念想，有如一个美丽的幌子，随着无数凌乱、压抑、悲凉的故事片段像纪录片一样一一还原：没有痴痴相思，没有海枯石烂，只剩下一个冰冷绝望的诡计，最后一丝温情也被完全抛弃，万千读者在一曲救赎罪恶的凄苦爱情中悲切动容……</p><h2 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h2><blockquote><p>“捡别人丢的东西不还，跟偷别人随意放置的东西，并没有什么差别。有错的难道不是把装了钱的包随便放的人吗？这个社会上，让别人有机可乘的人注定要吃亏。”</p></blockquote><blockquote><p>“我的人生就像在 <strong>白夜里走路</strong>。”</p></blockquote><p>– 书名来原</p><blockquote><p>“专家系统是人工智能的应用之一，就是以电脑取代专家的系统。”</p></blockquote><p>– 2008 年的小说就已经有 AI 应用</p><blockquote><p>“喏，夏美，一天当中，有太阳升起的时候，也有下沉的时候。人生也一样，有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。看个人，有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失，现在的夏美就是这样。”</p></blockquote><blockquote><p>“我呢，”雪穗继续说，“从来就没有生活在太阳底下过。”</p></blockquote><blockquote><p>“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吧？我从来就没有太阳，所以不怕失去。”</p></blockquote><h2 id="《白夜行》vs-《幻夜》"><a href="#《白夜行》vs-《幻夜》" class="headerlink" title="《白夜行》vs 《幻夜》"></a>《白夜行》vs 《幻夜》</h2><p><img src="https://2020.iosdevlog.com/2020/02/12/9787544291811/1.svg" alt="《幻夜》人物关系图"></p><p>失去生命中最后的光芒，她完全堕入无边幻夜，开始极尽邪恶而妖艳的表演……</p><p>如果要说《白夜行》中有着任何一丝可以被称为是 <strong>希望</strong> 的东西，那么到了《幻夜》，东野圭吾连这一丝都从我们面前夺走了。</p><p>从这个意义上，《幻夜》是一本不折不扣的 <strong>绝望之书</strong>。”</p><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>《白夜行》</p><p>女主遭性侵，男主杀人。</p><p>《幻夜》</p><p>男主杀人，女主遭性侵。</p><h3 id="书名"><a href="#书名" class="headerlink" title="书名"></a>书名</h3><p>《白夜行》</p><p>《飘》</p><p>《幻夜》</p><p>《飘》</p><h3 id="精品店名"><a href="#精品店名" class="headerlink" title="精品店名"></a>精品店名</h3><p>《白夜行》</p><p>BLUE SNOW / 蓝<strong>雪</strong></p><p>《幻夜》</p><p>WHITE NIGHT / <strong>白夜</strong></p><h3 id="警察"><a href="#警察" class="headerlink" title="警察"></a>警察</h3><blockquote><p>“<strong>枪虾</strong> 会挖洞，住在洞里。可有个家伙却要去住在它的洞里，那就是 <strong>虾虎鱼</strong>。不过虾虎鱼也不白住，它会在洞口巡视，要是有外敌靠近，就摆动尾鳍通知洞里的枪虾。它们合作无间，这好像叫互利共生。”</p></blockquote><p>– 笹垣比喻为 <strong>枪虾 &amp; 虾虎鱼</strong></p><blockquote><p>“大学毕业后，我曾经尝试过各种道路，因为不清楚应该如何生存下去。就在这时，我遇到了一个女子，我发现那个人正是我的理想。我在她身边工作，经常和她一起行动。当她舍弃一切、想去国外生活的时候，在我的再三恳求下，她同意带我一起去。我想成为那样的人，所有的一切都模仿她。后来，连外形，也就是容貌，都想变得和她一样。“</p></blockquote><p>– (假）新海美冬</p><blockquote><p>“她会不会就是你自己？是不是以前你就被真正的新海美冬这样仰慕过？而且，那个时候你见过曾我。所以到了今天，如果他再出现在作为新海美冬而活着的你面前，无疑是一种障碍，不对吗？“</p></blockquote><p>– 加藤</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>《白夜行》</p><p>只见雪穗正沿扶梯上楼，背影犹如白色的幽灵。</p><p>她一次都没有回头。</p><p>亮司最后强奸了美佳，变成了他的父亲那样的人。</p><p>雪穗安排这一切，变成了她母亲那样的人。</p><p>男主死</p><p>女主无罪</p><p>《幻夜》</p><blockquote><p>“没有。这么美好的夜晚还是第一次看到，简直像幻夜一般。”</p></blockquote><p>说着，她露出娇媚的笑容。</p><p>女主无罪</p><p>男主死</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/16/9787544242516/1.svg&quot; alt=&quot;《白夜行》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
  </entry>
  
  <entry>
    <title>Kindle 无 USB 传书</title>
    <link href="https://2020.iosdevlog.com/2020/02/15/kindle/"/>
    <id>https://2020.iosdevlog.com/2020/02/15/kindle/</id>
    <published>2020-02-15T15:01:35.000Z</published>
    <updated>2020-02-15T15:24:51.509Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/15/kindle/1.jpg" alt="不能连 USB"></p><a id="more"></a><p>如何把电子书资源导入到Kindle？</p><ol><li>亚马逊官方商城直接购买</li><li>使用 Kindle 电子邮箱传书（包括第三方推送）</li><li>使用 USB 数据线导入</li><li>通过公众号【亚马逊 Kindle 服务号】将文章推送到 Kindle</li><li>通过 Cailbre 传书到 Kindle</li><li>通过手机发送传书到 Kindle app</li></ol><p>如果是已经在电脑里面的书籍需要传书，使用 USB 数据线导入。</p><p>Kindle 的 USB 接口连接到 macOS 上面，能充电，却不能显示 U 盘。<br>还可以选 使用 Kindle 电子邮箱传书（包括第三方推送）。<br>不过电子邮箱传书大小有限制。<br>Kindle 如果可以访问网页版浏览器，这时候就可以自己搭建 <code>http</code> 服务器传书。</p><p><code>Kindle</code> 的 <code>USB</code> 接口连接到 <code>macOS</code> 上面，能充电，却不能显示 <code>U</code> 盘。</p><p>除了使用邮箱推送，还可以让 <code>Kindle</code> 访问 <code>http</code>。</p><h2 id="查看本机-ip-地址"><a href="#查看本机-ip-地址" class="headerlink" title="查看本机 ip 地址"></a>查看本机 <code>ip</code> 地址</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig | grep 192.168</span><br><span class="line">192.168.x.x</span><br></pre></td></tr></table></figure><h2 id="http-服务"><a href="#http-服务" class="headerlink" title="http 服务"></a>http 服务</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure><ol><li>Kindle 主页</li><li>最左侧三个点</li><li>体验网页版浏览器</li><li><code>192.168.x.x:8000</code></li></ol><p>下载文件即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/15/kindle/1.jpg&quot; alt=&quot;不能连 USB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="kindle" scheme="https://2020.iosdevlog.com/tags/kindle/"/>
    
  </entry>
  
  <entry>
    <title>通过挖掘类比关系加速创新</title>
    <link href="https://2020.iosdevlog.com/2020/02/15/mining/"/>
    <id>https://2020.iosdevlog.com/2020/02/15/mining/</id>
    <published>2020-02-15T13:00:11.000Z</published>
    <updated>2020-02-15T13:30:15.722Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/15/mining/1.png" alt="挖掘"></p><p>Paper: <a href="http://www.hyadatalab.com/papers/analogy-kdd17.pdf" target="_blank" rel="noopener">Accelerating Innovation Through Analogy Mining</a></p><p>这篇文章主要阐述了帮助创新的一个重要步骤，那就是如何找到合适并且有效的类比案例。</p><p>如何找到合适的类比，并能从中获取灵感，可能就是创新的一个关键因素。</p><a id="more"></a><h2 id="论文的核心方法"><a href="#论文的核心方法" class="headerlink" title="论文的核心方法"></a>论文的核心方法</h2><p>首先，作者们提出了一组叫“目的”（Purpose）和“机制”（Mechanism）的概念。什么叫“目的”呢？那就是当前的产品是要解决什么问题的。什么叫“机制”呢？那就是当前的产品是使用什么手段或者方法来解决这个问题的。对于一个产品，如果我们能够明确这个产品的目的和机制，找到类比就变得更加容易。比如，我们可以针对某一个问题，相同的目的，采用不同的机制或者对不同的问题采用相同的机制。</p><p>作者们认为，<strong>这种对产品信息的分类符合很多工程设计的过程，是创新过程中的一个必要环节</strong>。</p><p>有了这种想法以后，很自然的下一个步骤就是如何从数据中学习到目的和机制，如何自动挖掘出海量产品信息的目的和机制。要想学习到这样的信息，作者们提出了一种依靠标签数据的监督学习（Supervised Leanring）机制。具体说来，作者们把文本信息中的每句话、短语交给亚马逊土耳其机器人（Amazon Mechanical Turk）上的在线工人，来标注每个文本信息是目的信息还是机制信息。也就是说，作者们依靠有标注的数据来训练提出的算法。</p><p>首先，我们有一组文本，每组文本都有这些文本的原始文字。<strong>针对每个文档，我们都收集 K 个目的标注和 K 个机制标注</strong>。这时，我们定义一组“目的标注”（Purpose Annotation）向量，其实也就是一组 0 或者 1 的向量。当文本原始文字中的某个字被标识为目的的时候，这个向量的相应元素置 1，反之置 0。类似的，我们也可以定义“机制标注”（Mechanism Annotation）向量。因为我们有 K 个标注，因此我们也有相应的 K 个“目的标注”向量和“机制标注”向量。这两组向量可以说是原始标签信息的一种向量的表达。</p><p>下一步就是从每一个有标签信息的文档里产生 <strong>唯一的目的向量和机制向量</strong>。这篇文章采用的方法是，利用每个单词的 <strong>嵌入向量（Embedding）</strong> 来获得这个唯一的向量。</p><p>参考: <a href="https://time.geekbang.org/column/article/391" target="_blank" rel="noopener">https://time.geekbang.org/column/article/391</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/15/mining/1.png&quot; alt=&quot;挖掘&quot;&gt;&lt;/p&gt;
&lt;p&gt;Paper: &lt;a href=&quot;http://www.hyadatalab.com/papers/analogy-kdd17.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Accelerating Innovation Through Analogy Mining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章主要阐述了帮助创新的一个重要步骤，那就是如何找到合适并且有效的类比案例。&lt;/p&gt;
&lt;p&gt;如何找到合适的类比，并能从中获取灵感，可能就是创新的一个关键因素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="paper" scheme="https://2020.iosdevlog.com/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>一张图搞定《人民的名义》里错综复杂的人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/14/people/"/>
    <id>https://2020.iosdevlog.com/2020/02/14/people/</id>
    <published>2020-02-14T15:45:47.000Z</published>
    <updated>2020-02-14T18:01:07.356Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/14/people/1.svg" alt="《人民的名义》人物关系图"></p><a id="more"></a><p>书名：人民的名义<br>作者：周梅森<br>出版社：北京十月文艺出版社<br>出版时间：2017-01<br>ISBN：9787530216194</p><p>人民的名义</p><p>一分未花赵德汉<br>人脉能手丁义珍</p><p>王之蔑视李达康<br>学习外语陈清泉</p><p>信仰坚定刘新建<br>宇宙区长孙连城</p><p>锄地狂魔高育良</p><p>还没退休季昌明</p><p>不许牛逼赵瑞龙<br>聪明绝顶杜老板</p><p>再判回来<br>专业点穴易学习</p><p>命运坎坷高小琴<br>胜天半子祁同伟</p><p>挖地能手祁同伟<br>–沙瑞金评</p><blockquote><p>他拦下了李达康的车，挽救了李达康的政治前途啊！这是他的心里话，他真心感谢这位不畏权势的年轻反贪局局长。这位反贪局局长把一个天大的麻烦帮他拦在省内了。</p></blockquote><blockquote><p>沙瑞金看着湖面，又和田国富说了起来：国富，你不觉得这个事有点意思吗？李达康是市长，又做过赵立春的秘书，可他没批湖畔花园和湖上美食城，倒是育良同志给赵家公子批了，岂不耐人寻味？</p></blockquote><blockquote><p>今天我历尽艰难找到了你，真心是想带你回家，我不希望你死！可你清楚，有人希望你死！你死了，他们就安全了，他们就可以继续以 <strong>人民的名义</strong> 夸夸其谈了！老同学，你说你在这里找到了人民，那就请你以 <strong>人民的名义</strong> 去想一想，以残存的良知想一想，是不是该收手了？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/14/people/1.svg&quot; alt=&quot;《人民的名义》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="人物" scheme="https://2020.iosdevlog.com/tags/%E4%BA%BA%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>线性大规模支持向量机</title>
    <link href="https://2020.iosdevlog.com/2020/02/14/svm/"/>
    <id>https://2020.iosdevlog.com/2020/02/14/svm/</id>
    <published>2020-02-14T13:41:28.000Z</published>
    <updated>2020-02-16T07:03:36.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/14/svm/1.png" alt="svm"></p><p>Paper: <a href="https://www.cs.cornell.edu/people/tj/publications/joachims_06a.pdf" target="_blank" rel="noopener">Training Linear SVMs in Linear Time</a></p><a id="more"></a><p>回到这篇时间检验奖的论文，它解决的是大规模优化支持向量机的问题，特别是线性支持向量机。</p><p>这篇文章第一次提出了简单易行的线性支持向量机实现，包括对有序回归（Ordinal Regression）的支持。</p><p>算法对于分类问题达到了 O(sn)（其中 s 是非 0 的特征数目而 n 是数据点的个数），也就是实现了线性复杂度，而对有序回归的问题达到了 O(snlog(n)) 的复杂度。</p><p>算法本身简单、高效、易于实现，并且理论上可以扩展到核函数（Kernel）的情况。</p><p>在此之前，很多线性支持向量机的实现都无法达到线性复杂度 。</p><p>比如当时的 LibSVM（台湾国立大学的学者发明）、SVM-Torch、以及早期的 SVM-Light 中采用的分解算法（Decomposition Method）都只能比较有效地处理大规模的特征。</p><p>而对于大规模的数据 (n)，则是超线性（Super-Linear）的复杂度。</p><p>另外的一些方法，能够训练复杂度线性地随着训练数据的增长而增长，但是却对于特征数 N 呈现了二次方 (N^2) 的复杂度。</p><p>因此之前的这些方法无法应用到大规模的数据上。</p><p>这样的情况对于有序回归支持向量机更加麻烦。</p><p>从德国学者拉尔夫·赫布里希（Ralf Herbrich）提出有序回归支持向量机以来，一直需要通过转化为普通的支持向量机的分类问题而求解。</p><p>这个转换过程需要产生 O(n^2) 的训练数据，使得整个问题的求解也在这个量级的复杂度。</p><p>这篇文章里，Thorsten 首先做的是对普通的支持向量机算法的模型形式（Formalism）进行了变形。</p><p>他把传统的分类支持向量机（Classification SVM）写成了结构化分类支持向量机（Structural Classification SVM），并且提供了一个定理来证明两者之间的等价性。</p><p>粗一看，这个等价的结构化分类支持向量机并没有提供更多有价值的信息。</p><p>然而这个新的优化目标函数的对偶（Dual）形式，由于它特殊的稀疏性，使它能够被用来进行大规模训练。</p><p>紧接着，Thorsten 又把传统的有序回归支持向量机的优化函数，写成了结构化支持向量机的形式，并且证明了两者的等价性。</p><p>把两种模型表达成结构化向量机的特例之后，Thorsten 开始把解决结构化向量机的一种算法——切割平面算法（Cutting-Plane），以下称 CP 算法，运用到了这两种特例上。</p><p>首先，他展示了 CP 算法在分类问题上的应用。</p><p>简单说来，这个算法就是保持一个工作集合（Working Set），来存放当前循环时依然被违反的约束条件（Constraints），然后在下一轮中集中优化这部分工作集合的约束条件。</p><p>整个流程开始于一个空的工作集合，每一轮优化的是一个基于当前工作集合的支持向量机子问题，算法直到所有的约束条件的误差小于一个全局的参数误差为止。</p><p>Thorsten 在文章中详细证明了这个算法的有效性和时间复杂度。</p><p>相同的方法也使得有序回归支持向量机的算法能够转换成为更加计算有效的优化过程。</p><p>Thorsten 在文章中做了详尽的实验来展现新算法的有效性。</p><p>从数据的角度，他使用了 5 个不同的数据集，分别是路透社 RCV1 数据集的好几个子集。</p><p>数据的大小从 6 万多数据点到 80 多万数据点不等，特征数也从几十到四万多特征不等，这几种不同的数据集还是比较有代表性的。</p><p>从方法的比较上来说，Thorsten 主要比较了传统的分解方法。</p><p>有两个方面是重点比较的，第一就是训练时间。</p><p>在所有的数据集上，这篇文章提出的算法都比传统算法快几个数量级，提速达到近 100 倍。</p><p>而有序回归的例子中，传统算法在所有数据集上都无法得到最后结果。</p><p>Thorsten 进一步展示了训练时间和数据集大小的线性关系，从而验证了提出算法在真实数据上的表现。</p><p>第二个重要的比较指标是算法的准确度是否有所牺牲。</p><p>因为有时候算法的提速是在牺牲算法精度的基础上做到的，因此验证算法的准确度就很有意义。</p><p>在这篇文章里，Thorsten 展示，提出的算法精度，也就是分类准确度并没有统计意义上的区分度，也让这个算法的有效性有了保证。</p><p>Thorsten 在他的软件包 SVM-Perf 中实现了这个算法。</p><p>这个软件包一度成了支持向量机研究和开发的标准工具。</p><p>参考: <a href="https://time.geekbang.org/column/article/159" target="_blank" rel="noopener">https://time.geekbang.org/column/article/159</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/14/svm/1.png&quot; alt=&quot;svm&quot;&gt;&lt;/p&gt;
&lt;p&gt;Paper: &lt;a href=&quot;https://www.cs.cornell.edu/people/tj/publications/joachims_06a.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Training Linear SVMs in Linear Time&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="paper" scheme="https://2020.iosdevlog.com/tags/paper/"/>
    
      <category term="svm" scheme="https://2020.iosdevlog.com/tags/svm/"/>
    
  </entry>
  
  <entry>
    <title>数据的重要性</title>
    <link href="https://2020.iosdevlog.com/2020/02/13/data/"/>
    <id>https://2020.iosdevlog.com/2020/02/13/data/</id>
    <published>2020-02-13T15:26:32.000Z</published>
    <updated>2020-02-13T15:52:29.666Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/13/data/1.png" alt="数据"></p><a id="more"></a><p>机器学习三要素包括 <strong>数据</strong>、<strong>模型</strong>、<strong>算法</strong>。</p><p>总结成一句话:</p><blockquote><p>算法通过在数据上进行运算产生模型。</p></blockquote><p>2020年2月12日0时-24时，湖北省新增新冠状肺炎病例14840例(含临床诊断病例13332例)。</p><p>你有什么想说的？</p><p>​<strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</strong></p><p><strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</strong></p><p><strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</strong></p><p>重要的事情说 3 遍。</p><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>特征工程是利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。通俗的说，就是尽可能的从原始数据中获取更多信息，从而使得预测模型达到最佳。</p></blockquote><p>–维基百科</p><p>简而言之，特征工程是一个把原始数据变成特征的过程，这些特征可以很好的描述数据，并且利用它们建立的模型在未知数据上表现性能可以达到最优。</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>实验结果取决于获取的数据、使用的特征以及选择的模型，甚至问题的形式和评估精度的客观方法也扮演了一部分。我们需要的是能够很好地描述数据内部结构的好特征。</p><ul><li>特征越好，灵活性越强</li></ul><p>只要特征选得好，即使是一般的模型（或算法）也能获得很好的性能，因为大多数模型（或算法）在好的数据特征下表现的性能都还不错。好特征的灵活性在于它允许你选择不复杂的模型，同时运行速度也更快，也更容易理解和维护。</p><ul><li>特征越好，构建的模型越简单</li></ul><p>有了好的特征，即便你的参数不是最优的，你的模型性能也能仍然会表现的很nice，所以你就不需要花太多的时间去寻找最有参数，这大大的降低了模型的复杂度，使模型趋于简单。</p><ul><li>特征越好，模型的性能越出色</li></ul><p>特征工程的最终目的就是提升模型的性能。</p><p>总结：</p><p><strong>数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/13/data/1.png&quot; alt=&quot;数据&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="ML" scheme="https://2020.iosdevlog.com/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>《AI技术内参》开篇</title>
    <link href="https://2020.iosdevlog.com/2020/02/13/ai/"/>
    <id>https://2020.iosdevlog.com/2020/02/13/ai/</id>
    <published>2020-02-13T11:44:32.000Z</published>
    <updated>2020-02-13T11:50:21.115Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/13/ai/1.png" alt="《AI技术内参》"></p><a id="more"></a><p>第一，一些经典的人工智能技术。这些技术涵盖搜索、推荐系统、广告系统、图像处理等领域。了解这些经典技术能够让你迅速入门并能为今后的学习打下基础。这部分内容帮助你分析核心的算法模型，并为你进行系统性学习提供纲要和指引。</p><p>第二，最新的顶级学术会议动态，帮助你了解和掌握这些学术会议最火热和最新的研究成果。每一年和人工智能相关的顶级学术会议有十余个，每个会议都会有上百篇甚至几百篇论文发表。从这些论文和成果中找到有价值的信息，对于初学者，甚至是有一定经验的从业人员来说都是非常困难、也非常耗时的一件事情。那么，在这个专栏里，我会为你精选内容，可以让你不错过任何有价值的最新成果。</p><p>第三，人工智能的从业人员提供指南，帮助数据科学家和工程师提升自我价值，帮助人工智能团队的管理者构建团队，为你在职场发展中的关键步骤出谋划策。</p><p><img src="https://2020.iosdevlog.com/2020/02/13/ai/2.png" alt="《AI技术内参》"></p><p>总结：<a href="https://time.geekbang.org/column/article/153" target="_blank" rel="noopener">https://time.geekbang.org/column/article/153</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/13/ai/1.png&quot; alt=&quot;《AI技术内参》&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="极客时间" scheme="https://2020.iosdevlog.com/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>移动深度学习</title>
    <link href="https://2020.iosdevlog.com/2020/02/12/mobile-dl/"/>
    <id>https://2020.iosdevlog.com/2020/02/12/mobile-dl/</id>
    <published>2020-02-12T15:29:15.000Z</published>
    <updated>2020-02-16T07:03:36.370Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pytorch.org/assets/images/pytorch-mobile.png" alt="PyTorch Mobile"></p><a id="more"></a><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="PyTorch-Mobile"><a href="#PyTorch-Mobile" class="headerlink" title="PyTorch Mobile"></a><a href="https://pytorch.org/mobile/home/" target="_blank" rel="noopener">PyTorch Mobile</a></h3><p>随着应用程序继续要求更低的延迟，在边缘设备上运行ML的重要性越来越重要。它也是诸如联合学习之类的隐私保护技术的基础要素。从 <code>PyTorch 1.3</code> 开始，<code>PyTorch</code> 支持从 <code>Python</code> 到在 <code>iOS</code> 和 <code>Android</code> 上部署的端到端工作流。</p><p>这是一个早期的实验版本，我们将在接下来的几个月中在以下几个方面进行开发：</p><ul><li>提供 <code>API</code>，涵盖将ML集成到移动应用程序中所需的常见预处理和集成任务</li><li>支持 <code>QNNPACK</code> 量化内核库并支持 <code>ARM CPU</code></li><li>根据用户应用程序所需的运算符，进行构建级别的优化和选择性编译（即，仅为所需的运算符支付二进制大小）</li><li>进一步改善移动 <code>CPU</code> 和 <code>GPU</code> 的性能和覆盖范围</li></ul><p>了解更多信息或开始使用 <a href="https://pytorch.org/mobile/android" target="_blank" rel="noopener">Android</a> 或 <a href="https://pytorch.org/mobile/ios" target="_blank" rel="noopener">iOS</a>。</p><h3 id="TensorFlow-Lite"><a href="#TensorFlow-Lite" class="headerlink" title="TensorFlow Lite"></a><a href="https://www.tensorflow.org/lite/" target="_blank" rel="noopener">TensorFlow Lite</a></h3><p>在移动设备和 IoT 设备上部署机器学习模型</p><p>TensorFlow Lite 是一种用于设备端推断的开源深度学习框架。</p><p><a href="https://www.tensorflow.org/lite/guide" target="_blank" rel="noopener">查看指南</a></p><p>指南介绍了 TensorFlow Lite 的概念和组件。</p><p><a href="https://www.tensorflow.org/lite/examples/" target="_blank" rel="noopener">查看示例</a></p><p>探索使用 TensorFlow Lite 的 Android 和 iOS 应用。</p><p><a href="https://www.tensorflow.org/lite/models/" target="_blank" rel="noopener">查看模型</a></p><p>轻松地部署预训练模型。</p><p><img src="https://www.tensorflow.org/site-assets/images/marketing/learn/learn-lite-hero.svg" alt=""></p><p>工作原理</p><ul><li>选择模型</li></ul><p>选择新模型或重新训练现有模型。</p><ul><li>转换</li></ul><p>使用 TensorFlow Lite Converter 将 TensorFlow 模型转换为压缩的 FlatBuffer 文件。</p><ul><li>部署</li></ul><p>获取压缩的 .tflite 文件，并将其加载到移动设备或嵌入式设备中。</p><ul><li>优化</li></ul><p>通过将 32 位浮点数转换为更高效的 8 位整数进行量化，或者在 GPU 上运行。</p><h4 id="常见问题的解决方案"><a href="#常见问题的解决方案" class="headerlink" title="常见问题的解决方案"></a>常见问题的解决方案</h4><p>探索帮助解决常见移动和边缘用例的优化模型。</p><p><a href="https://www.tensorflow.org/lite/models/" target="_blank" rel="noopener">查看所有用例</a></p><ul><li>图像分类</li></ul><p>识别数百个对象，包括人、活动、动物、植物和地点。</p><ul><li>对象检测</li></ul><p>使用边界框检测多个对象。是的，包括狗和猫。</p><ul><li>智能回复</li></ul><p>生成回复建议以输入对话聊天消息。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>移动深度学习主要应用为物体检测和分类。</p><ul><li>主体检测（ObjectDetection）：物体的大小和位置</li><li>分类：种类 &amp; 概率</li></ul><p>部署</p><ul><li>云端服务器：性能和体验都会非常差，也会消耗大量的服务器资源，企业成本会骤增</li><li>移动端：提升用户体验</li></ul><p>案例</p><ul><li>物体识别</li><li>风格迁移</li><li>视频主体检测</li><li>语音识别</li><li>自然语言处理</li><li>听歌识曲</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://pytorch.org/assets/images/pytorch-mobile.png&quot; alt=&quot;PyTorch Mobile&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="AI" scheme="https://2020.iosdevlog.com/categories/AI/"/>
    
    
      <category term="DL" scheme="https://2020.iosdevlog.com/tags/DL/"/>
    
      <category term="移动" scheme="https://2020.iosdevlog.com/tags/%E7%A7%BB%E5%8A%A8/"/>
    
      <category term="PyTorch" scheme="https://2020.iosdevlog.com/tags/PyTorch/"/>
    
      <category term="TensorFlow" scheme="https://2020.iosdevlog.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Scikit-Learn Cheat Sheet：Python机器学习</title>
    <link href="https://2020.iosdevlog.com/2020/02/11/sklean/"/>
    <id>https://2020.iosdevlog.com/2020/02/11/sklean/</id>
    <published>2020-02-11T15:29:44.000Z</published>
    <updated>2020-02-16T07:03:36.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://scikit-learn.org/stable/_static/ml_map.png" alt="scikit-learn"></p><a id="more"></a><p>一个方便的 <code>scikit-learn</code> 备忘录，用于使用 <code>Python</code> 进行机器学习，包括代码示例。</p><p>大多数使用 <code>Python</code> 学习数据科学的人肯定已经听说过 <code>scikit-learn</code>，开源 <code>Python</code> 库在统一界面的帮助下实现了各种机器学习，预处理，交叉验证和可视化算法。 </p><p>如果你还是这个领域的新手，你应该意识到机器学习，以及这个 <code>Python</code> 库，都属于每个有抱负的数据科学家必须知道的。 </p><p>这就是为什么 DataCamp 已经 <code>scikit-learn</code> 为那些已经开始学习 <code>Python</code> 包的人创建了一个备忘录，但仍然需要一个方便的参考表。或者，如果您仍然不知道如何 <code>scikit-learn</code> 工作，这台机器学习备忘录可能会派上用场，以便快速了解入门时需要了解的基础知识。 </p><p>无论哪种方式，我们都确信您在解决机器学习问题时会发现它很有用！  </p><p>这个 <code>scikit-learn</code>备忘录将向您介绍成功实现机器学习算法所需的基本步骤：您将看到如何加载数据，如何预处理它，如何创建自己的模型以适合您的模型您的数据和预测目标标签，如何验证您的模型以及如何进一步调整以提高其性能。 </p><p><a href="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Scikit_Learn_Cheat_Sheet_Python.pdf" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/910914-166f8a6e1d1180b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Scikit-Learn Cheat Sheet"></a></p><p>简而言之，这个备忘录将启动您的数据科学项目：借助代码示例，您可以立即创建，验证和调整您的机器学习模型。  </p><p>你还在等什么？开始的时候了！</p><p>*<em>（点击上方下载可打印版本或阅读以下在线版本。） *</em></p><h2 id="Python-For-Data-Science备忘录：Scikit-learn"><a href="#Python-For-Data-Science备忘录：Scikit-learn" class="headerlink" title="Python For Data Science备忘录：Scikit-learn"></a>Python For Data Science备忘录：Scikit-learn</h2><p>Scikit-learn是一个开源Python库，使用统一的界面实现一系列机器学习，预处理，交叉验证和可视化算法。</p><h3 id="一个基本的例子"><a href="#一个基本的例子" class="headerlink" title="一个基本的例子"></a>一个基本的例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import neighbors, datasets, preprocessing</span><br><span class="line">&gt;&gt;&gt; from sklearn.model_selection import train_test_split</span><br><span class="line">&gt;&gt;&gt; from sklearn.metrics import accuracy_score</span><br><span class="line">&gt;&gt;&gt; iris &#x3D; datasets.load_iris()</span><br><span class="line">&gt;&gt;&gt; X, y &#x3D; iris.data[:, :2], iris.target</span><br><span class="line">&gt;&gt;&gt; X_train, X_test, y_train, y_test &#x3D; train_test_split(X, y, random_state&#x3D;33)</span><br><span class="line">&gt;&gt;&gt; scaler &#x3D; preprocessing.StandardScaler().fit(X_train)</span><br><span class="line">&gt;&gt;&gt; X_train &#x3D; scaler.transform(X_train)</span><br><span class="line">&gt;&gt;&gt; X_test &#x3D; scaler.transform(X_test)</span><br><span class="line">&gt;&gt;&gt; knn &#x3D; neighbors.KNeighborsClassifier(n_neighbors&#x3D;5)</span><br><span class="line">&gt;&gt;&gt; knn.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt; y_pred &#x3D; knn.predict(X_test)</span><br><span class="line">&gt;&gt;&gt; accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><p>您的数据需要是数字并存储为NumPy数组或SciPy稀疏矩阵。其他可转换为数字数组的类型（如Pandas DataFrame）也是可以接受的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; X &#x3D; np.random.random((10,5))</span><br><span class="line">&gt;&gt;&gt; y &#x3D; np.array([&#39;M&#39;,&#39;M&#39;,&#39;F&#39;,&#39;F&#39;,&#39;M&#39;,&#39;F&#39;,&#39;M&#39;,&#39;M&#39;,&#39;F&#39;,&#39;F&#39;,&#39;F&#39;])</span><br><span class="line">&gt;&gt;&gt; X[X &lt; 0.7] &#x3D; 0</span><br></pre></td></tr></table></figure><h3 id="预处理数据"><a href="#预处理数据" class="headerlink" title="预处理数据"></a>预处理数据</h3><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler</span><br><span class="line">&gt;&gt;&gt; scaler &#x3D; StandardScaler().fit(X_train)</span><br><span class="line">&gt;&gt;&gt; standardized_X &#x3D; scaler.transform(X_train)</span><br><span class="line">&gt;&gt;&gt; standardized_X_test &#x3D; scaler.transform(X_test)</span><br></pre></td></tr></table></figure><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import Normalizer</span><br><span class="line">&gt;&gt;&gt; scaler &#x3D; Normalizer().fit(X_train)</span><br><span class="line">&gt;&gt;&gt; normalized_X &#x3D; scaler.transform(X_train)</span><br><span class="line">&gt;&gt;&gt; normalized_X_test &#x3D; scaler.transform(X_test)</span><br></pre></td></tr></table></figure><h4 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import Binarizer</span><br><span class="line">&gt;&gt;&gt; binarizer &#x3D; Binarizer(threshold&#x3D;0.0).fit(X)</span><br><span class="line">&gt;&gt;&gt; binary_X &#x3D; binarizer.transform(X)</span><br></pre></td></tr></table></figure><h4 id="编码分类功能"><a href="#编码分类功能" class="headerlink" title="编码分类功能"></a>编码分类功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import LabelEncoder</span><br><span class="line">&gt;&gt;&gt; enc &#x3D; LabelEncoder()</span><br><span class="line">&gt;&gt;&gt; y &#x3D; enc.fit_transform(y)</span><br></pre></td></tr></table></figure><h4 id="输入缺失值"><a href="#输入缺失值" class="headerlink" title="输入缺失值"></a>输入缺失值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from sklearn.preprocessing import Imputer</span><br><span class="line">&gt;&gt;&gt;imp &#x3D; Imputer(missing_values&#x3D;0, strategy&#x3D;&#39;mean&#39;, axis&#x3D;0)</span><br><span class="line">&gt;&gt;&gt;imp.fit_transform(X_train)</span><br></pre></td></tr></table></figure><h4 id="生成多项式特征"><a href="#生成多项式特征" class="headerlink" title="生成多项式特征"></a>生成多项式特征</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line">&gt;&gt;&gt; poly &#x3D; PolynomialFeatures(5)</span><br><span class="line">&gt;&gt;&gt; oly.fit_transform(X)</span><br></pre></td></tr></table></figure><h3 id="训练和测试数据"><a href="#训练和测试数据" class="headerlink" title="训练和测试数据"></a>训练和测试数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.model_selection import train_test_split</span><br><span class="line">&gt;&gt;&gt; X_train, X_test, y_train, y_test &#x3D; train_test_split(X,y,random_state&#x3D;0)</span><br></pre></td></tr></table></figure><h3 id="创建你的模型"><a href="#创建你的模型" class="headerlink" title="创建你的模型"></a>创建你的模型</h3><h4 id="监督学习估算"><a href="#监督学习估算" class="headerlink" title="监督学习估算"></a>监督学习估算</h4><p><strong>线性回归</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.linear_model import LinearRegression</span><br><span class="line">&gt;&gt;&gt; lr &#x3D; LinearRegression(normalize&#x3D;True)</span><br></pre></td></tr></table></figure><p><strong>支持向量机（SVM）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.svm import SVC</span><br><span class="line">&gt;&gt;&gt; svc &#x3D; SVC(kernel&#x3D;&#39;linear&#39;)</span><br></pre></td></tr></table></figure><p><strong>朴素贝叶斯</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB</span><br><span class="line">&gt;&gt;&gt; gnb &#x3D; GaussianNB()</span><br></pre></td></tr></table></figure><p><strong>K-近邻算法（KNN）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import neighbors</span><br><span class="line">&gt;&gt;&gt; knn &#x3D; neighbors.KNeighborsClassifier(n_neighbors&#x3D;5)</span><br></pre></td></tr></table></figure><p><strong>无监督学习估算器</strong></p><p><strong>主成分分析（PCA）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.decomposition import PCA</span><br><span class="line">&gt;&gt;&gt; pca &#x3D; PCA(n_components&#x3D;0.95)</span><br></pre></td></tr></table></figure><p><strong>K均值聚类算法(K-Means)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.cluster import KMeans</span><br><span class="line">&gt;&gt;&gt; k_means &#x3D; KMeans(n_clusters&#x3D;3, random_state&#x3D;0)</span><br></pre></td></tr></table></figure><h3 id="模型拟合"><a href="#模型拟合" class="headerlink" title="模型拟合"></a>模型拟合</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lr.fit(X, y)</span><br><span class="line">&gt;&gt;&gt; knn.fit(X_train, y_train)</span><br><span class="line">&gt;&gt;&gt; svc.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><p>无监督学习</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; k_means.fit(X_train)</span><br><span class="line">&gt;&gt;&gt; pca_model &#x3D; pca.fit_transform(X_train)</span><br></pre></td></tr></table></figure><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>监督估算师</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y_pred &#x3D; svc.predict(np.random.random((2,5)))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y_pred &#x3D; lr.predict(X_test)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y_pred &#x3D; knn.predict_proba(X_test))</span><br></pre></td></tr></table></figure><p><strong>无监督估计</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y_pred &#x3D; k_means.predict(X_test)</span><br></pre></td></tr></table></figure><h3 id="评估您的模型的性能"><a href="#评估您的模型的性能" class="headerlink" title="评估您的模型的性能"></a>评估您的模型的性能</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><p><strong>准确度分数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; knn.score(X_test, y_test)</span><br><span class="line">&gt;&gt;&gt; from sklearn.metrics import accuracy_score</span><br><span class="line">&gt;&gt;&gt; accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure><p><strong>分类报告</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import classification_report</span><br><span class="line">&gt;&gt;&gt; print(classification_report(y_test, y_pred)))</span><br></pre></td></tr></table></figure><p><strong>混淆矩阵</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import confusion_matrix</span><br><span class="line">&gt;&gt;&gt; print(confusion_matrix(y_test, y_pred)))</span><br></pre></td></tr></table></figure><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><p><strong>平均绝对误差</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import mean_absolute_error</span><br><span class="line">&gt;&gt;&gt; y_true &#x3D; [3, -0.5, 2])</span><br><span class="line">&gt;&gt;&gt; mean_absolute_error(y_true, y_pred))</span><br></pre></td></tr></table></figure><p><strong>均方误差</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import mean_squared_error</span><br><span class="line">&gt;&gt;&gt; mean_squared_error(y_test, y_pred))</span><br></pre></td></tr></table></figure><p><strong>R <sup>2</sup> score</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import r2_score</span><br><span class="line">&gt;&gt;&gt; r2_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><h4 id="群集指标"><a href="#群集指标" class="headerlink" title="群集指标"></a>群集指标</h4><p><strong>调整后的兰德指数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import adjusted_rand_score</span><br><span class="line">&gt;&gt;&gt; adjusted_rand_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><p><strong>同质性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import homogeneity_score</span><br><span class="line">&gt;&gt;&gt; homogeneity_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><p><strong>V-措施</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.metrics import v_measure_score</span><br><span class="line">&gt;&gt;&gt; metrics.v_measure_score(y_true, y_pred))</span><br></pre></td></tr></table></figure><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(cross_val_score(knn, X_train, y_train, cv&#x3D;4))</span><br><span class="line">&gt;&gt;&gt; print(cross_val_score(lr, X, y, cv&#x3D;2))</span><br></pre></td></tr></table></figure><h3 id="调整你的模型"><a href="#调整你的模型" class="headerlink" title="调整你的模型"></a>调整你的模型</h3><h4 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.grid_search import GridSearchCV</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; params &#x3D; &#123;&quot;n_neighbors&quot;: np.arange(1,3), &quot;metric&quot;: [&quot;euclidean&quot;, &quot;cityblock&quot;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; grid &#x3D; GridSearchCV(estimator&#x3D;knn,param_grid&#x3D;params)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; grid.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(grid.best_score_)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(grid.best_estimator_.n_neighbors)</span><br></pre></td></tr></table></figure><h4 id="随机参数优化"><a href="#随机参数优化" class="headerlink" title="随机参数优化"></a>随机参数优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.grid_search import RandomizedSearchCV</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; params &#x3D; &#123;&quot;n_neighbors&quot;: range(1,5), &quot;weights&quot;: [&quot;uniform&quot;, &quot;distance&quot;]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rsearch &#x3D; RandomizedSearchCV(estimator&#x3D;knn,</span><br><span class="line">   param_distributions&#x3D;params,</span><br><span class="line">   cv&#x3D;4,</span><br><span class="line">   n_iter&#x3D;8,</span><br><span class="line">   random_state&#x3D;5)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rsearch.fit(X_train, y_train)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(rsearch.best_score_)</span><br></pre></td></tr></table></figure><h3 id="走得更远"><a href="#走得更远" class="headerlink" title="走得更远"></a>走得更远</h3><p>从<a href="https://www.datacamp.com/community/tutorials/machine-learning-python/" target="_blank" rel="noopener">我们为初学者学习scikit-learn教程</a>开始  ，您将以简单，循序渐进的方式学习如何探索手写数字数据，如何为其创建模型，如何使您的数据适合您的模型和如何预测目标值。此外，您将使用Python的数据可视化库matplotlib来可视化您的结果。</p><p>&gt; PS：不要错过我们的<a href="https://www.datacamp.com/community/blog/bokeh-cheat-sheet-python/" target="_blank" rel="noopener">Bokeh备忘录</a>，  <a href="https://www.datacamp.com/community/blog/python-pandas-cheat-sheet/" target="_blank" rel="noopener">pandas备忘录</a>  或<a href="https://www.datacamp.com/community/tutorials/python-data-science-cheat-sheet-basics/" target="_blank" rel="noopener">数据科学</a>的  <a href="https://www.datacamp.com/community/tutorials/python-data-science-cheat-sheet-basics/" target="_blank" rel="noopener">Python备忘录</a>。</p><p>原文： <a href="https://www.datacamp.com/community/blog/scikit-learn-cheat-sheet" target="_blank" rel="noopener">https://www.datacamp.com/community/blog/scikit-learn-cheat-sheet</a><br>作者： <a href="https://www.datacamp.com/profile/karlijn" target="_blank" rel="noopener">Karlijn Willems</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://scikit-learn.org/stable/_static/ml_map.png&quot; alt=&quot;scikit-learn&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
  <entry>
    <title>《幻夜》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/11/9787544291811/"/>
    <id>https://2020.iosdevlog.com/2020/02/11/9787544291811/</id>
    <published>2020-02-11T15:08:30.000Z</published>
    <updated>2020-02-16T07:03:36.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/11/9787544291811/1.svg" alt="《幻夜》人物关系图"></p><a id="more"></a><p>书名：幻夜（2018精装版）<br>作者：[日]东野圭吾<br>译者：李炜<br>出版社：南海出版公司<br>出版时间：2018-05<br>ISBN：9787544291811</p><p><img src="https://2020.iosdevlog.com/2020/02/11/9787544291811/2.jpg" alt="幻夜（2018精装版）"></p><p>地震之后，宛如人间炼狱的断壁残垣中，水原雅也借机杀了舅舅，却被自称新海美冬的神秘女人目击。</p><p>女人答应为水原终生保守秘密。他们相偕前往东京，然而等待他们的，却是从此再无一丝太阳的无边幻夜：凡是接近过她的人，都莫名消失；凡是触碰过她过去的人，都不知所踪。</p><p>若永远只能活在黑暗中，且与你共度的每个夜晚都是幻影，我究竟该如何面对这狰狞的人生？</p><p>失去生命中最后的光芒，她完全堕入无边幻夜，开始极尽邪恶而妖艳的表演……“如果要说《白夜行》中有着任何一丝可以被称为是‘希望’的东西，那么到了《幻夜》，东野圭吾连这一丝都从我们面前夺走了。</p><p>从这个意义上，《幻夜》是一本不折不扣的‘绝望之书’。”</p><blockquote><p>“这世上任何人都有弱点，如果能掌握对方的弱点，不管她如何挑衅，我们都不用担心。”</p></blockquote><p>说这番话的时候，她浑身散发着一股寒气，待在她身边的雅也甚至不寒而栗。</p><p><img src="https://2020.iosdevlog.com/2020/02/11/9787544291811/3.png" alt="《幻夜》词云"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/11/9787544291811/1.svg&quot; alt=&quot;《幻夜》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何用 Kindle 高效学习</title>
    <link href="https://2020.iosdevlog.com/2020/02/10/kindle/"/>
    <id>https://2020.iosdevlog.com/2020/02/10/kindle/</id>
    <published>2020-02-10T13:54:33.000Z</published>
    <updated>2020-02-16T07:03:36.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-cn.ssl-images-amazon.com/images/I/61Tb-DVjsFL._AC_SL1000_.jpg" alt="kindle oasis"></p><a id="more"></a><p>书 名： 如何用 Kindle 高效学习<br>作 者： 直树桑<br>版权方： 华章<br>ISBN： 9787111618430</p><h2 id="纸书的发源"><a href="#纸书的发源" class="headerlink" title="纸书的发源"></a>纸书的发源</h2><h3 id="活字印刷术"><a href="#活字印刷术" class="headerlink" title="活字印刷术"></a>活字印刷术</h3><ul><li>11 世纪初</li><li>中国</li><li>毕昇</li></ul><h3 id="铅活字印刷术"><a href="#铅活字印刷术" class="headerlink" title="铅活字印刷术"></a>铅活字印刷术</h3><ul><li>15 世纪初</li><li>神圣罗马帝国</li><li>约翰内斯·古登堡（Johannes Gutenberg）</li><li>《古登堡圣经》</li></ul><h4 id="古登堡计划"><a href="#古登堡计划" class="headerlink" title="古登堡计划"></a>古登堡计划</h4><p>1971 年 7 月，一个来自美国伊利诺伊大学的学生迈克尔·哈特（Michael Hart）发起了一个由志愿者参与、致力于将文化作品数字化的项目，其中绝大部分书为公有领域书籍的原本。该计划目前藏书超过 5 万册，它就是古登堡计划，是为了纪念古登堡对纸质书的贡献而命名的。古登堡计划是世界上最早的数字图书馆，它的诞生也意味着电子阅读的开始。</p><h2 id="Kindle-比较"><a href="#Kindle-比较" class="headerlink" title="Kindle 比较"></a>Kindle 比较</h2><table><thead><tr><th>属性</th><th>Kindle</th><th>纸质书</th></tr></thead><tbody><tr><td>便捷性</td><td>便捷</td><td>笨重</td></tr><tr><td>时间</td><td>日夜</td><td>白天</td></tr></tbody></table><table><thead><tr><th>属性</th><th>Kindle</th><th>其它阅读器</th></tr></thead><tbody><tr><td>正版书库</td><td>全</td><td>不全</td></tr><tr><td>软件生态</td><td>闭环</td><td>不完善</td></tr><tr><td>品牌价值</td><td>安心</td><td>不安心</td></tr></tbody></table><table><thead><tr><th>属性</th><th>Kindle</th><th>其它电子设备</th></tr></thead><tbody><tr><td>分辨率</td><td>中</td><td>高</td></tr><tr><td>沉浸式</td><td>沉浸</td><td>打扰</td></tr><tr><td>跨平台</td><td>全</td><td>不全</td></tr></tbody></table><h2 id="Kindle-电子书阅读器系列对比"><a href="#Kindle-电子书阅读器系列对比" class="headerlink" title="Kindle 电子书阅读器系列对比"></a>Kindle 电子书阅读器系列对比</h2><table><thead><tr><th>图片</th><th><img src="https://images-cn.ssl-images-amazon.com/images/G/28/kindle/merch/2019/Rakia/Compchart_PC_jaeger._CB440561824_.png" alt=""></th><th><img src="https://images-cn.ssl-images-amazon.com/images/G/28/kindle/merch/2019/Rakia/Compchart_PC_rakia._CB442289858_.png" alt=""></th><th><img src="https://images-cn.ssl-images-amazon.com/images/G/28/kindle/merch/2019/stinger/Compchart_PC_stinger._CB462394424_.png" alt=""></th></tr></thead><tbody><tr><td>名称</td><td>青春版 Kindle</td><td>经典版 Kindle Paperwhite</td><td>尊享版 Kindle Oasis</td></tr><tr><td>价格</td><td>￥658.00</td><td>￥998.00</td><td>￥2,399.00</td></tr><tr><td>屏幕尺寸</td><td>6英寸</td><td>6英寸</td><td>7英寸</td></tr><tr><td>储存容量</td><td>4GB</td><td>8GB/32GB</td><td>8GB/32GB</td></tr><tr><td>分辨率</td><td>167ppi</td><td>300ppi</td><td>300ppi</td></tr><tr><td>内置阅读灯</td><td>4个内置阅读灯</td><td>5个内置阅读灯</td><td>25个内置阅读灯</td></tr><tr><td>防水</td><td>不防水</td><td>IPX8级防水设计(60分钟、2米水深清水)</td><td>IPX8级防水设计(60分钟、2米水深清水)</td></tr><tr><td>翻页键</td><td>触摸屏</td><td>触摸屏</td><td>触摸屏+物理按键</td></tr><tr><td>数周续航</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>纯平设计</td><td>×</td><td>✓</td><td>✓</td></tr><tr><td>可调节冷暖色温</td><td>×</td><td>×</td><td>✓</td></tr><tr><td>光线感应器</td><td>×</td><td>×</td><td>✓</td></tr><tr><td>人体工学设计</td><td>×</td><td>×</td><td>✓</td></tr><tr><td>屏幕自动旋转</td><td>×</td><td>×</td><td>✓</td></tr><tr><td>设备颜色</td><td>黑/白</td><td>墨黑/雾蓝/烟紫/玉青</td><td>银灰/香槟金</td></tr><tr><td>重量</td><td>174克</td><td>182克</td><td>188克</td></tr><tr><td>设备尺寸</td><td>160毫米x113毫米x8.7毫米</td><td>167毫米x116毫米x8.2毫米</td><td>159毫米x141毫米x3.4-8.3毫米</td></tr></tbody></table><h2 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h2><ul><li><p>生词本与生词提示<br>  *［右上角菜单］→［设置］→［阅读选项］→［语言习得］→［开启生词本］。</p></li><li><p>Whispersync 图书同步<br>  *［右上角菜单］→［设置］→［设备选项］→［高级选项］→［Whispersync 图书同步］</p></li><li><p>快速翻页</p><ul><li>物理按键</li><li>触屏</li><li>滑动</li><li>滚轮</li></ul></li><li><p>触点页码: 左下角</p><ul><li>书中位置</li><li>章节剩余时间</li><li>图书剩余时间</li><li>无</li></ul></li><li><p>标注分享</p></li><li><p>截屏</p><ul><li>左上右下</li><li>左下右上</li><li>屏幕闪一下</li><li>根目录</li><li>png</li></ul></li><li><p>笔记导出</p><ul><li>邮箱</li></ul></li><li><p>磁盘传书</p><ul><li>USB</li><li>Documents</li></ul></li><li><p>固件升级</p><ul><li>静默升级<ul><li>update.bin.tmp.partial</li></ul></li><li>手动升级<ul><li><a href="https://www.amazon.cn/gp/help/customer/display.html?nodeId=200529680" target="_blank" rel="noopener">https://www.amazon.cn/gp/help/customer/display.html?nodeId=200529680</a></li></ul></li></ul></li><li><p>字号拉伸</p><ul><li>Zoom</li></ul></li><li><p>收藏夹</p><ul><li>日期</li><li>TGD (Getting Things Done)</li></ul></li><li><p>X-Ray: 书透</p><ul><li>高频人物</li><li>图片</li></ul></li><li><p>多端同步</p><ul><li>卡片输出</li></ul></li><li><p>飞行模式</p><ul><li>固件自动升级</li><li>新书</li><li>浏览器</li><li>数据同步</li></ul></li><li><p>批量删除</p><ul><li>存储管理<ul><li>［右上角菜单］→［设备选项］→［高级选项］→［存储管理］</li><li>手动删除</li><li>快速存档</li></ul></li></ul></li></ul><h2 id="找到优质的-Kindle-内容"><a href="#找到优质的-Kindle-内容" class="headerlink" title="找到优质的 Kindle 内容"></a>找到优质的 Kindle 内容</h2><p>阅读源</p><ul><li>官方书源</li><li>公版书源</li><li>个人文档</li></ul><p>优质读物</p><ul><li>读物排版精良（缺字、漏字现象少）；</li><li>读物不存在版权问题；</li><li>读物格式为亚马逊 Kindle 最适配的格式（mobi、azw3、kfx 等）；</li><li>读物支持 X-Ray、生词提示等功能；</li><li>读物提供热门标注、关于本书等参考信息。</li></ul><ol><li>个人文档<ul><li>自建优质内容<ul><li>Calibre</li><li><a href="https://calibre-ebook.com" target="_blank" rel="noopener">https://calibre-ebook.com</a></li></ul></li><li>聚合信息: RSS<ul><li>Inoreader</li><li>Reabble</li></ul></li><li>碎片化信息<ul><li>Send to Kindle</li><li>稍后读<ul><li>Pocket</li><li>Instapaper</li><li>收趣</li></ul></li></ul></li></ul></li><li>电子书<ul><li>官方正版书<ul><li>Kindle Unlimited（KU）</li><li>免费电子书</li></ul></li><li>公版书<ul><li>古登堡计划（Project Gutenberg）</li><li><a href="https://www.gutenberg.org/" target="_blank" rel="noopener">https://www.gutenberg.org/</a></li></ul></li></ul></li></ol><ol><li>科技类<ul><li>少数派</li><li>cnBeta.com</li></ul></li><li>新知/搞笑类<ul><li>煎蛋</li><li>喷嚏网</li></ul></li><li>阅读类<ul><li>左岸读书</li><li>豆瓣最受欢迎的书评</li><li>知乎每日精选</li></ul></li><li>生活类<ul><li>Lifehacker</li><li>理想生活实验室</li><li>胶片的味道。</li></ul></li><li>外文类<ul><li>The New Yorker</li><li>The Economist</li><li>BBC News</li></ul></li></ol><h2 id="利用-Kindle-学外语"><a href="#利用-Kindle-学外语" class="headerlink" title="利用 Kindle 学外语"></a>利用 Kindle 学外语</h2><p>记忆神器</p><ul><li>暗记（Anki）</li><li>Kindle Mate</li><li>AnKindle</li></ul><p>词典</p><ul><li>《现代英汉词典》（A Modern English-Chinese Dictionary）</li><li>《牛津英英词典》（The New Oxford American Dictionary）</li><li>欧路词典（EuDic）</li></ul><h2 id="Kindle-读记流"><a href="#Kindle-读记流" class="headerlink" title="Kindle 读记流"></a>Kindle 读记流</h2><ul><li>选书<ul><li>明确选书的目的</li><li>使用图书评分网站<ul><li>豆瓣阅读</li><li>Goodreads</li><li>amazon.cn / amazon.com</li></ul></li><li>对书进行二次筛选<ul><li>作者的知名度</li><li>对应圈子 KOL（意见领袖）</li><li>购买渠道</li></ul></li></ul></li><li>输入<ul><li>一个思维: 带着问题去阅读<ul><li>自我提问</li></ul></li><li>三个技巧<ul><li>标注<ul><li>作者的重点观点描述</li></ul></li><li>笔记<ul><li>对当下的你产生帮助</li><li>与自己产生共鸣</li></ul></li></ul></li><li>两个意识<ul><li>标注意识</li><li>笔记意识</li></ul></li></ul></li><li>加工<ul><li>标注/笔记的管理<ul><li>对标注中多余或欠缺的部分进行增减，以达到修整书摘的目的</li><li>对笔记中的简单记录进行深度提炼，将内容完整化、具象化</li><li>工具<ul><li>Kindle Mate（Windows）</li><li>Clippings.io（Web）</li><li>Knotes（Windows/macOS）</li><li>Klib（macOS）</li></ul></li></ul></li><li>标注/笔记的管理</li></ul></li><li>输出<ul><li>文章<ul><li>总结性的书评</li><li>开放性输出</li></ul></li><li>卡片<ul><li>Clippings.io+Anki</li><li>AnKindle+Anki</li></ul></li><li>框架图<ul><li>幕布</li></ul></li><li>思维导图<ul><li>XMind</li><li>MindMaster</li></ul></li></ul></li></ul><p><img src="https://2020.iosdevlog.com/2020/02/10/kindle/2.jpg" alt="Kindle 读记流"></p><ol><li>带着明确的目的和需求去选书并通过相关网站进行内容筛选，建立「目标书单」并对书单进行优化；</li><li>通过「一个思维」「三个技巧」和「两个意识」对 Kindle 上的所选读物进行阅读，将核心内容进行标注/笔记操作；</li><li>通过 Klib、Knotes 等标注笔记神器对 Kindle 的标注/笔记进行加工；</li><li>将加工过的标注/笔记通过标注/笔记工具（Klib 或 Knotes）同步到印象笔记中备用；</li><li>进行一次系统性的输出，遇到记不清的知识点就返回到 Kindle 中进行内容回顾，直到输出一篇自己满意的作品。作品的形式可以是文章、卡片、框架或思维导图，在这个过程中将书里的知识内化成你自己的东西。</li></ol><h2 id="电子墨水屏"><a href="#电子墨水屏" class="headerlink" title="电子墨水屏"></a>电子墨水屏</h2><p>E Ink 技术的原理如图所示，它实际展现的是一种电泳技术，即通过微小的胶囊内嵌带有负电的黑色颗粒和带正电的白色颗粒从而形成电子墨水。</p><p><img src="https://2020.iosdevlog.com/2020/02/10/kindle/3.jpg" alt="E Ink 技术的原理"></p><p>基于这样的特性，E Ink 拥有了一些特点：</p><ol><li>接近纸质书的质感，尤其是在白天。在强光下它也可以让我们轻松阅读，而同样的效果在手机、平板电脑这种 TFT 屏幕的设备上是很难实现的。</li><li>符合阅读习惯，在阅读过程中无闪烁，翻页方便，适合进行长时间的阅读。电子阅读器本身的轻盈设计也让我们拿着不累，装着不占地方。</li></ol><h2 id="知识管理系统"><a href="#知识管理系统" class="headerlink" title="知识管理系统"></a>知识管理系统</h2><ol><li>选择一个你想研究/学习/探索的主题；</li><li>选择一款自己长期固定使用的标注管理神器（Knotes/Klib/Kindle Mate）；</li><li>选择一个你可以固定输出的方式（框架/思维导图/卡片/文章）；</li><li>选择一个管理知识的笔记本（印象笔记/有道云笔记/Onenote)；</li><li>通过长期实践，打造一个从「输入」到「输出」的学习闭环。</li></ol><p>参考：<a href="https://www.zhihu.com/pub/book/119599037" target="_blank" rel="noopener">https://www.zhihu.com/pub/book/119599037</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://images-cn.ssl-images-amazon.com/images/I/61Tb-DVjsFL._AC_SL1000_.jpg&quot; alt=&quot;kindle oasis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="Kindle" scheme="https://2020.iosdevlog.com/tags/Kindle/"/>
    
  </entry>
  
  <entry>
    <title>《虚无的十字架》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/09/9787540471842/"/>
    <id>https://2020.iosdevlog.com/2020/02/09/9787540471842/</id>
    <published>2020-02-09T09:58:49.000Z</published>
    <updated>2020-02-16T07:03:36.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/09/9787540471842/0.png" alt="《虚无的十字架》人物关系图"></p><a id="more"></a><p>作者:  [日] 东野圭吾<br>出版社: 湖南文艺出版社<br>出品方: 博集天卷<br>原作名: 虚ろな十字架<br>译者: 王蕴洁<br>出版年: 2015-6<br>页数: 304<br>定价: 39.80元<br>装帧: 精装<br>ISBN: 9787540471842</p><p><img src="https://2020.iosdevlog.com/2020/02/09/9787540471842/1.jpg" alt="《虚无的十字架》"></p><p>《虚无的十字架》充分展现了东野圭吾的创作才华。东野圭吾这次选择的，是社会道德议题上一个两难的选择：关于罪与罚，是让犯人听到自己的死刑宣判而感到解脱？还是让他重返自由社会用尽一生赎罪？这正是东野圭吾想要展现的力量：现代社会关于死刑是否应该被废除的一次深刻的思考和解读。</p><p>《白夜行》后，东野圭吾最刺痛人心的代表作！</p><p>直面挑战社会道德议题，长踞亚马逊小说畅销榜榜首！</p><p>所谓的“罪”与“罚”，究竟本质为何？</p><p>是让犯人听到自己的死刑宣判而感到解脱？</p><p>还是让他重返自由社会，但用尽一生赎罪？</p><p>爱女被杀害的道正与小夜子夫妻在凶手被宣判死刑后，感到人生失去目标，即使凶手伏法，女儿也无法再复活的痛苦，终使道正与小夜子分手。某日，道正接到刑警致电，得知令人震惊的消息──小夜子被杀了。虽然不久后凶手自首，但道正却在小夜子的遗物中有所发现，她的死因似乎并不单纯……</p><p>如果你家人的生命被残酷地夺走，你希望该如何处置犯人？</p><p>如果犯人并未把死刑视为惩罚，至死仍未反省，死刑又有何作用？</p><p><img src="https://2020.iosdevlog.com/2020/02/09/9787540471842/2.png" alt="词云"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/09/9787540471842/0.png&quot; alt=&quot;《虚无的十字架》人物关系图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="东野圭吾" scheme="https://2020.iosdevlog.com/tags/%E4%B8%9C%E9%87%8E%E5%9C%AD%E5%90%BE/"/>
    
  </entry>
  
  <entry>
    <title>《蜗居》人物关系图</title>
    <link href="https://2020.iosdevlog.com/2020/02/08/9787535435828/"/>
    <id>https://2020.iosdevlog.com/2020/02/08/9787535435828/</id>
    <published>2020-02-08T15:26:33.000Z</published>
    <updated>2020-02-16T07:03:36.366Z</updated>
    
    <content type="html"><![CDATA[<p>看完了，更新一下关系图。</p><p><img src="https://2020.iosdevlog.com/2020/02/08/9787535435828/4.png" alt=""></p><p>作者:  六六<br>出版社: 长江文艺出版社<br>出版年: 2007-12<br>页数: 303<br>定价: 25.00元<br>装帧: 平装<br>ISBN: 9787535435828</p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/02/08/9787535435828/9787535435828.jpg" alt=""></p><blockquote><p>“海藻啊!人家兜，婚姻是爱情的坟墓。但我要告诉你，没有坟墓，这个婚姻就走不过去!而我呢!我现在就在自掘坟墓。海藻啊，我真不该打破你的梦，让你看到婚姻的疮疤丑陋。可你早看比迟看好，早醒悟比迟后悔好。我告诉你，爱情，爱情那都是男人骗女人的把戏。什么‘把我的心交给你，你会永远拥有我’，那都是一穷二白的穷光蛋的障眼术。他那是什么都没有了，就说点甜言蜜语。男人若真爱一个女人，别净玩儿虚的，你爱这个女人，第一个要给的，既不是你的心，也不是你的身体，一是拍上一摞票子，让女人不必担心未来，二是奉上一幢房子，至少在拥有不了男人的时候，心失落了，身体还有着落。哼哼，可惜，等我明白的时候，都太迟了。这世界上有两大毒草，一是莎士比亚，另一个就是琼瑶，这两个人最坏的地方，就是把无知少女给诱导了。”</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/02/08/9787535435828/3.png" alt=""></p><p>丈夫苏淳刑事拘留，海萍在与 Mark 讲中文课时。</p><blockquote><p>“都是我的错。你知道吗？这一路走来，都是我的错。我是个很贪心的女人，我要得太多太多，如果不是我，我的丈夫不会坐牢，所以，他的今天是我造成的。哎哟，我的头好疼。”</p></blockquote><p><img src="https://2020.iosdevlog.com/2020/02/08/9787535435828/1.png" alt="人物关系图"></p><p>刚看了个开头，读书不应该把书中的三观定义为作者的三观。我们可以以史为鉴；可以避免书中的错识；可以从书中学得知识。</p><h2 id="元宵节"><a href="#元宵节" class="headerlink" title="元宵节"></a>元宵节</h2><p>小武在做汤圆。</p><p><img src="https://2020.iosdevlog.com/2020/02/08/9787535435828/2.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完了，更新一下关系图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/08/9787535435828/4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作者:  六六&lt;br&gt;出版社: 长江文艺出版社&lt;br&gt;出版年: 2007-12&lt;br&gt;页数: 303&lt;br&gt;定价: 25.00元&lt;br&gt;装帧: 平装&lt;br&gt;ISBN: 9787535435828&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="https://2020.iosdevlog.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>知错能改，善莫大焉</title>
    <link href="https://2020.iosdevlog.com/2020/02/07/wrong/"/>
    <id>https://2020.iosdevlog.com/2020/02/07/wrong/</id>
    <published>2020-02-07T14:32:33.000Z</published>
    <updated>2020-02-16T07:03:36.367Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/2.jpg" alt=""></p><a id="more"></a><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/1.jpg" alt=""></p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/3.png" alt=""></p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/4.png" alt=""></p><p><a href="http://www.ccdi.gov.cn/toutiao/202002/t20200207_211015.html" target="_blank" rel="noopener">http://www.ccdi.gov.cn/toutiao/202002/t20200207_211015.html</a></p><p>经中央批准，国家监察委员会决定派出调查组赴湖北省武汉市，就群众反映的涉及李文亮医生的有关问题作全面调查<br>来源：中央纪委国家监委网站 发布时间：2020-02-07 13:02</p><p>　　本网讯  经中央批准，国家监察委员会决定派出调查组赴湖北省武汉市，就群众反映的涉及李文亮医生的有关问题作全面调查。</p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/8.png" alt=""></p><p><a href="http://www.ccdi.gov.cn/yaowen/202002/t20200207_211028.html" target="_blank" rel="noopener">http://www.ccdi.gov.cn/yaowen/202002/t20200207_211028.html</a></p><p>国家卫生健康委员会向李文亮医生表示深切哀悼</p><p>来源：国家卫健委网站 发布时间：2020-02-07 15:07</p><p>　　武汉市中心医院李文亮医生在抗击疫情中感染新型冠状病毒肺炎，经全力救治不幸逝世，国家卫生健康委表示深切哀悼，向李文亮医生的家属表示诚挚慰问。</p><p>　　疫情发生以来，广大医务工作者不顾个人安危，舍小家，为大家，迎难而上，英勇奋战在抗疫最前线，为保护人民生命健康作出了重大贡献，我们表示崇高敬意。</p><p>　　当前，抗击疫情正处于关键时期，防控形势依然严峻复杂，需要全社会更加关心关爱医务人员，团结一致，万众一心，共克时艰，坚决打赢疫情防控阻击战。</p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/5.png" alt=""></p><p><a href="http://www.ccdi.gov.cn/yaowen/202002/t20200207_211029.html" target="_blank" rel="noopener">http://www.ccdi.gov.cn/yaowen/202002/t20200207_211029.html</a></p><p>武汉市人民政府向李文亮医生致敬</p><p>来源：武汉市人民政府网站 发布时间：2020-02-07 15:07</p><p>　　武汉中心医院李文亮医生，因感染新型肺炎，经全力抢救无效不幸去世。我们深表哀悼，万分惋惜！对其坚守一线抗击疫情表示敬意，对其家人表示诚挚慰问！</p><p>武汉市人民政府</p><p>　　2020年2月7日</p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/6.jpg" alt=""></p><p><img src="https://2020.iosdevlog.com/2020/02/07/wrong/7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/07/wrong/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="肺炎" scheme="https://2020.iosdevlog.com/categories/%E8%82%BA%E7%82%8E/"/>
    
    
      <category term="错误" scheme="https://2020.iosdevlog.com/tags/%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>因为玩手机，差点铸成大错</title>
    <link href="https://2020.iosdevlog.com/2020/02/06/phone/"/>
    <id>https://2020.iosdevlog.com/2020/02/06/phone/</id>
    <published>2020-02-06T13:07:51.000Z</published>
    <updated>2020-02-06T14:43:09.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://2020.iosdevlog.com/2020/02/06/phone/1.jpg" alt="小久受伤"></p><a id="more"></a><p>今天小武的二姨带着两个小孩来外婆家。</p><p>二姨家一男一女，大的哥哥比小武小一点，他们两个在一起玩木头撬撬板；小的妹妹比小久小一点，他们一起跑着玩。</p><p>小久带着妹妹去冰箱里拿出 3 盒旺仔牛奶，让爸爸分开。</p><p>爸爸坐在电动车上看手机，让小久去找妈妈打开。</p><p>小久上了二楼找妈妈，妈妈在晾衣服，又叫小久找爸爸。</p><p>小久带着妹妹下来，哥哥看到有旺仔牛奶，就去抢。4 个小孩就在一起抢 3 盒牛奶。</p><p>哥哥在挣抢的过程中把小久推倒，后脑勺着地，小久大哭。</p><p>爸爸赶紧过来揉小久，妈妈下来时看到小久的头上有两处流血。</p><p>舅舅带小久去二爷家拿红药水。再买 1 箱旺仔牛奶。</p><p>小武午睡起来后，对妈妈说：<strong>“头，疼！“</strong></p><p><img src="https://2020.iosdevlog.com/2020/02/06/phone/2.png" alt="事件"></p><h2 id="责任化分"><a href="#责任化分" class="headerlink" title="责任化分"></a>责任化分</h2><ul><li>舅舅：喝了 1 盒牛奶（起因）1%</li><li>小久：拿 3 盒牛奶 5%</li><li>妈妈：晾衣服（拆开可避免）10%</li><li>哥哥：推小久，导致头着地 5%</li><li>爸爸：看手机 100%</li></ul><p>这次爸爸因为看手机，没有照看好小孩，导致小久头部受伤。</p><p>还不知道有没有引起 <strong>脑震荡</strong> 等后遗症。最近 2019 新型肺炎这么严重，也不敢带小久去医院检查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://2020.iosdevlog.com/2020/02/06/phone/1.jpg&quot; alt=&quot;小久受伤&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="game" scheme="https://2020.iosdevlog.com/categories/game/"/>
    
    
      <category term="Godot" scheme="https://2020.iosdevlog.com/tags/Godot/"/>
    
  </entry>
  
</feed>
